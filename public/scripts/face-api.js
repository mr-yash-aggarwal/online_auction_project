/*
  Face-API
  homepage: <https://github.com/vladmandic/face-api>
  author: <https://github.com/vladmandic>'
*/

var faceapi=(()=>{var EI=Object.defineProperty;var VF=e=>EI(e,"__esModule",{value:!0});var UF=(e=>typeof require!="undefined"?require:typeof Proxy!="undefined"?new Proxy(e,{get:(t,n)=>(typeof require!="undefined"?require:t)[n]}):e)(function(e){if(typeof require!="undefined")return require.apply(this,arguments);throw new Error('Dynamic require of "'+e+'" is not supported')});var ih=(e,t)=>{VF(e);for(var n in t)EI(e,n,{get:t[n],enumerable:!0})};var rbe={};ih(rbe,{AgeGenderNet:()=>ig,BoundingBox:()=>cl,Box:()=>dt,ComposableTask:()=>Wr,ComputeAllFaceDescriptorsTask:()=>Do,ComputeFaceDescriptorsTaskBase:()=>mg,ComputeSingleFaceDescriptorTask:()=>Ro,DetectAllFaceLandmarksTask:()=>bg,DetectAllFacesTask:()=>Dp,DetectFaceLandmarksTaskBase:()=>gg,DetectFacesTaskBase:()=>vg,DetectSingleFaceLandmarksTask:()=>yg,DetectSingleFaceTask:()=>xg,Dimensions:()=>On,FACE_EXPRESSION_LABELS:()=>tI,FaceDetection:()=>St,FaceDetectionNet:()=>A$,FaceExpressionNet:()=>ag,FaceExpressions:()=>Fo,FaceLandmark68Net:()=>yl,FaceLandmark68TinyNet:()=>ug,FaceLandmarkNet:()=>y$,FaceLandmarks:()=>Sr,FaceLandmarks5:()=>r$,FaceLandmarks68:()=>dl,FaceMatch:()=>wp,FaceMatcher:()=>kg,FaceRecognitionNet:()=>vl,Gender:()=>Ys,LabeledBox:()=>kp,LabeledFaceDescriptors:()=>qs,NetInput:()=>Ks,NeuralNetwork:()=>gn,ObjectDetection:()=>Ao,Point:()=>Pe,PredictedBox:()=>s$,Rect:()=>ll,SsdMobilenetv1:()=>wu,SsdMobilenetv1Options:()=>zr,TinyFaceDetector:()=>Sl,TinyFaceDetectorOptions:()=>fg,TinyYolov2:()=>kl,TinyYolov2Options:()=>Is,allFaces:()=>ebe,allFacesSsdMobilenetv1:()=>H$,allFacesTinyYolov2:()=>Jge,awaitMediaLoaded:()=>Xk,bufferToImage:()=>Yk,computeFaceDescriptor:()=>Bge,createCanvas:()=>bu,createCanvasFromMedia:()=>Tp,createFaceDetectionNet:()=>Fge,createFaceRecognitionNet:()=>wge,createSsdMobilenetv1:()=>E$,createTinyFaceDetector:()=>tbe,createTinyYolov2:()=>Pge,detectAllFaces:()=>wg,detectFaceLandmarks:()=>U$,detectFaceLandmarksTiny:()=>Lge,detectLandmarks:()=>Qge,detectSingleFace:()=>Zge,draw:()=>aI,env:()=>rt,euclideanDistance:()=>mI,extendWithAge:()=>dg,extendWithFaceDescriptor:()=>lg,extendWithFaceDetection:()=>fu,extendWithFaceExpressions:()=>og,extendWithFaceLandmarks:()=>bl,extendWithGender:()=>pg,extractFaceTensors:()=>hl,extractFaces:()=>pl,fetchImage:()=>uge,fetchJson:()=>Jk,fetchNetWeights:()=>cge,fetchOrThrow:()=>Xs,fetchVideo:()=>lge,getContext2dOrThrow:()=>Xn,getMediaDimensions:()=>gu,imageTensorToCanvas:()=>Qk,imageToSquare:()=>Zk,inverseSigmoid:()=>tge,iou:()=>Bk,isMediaElement:()=>Ym,isMediaLoaded:()=>Cp,isWithAge:()=>kge,isWithFaceDetection:()=>ws,isWithFaceExpressions:()=>nI,isWithFaceLandmarks:()=>vu,isWithGender:()=>Ige,loadAgeGenderModel:()=>Kge,loadFaceDetectionModel:()=>Xge,loadFaceExpressionModel:()=>qge,loadFaceLandmarkModel:()=>Gge,loadFaceLandmarkTinyModel:()=>Hge,loadFaceRecognitionModel:()=>jge,loadSsdMobilenetv1Model:()=>G$,loadTinyFaceDetectorModel:()=>Vge,loadTinyYolov2Model:()=>Uge,loadWeightMap:()=>eI,locateFaces:()=>Yge,matchDimensions:()=>dge,minBbox:()=>zk,nets:()=>st,nonMaxSuppression:()=>Wk,normalize:()=>rs,padToSquare:()=>Vk,predictAgeAndGender:()=>Wge,recognizeFaceExpressions:()=>zge,resizeResults:()=>j$,resolveInput:()=>mu,shuffleArray:()=>ege,sigmoid:()=>xp,ssdMobilenetv1:()=>V$,tf:()=>Rk,tinyFaceDetector:()=>Oge,tinyYolov2:()=>Mge,toNetInput:()=>xt,utils:()=>Lk,validateConfig:()=>dI,version:()=>nbe});var Rk={};ih(Rk,{Abs:()=>Vo,Acos:()=>Wu,Acosh:()=>Vu,AdadeltaOptimizer:()=>kf,AdagradOptimizer:()=>If,AdamOptimizer:()=>Sf,AdamaxOptimizer:()=>Cf,Add:()=>_s,AddN:()=>la,All:()=>Uu,Any:()=>Gu,ArgMax:()=>da,ArgMin:()=>Hu,Asin:()=>ju,Asinh:()=>qu,Atan:()=>Ku,Atan2:()=>Yu,Atanh:()=>Xu,AvgPool:()=>pa,AvgPool3D:()=>jl,AvgPool3DGrad:()=>gh,AvgPoolGrad:()=>mh,BackendWasm:()=>e$,BatchMatMul:()=>ha,BatchToSpaceND:()=>Uo,Bincount:()=>bh,BroadcastArgs:()=>yh,BroadcastTo:()=>HI,Callback:()=>nC,CallbackList:()=>G0,Cast:()=>fa,Ceil:()=>ma,ClipByValue:()=>Es,Complex:()=>ql,ComplexAbs:()=>Kl,Concat:()=>Go,Conv2D:()=>ga,Conv2DBackpropFilter:()=>vh,Conv2DBackpropInput:()=>ba,Conv3D:()=>Xl,Conv3DBackpropFilterV2:()=>xh,Conv3DBackpropInputV2:()=>wh,Cos:()=>ya,Cosh:()=>va,CropAndResize:()=>jo,Cumsum:()=>Ho,CustomCallback:()=>j0,DataStorage:()=>Ul,DenseBincount:()=>kh,DepthToSpace:()=>qo,DepthwiseConv2dNative:()=>xa,DepthwiseConv2dNativeBackpropFilter:()=>Ih,DepthwiseConv2dNativeBackpropInput:()=>Sh,Diag:()=>Ch,Dilation2D:()=>Yl,Dilation2DBackpropFilter:()=>Nh,Dilation2DBackpropInput:()=>Th,ENV:()=>Jb,EarlyStopping:()=>sC,Einsum:()=>Ql,Elu:()=>ka,EluGrad:()=>_h,Environment:()=>UI,Equal:()=>Ko,Erf:()=>Qu,Exp:()=>Ia,ExpandDims:()=>Xo,Expm1:()=>Yo,FFT:()=>Eh,Fill:()=>Zu,FlipLeftRight:()=>Qo,Floor:()=>Sa,FloorDiv:()=>Ca,FromPixels:()=>cd,FusedBatchNorm:()=>Ta,FusedConv2D:()=>no,FusedDepthwiseConv2D:()=>ro,GPGPUContext:()=>s_,GatherNd:()=>Jo,GatherV2:()=>Zo,GraphModel:()=>OC,Greater:()=>ei,GreaterEqual:()=>Na,History:()=>H0,IFFT:()=>Ah,Identity:()=>_a,Imag:()=>Zl,InputSpec:()=>Gt,IsFinite:()=>Ju,IsInf:()=>ec,IsNan:()=>tc,KernelBackend:()=>Mu,LRN:()=>ed,LRNGrad:()=>Fh,LayerVariable:()=>B0,LayersModel:()=>Bs,LeakyRelu:()=>ti,Less:()=>ni,LessEqual:()=>ri,LinSpace:()=>$h,Log:()=>Ea,Log1p:()=>nc,LogSoftmax:()=>jI,LogicalAnd:()=>si,LogicalNot:()=>rc,LogicalOr:()=>Jl,MathBackendCPU:()=>$w,MathBackendWebGL:()=>ik,Max:()=>Aa,MaxPool:()=>Fa,MaxPool3D:()=>td,MaxPool3DGrad:()=>Rh,MaxPoolGrad:()=>Dh,MaxPoolWithArgmax:()=>Ph,Maximum:()=>$a,Mean:()=>Da,Min:()=>Ra,Minimum:()=>Pa,MirrorPad:()=>Oa,Mod:()=>sc,MomentumOptimizer:()=>Tf,Multinomial:()=>Oh,Multiply:()=>Ma,Neg:()=>ai,NonMaxSuppressionV3:()=>ii,NonMaxSuppressionV4:()=>ac,NonMaxSuppressionV5:()=>ui,NotEqual:()=>oi,OP_SCOPE_SUFFIX:()=>i1,OneHot:()=>li,OnesLike:()=>ci,Optimizer:()=>Os,OptimizerConstructors:()=>go,Pack:()=>di,PadV2:()=>La,Pool:()=>RD,Pow:()=>Ba,Prelu:()=>za,Prod:()=>pi,RMSPropOptimizer:()=>Nf,RNN:()=>zs,Range:()=>oc,Rank:()=>oy,Real:()=>nd,RealDiv:()=>wa,Reciprocal:()=>ic,Reduction:()=>En,Relu:()=>Wa,Relu6:()=>Ua,Reshape:()=>hi,ResizeBilinear:()=>Va,ResizeBilinearGrad:()=>Lh,ResizeNearestNeighbor:()=>uc,ResizeNearestNeighborGrad:()=>Mh,Reverse:()=>fi,RotateWithOffset:()=>_i,Round:()=>mi,Rsqrt:()=>Ga,SGDOptimizer:()=>Fd,ScatterNd:()=>gi,Select:()=>bi,Selu:()=>cc,Sequential:()=>Zf,Sigmoid:()=>ja,Sign:()=>lc,Sin:()=>Ha,Sinh:()=>vi,Slice:()=>yi,Softmax:()=>Xa,Softplus:()=>dc,SpaceToBatchND:()=>xi,SparseFillEmptyRows:()=>rd,SparseReshape:()=>pc,SparseSegmentMean:()=>sd,SparseSegmentSum:()=>ad,SparseToDense:()=>od,SplitV:()=>wi,Sqrt:()=>qa,Square:()=>hc,SquaredDifference:()=>Ya,Step:()=>eo,StridedSlice:()=>ki,StringNGrams:()=>id,StringSplit:()=>Bh,StringToHashBucketFast:()=>zh,Sub:()=>Qa,Sum:()=>Ka,SymbolicTensor:()=>Zr,Tan:()=>Ii,Tanh:()=>Za,Tensor:()=>Ae,TensorBuffer:()=>Kt,Tile:()=>As,TopK:()=>Si,Transform:()=>Ci,Transpose:()=>Ja,Unique:()=>Wh,Unpack:()=>Ti,UnsortedSegmentSum:()=>ud,Variable:()=>oo,ZerosLike:()=>Ni,_FusedMatMul:()=>to,abs:()=>Xt,acos:()=>H1,acosh:()=>j1,add:()=>Z,addN:()=>q1,all:()=>By,any:()=>Jh,argMax:()=>xc,argMin:()=>K1,asin:()=>X1,asinh:()=>Y1,atan:()=>Q1,atan2:()=>Z1,atanh:()=>J1,avgPool:()=>Ar,avgPool3d:()=>Vy,backend:()=>G1,backend_util:()=>N,basicLSTMCell:()=>NP,batchNorm:()=>ho,batchNorm2d:()=>rS,batchNorm3d:()=>sS,batchNorm4d:()=>aS,batchToSpaceND:()=>tf,bincount:()=>Uy,booleanMaskAsync:()=>LL,broadcastArgs:()=>oS,broadcastTo:()=>Id,broadcast_util:()=>Ri,browser:()=>Pi,buffer:()=>$e,callbacks:()=>d6,cast:()=>ue,ceil:()=>iS,clipByValue:()=>dn,clone:()=>Fs,complex:()=>io,concat:()=>ot,concat1d:()=>uS,concat2d:()=>cS,concat3d:()=>lS,concat4d:()=>dS,constraints:()=>y0,conv1d:()=>Gy,conv2d:()=>Wt,conv2dTranspose:()=>jy,conv3d:()=>qy,conv3dTranspose:()=>hS,copyRegisteredKernels:()=>LD,cos:()=>nf,cosh:()=>Ky,cosineWindow:()=>vv,cumsum:()=>Xy,customGrad:()=>cs,data:()=>MC,denseBincount:()=>fS,deprecationWarn:()=>My,depthToSpace:()=>mS,depthwiseConv2d:()=>Bi,deregisterOp:()=>f6,device_util:()=>bc,diag:()=>rO,dilation2d:()=>gS,disableDeprecationWarnings:()=>B3,dispose:()=>Fe,disposeVariables:()=>z3,div:()=>me,divNoNan:()=>bS,dot:()=>lO,dropout:()=>jS,einsum:()=>yS,elu:()=>Sd,enableDebugMode:()=>L3,enableProdMode:()=>M3,enclosingPowerOfTwo:()=>qS,engine:()=>is,env:()=>X,equal:()=>mr,erf:()=>vS,exp:()=>Tn,expandDims:()=>Nn,expm1:()=>xS,eye:()=>Yy,fft:()=>ff,fill:()=>_n,findBackend:()=>q3,findBackendFactory:()=>K3,floor:()=>Cd,floorDiv:()=>Ly,forceHalfFloat:()=>m_,fused:()=>mo,gather:()=>Ic,gatherND:()=>HS,gather_util:()=>Ey,getBackend:()=>H3,getGradient:()=>ny,getKernel:()=>Vh,getKernelsForBackend:()=>Uh,getThreadsCount:()=>Xme,gpgpu_util:()=>WN,grad:()=>PO,grads:()=>OO,greater:()=>nr,greaterEqual:()=>zi,ifft:()=>Ed,imag:()=>rf,image:()=>ar,inTopKAsync:()=>XL,initializers:()=>C0,input:()=>m2,io:()=>tn,irfft:()=>hv,isFinite:()=>CO,isInf:()=>NO,isNaN:()=>wS,keep:()=>nn,kernel_impls:()=>Dr,layers:()=>O0,leakyRelu:()=>sf,less:()=>Qy,lessEqual:()=>Wi,linalg:()=>r0,linspace:()=>kS,loadGraphModel:()=>b5,loadLayersModel:()=>kG,localResponseNormalization:()=>IS,log:()=>gr,log1p:()=>af,logSigmoid:()=>VO,logSoftmax:()=>Zy,logSumExp:()=>_S,logicalAnd:()=>Hr,logicalNot:()=>uf,logicalOr:()=>tv,logicalXor:()=>eM,losses:()=>Dz,matMul:()=>Re,math:()=>C1,max:()=>Gr,maxPool:()=>Vt,maxPool3d:()=>nv,maxPoolWithArgmax:()=>ES,maximum:()=>Ds,mean:()=>Ot,memory:()=>Zh,meshgrid:()=>oM,metrics:()=>J2,min:()=>cf,minimum:()=>Td,mirrorPad:()=>AS,mod:()=>$S,model:()=>xG,models:()=>eC,moments:()=>lf,movingAverage:()=>WL,mul:()=>V,multiRNNCell:()=>fM,multinomial:()=>FS,neg:()=>Ft,nextFrame:()=>s0,norm:()=>bv,notEqual:()=>Cc,oneHot:()=>xd,ones:()=>rr,onesLike:()=>br,op:()=>W,outerProduct:()=>vM,pad:()=>Fr,pad1d:()=>kM,pad2d:()=>SM,pad3d:()=>TM,pad4d:()=>_M,pool:()=>DM,pow:()=>fo,prelu:()=>pf,print:()=>v1,prod:()=>rv,profile:()=>W3,rand:()=>LM,randomGamma:()=>VM,randomNormal:()=>DS,randomUniform:()=>Tc,range:()=>Nc,ready:()=>G3,real:()=>Nd,reciprocal:()=>RS,registerBackend:()=>wd,registerCallbackConstructor:()=>IG,registerGradient:()=>qI,registerKernel:()=>mc,registerOp:()=>h6,regularizers:()=>tC,relu:()=>Qe,relu6:()=>ov,removeBackend:()=>j3,reshape:()=>G,reverse:()=>yr,reverse1d:()=>QM,reverse2d:()=>JM,reverse3d:()=>tL,reverse4d:()=>rL,rfft:()=>mf,round:()=>iv,rsqrt:()=>uv,scalar:()=>ke,scatterND:()=>GS,scatter_util:()=>Ay,selu:()=>cv,separableConv2d:()=>_c,sequential:()=>wG,serialization:()=>oe,setBackend:()=>U3,setPlatform:()=>X3,setThreadsCount:()=>Kme,setWasmPath:()=>jme,setWasmPaths:()=>qme,setWebGLContext:()=>dN,setdiff1dAsync:()=>PS,shared:()=>fm,sigmoid:()=>$r,sign:()=>OS,signal:()=>Fz,sin:()=>lv,sinh:()=>dv,slice:()=>Ve,slice1d:()=>hf,slice2d:()=>pv,slice3d:()=>Ec,slice4d:()=>_d,slice_util:()=>$t,softmax:()=>ls,softplus:()=>Sc,spaceToBatchND:()=>df,sparse:()=>$d,sparseToDense:()=>yv,spectral:()=>$z,split:()=>sr,sqrt:()=>vn,square:()=>ft,squaredDifference:()=>fv,squeeze:()=>Rs,stack:()=>Ut,step:()=>Ad,stridedSlice:()=>MS,string:()=>wf,sub:()=>he,sum:()=>ve,sumOutType:()=>bd,tan:()=>LS,tanh:()=>kc,tensor:()=>er,tensor1d:()=>je,tensor2d:()=>jr,tensor3d:()=>Qh,tensor4d:()=>qr,tensor5d:()=>EL,tensor6d:()=>AL,tensor_util:()=>Vr,test_util:()=>W1,tidy:()=>M,tile:()=>tr,time:()=>V3,topk:()=>BS,train:()=>Ui,transpose:()=>Oe,truncatedNormal:()=>gf,unique:()=>mv,unregisterGradient:()=>MD,unregisterKernel:()=>OD,unsortedSegmentSum:()=>zS,unstack:()=>vt,upcastType:()=>In,util:()=>w,valueAndGrad:()=>MO,valueAndGrads:()=>LO,variable:()=>WS,variableGrads:()=>SS,version:()=>Zme,version_converter:()=>y5,version_core:()=>O3,version_cpu:()=>sq,version_layers:()=>tx,version_wasm:()=>Yme,version_webgl:()=>NQ,webgl:()=>_Q,webgl_util:()=>lN,webgpu:()=>QE,where:()=>Cn,whereAsync:()=>gv,zeros:()=>kt,zerosLike:()=>Xe});var GF=Object.create,uh=Object.defineProperty,HF=Object.getOwnPropertyDescriptor,jF=Object.getOwnPropertyNames,qF=Object.getPrototypeOf,KF=Object.prototype.hasOwnProperty,AI=e=>uh(e,"__esModule",{value:!0}),qt=(e,t)=>function(){return t||(0,e[Object.keys(e)[0]])((t={exports:{}}).exports,t),t.exports},Ee=(e,t)=>{AI(e);for(var n in t)uh(e,n,{get:t[n],enumerable:!0})},XF=(e,t,n)=>{if(t&&typeof t=="object"||typeof t=="function")for(let r of jF(t))!KF.call(e,r)&&r!=="default"&&uh(e,r,{get:()=>t[r],enumerable:!(n=HF(t,r))||n.enumerable});return e},Bo=e=>XF(AI(uh(e!=null?GF(qF(e)):{},"default",e&&e.__esModule&&"default"in e?{get:()=>e.default,enumerable:!0}:{value:e,enumerable:!0})),e),YF=qt({"src/node_modules/long/src/long.js"(e,t){t.exports=r;var n=null;try{n=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(R){}function r(R,_,L){this.low=R|0,this.high=_|0,this.unsigned=!!L}r.prototype.__isLong__,Object.defineProperty(r.prototype,"__isLong__",{value:!0});function s(R){return(R&&R.__isLong__)===!0}r.isLong=s;var a={},o={};function i(R,_){var L,U,j;return _?(R>>>=0,(j=0<=R&&R<256)&&(U=o[R],U)?U:(L=l(R,(R|0)<0?-1:0,!0),j&&(o[R]=L),L)):(R|=0,(j=-128<=R&&R<128)&&(U=a[R],U)?U:(L=l(R,R<0?-1:0,!1),j&&(a[R]=L),L))}r.fromInt=i;function u(R,_){if(isNaN(R))return _?x:v;if(_){if(R<0)return x;if(R>=g)return F}else{if(R<=-b)return O;if(R+1>=b)return E}return R<0?u(-R,_).neg():l(R%m|0,R/m|0,_)}r.fromNumber=u;function l(R,_,L){return new r(R,_,L)}r.fromBits=l;var c=Math.pow;function d(R,_,L){if(R.length===0)throw Error("empty string");if(R==="NaN"||R==="Infinity"||R==="+Infinity"||R==="-Infinity")return v;if(typeof _=="number"?(L=_,_=!1):_=!!_,L=L||10,L<2||36<L)throw RangeError("radix");var U;if((U=R.indexOf("-"))>0)throw Error("interior hyphen");if(U===0)return d(R.substring(1),_,L).neg();for(var j=u(c(L,8)),K=v,q=0;q<R.length;q+=8){var Q=Math.min(8,R.length-q),ee=parseInt(R.substring(q,q+Q),L);if(Q<8){var re=u(c(L,Q));K=K.mul(re).add(u(ee))}else K=K.mul(j),K=K.add(u(ee))}return K.unsigned=_,K}r.fromString=d;function p(R,_){return typeof R=="number"?u(R,_):typeof R=="string"?d(R,_):l(R.low,R.high,typeof _=="boolean"?_:R.unsigned)}r.fromValue=p;var h=1<<16,f=1<<24,m=h*h,g=m*m,b=g/2,y=i(f),v=i(0);r.ZERO=v;var x=i(0,!0);r.UZERO=x;var k=i(1);r.ONE=k;var T=i(1,!0);r.UONE=T;var C=i(-1);r.NEG_ONE=C;var E=l(4294967295|0,2147483647|0,!1);r.MAX_VALUE=E;var F=l(4294967295|0,4294967295|0,!0);r.MAX_UNSIGNED_VALUE=F;var O=l(0,2147483648|0,!1);r.MIN_VALUE=O;var D=r.prototype;D.toInt=function(){return this.unsigned?this.low>>>0:this.low},D.toNumber=function(){return this.unsigned?(this.high>>>0)*m+(this.low>>>0):this.high*m+(this.low>>>0)},D.toString=function(_){if(_=_||10,_<2||36<_)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(O)){var L=u(_),U=this.div(L),j=U.mul(L).sub(this);return U.toString(_)+j.toInt().toString(_)}else return"-"+this.neg().toString(_);for(var K=u(c(_,6),this.unsigned),q=this,Q="";;){var ee=q.div(K),re=q.sub(ee.mul(K)).toInt()>>>0,se=re.toString(_);if(q=ee,q.isZero())return se+Q;for(;se.length<6;)se="0"+se;Q=""+se+Q}},D.getHighBits=function(){return this.high},D.getHighBitsUnsigned=function(){return this.high>>>0},D.getLowBits=function(){return this.low},D.getLowBitsUnsigned=function(){return this.low>>>0},D.getNumBitsAbs=function(){if(this.isNegative())return this.eq(O)?64:this.neg().getNumBitsAbs();for(var _=this.high!=0?this.high:this.low,L=31;L>0&&(_&1<<L)==0;L--);return this.high!=0?L+33:L+1},D.isZero=function(){return this.high===0&&this.low===0},D.eqz=D.isZero,D.isNegative=function(){return!this.unsigned&&this.high<0},D.isPositive=function(){return this.unsigned||this.high>=0},D.isOdd=function(){return(this.low&1)==1},D.isEven=function(){return(this.low&1)==0},D.equals=function(_){return s(_)||(_=p(_)),this.unsigned!==_.unsigned&&this.high>>>31==1&&_.high>>>31==1?!1:this.high===_.high&&this.low===_.low},D.eq=D.equals,D.notEquals=function(_){return!this.eq(_)},D.neq=D.notEquals,D.ne=D.notEquals,D.lessThan=function(_){return this.comp(_)<0},D.lt=D.lessThan,D.lessThanOrEqual=function(_){return this.comp(_)<=0},D.lte=D.lessThanOrEqual,D.le=D.lessThanOrEqual,D.greaterThan=function(_){return this.comp(_)>0},D.gt=D.greaterThan,D.greaterThanOrEqual=function(_){return this.comp(_)>=0},D.gte=D.greaterThanOrEqual,D.ge=D.greaterThanOrEqual,D.compare=function(_){if(s(_)||(_=p(_)),this.eq(_))return 0;var L=this.isNegative(),U=_.isNegative();return L&&!U?-1:!L&&U?1:this.unsigned?_.high>>>0>this.high>>>0||_.high===this.high&&_.low>>>0>this.low>>>0?-1:1:this.sub(_).isNegative()?-1:1},D.comp=D.compare,D.negate=function(){return!this.unsigned&&this.eq(O)?O:this.not().add(k)},D.neg=D.negate,D.add=function(_){s(_)||(_=p(_));var L=this.high>>>16,U=this.high&65535,j=this.low>>>16,K=this.low&65535,q=_.high>>>16,Q=_.high&65535,ee=_.low>>>16,re=_.low&65535,se=0,ne=0,ie=0,te=0;return te+=K+re,ie+=te>>>16,te&=65535,ie+=j+ee,ne+=ie>>>16,ie&=65535,ne+=U+Q,se+=ne>>>16,ne&=65535,se+=L+q,se&=65535,l(ie<<16|te,se<<16|ne,this.unsigned)},D.subtract=function(_){return s(_)||(_=p(_)),this.add(_.neg())},D.sub=D.subtract,D.multiply=function(_){if(this.isZero())return v;if(s(_)||(_=p(_)),n){var L=n.mul(this.low,this.high,_.low,_.high);return l(L,n.get_high(),this.unsigned)}if(_.isZero())return v;if(this.eq(O))return _.isOdd()?O:v;if(_.eq(O))return this.isOdd()?O:v;if(this.isNegative())return _.isNegative()?this.neg().mul(_.neg()):this.neg().mul(_).neg();if(_.isNegative())return this.mul(_.neg()).neg();if(this.lt(y)&&_.lt(y))return u(this.toNumber()*_.toNumber(),this.unsigned);var U=this.high>>>16,j=this.high&65535,K=this.low>>>16,q=this.low&65535,Q=_.high>>>16,ee=_.high&65535,re=_.low>>>16,se=_.low&65535,ne=0,ie=0,te=0,pe=0;return pe+=q*se,te+=pe>>>16,pe&=65535,te+=K*se,ie+=te>>>16,te&=65535,te+=q*re,ie+=te>>>16,te&=65535,ie+=j*se,ne+=ie>>>16,ie&=65535,ie+=K*re,ne+=ie>>>16,ie&=65535,ie+=q*ee,ne+=ie>>>16,ie&=65535,ne+=U*se+j*re+K*ee+q*Q,ne&=65535,l(te<<16|pe,ne<<16|ie,this.unsigned)},D.mul=D.multiply,D.divide=function(_){if(s(_)||(_=p(_)),_.isZero())throw Error("division by zero");if(n){if(!this.unsigned&&this.high===-2147483648&&_.low===-1&&_.high===-1)return this;var L=(this.unsigned?n.div_u:n.div_s)(this.low,this.high,_.low,_.high);return l(L,n.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?x:v;var U,j,K;if(this.unsigned){if(_.unsigned||(_=_.toUnsigned()),_.gt(this))return x;if(_.gt(this.shru(1)))return T;K=x}else{if(this.eq(O)){if(_.eq(k)||_.eq(C))return O;if(_.eq(O))return k;var q=this.shr(1);return U=q.div(_).shl(1),U.eq(v)?_.isNegative()?k:C:(j=this.sub(_.mul(U)),K=U.add(j.div(_)),K)}else if(_.eq(O))return this.unsigned?x:v;if(this.isNegative())return _.isNegative()?this.neg().div(_.neg()):this.neg().div(_).neg();if(_.isNegative())return this.div(_.neg()).neg();K=v}for(j=this;j.gte(_);){U=Math.max(1,Math.floor(j.toNumber()/_.toNumber()));for(var Q=Math.ceil(Math.log(U)/Math.LN2),ee=Q<=48?1:c(2,Q-48),re=u(U),se=re.mul(_);se.isNegative()||se.gt(j);)U-=ee,re=u(U,this.unsigned),se=re.mul(_);re.isZero()&&(re=k),K=K.add(re),j=j.sub(se)}return K},D.div=D.divide,D.modulo=function(_){if(s(_)||(_=p(_)),n){var L=(this.unsigned?n.rem_u:n.rem_s)(this.low,this.high,_.low,_.high);return l(L,n.get_high(),this.unsigned)}return this.sub(this.div(_).mul(_))},D.mod=D.modulo,D.rem=D.modulo,D.not=function(){return l(~this.low,~this.high,this.unsigned)},D.and=function(_){return s(_)||(_=p(_)),l(this.low&_.low,this.high&_.high,this.unsigned)},D.or=function(_){return s(_)||(_=p(_)),l(this.low|_.low,this.high|_.high,this.unsigned)},D.xor=function(_){return s(_)||(_=p(_)),l(this.low^_.low,this.high^_.high,this.unsigned)},D.shiftLeft=function(_){return s(_)&&(_=_.toInt()),(_&=63)==0?this:_<32?l(this.low<<_,this.high<<_|this.low>>>32-_,this.unsigned):l(0,this.low<<_-32,this.unsigned)},D.shl=D.shiftLeft,D.shiftRight=function(_){return s(_)&&(_=_.toInt()),(_&=63)==0?this:_<32?l(this.low>>>_|this.high<<32-_,this.high>>_,this.unsigned):l(this.high>>_-32,this.high>=0?0:-1,this.unsigned)},D.shr=D.shiftRight,D.shiftRightUnsigned=function(_){if(s(_)&&(_=_.toInt()),_&=63,_===0)return this;var L=this.high;if(_<32){var U=this.low;return l(U>>>_|L<<32-_,L>>>_,this.unsigned)}else return _===32?l(L,0,this.unsigned):l(L>>>_-32,0,this.unsigned)},D.shru=D.shiftRightUnsigned,D.shr_u=D.shiftRightUnsigned,D.toSigned=function(){return this.unsigned?l(this.low,this.high,!1):this},D.toUnsigned=function(){return this.unsigned?this:l(this.low,this.high,!0)},D.toBytes=function(_){return _?this.toBytesLE():this.toBytesBE()},D.toBytesLE=function(){var _=this.high,L=this.low;return[L&255,L>>>8&255,L>>>16&255,L>>>24,_&255,_>>>8&255,_>>>16&255,_>>>24]},D.toBytesBE=function(){var _=this.high,L=this.low;return[_>>>24,_>>>16&255,_>>>8&255,_&255,L>>>24,L>>>16&255,L>>>8&255,L&255]},r.fromBytes=function(_,L,U){return U?r.fromBytesLE(_,L):r.fromBytesBE(_,L)},r.fromBytesLE=function(_,L){return new r(_[0]|_[1]<<8|_[2]<<16|_[3]<<24,_[4]|_[5]<<8|_[6]<<16|_[7]<<24,L)},r.fromBytesBE=function(_,L){return new r(_[4]<<24|_[5]<<16|_[6]<<8|_[7],_[0]<<24|_[1]<<16|_[2]<<8|_[3],L)}}}),QF=qt({"(disabled):src/node_modules/node-fetch/browser.js"(){}}),ZF=qt({"(disabled):util"(){}}),JF=qt({"src/node_modules/seedrandom/lib/alea.js"(e,t){(function(n,r,s){function a(l){var c=this,d=u();c.next=function(){var p=2091639*c.s0+c.c*23283064365386963e-26;return c.s0=c.s1,c.s1=c.s2,c.s2=p-(c.c=p|0)},c.c=1,c.s0=d(" "),c.s1=d(" "),c.s2=d(" "),c.s0-=d(l),c.s0<0&&(c.s0+=1),c.s1-=d(l),c.s1<0&&(c.s1+=1),c.s2-=d(l),c.s2<0&&(c.s2+=1),d=null}function o(l,c){return c.c=l.c,c.s0=l.s0,c.s1=l.s1,c.s2=l.s2,c}function i(l,c){var d=new a(l),p=c&&c.state,h=d.next;return h.int32=function(){return d.next()*4294967296|0},h.double=function(){return h()+(h()*2097152|0)*11102230246251565e-32},h.quick=h,p&&(typeof p=="object"&&o(p,d),h.state=function(){return o(d,{})}),h}function u(){var l=4022871197,c=function(d){d=String(d);for(var p=0;p<d.length;p++){l+=d.charCodeAt(p);var h=.02519603282416938*l;l=h>>>0,h-=l,h*=l,l=h>>>0,h-=l,l+=h*4294967296}return(l>>>0)*23283064365386963e-26};return c}r&&r.exports?r.exports=i:s&&s.amd?s(function(){return i}):this.alea=i})(e,typeof t=="object"&&t,typeof define=="function"&&define)}}),eD=qt({"src/node_modules/seedrandom/lib/xor128.js"(e,t){(function(n,r,s){function a(u){var l=this,c="";l.x=0,l.y=0,l.z=0,l.w=0,l.next=function(){var p=l.x^l.x<<11;return l.x=l.y,l.y=l.z,l.z=l.w,l.w^=l.w>>>19^p^p>>>8},u===(u|0)?l.x=u:c+=u;for(var d=0;d<c.length+64;d++)l.x^=c.charCodeAt(d)|0,l.next()}function o(u,l){return l.x=u.x,l.y=u.y,l.z=u.z,l.w=u.w,l}function i(u,l){var c=new a(u),d=l&&l.state,p=function(){return(c.next()>>>0)/4294967296};return p.double=function(){do var h=c.next()>>>11,f=(c.next()>>>0)/4294967296,m=(h+f)/(1<<21);while(m===0);return m},p.int32=c.next,p.quick=p,d&&(typeof d=="object"&&o(d,c),p.state=function(){return o(c,{})}),p}r&&r.exports?r.exports=i:s&&s.amd?s(function(){return i}):this.xor128=i})(e,typeof t=="object"&&t,typeof define=="function"&&define)}}),tD=qt({"src/node_modules/seedrandom/lib/xorwow.js"(e,t){(function(n,r,s){function a(u){var l=this,c="";l.next=function(){var p=l.x^l.x>>>2;return l.x=l.y,l.y=l.z,l.z=l.w,l.w=l.v,(l.d=l.d+362437|0)+(l.v=l.v^l.v<<4^(p^p<<1))|0},l.x=0,l.y=0,l.z=0,l.w=0,l.v=0,u===(u|0)?l.x=u:c+=u;for(var d=0;d<c.length+64;d++)l.x^=c.charCodeAt(d)|0,d==c.length&&(l.d=l.x<<10^l.x>>>4),l.next()}function o(u,l){return l.x=u.x,l.y=u.y,l.z=u.z,l.w=u.w,l.v=u.v,l.d=u.d,l}function i(u,l){var c=new a(u),d=l&&l.state,p=function(){return(c.next()>>>0)/4294967296};return p.double=function(){do var h=c.next()>>>11,f=(c.next()>>>0)/4294967296,m=(h+f)/(1<<21);while(m===0);return m},p.int32=c.next,p.quick=p,d&&(typeof d=="object"&&o(d,c),p.state=function(){return o(c,{})}),p}r&&r.exports?r.exports=i:s&&s.amd?s(function(){return i}):this.xorwow=i})(e,typeof t=="object"&&t,typeof define=="function"&&define)}}),nD=qt({"src/node_modules/seedrandom/lib/xorshift7.js"(e,t){(function(n,r,s){function a(u){var l=this;l.next=function(){var d=l.x,p=l.i,h,f,m;return h=d[p],h^=h>>>7,f=h^h<<24,h=d[p+1&7],f^=h^h>>>10,h=d[p+3&7],f^=h^h>>>3,h=d[p+4&7],f^=h^h<<7,h=d[p+7&7],h=h^h<<13,f^=h^h<<9,d[p]=f,l.i=p+1&7,f};function c(d,p){var h,f,m=[];if(p===(p|0))f=m[0]=p;else for(p=""+p,h=0;h<p.length;++h)m[h&7]=m[h&7]<<15^p.charCodeAt(h)+m[h+1&7]<<13;for(;m.length<8;)m.push(0);for(h=0;h<8&&m[h]===0;++h);for(h==8?f=m[7]=-1:f=m[h],d.x=m,d.i=0,h=256;h>0;--h)d.next()}c(l,u)}function o(u,l){return l.x=u.x.slice(),l.i=u.i,l}function i(u,l){u==null&&(u=+new Date);var c=new a(u),d=l&&l.state,p=function(){return(c.next()>>>0)/4294967296};return p.double=function(){do var h=c.next()>>>11,f=(c.next()>>>0)/4294967296,m=(h+f)/(1<<21);while(m===0);return m},p.int32=c.next,p.quick=p,d&&(d.x&&o(d,c),p.state=function(){return o(c,{})}),p}r&&r.exports?r.exports=i:s&&s.amd?s(function(){return i}):this.xorshift7=i})(e,typeof t=="object"&&t,typeof define=="function"&&define)}}),rD=qt({"src/node_modules/seedrandom/lib/xor4096.js"(e,t){(function(n,r,s){function a(u){var l=this;l.next=function(){var d=l.w,p=l.X,h=l.i,f,m;return l.w=d=d+1640531527|0,m=p[h+34&127],f=p[h=h+1&127],m^=m<<13,f^=f<<17,m^=m>>>15,f^=f>>>12,m=p[h]=m^f,l.i=h,m+(d^d>>>16)|0};function c(d,p){var h,f,m,g,b,y=[],v=128;for(p===(p|0)?(f=p,p=null):(p=p+"\0",f=0,v=Math.max(v,p.length)),m=0,g=-32;g<v;++g)p&&(f^=p.charCodeAt((g+32)%p.length)),g===0&&(b=f),f^=f<<10,f^=f>>>15,f^=f<<4,f^=f>>>13,g>=0&&(b=b+1640531527|0,h=y[g&127]^=f+b,m=h==0?m+1:0);for(m>=128&&(y[(p&&p.length||0)&127]=-1),m=127,g=4*128;g>0;--g)f=y[m+34&127],h=y[m=m+1&127],f^=f<<13,h^=h<<17,f^=f>>>15,h^=h>>>12,y[m]=f^h;d.w=b,d.X=y,d.i=m}c(l,u)}function o(u,l){return l.i=u.i,l.w=u.w,l.X=u.X.slice(),l}function i(u,l){u==null&&(u=+new Date);var c=new a(u),d=l&&l.state,p=function(){return(c.next()>>>0)/4294967296};return p.double=function(){do var h=c.next()>>>11,f=(c.next()>>>0)/4294967296,m=(h+f)/(1<<21);while(m===0);return m},p.int32=c.next,p.quick=p,d&&(d.X&&o(d,c),p.state=function(){return o(c,{})}),p}r&&r.exports?r.exports=i:s&&s.amd?s(function(){return i}):this.xor4096=i})(e,typeof t=="object"&&t,typeof define=="function"&&define)}}),sD=qt({"src/node_modules/seedrandom/lib/tychei.js"(e,t){(function(n,r,s){function a(u){var l=this,c="";l.next=function(){var p=l.b,h=l.c,f=l.d,m=l.a;return p=p<<25^p>>>7^h,h=h-f|0,f=f<<24^f>>>8^m,m=m-p|0,l.b=p=p<<20^p>>>12^h,l.c=h=h-f|0,l.d=f<<16^h>>>16^m,l.a=m-p|0},l.a=0,l.b=0,l.c=2654435769|0,l.d=1367130551,u===Math.floor(u)?(l.a=u/4294967296|0,l.b=u|0):c+=u;for(var d=0;d<c.length+20;d++)l.b^=c.charCodeAt(d)|0,l.next()}function o(u,l){return l.a=u.a,l.b=u.b,l.c=u.c,l.d=u.d,l}function i(u,l){var c=new a(u),d=l&&l.state,p=function(){return(c.next()>>>0)/4294967296};return p.double=function(){do var h=c.next()>>>11,f=(c.next()>>>0)/4294967296,m=(h+f)/(1<<21);while(m===0);return m},p.int32=c.next,p.quick=p,d&&(typeof d=="object"&&o(d,c),p.state=function(){return o(c,{})}),p}r&&r.exports?r.exports=i:s&&s.amd?s(function(){return i}):this.tychei=i})(e,typeof t=="object"&&t,typeof define=="function"&&define)}}),aD=qt({"(disabled):crypto"(){}}),oD=qt({"src/node_modules/seedrandom/seedrandom.js"(e,t){(function(n,r,s){var a=256,o=6,i=52,u="random",l=s.pow(a,o),c=s.pow(2,i),d=c*2,p=a-1,h;function f(k,T,C){var E=[];T=T==!0?{entropy:!0}:T||{};var F=y(b(T.entropy?[k,x(r)]:k==null?v():k,3),E),O=new m(E),D=function(){for(var R=O.g(o),_=l,L=0;R<c;)R=(R+L)*a,_*=a,L=O.g(1);for(;R>=d;)R/=2,_/=2,L>>>=1;return(R+L)/_};return D.int32=function(){return O.g(4)|0},D.quick=function(){return O.g(4)/4294967296},D.double=D,y(x(O.S),r),(T.pass||C||function(R,_,L,U){return U&&(U.S&&g(U,O),R.state=function(){return g(O,{})}),L?(s[u]=R,_):R})(D,F,"global"in T?T.global:this==s,T.state)}function m(k){var T,C=k.length,E=this,F=0,O=E.i=E.j=0,D=E.S=[];for(C||(k=[C++]);F<a;)D[F]=F++;for(F=0;F<a;F++)D[F]=D[O=p&O+k[F%C]+(T=D[F])],D[O]=T;(E.g=function(R){for(var _,L=0,U=E.i,j=E.j,K=E.S;R--;)_=K[U=p&U+1],L=L*a+K[p&(K[U]=K[j=p&j+_])+(K[j]=_)];return E.i=U,E.j=j,L})(a)}function g(k,T){return T.i=k.i,T.j=k.j,T.S=k.S.slice(),T}function b(k,T){var C=[],E=typeof k,F;if(T&&E=="object")for(F in k)try{C.push(b(k[F],T-1))}catch(O){}return C.length?C:E=="string"?k:k+"\0"}function y(k,T){for(var C=k+"",E,F=0;F<C.length;)T[p&F]=p&(E^=T[p&F]*19)+C.charCodeAt(F++);return x(T)}function v(){try{var k;return h&&(k=h.randomBytes)?k=k(a):(k=new Uint8Array(a),(n.crypto||n.msCrypto).getRandomValues(k)),x(k)}catch(E){var T=n.navigator,C=T&&T.plugins;return[+new Date,n,C,n.screen,x(r)]}}function x(k){return String.fromCharCode.apply(0,k)}if(y(s.random(),r),typeof t=="object"&&t.exports){t.exports=f;try{h=aD()}catch(k){}}else typeof define=="function"&&define.amd?define(function(){return f}):s["seed"+u]=f})(typeof self!="undefined"?self:e,[],Math)}}),ch=qt({"src/node_modules/seedrandom/index.js"(e,t){var n=JF(),r=eD(),s=tD(),a=nD(),o=rD(),i=sD(),u=oD();u.alea=n,u.xor128=r,u.xorwow=s,u.xorshift7=a,u.xor4096=o,u.tychei=i,t.exports=u}}),$I=qt({"(disabled):src/node_modules/string_decoder/index.js"(){}}),lh=qt({"(disabled):fs"(){}}),Vl=qt({"(disabled):path"(){}}),iD=qt({"(disabled):worker_threads"(){}}),uD=qt({"(disabled):perf_hooks"(){}}),cD=qt({"(disabled):os"(){}}),lD=qt({"src/tfjs-backend-wasm/wasm-out/tfjs-backend-wasm-threaded-simd.js"(e,t){var n=function(){var r=typeof document!="undefined"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename!="undefined"&&(r=r||__filename),function(s){s=s||{};function a(){return te.buffer!=tt&&Wn(te.buffer),Qn}function o(){return te.buffer!=tt&&Wn(te.buffer),cn}function i(){return te.buffer!=tt&&Wn(te.buffer),Zn}function u(){return te.buffer!=tt&&Wn(te.buffer),dr}function l(){return te.buffer!=tt&&Wn(te.buffer),pr}var c=typeof s!="undefined"?s:{},d,p;c.ready=new Promise(function(S,A){d=S,p=A});var h;typeof process!="undefined"&&process.listeners&&(h={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var f={},m;for(m in c)c.hasOwnProperty(m)&&(f[m]=c[m]);var g=[],b="./this.program",y=function(S,A){throw A},v=!1,x=!1,k=!1,T=!1;v=typeof window=="object",x=typeof importScripts=="function",k=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",T=!v&&!k&&!x;var C=c.ENVIRONMENT_IS_PTHREAD||!1;C&&(tt=c.buffer);var E="";function F(S){return c.locateFile?c.locateFile(S,E):E+S}var O,D,R,_,L,U;if(k){x?E=Vl().dirname(E)+"/":E=__dirname+"/",O=function(A,B){return L||(L=lh()),U||(U=Vl()),A=U.normalize(A),L.readFileSync(A,B?null:"utf8")},R=function(A){var B=O(A,!0);return B.buffer||(B=new Uint8Array(B)),Ie(B.buffer),B},process.argv.length>1&&(b=process.argv[1].replace(/\\/g,"/")),g=process.argv.slice(2),process.on("uncaughtException",function(S){if(!(S instanceof Wl))throw S}),process.on("unhandledRejection",Cs),y=function(S){process.exit(S)},c.inspect=function(){return"[Emscripten Module object]"};var j;try{j=iD()}catch(S){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),S}global.Worker=j.Worker}else T?(typeof read!="undefined"&&(O=function(A){return read(A)}),R=function(A){var B;return typeof readbuffer=="function"?new Uint8Array(readbuffer(A)):(B=read(A,"binary"),Ie(typeof B=="object"),B)},typeof scriptArgs!="undefined"?g=scriptArgs:typeof arguments!="undefined"&&(g=arguments),typeof quit=="function"&&(y=function(S){quit(S)}),typeof print!="undefined"&&(typeof console=="undefined"&&(console={}),console.log=print,console.warn=console.error=typeof printErr!="undefined"?printErr:print)):(v||x)&&(x?E=self.location.href:typeof document!="undefined"&&document.currentScript&&(E=document.currentScript.src),typeof r!="undefined"&&r&&(E=r),E.indexOf("blob:")!==0?E=E.substr(0,E.lastIndexOf("/")+1):E="",k?(O=function(A,B){return L||(L=lh()),U||(U=Vl()),A=U.normalize(A),L.readFileSync(A,B?null:"utf8")},R=function(A){var B=O(A,!0);return B.buffer||(B=new Uint8Array(B)),Ie(B.buffer),B}):(O=function(S){var A=new XMLHttpRequest;return A.open("GET",S,!1),A.send(null),A.responseText},x&&(R=function(S){var A=new XMLHttpRequest;return A.open("GET",S,!1),A.responseType="arraybuffer",A.send(null),new Uint8Array(A.response)}),D=function(S,A,B){var Y=new XMLHttpRequest;Y.open("GET",S,!0),Y.responseType="arraybuffer",Y.onload=function(){if(Y.status==200||Y.status==0&&Y.response){A(Y.response);return}B()},Y.onerror=B,Y.send(null)}),_=function(S){document.title=S});k&&typeof performance=="undefined"&&(global.performance=uD().performance);var K=c.print||console.log.bind(console),q=c.printErr||console.warn.bind(console);for(m in f)f.hasOwnProperty(m)&&(c[m]=f[m]);f=null,c.arguments&&(g=c.arguments),c.thisProgram&&(b=c.thisProgram),c.quit&&(y=c.quit);function Q(S){Q.shown||(Q.shown={}),Q.shown[S]||(Q.shown[S]=1,q(S))}var ee=Atomics.load,re=Atomics.store,se=Atomics.compareExchange,ne;c.wasmBinary&&(ne=c.wasmBinary);var ie=c.noExitRuntime||!0;typeof WebAssembly!="object"&&Cs("no native wasm support detected");var te,pe,be=!1,Ce;function Ie(S,A){S||Cs("Assertion failed: "+A)}function Ne(S){var A=c["_"+S];return Ie(A,"Cannot call unknown function "+S+", make sure it is exported"),A}function Le(S,A,B,Y,de){var ce={string:function(xn){var Ou=0;if(xn!=null&&xn!==0){var _I=(xn.length<<2)+1;Ou=Du(_I),et(xn,Ou,_I)}return Ou},array:function(xn){var Ou=Du(xn.length);return Ct(xn,Ou),Ou}};function le(xn){return A==="string"?Ge(xn):A==="boolean"?Boolean(xn):xn}var xe=Ne(S),it=[],Jt=0;if(Y)for(var jt=0;jt<Y.length;jt++){var oa=ce[B[jt]];oa?(Jt===0&&(Jt=zl()),it[jt]=oa(Y[jt])):it[jt]=Y[jt]}var Pu=xe.apply(null,it);return Pu=le(Pu),Jt!==0&&Fu(Jt),Pu}function Je(S,A,B,Y){B=B||[];var de=B.every(function(le){return le==="number"}),ce=A!=="string";return ce&&de&&!Y?Ne(S):function(){return Le(S,A,B,arguments,Y)}}function qe(S,A,B){for(var Y=A+B,de="";!(A>=Y);){var ce=S[A++];if(!ce)return de;if(!(ce&128)){de+=String.fromCharCode(ce);continue}var le=S[A++]&63;if((ce&224)==192){de+=String.fromCharCode((ce&31)<<6|le);continue}var xe=S[A++]&63;if((ce&240)==224?ce=(ce&15)<<12|le<<6|xe:ce=(ce&7)<<18|le<<12|xe<<6|S[A++]&63,ce<65536)de+=String.fromCharCode(ce);else{var it=ce-65536;de+=String.fromCharCode(55296|it>>10,56320|it&1023)}}return de}function Ge(S,A){return S?qe(o(),S,A):""}function lt(S,A,B,Y){if(!(Y>0))return 0;for(var de=B,ce=B+Y-1,le=0;le<S.length;++le){var xe=S.charCodeAt(le);if(xe>=55296&&xe<=57343){var it=S.charCodeAt(++le);xe=65536+((xe&1023)<<10)|it&1023}if(xe<=127){if(B>=ce)break;A[B++]=xe}else if(xe<=2047){if(B+1>=ce)break;A[B++]=192|xe>>6,A[B++]=128|xe&63}else if(xe<=65535){if(B+2>=ce)break;A[B++]=224|xe>>12,A[B++]=128|xe>>6&63,A[B++]=128|xe&63}else{if(B+3>=ce)break;A[B++]=240|xe>>18,A[B++]=128|xe>>12&63,A[B++]=128|xe>>6&63,A[B++]=128|xe&63}}return A[B]=0,B-de}function et(S,A,B){return lt(S,o(),A,B)}function pt(S){for(var A=0,B=0;B<S.length;++B){var Y=S.charCodeAt(B);Y>=55296&&Y<=57343&&(Y=65536+((Y&1023)<<10)|S.charCodeAt(++B)&1023),Y<=127?++A:Y<=2047?A+=2:Y<=65535?A+=3:A+=4}return A}function Ct(S,A){a().set(S,A)}function Bn(S,A){return S%A>0&&(S+=A-S%A),S}var tt,Qn,cn,Cr,zn,Zn,dr,Tr,pr;function Wn(S){tt=S,c.HEAP8=Qn=new Int8Array(S),c.HEAP16=Cr=new Int16Array(S),c.HEAP32=Zn=new Int32Array(S),c.HEAPU8=cn=new Uint8Array(S),c.HEAPU16=zn=new Uint16Array(S),c.HEAPU32=dr=new Uint32Array(S),c.HEAPF32=Tr=new Float32Array(S),c.HEAPF64=pr=new Float64Array(S)}var Js=c.INITIAL_MEMORY||16777216;if(C)te=c.wasmMemory,tt=c.buffer;else if(c.wasmMemory)te=c.wasmMemory;else if(te=new WebAssembly.Memory({initial:Js/65536,maximum:2147483648/65536,shared:!0}),!(te.buffer instanceof SharedArrayBuffer))throw q("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),k&&console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)"),Error("bad memory");te&&(tt=te.buffer),Js=tt.byteLength,Wn(tt);var bn,ea=[],hr=[],El=[],Al=[],Ss=[],Rp=!1,Ig=!1;C||hr.push({func:function(){Zp()}});function Pp(){if(!C){if(c.preRun)for(typeof c.preRun=="function"&&(c.preRun=[c.preRun]);c.preRun.length;)Sg(c.preRun.shift());Nu(ea)}}function Op(){Rp=!0,!C&&Nu(hr)}function Mp(){C||Nu(El)}function Vn(){C||(Ig=!0)}function Lp(){if(!C){if(c.postRun)for(typeof c.postRun=="function"&&(c.postRun=[c.postRun]);c.postRun.length;)Cg(c.postRun.shift());Nu(Ss)}}function Sg(S){ea.unshift(S)}function Cg(S){Ss.unshift(S)}var Nr=0,$l=null,Po=null;function Tg(S){Ie(!C,"addRunDependency cannot be used in a pthread worker"),Nr++,c.monitorRunDependencies&&c.monitorRunDependencies(Nr)}function Ng(S){if(Nr--,c.monitorRunDependencies&&c.monitorRunDependencies(Nr),Nr==0&&($l!==null&&(clearInterval($l),$l=null),Po)){var A=Po;Po=null,A()}}c.preloadedImages={},c.preloadedAudios={};function Cs(S){c.onAbort&&c.onAbort(S),C&&console.error("Pthread aborting at "+new Error().stack),S+="",q(S),be=!0,Ce=1,S="abort("+S+"). Build with -s ASSERTIONS=1 for more info.";var A=new WebAssembly.RuntimeError(S);throw p(A),A}function Oo(S,A){return String.prototype.startsWith?S.startsWith(A):S.indexOf(A)===0}var _g="data:application/octet-stream;base64,";function Bp(S){return Oo(S,_g)}var Eg="file://";function zp(S){return Oo(S,Eg)}var Un="tfjs-backend-wasm-threaded-simd.wasm";Bp(Un)||(Un=F(Un));function Ag(S){try{if(S==Un&&ne)return new Uint8Array(ne);if(R)return R(S);throw"both async and sync fetching of the wasm failed"}catch(A){Cs(A)}}function Wp(){if(!ne&&(v||x)){if(typeof fetch=="function"&&!zp(Un))return fetch(Un,{credentials:"same-origin"}).then(function(S){if(!S.ok)throw"failed to load wasm binary file at '"+Un+"'";return S.arrayBuffer()}).catch(function(){return Ag(Un)});if(D)return new Promise(function(S,A){D(Un,function(B){S(new Uint8Array(B))},A)})}return Promise.resolve().then(function(){return Ag(Un)})}function $g(){var S={a:Ib};function A(le,xe){var it=le.exports;if(c.asm=it,bn=c.asm.nb,pe=xe,!C){var Jt=Se.unusedWorkers.length;Se.unusedWorkers.forEach(function(jt){Se.loadWasmModuleToWorker(jt,function(){--Jt||Ng("wasm-instantiate")})})}}C||Tg("wasm-instantiate");function B(le){A(le.instance,le.module)}function Y(le){return Wp().then(function(xe){return WebAssembly.instantiate(xe,S)}).then(le,function(xe){q("failed to asynchronously prepare wasm: "+xe),Cs(xe)})}function de(){return!ne&&typeof WebAssembly.instantiateStreaming=="function"&&!Bp(Un)&&!zp(Un)&&typeof fetch=="function"?fetch(Un,{credentials:"same-origin"}).then(function(le){var xe=WebAssembly.instantiateStreaming(le,S);return xe.then(B,function(it){return q("wasm streaming compile failed: "+it),q("falling back to ArrayBuffer instantiation"),Y(B)})}):Y(B)}if(c.instantiateWasm)try{var ce=c.instantiateWasm(S,A);return ce}catch(le){return q("Module.instantiateWasm callback failed with error: "+le),!1}return de().catch(p),{}}var Vp={10216:function(){throw"Canceled!"},10234:function(S,A){setTimeout(function(){kI(S,A)},0)}};function Fg(){Se.initRuntime()}function Nu(S){for(;S.length>0;){var A=S.shift();if(typeof A=="function"){A(c);continue}var B=A.func;typeof B=="number"?A.arg===void 0?bn.get(B)():bn.get(B)(A.arg):B(A.arg===void 0?null:A.arg)}}var ta={EPERM:63,ENOENT:44,ESRCH:71,EINTR:27,EIO:29,ENXIO:60,E2BIG:1,ENOEXEC:45,EBADF:8,ECHILD:12,EAGAIN:6,EWOULDBLOCK:6,ENOMEM:48,EACCES:2,EFAULT:21,ENOTBLK:105,EBUSY:10,EEXIST:20,EXDEV:75,ENODEV:43,ENOTDIR:54,EISDIR:31,EINVAL:28,ENFILE:41,EMFILE:33,ENOTTY:59,ETXTBSY:74,EFBIG:22,ENOSPC:51,ESPIPE:70,EROFS:69,EMLINK:34,EPIPE:64,EDOM:18,ERANGE:68,ENOMSG:49,EIDRM:24,ECHRNG:106,EL2NSYNC:156,EL3HLT:107,EL3RST:108,ELNRNG:109,EUNATCH:110,ENOCSI:111,EL2HLT:112,EDEADLK:16,ENOLCK:46,EBADE:113,EBADR:114,EXFULL:115,ENOANO:104,EBADRQC:103,EBADSLT:102,EDEADLOCK:16,EBFONT:101,ENOSTR:100,ENODATA:116,ETIME:117,ENOSR:118,ENONET:119,ENOPKG:120,EREMOTE:121,ENOLINK:47,EADV:122,ESRMNT:123,ECOMM:124,EPROTO:65,EMULTIHOP:36,EDOTDOT:125,EBADMSG:9,ENOTUNIQ:126,EBADFD:127,EREMCHG:128,ELIBACC:129,ELIBBAD:130,ELIBSCN:131,ELIBMAX:132,ELIBEXEC:133,ENOSYS:52,ENOTEMPTY:55,ENAMETOOLONG:37,ELOOP:32,EOPNOTSUPP:138,EPFNOSUPPORT:139,ECONNRESET:15,ENOBUFS:42,EAFNOSUPPORT:5,EPROTOTYPE:67,ENOTSOCK:57,ENOPROTOOPT:50,ESHUTDOWN:140,ECONNREFUSED:14,EADDRINUSE:3,ECONNABORTED:13,ENETUNREACH:40,ENETDOWN:38,ETIMEDOUT:73,EHOSTDOWN:142,EHOSTUNREACH:23,EINPROGRESS:26,EALREADY:7,EDESTADDRREQ:17,EMSGSIZE:35,EPROTONOSUPPORT:66,ESOCKTNOSUPPORT:137,EADDRNOTAVAIL:4,ENETRESET:39,EISCONN:30,ENOTCONN:53,ETOOMANYREFS:141,EUSERS:136,EDQUOT:19,ESTALE:72,ENOTSUP:138,ENOMEDIUM:148,EILSEQ:25,EOVERFLOW:61,ECANCELED:11,ENOTRECOVERABLE:56,EOWNERDEAD:62,ESTRPIPE:135};function Fl(S,A){if(S<=0||S>a().length||S&!0||A<0)return-28;if(A==0)return 0;A>=2147483647&&(A=1/0);var B=Atomics.load(i(),Ru>>2),Y=0;if(B==S){var de=Atomics.compareExchange(i(),Ru>>2,B,0);if(de==B&&(--A,Y=1,A<=0))return 1}var ce=Atomics.notify(i(),S>>2,A);if(ce>=0)return ce+Y;throw"Atomics.notify returned an unexpected value "+ce}c._emscripten_futex_wake=Fl;function Dg(S){if(C)throw"Internal Error! killThread() can only ever be called from main application thread!";if(!S)throw"Internal Error! Null pthread_ptr in killThread!";i()[S+12>>2]=0;var A=Se.pthreads[S];A.worker.terminate(),Se.freeThreadData(A),Se.runningWorkers.splice(Se.runningWorkers.indexOf(A.worker),1),A.worker.pthread=void 0}function Rg(S){if(C)throw"Internal Error! cancelThread() can only ever be called from main application thread!";if(!S)throw"Internal Error! Null pthread_ptr in cancelThread!";var A=Se.pthreads[S];A.worker.postMessage({cmd:"cancel"})}function Up(S){if(C)throw"Internal Error! cleanupThread() can only ever be called from main application thread!";if(!S)throw"Internal Error! Null pthread_ptr in cleanupThread!";var A=Se.pthreads[S];if(A){i()[S+12>>2]=0;var B=A.worker;Se.returnWorkerToPool(B)}}var Se={unusedWorkers:[],runningWorkers:[],initMainThreadBlock:function(){for(var S=8,A=0;A<S;++A)Se.allocateUnusedWorker()},initRuntime:function(){for(var S=Lo(228),A=0;A<228/4;++A)u()[S/4+A]=0;i()[S+12>>2]=S;var B=S+152;i()[B>>2]=B;for(var Y=Lo(512),A=0;A<128;++A)u()[Y/4+A]=0;Atomics.store(u(),S+100>>2,Y),Atomics.store(u(),S+40>>2,S),qb(S,!x,1),xI(S)},initWorker:function(){},pthreads:{},threadExitHandlers:[],setThreadStatus:function(){},runExitHandlers:function(){for(;Se.threadExitHandlers.length>0;)Se.threadExitHandlers.pop()();C&&aa()&&vI()},runExitHandlersAndDeinitThread:function(S,A){Atomics.store(u(),S+56>>2,1),Atomics.store(u(),S+60>>2,0),Se.runExitHandlers(),Atomics.store(u(),S+4>>2,A),Atomics.store(u(),S+0>>2,1),Fl(S+0,2147483647),qb(0,0,0)},threadExit:function(S){var A=aa();A&&(Se.runExitHandlersAndDeinitThread(A,S),C&&postMessage({cmd:"exit"}))},threadCancel:function(){Se.runExitHandlersAndDeinitThread(aa(),-1),postMessage({cmd:"cancelDone"})},terminateAllThreads:function(){for(var S in Se.pthreads){var A=Se.pthreads[S];A&&A.worker&&Se.returnWorkerToPool(A.worker)}Se.pthreads={};for(var B=0;B<Se.unusedWorkers.length;++B){var Y=Se.unusedWorkers[B];Y.terminate()}Se.unusedWorkers=[];for(var B=0;B<Se.runningWorkers.length;++B){var Y=Se.runningWorkers[B],A=Y.pthread;Se.freeThreadData(A),Y.terminate()}Se.runningWorkers=[]},freeThreadData:function(S){if(!!S){if(S.threadInfoStruct){var A=i()[S.threadInfoStruct+100>>2];i()[S.threadInfoStruct+100>>2]=0,Bl(A),Bl(S.threadInfoStruct)}S.threadInfoStruct=0,S.allocatedOwnStack&&S.stackBase&&Bl(S.stackBase),S.stackBase=0,S.worker&&(S.worker.pthread=null)}},returnWorkerToPool:function(S){Se.runWithoutMainThreadQueuedCalls(function(){delete Se.pthreads[S.pthread.threadInfoStruct],Se.unusedWorkers.push(S),Se.runningWorkers.splice(Se.runningWorkers.indexOf(S),1),Se.freeThreadData(S.pthread),S.pthread=void 0})},runWithoutMainThreadQueuedCalls:function(S){i()[NI>>2]=0;try{S()}finally{i()[NI>>2]=1}},receiveObjectTransfer:function(S){},loadWasmModuleToWorker:function(S,A){S.onmessage=function(B){var Y=B.data,de=Y.cmd;if(S.pthread&&(Se.currentProxiedOperationCallerThread=S.pthread.threadInfoStruct),Y.targetThread&&Y.targetThread!=aa()){var ce=Se.pthreads[Y.targetThread];ce?ce.worker.postMessage(B.data,Y.transferList):console.error('Internal error! Worker sent a message "'+de+'" to target pthread '+Y.targetThread+", but that thread no longer exists!"),Se.currentProxiedOperationCallerThread=void 0;return}if(de==="processQueuedMainThreadWork")rh();else if(de==="spawnThread")Yp(B.data);else if(de==="cleanupThread")Up(Y.thread);else if(de==="killThread")Dg(Y.thread);else if(de==="cancelThread")Rg(Y.thread);else if(de==="loaded")S.loaded=!0,A&&A(S),S.runPthread&&(S.runPthread(),delete S.runPthread);else if(de==="print")K("Thread "+Y.threadId+": "+Y.text);else if(de==="printErr")q("Thread "+Y.threadId+": "+Y.text);else if(de==="alert")alert("Thread "+Y.threadId+": "+Y.text);else if(de==="exit"){var le=S.pthread&&Atomics.load(u(),S.pthread.threadInfoStruct+64>>2);le&&Se.returnWorkerToPool(S)}else if(de==="exitProcess")try{zF(Y.returnCode)}catch(xe){if(xe instanceof Wl)return;throw xe}else de==="cancelDone"?Se.returnWorkerToPool(S):de==="objectTransfer"?Se.receiveObjectTransfer(B.data):B.data.target==="setimmediate"?S.postMessage(B.data):q("worker sent an unknown command "+de);Se.currentProxiedOperationCallerThread=void 0},S.onerror=function(B){q("pthread sent an error! "+B.filename+":"+B.lineno+": "+B.message)},k&&(S.on("message",function(B){S.onmessage({data:B})}),S.on("error",function(B){S.onerror(B)}),S.on("exit",function(B){})),S.postMessage({cmd:"load",urlOrBlob:c.mainScriptUrlOrBlob||r,wasmMemory:te,wasmModule:pe})},allocateUnusedWorker:function(){var S=F("tfjs-backend-wasm-threaded-simd.worker.js");Se.unusedWorkers.push(new Worker(S))},getNewWorker:function(){return Se.unusedWorkers.length==0&&(Se.allocateUnusedWorker(),Se.loadWasmModuleToWorker(Se.unusedWorkers[0])),Se.unusedWorkers.length>0?Se.unusedWorkers.pop():null},busySpinWait:function(S){for(var A=performance.now()+S;performance.now()<A;);}};function Pg(S,A){CI(S,A),Fu(S)}c.establishStackSpace=Pg;function Og(){return ie}c.getNoExitRuntime=Og;function Mg(S,A){return bn.get(S)(A)}c.invokeEntryPoint=Mg;function Lg(S,A,B,Y){Cs("Assertion failed: "+Ge(S)+", at: "+[A?Ge(A):"unknown filename",B,Y?Ge(Y):"unknown function"])}function Bg(S,A){var B=_main(S,A)}var Mo;k?Mo=function(){var S=process.hrtime();return S[0]*1e3+S[1]/1e6}:C?Mo=function(){return performance.now()-c.__performance_now_clock_drift}:typeof dateNow!="undefined"?Mo=dateNow:Mo=function(){return performance.now()};function zg(S){return i()[bI()>>2]=S,S}function Wg(S,A){if(C)return na(1,1,S,A)}function Vg(S,A){if(S==A)postMessage({cmd:"processQueuedMainThreadWork"});else if(C)postMessage({targetThread:S,cmd:"processThreadQueue"});else{var B=Se.pthreads[S],Y=B&&B.worker;if(!Y)return;Y.postMessage({cmd:"processThreadQueue"})}return 1}function Ug(){Cs()}function Gg(S,A,B){var Y=Kg(A,B);return Vp[S].apply(null,Y)}function Hg(S,A){}function Gp(S,A,B){if(S<=0||S>a().length||S&!0)return-28;if(v){if(Atomics.load(i(),S>>2)!=A)return-6;for(var de=performance.now(),ce=de+B,le=Atomics.exchange(i(),Ru>>2,S);;){if(de=performance.now(),de>ce)return le=Atomics.exchange(i(),Ru>>2,0),-73;if(le=Atomics.exchange(i(),Ru>>2,0),le==0)break;if(rh(),Atomics.load(i(),S>>2)!=A)return-6;le=Atomics.exchange(i(),Ru>>2,S)}return 0}else{var Y=Atomics.wait(i(),S>>2,A,B);if(Y==="timed-out")return-73;if(Y==="not-equal")return-6;if(Y==="ok")return 0;throw"Atomics.wait returned an unexpected value "+Y}}function jg(S,A,B){o().copyWithin(S,A,A+B)}function qg(){return k?cD().cpus().length:navigator.hardwareConcurrency}function na(S,A){for(var B=arguments.length-2,Y=zl(),de=B,ce=Du(de*8),le=ce>>3,xe=0;xe<B;xe++){var it=arguments[2+xe];l()[le+xe]=it}var Jt=SI(S,de,ce,A);return Fu(Y),Jt}var Dl=[],Rl=[];function Kg(S,A){Rl.length=0;var B;for(A>>=2;B=o()[S++];){var Y=B<105;Y&&A&1&&A++,Rl.push(Y?l()[A++>>1]:i()[A]),++A}return Rl}function Xg(S,A,B){Dl.length=A;for(var Y=B>>3,de=0;de<A;de++)Dl[de]=l()[Y+de];var ce=S<0,le=ce?Vp[-S-1]:kb[S];return le.apply(null,Dl)}function Yg(){return o().length}function Qg(S){try{return te.grow(S-tt.byteLength+65535>>>16),Wn(te.buffer),1}catch(A){}}function Zg(S){var A=Yg();if(S<=A)return!1;var B=2147483648;if(S>B)return!1;for(var Y=1;Y<=4;Y*=2){var de=A*(1+.2/Y);de=Math.min(de,S+100663296);var ce=Math.min(B,Bn(Math.max(S,de),65536)),le=Qg(ce);if(le)return!0}return!1}var Be={inEventHandler:0,removeAllEventListeners:function(){for(var S=Be.eventHandlers.length-1;S>=0;--S)Be._removeHandler(S);Be.eventHandlers=[],Be.deferredCalls=[]},registerRemoveEventListeners:function(){Be.removeEventListenersRegistered||(Al.push(Be.removeAllEventListeners),Be.removeEventListenersRegistered=!0)},deferredCalls:[],deferCall:function(S,A,B){function Y(le,xe){if(le.length!=xe.length)return!1;for(var it in le)if(le[it]!=xe[it])return!1;return!0}for(var de in Be.deferredCalls){var ce=Be.deferredCalls[de];if(ce.targetFunction==S&&Y(ce.argsList,B))return}Be.deferredCalls.push({targetFunction:S,precedence:A,argsList:B}),Be.deferredCalls.sort(function(le,xe){return le.precedence<xe.precedence})},removeDeferredCalls:function(S){for(var A=0;A<Be.deferredCalls.length;++A)Be.deferredCalls[A].targetFunction==S&&(Be.deferredCalls.splice(A,1),--A)},canPerformEventHandlerRequests:function(){return Be.inEventHandler&&Be.currentEventHandler.allowsDeferredCalls},runDeferredCalls:function(){if(!!Be.canPerformEventHandlerRequests())for(var S=0;S<Be.deferredCalls.length;++S){var A=Be.deferredCalls[S];Be.deferredCalls.splice(S,1),--S,A.targetFunction.apply(null,A.argsList)}},eventHandlers:[],removeAllHandlersOnTarget:function(S,A){for(var B=0;B<Be.eventHandlers.length;++B)Be.eventHandlers[B].target==S&&(!A||A==Be.eventHandlers[B].eventTypeString)&&Be._removeHandler(B--)},_removeHandler:function(S){var A=Be.eventHandlers[S];A.target.removeEventListener(A.eventTypeString,A.eventListenerFunc,A.useCapture),Be.eventHandlers.splice(S,1)},registerOrRemoveHandler:function(S){var A=function(de){++Be.inEventHandler,Be.currentEventHandler=S,Be.runDeferredCalls(),S.handlerFunc(de),Be.runDeferredCalls(),--Be.inEventHandler};if(S.callbackfunc)S.eventListenerFunc=A,S.target.addEventListener(S.eventTypeString,A,S.useCapture),Be.eventHandlers.push(S),Be.registerRemoveEventListeners();else for(var B=0;B<Be.eventHandlers.length;++B)Be.eventHandlers[B].target==S.target&&Be.eventHandlers[B].eventTypeString==S.eventTypeString&&Be._removeHandler(B--)},queueEventHandlerOnThread_iiii:function(S,A,B,Y,de){var ce=zl(),le=Du(12);i()[le>>2]=B,i()[le+4>>2]=Y,i()[le+8>>2]=de,jb(0,S,637534208,A,Y,le),Fu(ce)},getTargetThreadForEventCallback:function(S){switch(S){case 1:return 0;case 2:return Se.currentProxiedOperationCallerThread;default:return S}},getNodeNameForTarget:function(S){return S?S==window?"#window":S==screen?"#screen":S&&S.nodeName?S.nodeName:"":""},fullscreenEnabled:function(){return document.fullscreenEnabled||document.webkitFullscreenEnabled}};function Jg(S){var A=pt(S)+1,B=Lo(A);return et(S,B,A),B}function eb(S,A,B,Y){var de=zl(),ce=Du(12),le=0;A&&(le=Jg(A)),i()[ce>>2]=le,i()[ce+4>>2]=B,i()[ce+8>>2]=Y,jb(0,S,657457152,0,le,ce),Fu(de)}function tb(S,A,B,Y){A=A?Ge(A):"",eb(S,A,B,Y)}function nb(S){return S>2?Ge(S):S}var rb=[0,typeof document!="undefined"?document:0,typeof window!="undefined"?window:0];function sb(S){S=nb(S);var A=rb[S]||(typeof document!="undefined"?document.querySelector(S):void 0);return A}function Pl(S){return sb(S)}function Hp(S,A,B){var Y=Pl(S);if(!Y)return-4;if(Y.canvasSharedPtr&&(i()[Y.canvasSharedPtr>>2]=A,i()[Y.canvasSharedPtr+4>>2]=B),Y.offscreenCanvas||!Y.controlTransferredOffscreen){Y.offscreenCanvas&&(Y=Y.offscreenCanvas);var de=!1;if(Y.GLctxObject&&Y.GLctxObject.GLctx){var ce=Y.GLctxObject.GLctx.getParameter(2978);de=ce[0]===0&&ce[1]===0&&ce[2]===Y.width&&ce[3]===Y.height}Y.width=A,Y.height=B,de&&Y.GLctxObject.GLctx.viewport(0,0,A,B)}else if(Y.canvasSharedPtr){var le=i()[Y.canvasSharedPtr+8>>2];return tb(le,S,A,B),1}else return-4;return 0}function jp(S,A,B){return C?na(2,1,S,A,B):Hp(S,A,B)}function ab(S,A,B){var Y=Pl(S);return Y?Hp(S,A,B):jp(S,A,B)}function ob(S){}function ib(S,A){}function ub(S){var A=S.getExtension("ANGLE_instanced_arrays");if(A)return S.vertexAttribDivisor=function(B,Y){A.vertexAttribDivisorANGLE(B,Y)},S.drawArraysInstanced=function(B,Y,de,ce){A.drawArraysInstancedANGLE(B,Y,de,ce)},S.drawElementsInstanced=function(B,Y,de,ce,le){A.drawElementsInstancedANGLE(B,Y,de,ce,le)},1}function cb(S){var A=S.getExtension("OES_vertex_array_object");if(A)return S.createVertexArray=function(){return A.createVertexArrayOES()},S.deleteVertexArray=function(B){A.deleteVertexArrayOES(B)},S.bindVertexArray=function(B){A.bindVertexArrayOES(B)},S.isVertexArray=function(B){return A.isVertexArrayOES(B)},1}function lb(S){var A=S.getExtension("WEBGL_draw_buffers");if(A)return S.drawBuffers=function(B,Y){A.drawBuffersWEBGL(B,Y)},1}function db(S){return!!(S.multiDrawWebgl=S.getExtension("WEBGL_multi_draw"))}var at={counter:1,buffers:[],programs:[],framebuffers:[],renderbuffers:[],textures:[],uniforms:[],shaders:[],vaos:[],contexts:{},offscreenCanvases:{},timerQueriesEXT:[],programInfos:{},stringCache:{},unpackAlignment:4,recordError:function(A){at.lastError||(at.lastError=A)},getNewId:function(S){for(var A=at.counter++,B=S.length;B<A;B++)S[B]=null;return A},getSource:function(S,A,B,Y){for(var de="",ce=0;ce<A;++ce){var le=Y?i()[Y+ce*4>>2]:-1;de+=Ge(i()[B+ce*4>>2],le<0?void 0:le)}return de},createContext:function(S,A){var B=S.getContext("webgl",A);if(!B)return 0;var Y=at.registerContext(B,A);return Y},registerContext:function(S,A){var B=Lo(8);i()[B+4>>2]=aa();var Y={handle:B,attributes:A,version:A.majorVersion,GLctx:S};return S.canvas&&(S.canvas.GLctxObject=Y),at.contexts[B]=Y,(typeof A.enableExtensionsByDefault=="undefined"||A.enableExtensionsByDefault)&&at.initExtensions(Y),B},makeContextCurrent:function(S){return at.currentContext=at.contexts[S],c.ctx=ra=at.currentContext&&at.currentContext.GLctx,!(S&&!ra)},getContext:function(S){return at.contexts[S]},deleteContext:function(S){at.currentContext===at.contexts[S]&&(at.currentContext=null),typeof Be=="object"&&Be.removeAllHandlersOnTarget(at.contexts[S].GLctx.canvas),at.contexts[S]&&at.contexts[S].GLctx.canvas&&(at.contexts[S].GLctx.canvas.GLctxObject=void 0),Bl(at.contexts[S].handle),at.contexts[S]=null},initExtensions:function(S){if(S||(S=at.currentContext),!S.initExtensionsDone){S.initExtensionsDone=!0;var A=S.GLctx;ub(A),cb(A),lb(A),A.disjointTimerQueryExt=A.getExtension("EXT_disjoint_timer_query"),db(A);var B=A.getSupportedExtensions()||[];B.forEach(function(Y){Y.indexOf("lose_context")<0&&Y.indexOf("debug")<0&&A.getExtension(Y)})}},populateUniformTable:function(S){for(var A=at.programs[S],B=at.programInfos[S]={uniforms:{},maxUniformLength:0,maxAttributeLength:-1,maxUniformBlockNameLength:-1},Y=B.uniforms,de=ra.getProgramParameter(A,35718),ce=0;ce<de;++ce){var le=ra.getActiveUniform(A,ce),xe=le.name;B.maxUniformLength=Math.max(B.maxUniformLength,xe.length+1),xe.slice(-1)=="]"&&(xe=xe.slice(0,xe.lastIndexOf("[")));var it=ra.getUniformLocation(A,xe);if(it){var Jt=at.getNewId(at.uniforms);Y[xe]=[le.size,Jt],at.uniforms[Jt]=it;for(var jt=1;jt<le.size;++jt){var oa=xe+"["+jt+"]";it=ra.getUniformLocation(A,oa),Jt=at.getNewId(at.uniforms),at.uniforms[Jt]=it}}}}},pb=["default","low-power","high-performance"];function hb(S,A){var B=A>>2,Y=i()[B+(24>>2)],de={alpha:!!i()[B+(0>>2)],depth:!!i()[B+(4>>2)],stencil:!!i()[B+(8>>2)],antialias:!!i()[B+(12>>2)],premultipliedAlpha:!!i()[B+(16>>2)],preserveDrawingBuffer:!!i()[B+(20>>2)],powerPreference:pb[Y],failIfMajorPerformanceCaveat:!!i()[B+(28>>2)],majorVersion:i()[B+(32>>2)],minorVersion:i()[B+(36>>2)],enableExtensionsByDefault:i()[B+(40>>2)],explicitSwapControl:i()[B+(44>>2)],proxyContextToMainThread:i()[B+(48>>2)],renderViaOffscreenBackBuffer:i()[B+(52>>2)]},ce=Pl(S);if(!ce||de.explicitSwapControl)return 0;var le=at.createContext(ce,de);return le}function fb(S,A){return hb(S,A)}var _u={mappings:{},buffers:[null,[],[]],printChar:function(S,A){var B=_u.buffers[S];A===0||A===10?((S===1?K:q)(qe(B,0)),B.length=0):B.push(A)},varargs:void 0,get:function(){_u.varargs+=4;var S=i()[_u.varargs-4>>2];return S},getStr:function(S){var A=Ge(S);return A},get64:function(S,A){return S}};function qp(S){return C?na(3,1,S):0}function Kp(S,A,B,Y,de){if(C)return na(4,1,S,A,B,Y,de)}function Xp(S,A,B,Y){if(C)return na(5,1,S,A,B,Y);for(var de=0,ce=0;ce<B;ce++){for(var le=i()[A+ce*8>>2],xe=i()[A+(ce*8+4)>>2],it=0;it<xe;it++)_u.printChar(S,o()[le+it]);de+=xe}return i()[Y>>2]=de,0}function mb(S){var A=Se.threadExitHandlers.pop();S&&A()}function gb(S,A){Se.threadExitHandlers.push(function(){bn.get(S)(A)})}function Yp(S){if(C)throw"Internal Error! spawnThread() can only ever be called from main application thread!";var A=Se.getNewWorker();if(A.pthread!==void 0)throw"Internal error!";if(!S.pthread_ptr)throw"Internal error, no pthread ptr!";Se.runningWorkers.push(A);for(var B=Lo(128*4),Y=0;Y<128;++Y)i()[B+Y*4>>2]=0;var de=S.stackBase+S.stackSize,ce=Se.pthreads[S.pthread_ptr]={worker:A,stackBase:S.stackBase,stackSize:S.stackSize,allocatedOwnStack:S.allocatedOwnStack,threadInfoStruct:S.pthread_ptr},le=ce.threadInfoStruct>>2;Atomics.store(u(),le+(64>>2),S.detached),Atomics.store(u(),le+(100>>2),B),Atomics.store(u(),le+(40>>2),ce.threadInfoStruct),Atomics.store(u(),le+(80>>2),S.stackSize),Atomics.store(u(),le+(76>>2),de),Atomics.store(u(),le+(104>>2),S.stackSize),Atomics.store(u(),le+(104+8>>2),de),Atomics.store(u(),le+(104+12>>2),S.detached);var xe=yI(),it=xe+40;Atomics.store(u(),le+(172>>2),it),A.pthread=ce;var Jt={cmd:"run",start_routine:S.startRoutine,arg:S.arg,threadInfoStruct:S.pthread_ptr,stackBase:S.stackBase,stackSize:S.stackSize};A.runPthread=function(){Jt.time=performance.now(),A.postMessage(Jt,S.transferList)},A.loaded&&(A.runPthread(),delete A.runPthread)}function bb(S,A,B,Y){if(typeof SharedArrayBuffer=="undefined")return q("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;if(!S)return q("pthread_create called with a null thread pointer!"),28;var de=[],ce=0;if(C&&(de.length===0||ce))return II(687865856,S,A,B,Y);if(ce)return ce;var le=0,xe=0,it=0;A&&A!=-1?(le=i()[A>>2],le+=81920,xe=i()[A+8>>2],it=i()[A+12>>2]!==0):le=2097152;var Jt=xe==0;Jt?xe=TI(16,le):(xe-=le,Ie(xe>0));for(var jt=Lo(228),oa=0;oa<228>>2;++oa)u()[(jt>>2)+oa]=0;i()[S>>2]=jt,i()[jt+12>>2]=jt;var Pu=jt+152;i()[Pu>>2]=Pu;var xn={stackBase:xe,stackSize:le,allocatedOwnStack:Jt,detached:it,startRoutine:B,pthread_ptr:jt,arg:Y,transferList:de};return C?(xn.cmd="spawnThread",postMessage(xn,de)):Yp(xn),0}function yb(){if(!!C){var S=aa();if(!!S){var A=Atomics.load(u(),S+56>>2);if(!A){var B=Atomics.load(u(),S+0>>2);if(B==2)throw"Canceled!"}}}}function vb(){k||x||Q("Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread")}function xb(S,A,B){if(!S)return q("pthread_join attempted on a null thread pointer!"),ta.ESRCH;if(C&&aa()==S)return q("PThread "+S+" is attempting to join to itself!"),ta.EDEADLK;if(!C&&wI()==S)return q("Main thread "+S+" is attempting to join to itself!"),ta.EDEADLK;var Y=i()[S+12>>2];if(Y!==S)return q("pthread_join attempted on thread "+S+", which does not point to a valid thread, or does not exist anymore!"),ta.ESRCH;var de=Atomics.load(u(),S+64>>2);if(de)return q("Attempted to join thread "+S+", which was already detached!"),ta.EINVAL;for(B&&vb();;){var ce=Atomics.load(u(),S+0>>2);if(ce==1){var le=Atomics.load(u(),S+4>>2);return A&&(i()[A>>2]=le),Atomics.store(u(),S+64>>2,1),C?postMessage({cmd:"cleanupThread",thread:S}):Up(S),0}if(!B)return ta.EBUSY;yb(),C||rh(),Gp(S+0,ce,C?100:1)}}function wb(S,A){return xb(S,A,!0)}function Qp(S){if(C)return na(6,1,S);switch(S){case 30:return 16384;case 85:var A=2147483648;return A/16384;case 132:case 133:case 12:case 137:case 138:case 15:case 235:case 16:case 17:case 18:case 19:case 20:case 149:case 13:case 10:case 236:case 153:case 9:case 21:case 22:case 159:case 154:case 14:case 77:case 78:case 139:case 82:case 68:case 67:case 164:case 11:case 29:case 47:case 48:case 95:case 52:case 51:case 46:return 200809;case 27:case 246:case 127:case 128:case 23:case 24:case 160:case 161:case 181:case 182:case 242:case 183:case 184:case 243:case 244:case 245:case 165:case 178:case 179:case 49:case 50:case 168:case 169:case 175:case 170:case 171:case 172:case 97:case 76:case 32:case 173:case 35:case 80:case 81:case 79:return-1;case 176:case 177:case 7:case 155:case 8:case 157:case 125:case 126:case 92:case 93:case 129:case 130:case 131:case 94:case 91:return 1;case 74:case 60:case 69:case 70:case 4:return 1024;case 31:case 42:case 72:return 32;case 87:case 26:case 33:return 2147483647;case 34:case 1:return 47839;case 38:case 36:return 99;case 43:case 37:return 2048;case 0:return 2097152;case 3:return 65536;case 28:return 32768;case 44:return 32767;case 75:return 16384;case 39:return 1e3;case 89:return 700;case 71:return 256;case 40:return 255;case 2:return 100;case 180:return 64;case 25:return 20;case 5:return 16;case 6:return 6;case 73:return 4;case 84:return typeof navigator=="object"&&navigator.hardwareConcurrency||1}return zg(28),-1}C||Se.initMainThreadBlock();var ra,kb=[null,Wg,jp,qp,Kp,Xp,Qp],Ib={e:Lg,r:Bg,x:Vg,b:Ug,y:Gg,j:Hg,d:Gp,c:Fl,f:Mo,p:jg,A:qg,u:Xg,q:Zg,v:ab,i:ob,s:ib,w:fb,l:qp,n:Kp,g:Xp,o:Fg,a:te||c.wasmMemory,z:mb,k:gb,h:bb,m:wb,t:Qp},gI=$g(),Zp=c.___wasm_call_ctors=function(){return(Zp=c.___wasm_call_ctors=c.asm.B).apply(null,arguments)},Sb=c._init=function(){return(Sb=c._init=c.asm.C).apply(null,arguments)},Cb=c._init_with_threads_count=function(){return(Cb=c._init_with_threads_count=c.asm.D).apply(null,arguments)},Tb=c._get_threads_count=function(){return(Tb=c._get_threads_count=c.asm.E).apply(null,arguments)},Nb=c._register_tensor=function(){return(Nb=c._register_tensor=c.asm.F).apply(null,arguments)},_b=c._dispose_data=function(){return(_b=c._dispose_data=c.asm.G).apply(null,arguments)},Eb=c._dispose=function(){return(Eb=c._dispose=c.asm.H).apply(null,arguments)},Ab=c._Abs=function(){return(Ab=c._Abs=c.asm.I).apply(null,arguments)},$b=c._Add=function(){return($b=c._Add=c.asm.J).apply(null,arguments)},Fb=c._AddN=function(){return(Fb=c._AddN=c.asm.K).apply(null,arguments)},Db=c._All=function(){return(Db=c._All=c.asm.L).apply(null,arguments)},Rb=c._Any=function(){return(Rb=c._Any=c.asm.M).apply(null,arguments)},Pb=c._ArgMax=function(){return(Pb=c._ArgMax=c.asm.N).apply(null,arguments)},Ob=c._AvgPool=function(){return(Ob=c._AvgPool=c.asm.O).apply(null,arguments)},Mb=c._BatchMatMul=function(){return(Mb=c._BatchMatMul=c.asm.P).apply(null,arguments)},Lb=c._Ceil=function(){return(Lb=c._Ceil=c.asm.Q).apply(null,arguments)},Bb=c._ClipByValue=function(){return(Bb=c._ClipByValue=c.asm.R).apply(null,arguments)},zb=c._Conv2D=function(){return(zb=c._Conv2D=c.asm.S).apply(null,arguments)},Wb=c._Conv2DBackpropInput=function(){return(Wb=c._Conv2DBackpropInput=c.asm.T).apply(null,arguments)},Vb=c._Cos=function(){return(Vb=c._Cos=c.asm.U).apply(null,arguments)},Ub=c._Cosh=function(){return(Ub=c._Cosh=c.asm.V).apply(null,arguments)},Jp=c._CropAndResize=function(){return(Jp=c._CropAndResize=c.asm.W).apply(null,arguments)},eh=c._Cumsum=function(){return(eh=c._Cumsum=c.asm.X).apply(null,arguments)},Ol=c._DepthToSpace=function(){return(Ol=c._DepthToSpace=c.asm.Y).apply(null,arguments)},Eu=c._DepthwiseConv2dNative=function(){return(Eu=c._DepthwiseConv2dNative=c.asm.Z).apply(null,arguments)},Gb=c._Elu=function(){return(Gb=c._Elu=c.asm._).apply(null,arguments)},Ml=c._Equal=function(){return(Ml=c._Equal=c.asm.$).apply(null,arguments)},Au=c._Exp=function(){return(Au=c._Exp=c.asm.aa).apply(null,arguments)},$u=c._FlipLeftRight=function(){return($u=c._FlipLeftRight=c.asm.ba).apply(null,arguments)},Hb=c._Floor=function(){return(Hb=c._Floor=c.asm.ca).apply(null,arguments)},J=c._FloorDiv=function(){return(J=c._FloorDiv=c.asm.da).apply(null,arguments)},ae=c._FusedBatchNorm=function(){return(ae=c._FusedBatchNorm=c.asm.ea).apply(null,arguments)},ye=c._FusedConv2D=function(){return(ye=c._FusedConv2D=c.asm.fa).apply(null,arguments)},nt=c._FusedDepthwiseConv2D=function(){return(nt=c._FusedDepthwiseConv2D=c.asm.ga).apply(null,arguments)},Rt=c._Gather=function(){return(Rt=c._Gather=c.asm.ha).apply(null,arguments)},Tt=c._GatherNd=function(){return(Tt=c._GatherNd=c.asm.ia).apply(null,arguments)},He=c._Greater=function(){return(He=c._Greater=c.asm.ja).apply(null,arguments)},Ke=c._GreaterEqual=function(){return(Ke=c._GreaterEqual=c.asm.ka).apply(null,arguments)},ln=c._LeakyRelu=function(){return(ln=c._LeakyRelu=c.asm.la).apply(null,arguments)},Ts=c._Less=function(){return(Ts=c._Less=c.asm.ma).apply(null,arguments)},Ns=c._LessEqual=function(){return(Ns=c._LessEqual=c.asm.na).apply(null,arguments)},th=c._Log=function(){return(th=c._Log=c.asm.oa).apply(null,arguments)},Ll=c._LogicalAnd=function(){return(Ll=c._LogicalAnd=c.asm.pa).apply(null,arguments)},Jn=c._Max=function(){return(Jn=c._Max=c.asm.qa).apply(null,arguments)},sa=c._MaxPool=function(){return(sa=c._MaxPool=c.asm.ra).apply(null,arguments)},nh=c._Maximum=function(){return(nh=c._Maximum=c.asm.sa).apply(null,arguments)},q$=c._Mean=function(){return(q$=c._Mean=c.asm.ta).apply(null,arguments)},K$=c._Min=function(){return(K$=c._Min=c.asm.ua).apply(null,arguments)},X$=c._Minimum=function(){return(X$=c._Minimum=c.asm.va).apply(null,arguments)},Y$=c._MirrorPad=function(){return(Y$=c._MirrorPad=c.asm.wa).apply(null,arguments)},Q$=c._Multiply=function(){return(Q$=c._Multiply=c.asm.xa).apply(null,arguments)},Z$=c._Neg=function(){return(Z$=c._Neg=c.asm.ya).apply(null,arguments)},J$=c._NonMaxSuppressionV3=function(){return(J$=c._NonMaxSuppressionV3=c.asm.za).apply(null,arguments)},eF=c._NonMaxSuppressionV4=function(){return(eF=c._NonMaxSuppressionV4=c.asm.Aa).apply(null,arguments)},tF=c._NonMaxSuppressionV5=function(){return(tF=c._NonMaxSuppressionV5=c.asm.Ba).apply(null,arguments)},nF=c._NotEqual=function(){return(nF=c._NotEqual=c.asm.Ca).apply(null,arguments)},rF=c._OneHot=function(){return(rF=c._OneHot=c.asm.Da).apply(null,arguments)},sF=c._PadV2=function(){return(sF=c._PadV2=c.asm.Ea).apply(null,arguments)},aF=c._Pow=function(){return(aF=c._Pow=c.asm.Fa).apply(null,arguments)},oF=c._Prelu=function(){return(oF=c._Prelu=c.asm.Ga).apply(null,arguments)},iF=c._Prod=function(){return(iF=c._Prod=c.asm.Ha).apply(null,arguments)},uF=c._RealDiv=function(){return(uF=c._RealDiv=c.asm.Ia).apply(null,arguments)},cF=c._Relu=function(){return(cF=c._Relu=c.asm.Ja).apply(null,arguments)},lF=c._Relu6=function(){return(lF=c._Relu6=c.asm.Ka).apply(null,arguments)},dF=c._ResizeBilinear=function(){return(dF=c._ResizeBilinear=c.asm.La).apply(null,arguments)},pF=c._Reverse=function(){return(pF=c._Reverse=c.asm.Ma).apply(null,arguments)},hF=c._RotateWithOffset=function(){return(hF=c._RotateWithOffset=c.asm.Na).apply(null,arguments)},fF=c._Round=function(){return(fF=c._Round=c.asm.Oa).apply(null,arguments)},mF=c._Rsqrt=function(){return(mF=c._Rsqrt=c.asm.Pa).apply(null,arguments)},gF=c._ScatterNd=function(){return(gF=c._ScatterNd=c.asm.Qa).apply(null,arguments)},bF=c._SelectV2=function(){return(bF=c._SelectV2=c.asm.Ra).apply(null,arguments)},yF=c._Sigmoid=function(){return(yF=c._Sigmoid=c.asm.Sa).apply(null,arguments)},vF=c._Sin=function(){return(vF=c._Sin=c.asm.Ta).apply(null,arguments)},xF=c._Softmax=function(){return(xF=c._Softmax=c.asm.Ua).apply(null,arguments)},wF=c._SparseFillEmptyRows=function(){return(wF=c._SparseFillEmptyRows=c.asm.Va).apply(null,arguments)},kF=c._SparseReshape=function(){return(kF=c._SparseReshape=c.asm.Wa).apply(null,arguments)},IF=c._SparseSegmentReduction=function(){return(IF=c._SparseSegmentReduction=c.asm.Xa).apply(null,arguments)},SF=c._Sqrt=function(){return(SF=c._Sqrt=c.asm.Ya).apply(null,arguments)},CF=c._Square=function(){return(CF=c._Square=c.asm.Za).apply(null,arguments)},TF=c._SquaredDifference=function(){return(TF=c._SquaredDifference=c.asm._a).apply(null,arguments)},NF=c._Step=function(){return(NF=c._Step=c.asm.$a).apply(null,arguments)},_F=c._StridedSlice=function(){return(_F=c._StridedSlice=c.asm.ab).apply(null,arguments)},EF=c._Sub=function(){return(EF=c._Sub=c.asm.bb).apply(null,arguments)},AF=c._Sum=function(){return(AF=c._Sum=c.asm.cb).apply(null,arguments)},$F=c._Tan=function(){return($F=c._Tan=c.asm.db).apply(null,arguments)},FF=c._Tanh=function(){return(FF=c._Tanh=c.asm.eb).apply(null,arguments)},DF=c._Tile=function(){return(DF=c._Tile=c.asm.fb).apply(null,arguments)},RF=c._TopK=function(){return(RF=c._TopK=c.asm.gb).apply(null,arguments)},PF=c._Transform=function(){return(PF=c._Transform=c.asm.hb).apply(null,arguments)},OF=c._Transpose=function(){return(OF=c._Transpose=c.asm.ib).apply(null,arguments)},MF=c.__FusedMatMul=function(){return(MF=c.__FusedMatMul=c.asm.jb).apply(null,arguments)},Lo=c._malloc=function(){return(Lo=c._malloc=c.asm.kb).apply(null,arguments)},Bl=c._free=function(){return(Bl=c._free=c.asm.lb).apply(null,arguments)},bI=c.___errno_location=function(){return(bI=c.___errno_location=c.asm.mb).apply(null,arguments)},yI=c._emscripten_get_global_libc=function(){return(yI=c._emscripten_get_global_libc=c.asm.ob).apply(null,arguments)},aa=c._pthread_self=function(){return(aa=c._pthread_self=c.asm.pb).apply(null,arguments)},vI=c.___pthread_tsd_run_dtors=function(){return(vI=c.___pthread_tsd_run_dtors=c.asm.qb).apply(null,arguments)},rh=c._emscripten_main_thread_process_queued_calls=function(){return(rh=c._emscripten_main_thread_process_queued_calls=c.asm.rb).apply(null,arguments)},LF=c._emscripten_current_thread_process_queued_calls=function(){return(LF=c._emscripten_current_thread_process_queued_calls=c.asm.sb).apply(null,arguments)},xI=c._emscripten_register_main_browser_thread_id=function(){return(xI=c._emscripten_register_main_browser_thread_id=c.asm.tb).apply(null,arguments)},wI=c._emscripten_main_browser_thread_id=function(){return(wI=c._emscripten_main_browser_thread_id=c.asm.ub).apply(null,arguments)},kI=c.__emscripten_do_dispatch_to_thread=function(){return(kI=c.__emscripten_do_dispatch_to_thread=c.asm.vb).apply(null,arguments)},II=c._emscripten_sync_run_in_main_thread_4=function(){return(II=c._emscripten_sync_run_in_main_thread_4=c.asm.wb).apply(null,arguments)},SI=c._emscripten_run_in_main_runtime_thread_js=function(){return(SI=c._emscripten_run_in_main_runtime_thread_js=c.asm.xb).apply(null,arguments)},jb=c.__emscripten_call_on_thread=function(){return(jb=c.__emscripten_call_on_thread=c.asm.yb).apply(null,arguments)},BF=c._emscripten_tls_init=function(){return(BF=c._emscripten_tls_init=c.asm.zb).apply(null,arguments)},qb=c.__emscripten_thread_init=function(){return(qb=c.__emscripten_thread_init=c.asm.Ab).apply(null,arguments)},zl=c.stackSave=function(){return(zl=c.stackSave=c.asm.Bb).apply(null,arguments)},Fu=c.stackRestore=function(){return(Fu=c.stackRestore=c.asm.Cb).apply(null,arguments)},Du=c.stackAlloc=function(){return(Du=c.stackAlloc=c.asm.Db).apply(null,arguments)},CI=c._emscripten_stack_set_limits=function(){return(CI=c._emscripten_stack_set_limits=c.asm.Eb).apply(null,arguments)},TI=c._memalign=function(){return(TI=c._memalign=c.asm.Fb).apply(null,arguments)},NI=c.__emscripten_allow_main_runtime_queued_calls=10208,Ru=c.__emscripten_main_thread_futex=10412;c.cwrap=Je,c.PThread=Se,c.PThread=Se,c.wasmMemory=te,c.ExitStatus=Wl;var sh;function Wl(S){this.name="ExitStatus",this.message="Program terminated with exit("+S+")",this.status=S}Po=function S(){sh||Kb(),sh||(Po=S)};function Kb(S){if(S=S||g,Nr>0)return;if(C){d(c),Op(),postMessage({cmd:"loaded"});return}if(Pp(),Nr>0)return;function A(){sh||(sh=!0,c.calledRun=!0,!be&&(Op(),Mp(),d(c),c.onRuntimeInitialized&&c.onRuntimeInitialized(),Lp()))}c.setStatus?(c.setStatus("Running..."),setTimeout(function(){setTimeout(function(){c.setStatus("")},1),A()},1)):A()}c.run=Kb;function zF(S,A){if(!(A&&ie&&S===0)){if(!A&&C)throw postMessage({cmd:"exitProcess",returnCode:S}),new Wl(S);ie||(Se.terminateAllThreads(),Ce=S,Vn(),c.onExit&&c.onExit(S),be=!0),y(S,new Wl(S))}}if(c.preInit)for(typeof c.preInit=="function"&&(c.preInit=[c.preInit]);c.preInit.length>0;)c.preInit.pop()();C&&(ie=!1,Se.initWorker()),Kb();var ah;h&&(ah={uncaughtException:process.listeners("uncaughtException").filter(function(S){return!h.uncaughtException.indexOf(S)>-1}),unhandledRejection:process.listeners("unhandledRejection").filter(function(S){return!h.unhandledRejection.indexOf(S)>-1})});var oh;if(typeof WasmBackendModule!="undefined")oh=WasmBackendModule;else if(typeof s!="undefined")oh=s;else throw new Error("Could not find wasm module in post.js");if(ah){var WF=oh._dispose;oh._dispose=function(){WF(),ah.uncaughtException.forEach(function(S){process.removeListener("uncaughtException",S)}),ah.unhandledRejection.forEach(function(S){process.removeListener("unhandledRejection",S)})}}return s.ready}}();typeof e=="object"&&typeof t=="object"?t.exports=n:typeof define=="function"&&define.amd?define([],function(){return n}):typeof e=="object"&&(e.WasmBackendModuleThreadedSimd=n)}}),dD=qt({"src/tfjs-backend-wasm/wasm-out/tfjs-backend-wasm.js"(e,t){var n=function(){var r=typeof document!="undefined"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename!="undefined"&&(r=r||__filename),function(s){s=s||{};var a=typeof s!="undefined"?s:{},o,i;a.ready=new Promise(function(J,ae){o=J,i=ae});var u;typeof process!="undefined"&&process.listeners&&(u={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var l={},c;for(c in a)a.hasOwnProperty(c)&&(l[c]=a[c]);var d=[],p="./this.program",h=function(J,ae){throw ae},f=!1,m=!1,g=!1,b=!1;f=typeof window=="object",m=typeof importScripts=="function",g=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",b=!f&&!g&&!m;var y="";function v(J){return a.locateFile?a.locateFile(J,y):y+J}var x,k,T,C,E,F;g?(m?y=Vl().dirname(y)+"/":y=__dirname+"/",x=function(ae,ye){return E||(E=lh()),F||(F=Vl()),ae=F.normalize(ae),E.readFileSync(ae,ye?null:"utf8")},T=function(ae){var ye=x(ae,!0);return ye.buffer||(ye=new Uint8Array(ye)),K(ye.buffer),ye},process.argv.length>1&&(p=process.argv[1].replace(/\\/g,"/")),d=process.argv.slice(2),process.on("uncaughtException",function(J){if(!(J instanceof Gb))throw J}),process.on("unhandledRejection",Ss),h=function(J){process.exit(J)},a.inspect=function(){return"[Emscripten Module object]"}):b?(typeof read!="undefined"&&(x=function(ae){return read(ae)}),T=function(ae){var ye;return typeof readbuffer=="function"?new Uint8Array(readbuffer(ae)):(ye=read(ae,"binary"),K(typeof ye=="object"),ye)},typeof scriptArgs!="undefined"?d=scriptArgs:typeof arguments!="undefined"&&(d=arguments),typeof quit=="function"&&(h=function(J){quit(J)}),typeof print!="undefined"&&(typeof console=="undefined"&&(console={}),console.log=print,console.warn=console.error=typeof printErr!="undefined"?printErr:print)):(f||m)&&(m?y=self.location.href:typeof document!="undefined"&&document.currentScript&&(y=document.currentScript.src),r&&(y=r),y.indexOf("blob:")!==0?y=y.substr(0,y.lastIndexOf("/")+1):y="",x=function(J){var ae=new XMLHttpRequest;return ae.open("GET",J,!1),ae.send(null),ae.responseText},m&&(T=function(J){var ae=new XMLHttpRequest;return ae.open("GET",J,!1),ae.responseType="arraybuffer",ae.send(null),new Uint8Array(ae.response)}),k=function(J,ae,ye){var nt=new XMLHttpRequest;nt.open("GET",J,!0),nt.responseType="arraybuffer",nt.onload=function(){if(nt.status==200||nt.status==0&&nt.response){ae(nt.response);return}ye()},nt.onerror=ye,nt.send(null)},C=function(J){document.title=J});var O=a.print||console.log.bind(console),D=a.printErr||console.warn.bind(console);for(c in l)l.hasOwnProperty(c)&&(a[c]=l[c]);l=null,a.arguments&&(d=a.arguments),a.thisProgram&&(p=a.thisProgram),a.quit&&(h=a.quit);var R;a.wasmBinary&&(R=a.wasmBinary);var _=a.noExitRuntime||!0;typeof WebAssembly!="object"&&Ss("no native wasm support detected");var L,U=!1,j;function K(J,ae){J||Ss("Assertion failed: "+ae)}function q(J){var ae=a["_"+J];return K(ae,"Cannot call unknown function "+J+", make sure it is exported"),ae}function Q(J,ae,ye,nt,Rt){var Tt={string:function(Jn){var sa=0;if(Jn!=null&&Jn!==0){var nh=(Jn.length<<2)+1;sa=Ol(nh),te(Jn,sa,nh)}return sa},array:function(Jn){var sa=Ol(Jn.length);return pe(Jn,sa),sa}};function He(Jn){return ae==="string"?ne(Jn):ae==="boolean"?Boolean(Jn):Jn}var Ke=q(J),ln=[],Ts=0;if(nt)for(var Ns=0;Ns<nt.length;Ns++){var th=Tt[ye[Ns]];th?(Ts===0&&(Ts=Jp()),ln[Ns]=th(nt[Ns])):ln[Ns]=nt[Ns]}var Ll=Ke.apply(null,ln);return Ll=He(Ll),Ts!==0&&eh(Ts),Ll}function ee(J,ae,ye,nt){ye=ye||[];var Rt=ye.every(function(He){return He==="number"}),Tt=ae!=="string";return Tt&&Rt&&!nt?q(J):function(){return Q(J,ae,ye,arguments,nt)}}var re=typeof TextDecoder!="undefined"?new TextDecoder("utf8"):void 0;function se(J,ae,ye){for(var nt=ae+ye,Rt=ae;J[Rt]&&!(Rt>=nt);)++Rt;if(Rt-ae>16&&J.subarray&&re)return re.decode(J.subarray(ae,Rt));for(var Tt="";ae<Rt;){var He=J[ae++];if(!(He&128)){Tt+=String.fromCharCode(He);continue}var Ke=J[ae++]&63;if((He&224)==192){Tt+=String.fromCharCode((He&31)<<6|Ke);continue}var ln=J[ae++]&63;if((He&240)==224?He=(He&15)<<12|Ke<<6|ln:He=(He&7)<<18|Ke<<12|ln<<6|J[ae++]&63,He<65536)Tt+=String.fromCharCode(He);else{var Ts=He-65536;Tt+=String.fromCharCode(55296|Ts>>10,56320|Ts&1023)}}return Tt}function ne(J,ae){return J?se(Ne,J,ae):""}function ie(J,ae,ye,nt){if(!(nt>0))return 0;for(var Rt=ye,Tt=ye+nt-1,He=0;He<J.length;++He){var Ke=J.charCodeAt(He);if(Ke>=55296&&Ke<=57343){var ln=J.charCodeAt(++He);Ke=65536+((Ke&1023)<<10)|ln&1023}if(Ke<=127){if(ye>=Tt)break;ae[ye++]=Ke}else if(Ke<=2047){if(ye+1>=Tt)break;ae[ye++]=192|Ke>>6,ae[ye++]=128|Ke&63}else if(Ke<=65535){if(ye+2>=Tt)break;ae[ye++]=224|Ke>>12,ae[ye++]=128|Ke>>6&63,ae[ye++]=128|Ke&63}else{if(ye+3>=Tt)break;ae[ye++]=240|Ke>>18,ae[ye++]=128|Ke>>12&63,ae[ye++]=128|Ke>>6&63,ae[ye++]=128|Ke&63}}return ae[ye]=0,ye-Rt}function te(J,ae,ye){return ie(J,Ne,ae,ye)}function pe(J,ae){Ie.set(J,ae)}function be(J,ae){return J%ae>0&&(J+=ae-J%ae),J}var Ce,Ie,Ne,Le,Je,qe,Ge,lt,et;function pt(J){Ce=J,a.HEAP8=Ie=new Int8Array(J),a.HEAP16=Le=new Int16Array(J),a.HEAP32=qe=new Int32Array(J),a.HEAPU8=Ne=new Uint8Array(J),a.HEAPU16=Je=new Uint16Array(J),a.HEAPU32=Ge=new Uint32Array(J),a.HEAPF32=lt=new Float32Array(J),a.HEAPF64=et=new Float64Array(J)}var Ct=a.INITIAL_MEMORY||16777216,Bn,tt=[],Qn=[],cn=[],Cr=[],zn=!1;Qn.push({func:function(){Wp()}});function Zn(){if(a.preRun)for(typeof a.preRun=="function"&&(a.preRun=[a.preRun]);a.preRun.length;)Wn(a.preRun.shift());Nr(tt)}function dr(){zn=!0,Nr(Qn)}function Tr(){Nr(cn)}function pr(){if(a.postRun)for(typeof a.postRun=="function"&&(a.postRun=[a.postRun]);a.postRun.length;)Js(a.postRun.shift());Nr(Cr)}function Wn(J){tt.unshift(J)}function Js(J){Cr.unshift(J)}var bn=0,ea=null,hr=null;function El(J){bn++,a.monitorRunDependencies&&a.monitorRunDependencies(bn)}function Al(J){if(bn--,a.monitorRunDependencies&&a.monitorRunDependencies(bn),bn==0&&(ea!==null&&(clearInterval(ea),ea=null),hr)){var ae=hr;hr=null,ae()}}a.preloadedImages={},a.preloadedAudios={};function Ss(J){a.onAbort&&a.onAbort(J),J+="",D(J),U=!0,j=1,J="abort("+J+"). Build with -s ASSERTIONS=1 for more info.";var ae=new WebAssembly.RuntimeError(J);throw i(ae),ae}function Rp(J,ae){return String.prototype.startsWith?J.startsWith(ae):J.indexOf(ae)===0}var Ig="data:application/octet-stream;base64,";function Pp(J){return Rp(J,Ig)}var Op="file://";function Mp(J){return Rp(J,Op)}var Vn="tfjs-backend-wasm.wasm";Pp(Vn)||(Vn=v(Vn));function Lp(J){try{if(J==Vn&&R)return new Uint8Array(R);if(T)return T(J);throw"both async and sync fetching of the wasm failed"}catch(ae){Ss(ae)}}function Sg(){if(!R&&(f||m)){if(typeof fetch=="function"&&!Mp(Vn))return fetch(Vn,{credentials:"same-origin"}).then(function(J){if(!J.ok)throw"failed to load wasm binary file at '"+Vn+"'";return J.arrayBuffer()}).catch(function(){return Lp(Vn)});if(k)return new Promise(function(J,ae){k(Vn,function(ye){J(new Uint8Array(ye))},ae)})}return Promise.resolve().then(function(){return Lp(Vn)})}function Cg(){var J={a:Un};function ae(He,Ke){var ln=He.exports;a.asm=ln,L=a.asm.h,pt(L.buffer),Bn=a.asm.Va,Al("wasm-instantiate")}El("wasm-instantiate");function ye(He){ae(He.instance)}function nt(He){return Sg().then(function(Ke){return WebAssembly.instantiate(Ke,J)}).then(He,function(Ke){D("failed to asynchronously prepare wasm: "+Ke),Ss(Ke)})}function Rt(){return!R&&typeof WebAssembly.instantiateStreaming=="function"&&!Pp(Vn)&&!Mp(Vn)&&typeof fetch=="function"?fetch(Vn,{credentials:"same-origin"}).then(function(He){var Ke=WebAssembly.instantiateStreaming(He,J);return Ke.then(ye,function(ln){return D("wasm streaming compile failed: "+ln),D("falling back to ArrayBuffer instantiation"),nt(ye)})}):nt(ye)}if(a.instantiateWasm)try{var Tt=a.instantiateWasm(J,ae);return Tt}catch(He){return D("Module.instantiateWasm callback failed with error: "+He),!1}return Rt().catch(i),{}}function Nr(J){for(;J.length>0;){var ae=J.shift();if(typeof ae=="function"){ae(a);continue}var ye=ae.func;typeof ye=="number"?ae.arg===void 0?Bn.get(ye)():Bn.get(ye)(ae.arg):ye(ae.arg===void 0?null:ae.arg)}}function $l(){Ss()}function Po(J,ae,ye){Ne.copyWithin(J,ae,ae+ye)}function Tg(){return Ne.length}function Ng(J){try{return L.grow(J-Ce.byteLength+65535>>>16),pt(L.buffer),1}catch(ae){}}function Cs(J){var ae=Tg(),ye=2147483648;if(J>ye)return!1;for(var nt=1;nt<=4;nt*=2){var Rt=ae*(1+.2/nt);Rt=Math.min(Rt,J+100663296);var Tt=Math.min(ye,be(Math.max(J,Rt),65536)),He=Ng(Tt);if(He)return!0}return!1}var Oo={mappings:{},buffers:[null,[],[]],printChar:function(J,ae){var ye=Oo.buffers[J];ae===0||ae===10?((J===1?O:D)(se(ye,0)),ye.length=0):ye.push(ae)},varargs:void 0,get:function(){Oo.varargs+=4;var J=qe[Oo.varargs-4>>2];return J},getStr:function(J){var ae=ne(J);return ae},get64:function(J,ae){return J}};function _g(J){return 0}function Bp(J,ae,ye,nt,Rt){}function Eg(J,ae,ye,nt){for(var Rt=0,Tt=0;Tt<ye;Tt++){for(var He=qe[ae+Tt*8>>2],Ke=qe[ae+(Tt*8+4)>>2],ln=0;ln<Ke;ln++)Oo.printChar(J,Ne[He+ln]);Rt+=Ke}return qe[nt>>2]=Rt,0}function zp(){return 28}var Un={a:$l,d:Po,e:Cs,f:_g,c:Bp,b:Eg,g:zp},Ag=Cg(),Wp=a.___wasm_call_ctors=function(){return(Wp=a.___wasm_call_ctors=a.asm.i).apply(null,arguments)},$g=a._init=function(){return($g=a._init=a.asm.j).apply(null,arguments)},Vp=a._init_with_threads_count=function(){return(Vp=a._init_with_threads_count=a.asm.k).apply(null,arguments)},Fg=a._get_threads_count=function(){return(Fg=a._get_threads_count=a.asm.l).apply(null,arguments)},Nu=a._register_tensor=function(){return(Nu=a._register_tensor=a.asm.m).apply(null,arguments)},ta=a._dispose_data=function(){return(ta=a._dispose_data=a.asm.n).apply(null,arguments)},Fl=a._dispose=function(){return(Fl=a._dispose=a.asm.o).apply(null,arguments)},Dg=a._Abs=function(){return(Dg=a._Abs=a.asm.p).apply(null,arguments)},Rg=a._Add=function(){return(Rg=a._Add=a.asm.q).apply(null,arguments)},Up=a._AddN=function(){return(Up=a._AddN=a.asm.r).apply(null,arguments)},Se=a._All=function(){return(Se=a._All=a.asm.s).apply(null,arguments)},Pg=a._Any=function(){return(Pg=a._Any=a.asm.t).apply(null,arguments)},Og=a._ArgMax=function(){return(Og=a._ArgMax=a.asm.u).apply(null,arguments)},Mg=a._AvgPool=function(){return(Mg=a._AvgPool=a.asm.v).apply(null,arguments)},Lg=a._BatchMatMul=function(){return(Lg=a._BatchMatMul=a.asm.w).apply(null,arguments)},Bg=a._Ceil=function(){return(Bg=a._Ceil=a.asm.x).apply(null,arguments)},Mo=a._ClipByValue=function(){return(Mo=a._ClipByValue=a.asm.y).apply(null,arguments)},zg=a._Conv2D=function(){return(zg=a._Conv2D=a.asm.z).apply(null,arguments)},Wg=a._Conv2DBackpropInput=function(){return(Wg=a._Conv2DBackpropInput=a.asm.A).apply(null,arguments)},Vg=a._Cos=function(){return(Vg=a._Cos=a.asm.B).apply(null,arguments)},Ug=a._Cosh=function(){return(Ug=a._Cosh=a.asm.C).apply(null,arguments)},Gg=a._CropAndResize=function(){return(Gg=a._CropAndResize=a.asm.D).apply(null,arguments)},Hg=a._Cumsum=function(){return(Hg=a._Cumsum=a.asm.E).apply(null,arguments)},Gp=a._DepthToSpace=function(){return(Gp=a._DepthToSpace=a.asm.F).apply(null,arguments)},jg=a._DepthwiseConv2dNative=function(){return(jg=a._DepthwiseConv2dNative=a.asm.G).apply(null,arguments)},qg=a._Elu=function(){return(qg=a._Elu=a.asm.H).apply(null,arguments)},na=a._Equal=function(){return(na=a._Equal=a.asm.I).apply(null,arguments)},Dl=a._Exp=function(){return(Dl=a._Exp=a.asm.J).apply(null,arguments)},Rl=a._FlipLeftRight=function(){return(Rl=a._FlipLeftRight=a.asm.K).apply(null,arguments)},Kg=a._Floor=function(){return(Kg=a._Floor=a.asm.L).apply(null,arguments)},Xg=a._FloorDiv=function(){return(Xg=a._FloorDiv=a.asm.M).apply(null,arguments)},Yg=a._FusedBatchNorm=function(){return(Yg=a._FusedBatchNorm=a.asm.N).apply(null,arguments)},Qg=a._FusedConv2D=function(){return(Qg=a._FusedConv2D=a.asm.O).apply(null,arguments)},Zg=a._FusedDepthwiseConv2D=function(){return(Zg=a._FusedDepthwiseConv2D=a.asm.P).apply(null,arguments)},Be=a._Gather=function(){return(Be=a._Gather=a.asm.Q).apply(null,arguments)},Jg=a._GatherNd=function(){return(Jg=a._GatherNd=a.asm.R).apply(null,arguments)},eb=a._Greater=function(){return(eb=a._Greater=a.asm.S).apply(null,arguments)},tb=a._GreaterEqual=function(){return(tb=a._GreaterEqual=a.asm.T).apply(null,arguments)},nb=a._LeakyRelu=function(){return(nb=a._LeakyRelu=a.asm.U).apply(null,arguments)},rb=a._Less=function(){return(rb=a._Less=a.asm.V).apply(null,arguments)},sb=a._LessEqual=function(){return(sb=a._LessEqual=a.asm.W).apply(null,arguments)},Pl=a._Log=function(){return(Pl=a._Log=a.asm.X).apply(null,arguments)},Hp=a._LogicalAnd=function(){return(Hp=a._LogicalAnd=a.asm.Y).apply(null,arguments)},jp=a._Max=function(){return(jp=a._Max=a.asm.Z).apply(null,arguments)},ab=a._MaxPool=function(){return(ab=a._MaxPool=a.asm._).apply(null,arguments)},ob=a._Maximum=function(){return(ob=a._Maximum=a.asm.$).apply(null,arguments)},ib=a._Mean=function(){return(ib=a._Mean=a.asm.aa).apply(null,arguments)},ub=a._Min=function(){return(ub=a._Min=a.asm.ba).apply(null,arguments)},cb=a._Minimum=function(){return(cb=a._Minimum=a.asm.ca).apply(null,arguments)},lb=a._MirrorPad=function(){return(lb=a._MirrorPad=a.asm.da).apply(null,arguments)},db=a._Multiply=function(){return(db=a._Multiply=a.asm.ea).apply(null,arguments)},at=a._Neg=function(){return(at=a._Neg=a.asm.fa).apply(null,arguments)},pb=a._NonMaxSuppressionV3=function(){return(pb=a._NonMaxSuppressionV3=a.asm.ga).apply(null,arguments)},hb=a._NonMaxSuppressionV4=function(){return(hb=a._NonMaxSuppressionV4=a.asm.ha).apply(null,arguments)},fb=a._NonMaxSuppressionV5=function(){return(fb=a._NonMaxSuppressionV5=a.asm.ia).apply(null,arguments)},_u=a._NotEqual=function(){return(_u=a._NotEqual=a.asm.ja).apply(null,arguments)},qp=a._OneHot=function(){return(qp=a._OneHot=a.asm.ka).apply(null,arguments)},Kp=a._PadV2=function(){return(Kp=a._PadV2=a.asm.la).apply(null,arguments)},Xp=a._Pow=function(){return(Xp=a._Pow=a.asm.ma).apply(null,arguments)},mb=a._Prelu=function(){return(mb=a._Prelu=a.asm.na).apply(null,arguments)},gb=a._Prod=function(){return(gb=a._Prod=a.asm.oa).apply(null,arguments)},Yp=a._RealDiv=function(){return(Yp=a._RealDiv=a.asm.pa).apply(null,arguments)},bb=a._Relu=function(){return(bb=a._Relu=a.asm.qa).apply(null,arguments)},yb=a._Relu6=function(){return(yb=a._Relu6=a.asm.ra).apply(null,arguments)},vb=a._ResizeBilinear=function(){return(vb=a._ResizeBilinear=a.asm.sa).apply(null,arguments)},xb=a._Reverse=function(){return(xb=a._Reverse=a.asm.ta).apply(null,arguments)},wb=a._RotateWithOffset=function(){return(wb=a._RotateWithOffset=a.asm.ua).apply(null,arguments)},Qp=a._Round=function(){return(Qp=a._Round=a.asm.va).apply(null,arguments)},ra=a._Rsqrt=function(){return(ra=a._Rsqrt=a.asm.wa).apply(null,arguments)},kb=a._ScatterNd=function(){return(kb=a._ScatterNd=a.asm.xa).apply(null,arguments)},Ib=a._SelectV2=function(){return(Ib=a._SelectV2=a.asm.ya).apply(null,arguments)},gI=a._Sigmoid=function(){return(gI=a._Sigmoid=a.asm.za).apply(null,arguments)},Zp=a._Sin=function(){return(Zp=a._Sin=a.asm.Aa).apply(null,arguments)},Sb=a._Softmax=function(){return(Sb=a._Softmax=a.asm.Ba).apply(null,arguments)},Cb=a._SparseFillEmptyRows=function(){return(Cb=a._SparseFillEmptyRows=a.asm.Ca).apply(null,arguments)},Tb=a._SparseReshape=function(){return(Tb=a._SparseReshape=a.asm.Da).apply(null,arguments)},Nb=a._SparseSegmentReduction=function(){return(Nb=a._SparseSegmentReduction=a.asm.Ea).apply(null,arguments)},_b=a._Sqrt=function(){return(_b=a._Sqrt=a.asm.Fa).apply(null,arguments)},Eb=a._Square=function(){return(Eb=a._Square=a.asm.Ga).apply(null,arguments)},Ab=a._SquaredDifference=function(){return(Ab=a._SquaredDifference=a.asm.Ha).apply(null,arguments)},$b=a._Step=function(){return($b=a._Step=a.asm.Ia).apply(null,arguments)},Fb=a._StridedSlice=function(){return(Fb=a._StridedSlice=a.asm.Ja).apply(null,arguments)},Db=a._Sub=function(){return(Db=a._Sub=a.asm.Ka).apply(null,arguments)},Rb=a._Sum=function(){return(Rb=a._Sum=a.asm.La).apply(null,arguments)},Pb=a._Tan=function(){return(Pb=a._Tan=a.asm.Ma).apply(null,arguments)},Ob=a._Tanh=function(){return(Ob=a._Tanh=a.asm.Na).apply(null,arguments)},Mb=a._Tile=function(){return(Mb=a._Tile=a.asm.Oa).apply(null,arguments)},Lb=a._TopK=function(){return(Lb=a._TopK=a.asm.Pa).apply(null,arguments)},Bb=a._Transform=function(){return(Bb=a._Transform=a.asm.Qa).apply(null,arguments)},zb=a._Transpose=function(){return(zb=a._Transpose=a.asm.Ra).apply(null,arguments)},Wb=a.__FusedMatMul=function(){return(Wb=a.__FusedMatMul=a.asm.Sa).apply(null,arguments)},Vb=a._malloc=function(){return(Vb=a._malloc=a.asm.Ta).apply(null,arguments)},Ub=a._free=function(){return(Ub=a._free=a.asm.Ua).apply(null,arguments)},Jp=a.stackSave=function(){return(Jp=a.stackSave=a.asm.Wa).apply(null,arguments)},eh=a.stackRestore=function(){return(eh=a.stackRestore=a.asm.Xa).apply(null,arguments)},Ol=a.stackAlloc=function(){return(Ol=a.stackAlloc=a.asm.Ya).apply(null,arguments)};a.cwrap=ee;var Eu;function Gb(J){this.name="ExitStatus",this.message="Program terminated with exit("+J+")",this.status=J}hr=function J(){Eu||Ml(),Eu||(hr=J)};function Ml(J){if(J=J||d,bn>0||(Zn(),bn>0))return;function ae(){Eu||(Eu=!0,a.calledRun=!0,!U&&(dr(),Tr(),o(a),a.onRuntimeInitialized&&a.onRuntimeInitialized(),pr()))}a.setStatus?(a.setStatus("Running..."),setTimeout(function(){setTimeout(function(){a.setStatus("")},1),ae()},1)):ae()}if(a.run=Ml,a.preInit)for(typeof a.preInit=="function"&&(a.preInit=[a.preInit]);a.preInit.length>0;)a.preInit.pop()();Ml();var Au;u&&(Au={uncaughtException:process.listeners("uncaughtException").filter(function(J){return!u.uncaughtException.indexOf(J)>-1}),unhandledRejection:process.listeners("unhandledRejection").filter(function(J){return!u.unhandledRejection.indexOf(J)>-1})});var $u;if(typeof s!="undefined")$u=s;else if(typeof WasmBackendModuleThreadedSimd!="undefined")$u=WasmBackendModuleThreadedSimd;else throw new Error("Could not find wasm module in post.js");if(Au){var Hb=$u._dispose;$u._dispose=function(){Hb(),Au.uncaughtException.forEach(function(J){process.removeListener("uncaughtException",J)}),Au.unhandledRejection.forEach(function(J){process.removeListener("unhandledRejection",J)})}}return s.ready}}();typeof e=="object"&&typeof t=="object"?t.exports=n:typeof define=="function"&&define.amd?define([],function(){return n}):typeof e=="object"&&(e.WasmBackendModule=n)}}),pD=1e-7,hD=1e-4,Ul=class{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}},Mu=class{refCount(e){return _r("refCount")}incRef(e){return _r("incRef")}timerAvailable(){return!0}time(e){return _r("time")}read(e){return _r("read")}readSync(e){return _r("readSync")}numDataIds(){return _r("numDataIds")}disposeData(e,t){return _r("disposeData")}write(e,t,n){return _r("write")}move(e,t,n,r,s){return _r("move")}memory(){return _r("memory")}floatPrecision(){return _r("floatPrecision")}epsilon(){return this.floatPrecision()===32?pD:hD}dispose(){return _r("dispose")}};function _r(e){throw new Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function FI(e){let t=e.length,n=0;for(;t>0;)n=Math.random()*t|0,t--,dh(e,t,n)}function fD(e,t){if(e.length!==t.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${e.length}Second array length was ${t.length}`);let n=e.length,r=0;for(;n>0;)r=Math.random()*n|0,n--,dh(e,n,r),dh(t,n,r)}function Gl(e,t,n){return Math.max(e,Math.min(t,n))}function mD(e){return e%2==0?e:e+1}function dh(e,t,n){let r=e[t];e[t]=e[n],e[n]=r}function gD(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}function bD(e,t){let n=Math.random();return t*n+(1-n)*e}function yD(e,t){let n=0;for(let r=0;r<e.length;r++){let s=Number(e[r])-Number(t[r]);n+=s*s}return n}function P(e,t){if(!e)throw new Error(typeof t=="string"?t:t())}function wn(e,t,n=""){P(ia(e,t),()=>n+` Shapes ${e} and ${t} must match`)}function zo(e){P(e!=null,()=>"The input to the tensor constructor must be a non-null value.")}function Wo(e,t=[],n=!1){if(t==null&&(t=[]),Array.isArray(e)||yn(e)&&!n)for(let r=0;r<e.length;++r)Wo(e[r],t,n);else t.push(e);return t}function wt(e){if(e.length===0)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function vD(e){return e.length===0}function ia(e,t){if(e===t)return!0;if(e==null||t==null||e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function Lu(e){return e%1==0}function xD(e){if(Math.tanh!=null)return Math.tanh(e);if(e===1/0)return 1;if(e===-1/0)return-1;{let t=Math.exp(2*e);return(t-1)/(t+1)}}function wD(e){let t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function kD(e){let t=new Uint32Array(e);for(let n=0;n<e;++n)t[n]=n;return FI(t),t}function Hl(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function ID(e,t=r=>0,n){return new Promise((r,s)=>{let a=0,o=()=>{if(e()){r();return}a++;let i=t(a);if(n!=null&&a>=n){s();return}setTimeout(o,i)};o()})}function SD(e,t){let n=1,r=-1;for(let a=0;a<e.length;++a)if(e[a]>=0)n*=e[a];else if(e[a]===-1){if(r!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${a}`);r=a}else if(e[a]<0)throw Error(`Shapes can not be < 0. Found ${e[a]} at dim ${a}`);if(r===-1){if(t>0&&t!==n)throw Error(`Size(${t}) must match the product of shape ${e}`);return e}if(n===0)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(t%n!=0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);let s=e.slice();return s[r]=t/n,s}function Er(e,t){let n=t.length;return e=e==null?t.map((r,s)=>s):[].concat(e),P(e.every(r=>r>=-n&&r<n),()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`),P(e.every(r=>Lu(r)),()=>`All values in axis param must be integers but got axis ${e}`),e.map(r=>r<0?n+r:r)}function DI(e,t){let n=[],r=[],s=t!=null&&Array.isArray(t)&&t.length===0,a=t==null||s?null:Er(t,e).sort(),o=0;for(let i=0;i<e.length;++i){if(a!=null){if(a[o]===i&&e[i]!==1)throw new Error(`Can't squeeze axis ${i} since its dim '${e[i]}' is not 1`);(a[o]==null||a[o]>i)&&e[i]===1&&(n.push(e[i]),r.push(i)),a[o]<=i&&o++}e[i]!==1&&(n.push(e[i]),r.push(i))}return{newShape:n,keptDims:r}}function RI(e,t){let n=null;if(e==null||e==="float32")n=new Float32Array(t);else if(e==="int32")n=new Int32Array(t);else if(e==="bool")n=new Uint8Array(t);else throw new Error(`Unknown data type ${e}`);return n}function PI(e,t){let n=null;if(e==null||e==="float32")n=new Float32Array(t);else if(e==="int32")n=new Int32Array(t);else if(e==="bool")n=new Uint8Array(t);else if(e==="string")n=new Array(t);else throw new Error(`Unknown data type ${e}`);return n}function OI(e,t){for(let n=0;n<e.length;n++){let r=e[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${t} being uploaded contains ${r}.`)}}function MI(e){return e==="bool"||e==="complex64"||e==="float32"||e==="int32"||e==="string"}function CD(e,t){return!(t==="complex64"||t==="float32"&&e!=="complex64"||t==="int32"&&e!=="float32"&&e!=="complex64"||t==="bool"&&e==="bool")}function yn(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}function Xb(e){if(e==="float32"||e==="int32")return 4;if(e==="complex64")return 8;if(e==="bool")return 1;throw new Error(`Unknown dtype ${e}`)}function LI(e){if(e==null)return 0;let t=0;return e.forEach(n=>t+=n.length),t}function ua(e){return typeof e=="string"||e instanceof String}function BI(e){return typeof e=="boolean"}function zI(e){return typeof e=="number"}function ph(e){return Array.isArray(e)?ph(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray?"int32":zI(e)?"float32":ua(e)?"string":BI(e)?"bool":"float32"}function ca(e){return!!(e&&e.constructor&&e.call&&e.apply)}function hh(e,t){for(let n=t;n<e;++n)if(e%n==0)return n;return e}function Bu(e){let t=e.length;if(t<2)return[];let n=new Array(t-1);n[t-2]=e[t-1];for(let r=t-3;r>=0;--r)n[r]=n[r+1]*e[r+1];return n}function WI(e,t,n,r=!1){let s=new Array;if(t.length===1){let a=t[0]*(r?2:1);for(let o=0;o<a;o++)s[o]=n[e+o]}else{let a=t[0],o=t.slice(1),i=o.reduce((u,l)=>u*l)*(r?2:1);for(let u=0;u<a;u++)s[u]=WI(e+u*i,o,n,r)}return s}function zu(e,t,n=!1){if(e.length===0)return t[0];let r=e.reduce((s,a)=>s*a)*(n?2:1);if(r===0)return[];if(r!==t.length)throw new Error(`[${e}] does not match the input size ${t.length}${n?" for a complex tensor":""}.`);return WI(0,e,t,n)}function Yb(e,t){let n=fh(e,t);for(let r=0;r<n.length;r++)n[r]=1;return n}function fh(e,t){if(t==null||t==="float32"||t==="complex64")return new Float32Array(e);if(t==="int32")return new Int32Array(e);if(t==="bool")return new Uint8Array(e);throw new Error(`Unknown data type ${t}`)}function TD(e,t){let n=e.reduce((r,s)=>r*s,1);if(t==null||t==="float32")return zu(e,new Float32Array(n));if(t==="int32")return zu(e,new Int32Array(n));if(t==="bool")return zu(e,new Uint8Array(n));throw new Error(`Unknown data type ${t}`)}function Qb(e){e.forEach(t=>{P(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`)})}function ND(e,t,n){if(t===0)return 0;if(t===1)return e[0];let r=e[e.length-1];for(let s=0;s<e.length-1;++s)r+=n[s]*e[s];return r}function _D(e,t,n){if(t===0)return[];if(t===1)return[e];let r=new Array(t);for(let s=0;s<r.length-1;++s)r[s]=Math.floor(e/n[s]),e-=r[s]*n[s];return r[r.length-1]=e,r}function Zb(e){return e&&e.then&&typeof e.then=="function"}var VI="tfjsflags",UI=class{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=ED,this.populateURLFlags()}setPlatform(e,t){this.platform!=null&&(X().getBool("IS_TEST")||X().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${t}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},this.urlFlags[e]!=null){let r=this.urlFlags[e];X().getBool("IS_TEST")||X().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${r}.`),this.set(e,r)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];let t=this.evaluateFlag(e);if(Zb(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global=="undefined"||typeof this.global.location=="undefined"||typeof this.global.location.search=="undefined")return;let e=this.getQueryParams(this.global.location.search);VI in e&&e[VI].split(",").forEach(n=>{let[r,s]=n.split(":");this.urlFlags[r]=$D(r,s)})}};function ED(e){let t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(n,...r)=>(AD(t,r[0],r[1]),r.join("="))),t}function AD(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}function $D(e,t){if(t=t.toLowerCase(),t==="true"||t==="false")return t==="true";if(`${+t}`===t)return+t;throw new Error(`Could not parse value flag value ${t} for flag ${e}.`)}function X(){return Jb}var Jb=null;function FD(e){Jb=e}var ey;function GI(){if(ey==null){let e;if(typeof window!="undefined")e=window;else if(typeof global!="undefined")e=global;else if(typeof process!="undefined")e=process;else if(typeof self!="undefined")e=self;else throw new Error("Could not find a global object");ey=e}return ey}function DD(){let e=GI();return e._tfGlobals==null&&(e._tfGlobals=new Map),e._tfGlobals}function ty(e,t){let n=DD();if(n.has(e))return n.get(e);{let r=t();return n.set(e,r),n.get(e)}}var Vo="Abs",Wu="Acos",Vu="Acosh",_s="Add",la="AddN",Uu="All",Gu="Any",da="ArgMax",Hu="ArgMin",ju="Asin",qu="Asinh",Ku="Atan",Xu="Atanh",Yu="Atan2",pa="AvgPool",mh="AvgPoolGrad",jl="AvgPool3D",gh="AvgPool3DGrad",ha="BatchMatMul",Uo="BatchToSpaceND",bh="Bincount",HI="BroadcastTo",yh="BroadcastArgs",fa="Cast",ma="Ceil",Es="ClipByValue",ql="Complex",Kl="ComplexAbs",Go="Concat",ga="Conv2D",vh="Conv2DBackpropFilter",ba="Conv2DBackpropInput",Xl="Conv3D",xh="Conv3DBackpropFilterV2",wh="Conv3DBackpropInputV2",ya="Cos",va="Cosh",Ho="Cumsum",jo="CropAndResize",kh="DenseBincount",qo="DepthToSpace",xa="DepthwiseConv2dNative",Ih="DepthwiseConv2dNativeBackpropFilter",Sh="DepthwiseConv2dNativeBackpropInput",Ch="Diag",Yl="Dilation2D",Th="Dilation2DBackpropInput",Nh="Dilation2DBackpropFilter",wa="RealDiv",Ql="Einsum",ka="Elu",_h="EluGrad",Qu="Erf",Ko="Equal",Ia="Exp",Xo="ExpandDims",Yo="Expm1",Eh="FFT",Zu="Fill",Qo="FlipLeftRight",Sa="Floor",Ca="FloorDiv",Ta="FusedBatchNorm",Zo="GatherV2",Jo="GatherNd",ei="Greater",Na="GreaterEqual",_a="Identity",Ah="IFFT",Zl="Imag",Ju="IsFinite",ec="IsInf",tc="IsNan",ti="LeakyRelu",ni="Less",ri="LessEqual",$h="LinSpace",Ea="Log",nc="Log1p",si="LogicalAnd",rc="LogicalNot",Jl="LogicalOr",jI="LogSoftmax",ed="LRN",Fh="LRNGrad",Aa="Max",$a="Maximum",Fa="MaxPool",Dh="MaxPoolGrad",td="MaxPool3D",Rh="MaxPool3DGrad",Ph="MaxPoolWithArgmax",Da="Mean",Ra="Min",Pa="Minimum",Oa="MirrorPad",sc="Mod",Oh="Multinomial",Ma="Multiply",ai="Neg",oi="NotEqual",ii="NonMaxSuppressionV3",ac="NonMaxSuppressionV4",ui="NonMaxSuppressionV5",ci="OnesLike",li="OneHot",di="Pack",La="PadV2",RD="Pool",Ba="Pow",za="Prelu",pi="Prod",oc="Range",nd="Real",ic="Reciprocal",Wa="Relu",hi="Reshape",uc="ResizeNearestNeighbor",Mh="ResizeNearestNeighborGrad",Va="ResizeBilinear",Lh="ResizeBilinearGrad",Ua="Relu6",fi="Reverse",mi="Round",Ga="Rsqrt",gi="ScatterNd",bi="Select",cc="Selu",yi="Slice",Ha="Sin",vi="Sinh",lc="Sign",ja="Sigmoid",dc="Softplus",qa="Sqrt",Ka="Sum",xi="SpaceToBatchND",wi="SplitV",Xa="Softmax",rd="SparseFillEmptyRows",pc="SparseReshape",sd="SparseSegmentMean",ad="SparseSegmentSum",od="SparseToDense",Ya="SquaredDifference",hc="Square",ki="StridedSlice",id="StringNGrams",Bh="StringSplit",zh="StringToHashBucketFast",Qa="Sub",Ii="Tan",Za="Tanh",As="Tile",Si="TopK",Ci="Transform",Ja="Transpose",Wh="Unique",Ti="Unpack",ud="UnsortedSegmentSum",Ni="ZerosLike",eo="Step",cd="FromPixels",_i="RotateWithOffset",to="_FusedMatMul",no="FusedConv2D",ro="FusedDepthwiseConv2D";function so(...e){X().getBool("IS_TEST")||X().getBool("PROD")||console.warn(...e)}function PD(...e){X().getBool("IS_TEST")||X().getBool("PROD")||console.log(...e)}var fc=ty("kernelRegistry",()=>new Map),ld=ty("gradRegistry",()=>new Map);function Vh(e,t){let n=ry(e,t);return fc.get(n)}function ny(e){return ld.get(e)}function Uh(e){let t=fc.entries(),n=[];for(;;){let{done:r,value:s}=t.next();if(r)break;let[a,o]=s,[i]=a.split("_");i===e&&n.push(o)}return n}function mc(e){let{kernelName:t,backendName:n}=e,r=ry(t,n);fc.has(r)&&so(`The kernel '${t}' for backend '${n}' is already registered`),fc.set(r,e)}function qI(e){let{kernelName:t}=e;ld.has(t)&&X().getBool("DEBUG")&&so(`Overriding the gradient for '${t}'`),ld.set(t,e)}function OD(e,t){let n=ry(e,t);if(!fc.has(n))throw new Error(`The kernel '${e}' for backend '${t}' is not registered`);fc.delete(n)}function MD(e){if(!ld.has(e))throw new Error(`The gradient '${e}' for backend is not registered`);ld.delete(e)}function LD(e,t){Uh(e).forEach(r=>{let s=Object.assign({},r,{backendName:t});mc(s)})}function ry(e,t){return`${t}_${e}`}var w={};Ee(w,{arraysEqual:()=>ia,assert:()=>P,assertNonNegativeIntegerDimensions:()=>Qb,assertNonNull:()=>zo,assertShapesMatch:()=>wn,bytesFromStringArray:()=>LI,bytesPerElement:()=>Xb,checkConversionForErrors:()=>OI,clamp:()=>Gl,computeStrides:()=>Bu,createScalarValue:()=>GD,createShuffledIndices:()=>kD,decodeString:()=>jh,distSquared:()=>yD,encodeString:()=>hd,fetch:()=>jD,fingerPrint64:()=>UD,flatten:()=>Wo,getArrayFromDType:()=>PI,getTypedArrayFromDType:()=>RI,hasEncodingLoss:()=>CD,hexToLong:()=>dd,indexToLoc:()=>_D,inferDtype:()=>ph,inferFromImplicitShape:()=>SD,isBoolean:()=>BI,isFunction:()=>ca,isInt:()=>Lu,isNumber:()=>zI,isPromise:()=>Zb,isScalarShape:()=>vD,isString:()=>ua,isTypedArray:()=>yn,isValidDtype:()=>MI,locToIndex:()=>ND,makeOnesTypedArray:()=>Yb,makeZerosNestedTypedArray:()=>TD,makeZerosTypedArray:()=>fh,nearestDivisor:()=>hh,nearestLargerEven:()=>mD,now:()=>pd,parseAxisParam:()=>Er,randUniform:()=>bD,repeatedTry:()=>ID,rightPad:()=>Hl,shuffle:()=>FI,shuffleCombo:()=>fD,sizeFromShape:()=>wt,sizeToSquarishShape:()=>wD,squeezeShape:()=>DI,sum:()=>gD,swap:()=>dh,tanh:()=>xD,toNestedArray:()=>zu,toTypedArray:()=>Hh});var KI=Bo(YF()),Ei=KI.default||KI;function dd(e){return Ei.fromString(e,!0,16)}var XI=dd("c3a5c85c97cb3127"),Ai=dd("b492b66fbe98f273"),kn=dd("9ae16a3b2f90404f");function sy(e){return e.xor(e.shru(47))}function YI(e,t,n){let r=e.slice(t,t+n);return Ei.fromBytes(Array.from(r),!0,!0)}function yt(e,t){return YI(e,t,8)}function QI(e,t){return YI(e,t,4)}function en(e,t){return t===0?e:e.shru(t).or(e.shl(64-t))}function ao(e,t,n=dd("9ddfea08eb382d69")){let r=e.xor(t).mul(n);r=r.xor(r.shru(47));let s=t.xor(r).mul(n);return s=s.xor(s.shru(47)),s=s.mul(n),s}function BD(e,t,n,r,s,a){s=s.add(e),a=en(a.add(s).add(r),21);let o=s;return s=s.add(t),s=s.add(n),a=a.add(en(s,44)),[s.add(r),a.add(o)]}function Gh(e,t,n,r){return BD(yt(e,t),yt(e,t+8),yt(e,t+16),yt(e,t+24),n,r)}function zD(e,t=e.length){if(t>=8){let n=kn.add(t*2),r=yt(e,0).add(kn),s=yt(e,t-8),a=en(s,37).mul(n).add(r),o=en(r,25).add(s).mul(n);return ao(a,o,n)}if(t>=4){let n=kn.add(t*2),r=QI(e,0);return ao(r.shl(3).add(t),QI(e,t-4),n)}if(t>0){let n=e[0],r=e[t>>1],s=e[t-1],a=n+(r<<8),o=t+(s<<2);return sy(kn.mul(a).xor(XI.mul(o))).mul(kn)}return kn}function WD(e,t=e.length){let n=kn.add(t*2),r=yt(e,0).mul(Ai),s=yt(e,8),a=yt(e,t-8).mul(n),o=yt(e,t-16).mul(kn);return ao(en(r.add(s),43).add(en(a,30)).add(o),r.add(en(s.add(kn),18)).add(a),n)}function VD(e,t=e.length){let n=kn.add(t*2),r=yt(e,0).mul(kn),s=yt(e,8),a=yt(e,t-8).mul(n),o=yt(e,t-16).mul(kn),i=en(r.add(s),43).add(en(a,30)).add(o),u=ao(i,r.add(en(s.add(kn),18)).add(a),n),l=yt(e,16).mul(n),c=yt(e,24),d=i.add(yt(e,t-32)).mul(n),p=u.add(yt(e,t-24)).mul(n);return ao(en(l.add(c),43).add(en(d,30)).add(p),l.add(en(c.add(r),18)).add(d),n)}function UD(e,t=e.length){let n=Ei.fromNumber(81,!0);if(t<=32)return t<=16?zD(e,t):WD(e,t);if(t<=64)return VD(e,t);let r=n,s=n.mul(Ai).add(113),a=sy(s.mul(kn).add(113)).mul(kn),o=[Ei.UZERO,Ei.UZERO],i=[Ei.UZERO,Ei.UZERO];r=r.mul(kn).add(yt(e,0));let u=0,l=(t-1>>6)*64,c=l+(t-1&63)-63;do r=en(r.add(s).add(o[0]).add(yt(e,u+8)),37).mul(Ai),s=en(s.add(o[1]).add(yt(e,u+48)),42).mul(Ai),r=r.xor(i[1]),s=s.add(o[0]).add(yt(e,u+40)),a=en(a.add(i[0]),33).mul(Ai),o=Gh(e,u,o[1].mul(Ai),r.add(i[0])),i=Gh(e,u+32,a.add(i[1]),s.add(yt(e,u+16))),[a,r]=[r,a],u+=64;while(u!==l);let d=Ai.add(a.and(255).shl(1));return u=c,i[0]=i[0].add(t-1&63),o[0]=o[0].add(i[0]),i[0]=i[0].add(o[0]),r=en(r.add(s).add(o[0]).add(yt(e,u+8)),37).mul(d),s=en(s.add(o[1]).add(yt(e,u+48)),42).mul(d),r=r.xor(i[1].mul(9)),s=s.add(o[0].mul(9).add(yt(e,u+40))),a=en(a.add(i[0]),33).mul(d),o=Gh(e,u,o[1].mul(d),r.add(i[0])),i=Gh(e,u+32,a.add(i[1]),s.add(yt(e,u+16))),[a,r]=[r,a],ao(ao(o[0],i[0],d).add(sy(s).mul(XI)).add(a),ao(o[1],i[1],d).add(r),d)}function GD(e,t){return t==="string"?hd(e):Hh([e],t)}function HD(e,t){return e instanceof Float32Array&&t==="float32"||e instanceof Int32Array&&t==="int32"||e instanceof Uint8Array&&t==="bool"}function Hh(e,t){if(t==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=Wo(e)),X().getBool("DEBUG")&&OI(e,t),HD(e,t))return e;if(t==null||t==="float32"||t==="complex64")return new Float32Array(e);if(t==="int32")return new Int32Array(e);if(t==="bool"){let n=new Uint8Array(e.length);for(let r=0;r<n.length;++r)Math.round(e[r])!==0&&(n[r]=1);return n}else throw new Error(`Unknown data type ${t}`)}function pd(){return X().platform.now()}function jD(e,t){return X().platform.fetch(e,t)}function hd(e,t="utf-8"){return t=t||"utf-8",X().platform.encode(e,t)}function jh(e,t="utf-8"){return t=t||"utf-8",X().platform.decode(e,t)}var qD=class{constructor(e,t){this.backendTimer=e,this.logger=t,t==null&&(this.logger=new XD)}profileKernel(e,t,n){let r,s=()=>{r=n()},a,o=pd();if(this.backendTimer.timerAvailable())a=this.backendTimer.time(s);else{s();for(let u of r)u.dataSync();a=Promise.resolve({kernelMs:pd()-o})}if(X().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let u=0;u<r.length;u++){let l=r[u];l.data().then(c=>{KD(c,l.dtype,e)})}return{kernelName:e,outputs:r,inputs:t,timeMs:a.then(u=>u.kernelMs),extraInfo:a.then(u=>u.getExtraProfileInfo!=null?u.getExtraProfileInfo():"")}}logKernelProfile(e){let{kernelName:t,outputs:n,timeMs:r,inputs:s,extraInfo:a}=e;n.forEach(o=>{Promise.all([o.data(),r,a]).then(i=>{this.logger.logKernelProfile(t,o,i[0],i[1],s,i[2])})})}};function KD(e,t,n){if(t!=="float32")return!1;for(let r=0;r<e.length;r++){let s=e[r];if(isNaN(s)||!isFinite(s))return console.warn(`Found ${s} in the result of '${n}'`),!0}return!1}var XD=class{logKernelProfile(e,t,n,r,s,a){let o=typeof r=="number"?Hl(`${r}ms`,9):r.error,i=Hl(e,25),u=t.rank,l=t.size,c=Hl(t.shape.toString(),14),d="";for(let p in s){let h=s[p];if(h!=null){let f=h.shape||t.shape,m=f.length;d+=`${p}: ${m}D ${m>0?f:""} `}}console.log(`%c${i}	%c${o}	%c${u}D ${c}	%c${l}	%c${d}	%c${a}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}};function YD(e,t,n){let r={},s={};for(let u=0;u<t.length;u++)r[t[u].id]=!0;for(let u=0;u<e.length;u++){let l=e[u],c=l.inputs;for(let d in c){let p=c[d],h=!1;for(let f=0;f<t.length;f++)if(r[p.id]){l.outputs.forEach(m=>r[m.id]=!0),h=!0,s[l.id]=!0;break}if(h)break}}let a={};a[n.id]=!0;let o={};for(let u=e.length-1;u>=0;u--){let l=e[u],c=l.inputs;for(let d=0;d<l.outputs.length;d++)if(a[l.outputs[d].id]){for(let p in c)a[c[p].id]=!0,o[l.id]=!0;break}}let i=[];for(let u=0;u<e.length;u++){let l=e[u];if(s[l.id]&&o[l.id]){let c={};for(let p in l.inputs){let h=l.inputs[p];r[h.id]&&(c[p]=h)}let d=Object.assign({},l);d.inputs=c,d.outputs=l.outputs,i.push(d)}}return i}function QD(e,t,n,r){for(let s=t.length-1;s>=0;s--){let a=t[s],o=[];if(a.outputs.forEach(u=>{let l=e[u.id];l!=null?o.push(l):o.push(null)}),a.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${a.kernelName}.`);let i=a.gradient(o);for(let u in a.inputs){if(!(u in i))throw new Error(`Cannot backprop through input ${u}. Available gradients found: ${Object.keys(i)}.`);let l=n(()=>i[u]());if(l.dtype!=="float32")throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input ${u} must have 'float32' dtype, but has '${l.dtype}'`);let c=a.inputs[u];if(!ia(l.shape,c.shape))throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input '${u}' has shape '${l.shape}', which does not match the shape of the input '${c.shape}'`);if(e[c.id]==null)e[c.id]=l;else{let d=e[c.id];e[c.id]=r(d,l),d.dispose()}}}}var ZI=20,fd=3,ay=7;function ZD(e,t,n,r){let s=Bu(t),a=JD(e,t,n,s),o=t.length,i=qh(e,t,n,s,a),u=["Tensor"];return r&&(u.push(`  dtype: ${n}`),u.push(`  rank: ${o}`),u.push(`  shape: [${t}]`),u.push("  values:")),u.push(i.map(l=>"    "+l).join(`
`)),u.join(`
`)}function JD(e,t,n,r){let s=wt(t),a=r[r.length-1],o=new Array(a).fill(0),i=t.length,u=n==="complex64"?gd(e):e;if(i>1)for(let l=0;l<s/a;l++){let c=l*a;for(let d=0;d<a;d++)o[d]=Math.max(o[d],md(u[c+d],0,n).length)}return o}function md(e,t,n){let r;return Array.isArray(e)?r=`${parseFloat(e[0].toFixed(ay))} + ${parseFloat(e[1].toFixed(ay))}j`:ua(e)?r=`'${e}'`:n==="bool"?r=JI(e):r=parseFloat(e.toFixed(ay)).toString(),Hl(r,t)}function JI(e){return e===0?"false":"true"}function qh(e,t,n,r,s,a=!0){let o=n==="complex64"?2:1,i=t[0],u=t.length;if(u===0){if(n==="complex64"){let m=gd(e);return[md(m[0],0,n)]}return n==="bool"?[JI(e[0])]:[e[0].toString()]}if(u===1){if(i>ZI){let g=fd*o,b=Array.from(e.slice(0,g)),y=Array.from(e.slice((i-fd)*o,i*o));return n==="complex64"&&(b=gd(b),y=gd(y)),["["+b.map((v,x)=>md(v,s[x],n)).join(", ")+", ..., "+y.map((v,x)=>md(v,s[i-fd+x],n)).join(", ")+"]"]}let m=n==="complex64"?gd(e):Array.from(e);return["["+m.map((g,b)=>md(g,s[b],n)).join(", ")+"]"]}let l=t.slice(1),c=r.slice(1),d=r[0]*o,p=[];if(i>ZI){for(let m=0;m<fd;m++){let g=m*d,b=g+d;p.push(...qh(e.slice(g,b),l,n,c,s,!1))}p.push("...");for(let m=i-fd;m<i;m++){let g=m*d,b=g+d;p.push(...qh(e.slice(g,b),l,n,c,s,m===i-1))}}else for(let m=0;m<i;m++){let g=m*d,b=g+d;p.push(...qh(e.slice(g,b),l,n,c,s,m===i-1))}let h=u===2?",":"";p[0]="["+p[0]+h;for(let m=1;m<p.length-1;m++)p[m]=" "+p[m]+h;let f=`,
`;for(let m=2;m<u;m++)f+=`
`;return p[p.length-1]=" "+p[p.length-1]+"]"+(a?"":f),p}function gd(e){let t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}var Kt=class{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=wt(e),n!=null){let r=n.length;P(r===this.size,()=>`Length of values '${r}' does not match the size inferred by the shape '${this.size}'.`)}if(t==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||PI(t,this.size),this.strides=Bu(e)}set(e,...t){t.length===0&&(t=[0]),P(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);let n=this.locToIndex(t);this.values[n]=e}get(...e){e.length===0&&(e=[0]);let t=0;for(let r of e){if(r<0||r>=this.shape[t]){let s=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(s)}t++}let n=e[e.length-1];for(let r=0;r<e.length-1;++r)n+=this.strides[r]*e[r];return this.values[n]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];let t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return as().makeTensor(this.values,this.shape,this.dtype)}},as=null,gc=null,eR=null;function tR(e){as=e}function nR(e){gc=e}function rR(e){eR=e}var Ae=class{constructor(e,t,n,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=wt(e),this.strides=Bu(e),this.dataId=n,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){let e=await this.data();return gc.buffer(this.shape,this.dtype,e)}bufferSync(){return gc.buffer(this.shape,this.dtype,this.dataSync())}async array(){let e=await this.data();return zu(this.shape,e,this.dtype==="complex64")}arraySync(){return zu(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();let e=as().read(this.dataId);if(this.dtype==="string"){let t=await e;try{return t.map(n=>jh(n))}catch(n){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataSync(){this.throwIfDisposed();let e=as().readSync(this.dataId);if(this.dtype==="string")try{return e.map(t=>jh(t))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();let e=await as().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(as().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return gc.print(this,e)}clone(){return this.throwIfDisposed(),gc.clone(this)}toString(e=!1){let t=this.dataSync();return ZD(t,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),gc.cast(this,e)}variable(e=!0,t,n){return this.throwIfDisposed(),as().makeVariable(this,e,t,n)}};Object.defineProperty(Ae,Symbol.hasInstance,{value:e=>!!e&&e.data!=null&&e.dataSync!=null&&e.throwIfDisposed!=null});function sR(){return ty("Tensor",()=>Ae)}sR();var oo=class extends Ae{constructor(e,t,n,r){super(e.shape,e.dtype,e.dataId,r);this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!ia(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);as().disposeTensor(this),this.dataId=e.dataId,as().incRef(this,null)}dispose(){as().disposeVariable(this),this.isDisposedInternal=!0}};Object.defineProperty(oo,Symbol.hasInstance,{value:e=>e instanceof Ae&&e.assign!=null&&e.assign instanceof Function});var Vr={};Ee(Vr,{assertTypesMatch:()=>e1,getTensorsInContainer:()=>dy,isTensorInList:()=>oR,makeTypesMatch:()=>At});var oy;(function(e){e.R0="R0",e.R1="R1",e.R2="R2",e.R3="R3",e.R4="R4",e.R5="R5",e.R6="R6"})(oy||(oy={}));var iy;(function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"})(iy||(iy={}));var uy;(function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"})(uy||(uy={}));var cy;(function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"})(cy||(cy={}));var ly;(function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"})(ly||(ly={}));var aR={float32:cy,int32:iy,bool:uy,complex64:ly};function In(e,t){if(e==="string"||t==="string"){if(e==="string"&&t==="string")return"string";throw new Error(`Can not upcast ${e} with ${t}`)}return aR[e][t]}function bd(e){return In(e,"int32")}function At(e,t){if(e.dtype===t.dtype)return[e,t];let n=In(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function e1(e,t){P(e.dtype===t.dtype,()=>`The dtypes of the first(${e.dtype}) and second(${t.dtype}) input must match`)}function oR(e,t){return t.some(n=>n.id===e.id)}function dy(e){let t=[],n=new Set;return t1(e,t,n),t}function t1(e,t,n){if(e==null)return;if(e instanceof Ae){t.push(e);return}if(!iR(e))return;let r=e;for(let s in r){let a=r[s];n.has(a)||(n.add(a),t1(a,t,n))}}function iR(e){return Array.isArray(e)||typeof e=="object"}function py(e){return e.kernelName!=null}var n1=class{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(let e in this.registeredVariables)this.registeredVariables[e].dispose()}},hy=class{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new n1}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;let e=this.getSortedBackends();for(let t=0;t<e.length;t++){let n=e[t];if(await this.initializeBackend(n).success){await this.setBackend(n);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){let{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){let{asyncInit:t}=this.initializeBackend(e);if(t)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,n=1){return e in this.registryFactory?(so(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:n},!0)}async setBackend(e){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;let{success:t,asyncInit:n}=this.initializeBackend(e);if(!(n?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new qD(this.backendInstance),!0}setupRegisteredKernels(){Uh(this.backendName).forEach(t=>{t.setupFunc!=null&&t.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){Uh(e).forEach(n=>{n.disposeFunc!=null&&n.disposeFunc(this.registry[e])})}initializeBackend(e){let t=this.registryFactory[e];if(t==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{let n=t.factory();if(n&&!(n instanceof Mu)&&typeof n.then=="function"){let r=++this.pendingBackendInitId,s=n.then(a=>r<this.pendingBackendInitId?!1:(this.registry[e]=a,this.pendingBackendInit=null,!0)).catch(a=>(r<this.pendingBackendInitId||(this.pendingBackendInit=null,so(`Initialization of backend ${e} failed`),so(a.stack||a.message)),!1));return this.pendingBackendInit=s,{success:s,asyncInit:!0}}else return this.registry[e]=n,{success:!0,asyncInit:!1}}catch(n){return so(`Initialization of backend ${e} failed`),so(n.stack||n.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){let e=this.getSortedBackends();for(let t=0;t<e.length;t++){let n=e[t],{success:r,asyncInit:s}=this.initializeBackend(n);if(s||r)return{name:n,asyncInit:s}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){let n=this.state.tensorInfo.get(t),r=n.backend,s=this.readSync(t),a=r.refCount(t);r.disposeData(t,!0),n.backend=e,e.move(t,s,n.shape,n.dtype,a),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let n=null;if(t==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");t=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof t!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");n=e}let r;return this.scopedRun(()=>this.startScope(n),()=>this.endScope(r),()=>(r=t(),r instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),r))}scopedRun(e,t,n){e();try{let r=n();return t(),r}catch(r){throw t(),r}}nextTensorId(){return hy.nextTensorId++}nextVariableId(){return hy.nextVariableId++}clone(e){let t=z.runKernel(_a,{x:e}),n={x:e},r=a=>({x:()=>{let o="float32",i={x:a},u={dtype:o};return z.runKernel(fa,i,u)}}),s=[];return this.addTapeNode(this.state.activeScope.name,n,[t],r,s,{}),t}runKernel(e,t,n){if(this.backendName==null&&this.backend,!(Vh(e,this.backendName)!=null))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,n){let r=this.backend.numDataIds(),s=0;n.forEach(i=>{s+=i.dtype==="complex64"?3:1});let a=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],o=r-t-s-a;if(o>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${o} data ids) after running '${e}'`)}runKernelFunc(e){let t,n=[],r=this.isTapeOn(),s=this.state.numBytes,a=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let o;this.backendName==null&&this.backend;let i,u=py(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(py(e)){let{kernelName:h,inputs:f,attrs:m}=e;this.backendName==null&&this.backend;let g=Vh(h,this.backendName);P(g!=null,()=>`Cannot find registered kernel '${h}' for backend '${this.backendName}'`),o=()=>{let b=this.backend.numDataIds();i=g.kernelFunc({inputs:f,attrs:m,backend:this.backend});let y=Array.isArray(i)?i:[i];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(h,b,y);let v=y.map(x=>{if(x.rank!=null)return x;let{dataId:k,shape:T,dtype:C}=x;return this.makeTensorFromDataId(k,T,C)});if(r){let x=this.getTensorsForGradient(h,f,v);n=this.saveTensorsForBackwardMode(x)}return v}}else{let{forwardFunc:h}=e,f=m=>{!r||(n=m.map(g=>this.keep(this.clone(g))))};o=()=>{let m=this.backend.numDataIds();i=this.tidy(()=>h(this.backend,f));let g=Array.isArray(i)?i:[i];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(u,m,g),g}}let{inputs:l,attrs:c}=e,d=py(e)?null:e.backwardsFunc,p;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?t=o():(p=this.profiler.profileKernel(u,l,()=>o()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(p),t=p.outputs)}),r&&this.addTapeNode(u,l,t,d,n,c),this.state.profiling&&this.state.activeProfile.kernels.push({name:u,bytesAdded:this.state.numBytes-s,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-a,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(l).map(h=>l[h]!=null?l[h].shape:null),outputShapes:t.map(h=>h.shape),kernelTimeMs:p.timeMs,extraInfo:p.extraInfo}),Array.isArray(i)?t:t[0]}saveTensorsForBackwardMode(e){return e.map(n=>this.keep(this.clone(n)))}getTensorsForGradient(e,t,n){let r=ny(e);if(r!=null){let s=r.inputsToSave||[],a=r.outputsToSave||[],o;r.saveAllInputs?(P(Array.isArray(t),()=>"saveAllInputs is true, expected inputs to be an array."),o=Object.keys(t).map(u=>t[u])):o=s.map(u=>t[u]);let i=n.filter((u,l)=>a[l]);return o.concat(i)}return[]}makeTensor(e,t,n,r){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",r=r||this.backend;let s=e;n==="string"&&ua(e[0])&&(s=e.map(i=>hd(i)));let a=r.write(s,t,n),o=new Ae(t,n,a,this.nextTensorId());if(this.trackTensor(o,r),n==="string"){let i=this.state.tensorInfo.get(a),u=LI(s);this.state.numBytes+=u-i.bytes,i.bytes=u}return o}makeTensorFromDataId(e,t,n,r){n=n||"float32";let s=new Ae(t,n,e,this.nextTensorId());return this.trackTensor(s,r),s}makeVariable(e,t=!0,n,r){n=n||this.nextVariableId().toString(),r!=null&&r!==e.dtype&&(e=e.cast(r));let s=new oo(e,t,n,this.nextTensorId());if(this.state.registeredVariables[s.name]!=null)throw new Error(`Variable with name ${s.name} was already registered`);return this.state.registeredVariables[s.name]=s,this.incRef(s,this.backend),s}trackTensor(e,t){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let n=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(n=e.size*Xb(e.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:n})),e instanceof oo||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;let t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){let n=e.size*Xb(e.dtype);this.state.numBytes-=n}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(let e in this.state.registeredVariables){let t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){let e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;let t=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(r=>r.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-n;for(let r of this.state.activeProfile.kernels)r.kernelTimeMs=await r.kernelTimeMs,r.extraInfo=await r.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,t,n,r,s,a){let o={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:n,saved:s},i=ny(e);i!=null&&(r=i.gradFunc),r!=null&&(o.gradient=u=>(u=u.map((l,c)=>{if(l==null){let d=n[c],p=fh(d.size,d.dtype);return this.makeTensor(p,d.shape,d.dtype)}return l}),r(u.length>1?u:u[0],s,a))),this.state.activeTape.push(o)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){let t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){let t=dy(e),n=new Set(t.map(s=>s.id));for(let s=0;s<this.state.activeScope.track.length;s++){let a=this.state.activeScope.track[s];!a.kept&&!n.has(a.id)&&a.dispose()}let r=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach(s=>{!s.kept&&s.scopeId===r.id&&this.track(s)})}gradients(e,t,n,r=!1){if(P(t.length>0,()=>"gradients() received an empty list of xs."),n!=null&&n.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);let s=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));P(s instanceof Ae,()=>"The result y returned by f() must be a tensor.");let a=YD(this.state.activeTape,t,s);if(!r&&a.length===0&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{let o={};o[s.id]=n==null?uR(s.shape):n,QD(o,a,u=>this.tidy(u),cR);let i=t.map(u=>o[u.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(u=>{for(let l of u.saved)l.dispose()}),this.state.activeTape=null),{value:s,grads:i}})}customGrad(e){return P(ca(e),()=>"The f passed in customGrad(f) must be a function."),(...t)=>{P(t.every(o=>o instanceof Ae),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let n,r={};t.forEach((o,i)=>{r[i]=o});let s=(o,i)=>(n=e(...t,i),P(n.value instanceof Ae,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),P(ca(n.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),n.value),a=(o,i)=>{let u=n.gradFunc(o,i),l=Array.isArray(u)?u:[u];P(l.length===t.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),P(l.every(d=>d instanceof Ae),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");let c={};return l.forEach((d,p)=>{c[p]=()=>d}),c};return this.runKernelFunc({forwardFunc:s,backwardsFunc:a,inputs:r})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}async time(e){let t=pd(),n=await this.backend.time(e);return n.wallMs=pd()-t,n}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new n1;for(let e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}},fy=hy;fy.nextTensorId=0;fy.nextVariableId=0;function uR(e){let t=Yb(wt(e),"float32");return z.makeTensor(t,e,"float32")}function r1(){let e=GI();if(e._tfengine==null){let t=new UI(e);e._tfengine=new fy(t)}return FD(e._tfengine.ENV),tR(()=>e._tfengine),e._tfengine}var z=r1();function cR(e,t){let n={a:e,b:t};return z.runKernel(_s,n)}var bc={};Ee(bc,{isBrowser:()=>s1,isMobile:()=>pR,mockIsMobile:()=>dR});function lR(){return typeof navigator!="undefined"&&navigator!=null}var my;function dR(e){my=e}function pR(e){if(my!==void 0)return my;if(e||lR()){if(e||(e=navigator),e.product==="ReactNative")return!0;let t=e.userAgent||e.vendor||(typeof window!="undefined"?window.opera:"");if(!t){let n=e;return n.userAgentData&&n.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function s1(){return typeof window!="undefined"&&window.document!=null||typeof WorkerGlobalScope!="undefined"}var Ur=X();Ur.registerFlag("DEBUG",()=>!1,e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});Ur.registerFlag("IS_BROWSER",()=>s1());Ur.registerFlag("IS_NODE",()=>typeof process!="undefined"&&typeof process.versions!="undefined"&&typeof process.versions.node!="undefined");Ur.registerFlag("IS_CHROME",()=>typeof navigator!="undefined"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));Ur.registerFlag("PROD",()=>!1);Ur.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>Ur.getBool("DEBUG"));Ur.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);Ur.registerFlag("IS_TEST",()=>!1);Ur.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>!0);Ur.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);function os(e,t){let n=e;if(yn(e))return t==="string"?[]:[e.length];if(!Array.isArray(e))return[];let r=[];for(;Array.isArray(n)||yn(n)&&t!=="string";)r.push(n.length),n=n[0];return Array.isArray(e)&&X().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&a1(e,r,[]),r}function a1(e,t,n){if(n=n||[],!Array.isArray(e)&&!yn(e)){P(t.length===0,()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);return}P(t.length>0,()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${e.length} elements`),P(e.length===t[0],()=>`Element arr[${n.join("][")}] should have ${t[0]} elements, but has ${e.length} elements`);let r=t.slice(1);for(let s=0;s<e.length;++s)a1(e[s],r,n.concat(s))}function o1(e,t,n,r){if(e!=="string_or_numeric"){if(e==null)throw new Error("Expected dtype cannot be null.");if(e!=="numeric"&&e!==t||e==="numeric"&&t==="string")throw new Error(`Argument '${n}' passed to '${r}' must be ${e} tensor, but got ${t} tensor`)}}function $(e,t,n,r="numeric"){if(e instanceof Ae)return o1(r,e.dtype,t,n),e;let s=ph(e);if(s!=="string"&&["bool","int32","float32"].indexOf(r)>=0&&(s=r),o1(r,s,t,n),e==null||!yn(e)&&!Array.isArray(e)&&typeof e!="number"&&typeof e!="boolean"&&typeof e!="string"){let u=e==null?"null":e.constructor.name;throw new Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${u}'`)}let a=os(e,s);!yn(e)&&!Array.isArray(e)&&(e=[e]);let i=s!=="string"?Hh(e,s):Wo(e,[],!0);return z.makeTensor(i,a,s)}function yd(e,t,n,r="numeric"){if(!Array.isArray(e))throw new Error(`Argument ${t} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return e.map((a,o)=>$(a,`${t}[${o}]`,n,r))}var i1="__op";function W(e){let t=Object.keys(e);if(t.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let n=t[0],r=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n=n+i1;let s=(...a)=>{z.startScope(n);try{let o=r(...a);return Zb(o)&&console.error("Cannot return a Promise inside of tidy."),z.endScope(o),o}catch(o){throw z.endScope(null),o}};return Object.defineProperty(s,"name",{value:n,configurable:!0}),s}function hR(e,t){let n=$(e,"real","complex"),r=$(t,"imag","complex");wn(n.shape,r.shape,`real and imag shapes, ${n.shape} and ${r.shape}, must match in call to tf.complex().`);let s={real:n,imag:r};return z.runKernel(ql,s)}var io=W({complex_:hR});function uo(e,t,n,r){if(r==null&&(r=ph(e)),r==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!yn(e)&&!Array.isArray(e)&&typeof e!="number"&&typeof e!="boolean"&&typeof e!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(t!=null){Qb(t);let s=wt(t),a=wt(n);P(s===a,()=>`Based on the provided shape, [${t}], the tensor should have ${s} values but has ${a}`);for(let o=0;o<n.length;++o){let i=n[o],u=o===n.length-1?i!==wt(t.slice(o)):!0;P(n[o]===t[o]||!u,()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `)}}return!yn(e)&&!Array.isArray(e)&&(e=[e]),t=t||n,e=r!=="string"?Hh(e,r):Wo(e,[],!0),z.makeTensor(e,t,r)}function er(e,t,n){let r=os(e,n);return uo(e,t,r,n)}var gy={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8},Kh=4;async function fR(e,t){let n=[],r=[],s=Array.isArray(e)?e.map(o=>o.name):Object.keys(e);for(let o=0;o<s.length;++o){let i=s[o],u=Array.isArray(e)?e[o].tensor:e[i];if(u.dtype!=="float32"&&u.dtype!=="int32"&&u.dtype!=="bool"&&u.dtype!=="string"&&u.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${i}': ${u.dtype}`);let l={name:i,shape:u.shape,dtype:u.dtype};if(u.dtype==="string"){let c=new Promise(async d=>{let p=await u.bytes(),h=p.reduce((g,b)=>g+b.length,0)+Kh*p.length,f=new Uint8Array(h),m=0;for(let g=0;g<p.length;g++){let b=p[g],y=new Uint8Array(new Uint32Array([b.length]).buffer);f.set(y,m),m+=Kh,f.set(b,m),m+=b.length}d(f)});r.push(c)}else r.push(u.data());t!=null&&(l.group=t),n.push(l)}let a=await Promise.all(r);return{data:mR(a),specs:n}}function u1(e,t){let n={},r,s=0;for(let a of t){let o=a.name,i=a.dtype,u=a.shape,l=wt(u),c;if("quantization"in a){let d=a.quantization;if(d.dtype==="uint8"||d.dtype==="uint16"){if(!("min"in d&&"scale"in d))throw new Error(`Weight ${a.name} with quantization ${d.dtype} doesn't have corresponding metadata min and scale.`)}else if(d.dtype==="float16"){if(i!=="float32")throw new Error(`Weight ${a.name} is quantized with ${d.dtype} which only supports weights of type float32 not ${i}.`)}else throw new Error(`Weight ${a.name} has unknown quantization dtype ${d.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);let p=gy[d.dtype],h=e.slice(s,s+l*p),f=d.dtype==="uint8"?new Uint8Array(h):new Uint16Array(h);if(i==="float32")if(d.dtype==="uint8"||d.dtype==="uint16"){c=new Float32Array(f.length);for(let m=0;m<f.length;m++){let g=f[m];c[m]=g*d.scale+d.min}}else if(d.dtype==="float16")r===void 0&&(r=wR()),c=r(f);else throw new Error(`Unsupported quantization type ${d.dtype} for weight type float32.`);else if(i==="int32"){if(d.dtype!=="uint8"&&d.dtype!=="uint16")throw new Error(`Unsupported quantization type ${d.dtype} for weight type int32.`);c=new Int32Array(f.length);for(let m=0;m<f.length;m++){let g=f[m];c[m]=Math.round(g*d.scale+d.min)}}else throw new Error(`Unsupported dtype in weight '${o}': ${i}`);s+=l*p}else if(i==="string"){let d=wt(a.shape);c=[];for(let p=0;p<d;p++){let h=new Uint32Array(e.slice(s,s+Kh))[0];s+=Kh;let f=new Uint8Array(e.slice(s,s+h));c.push(f),s+=h}}else{let d=gy[i],p=e.slice(s,s+l*d);if(i==="float32")c=new Float32Array(p);else if(i==="int32")c=new Int32Array(p);else if(i==="bool")c=new Uint8Array(p);else if(i==="complex64"){c=new Float32Array(p);let h=new Float32Array(c.length/2),f=new Float32Array(c.length/2);for(let b=0;b<h.length;b++)h[b]=c[b*2],f[b]=c[b*2+1];let m=er(h,u,"float32"),g=er(f,u,"float32");n[o]=io(m,g),m.dispose(),g.dispose()}else throw new Error(`Unsupported dtype in weight '${o}': ${i}`);s+=l*d}i!=="complex64"&&(n[o]=er(c,u,i))}return n}function mR(e){if(e===null)throw new Error(`Invalid input value: ${JSON.stringify(e)}`);let t=0,n=[];e.forEach(a=>{if(t+=a.byteLength,n.push(a.byteLength===a.buffer.byteLength?a:new a.constructor(a)),!(a instanceof Float32Array||a instanceof Int32Array||a instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${a.constructor.name}`)});let r=new Uint8Array(t),s=0;return n.forEach(a=>{r.set(new Uint8Array(a.buffer),s),s+=a.byteLength}),r.buffer}var by=typeof Buffer!="undefined"&&(typeof Blob=="undefined"||typeof atob=="undefined"||typeof btoa=="undefined");function c1(e){return by?Buffer.byteLength(e):new Blob([e]).size}function gR(e){if(by)return Buffer.from(e).toString("base64");let t=new Uint8Array(e),n="";for(let r=0,s=t.length;r<s;r++)n+=String.fromCharCode(t[r]);return btoa(n)}function bR(e){if(by){let r=Buffer.from(e,"base64");return r.buffer.slice(r.byteOffset,r.byteOffset+r.byteLength)}let t=atob(e),n=new Uint8Array(t.length);for(let r=0;r<t.length;++r)n.set([t.charCodeAt(r)],r);return n.buffer}function yy(e){if(e.length===1)return e[0];let t=0;e.forEach(s=>{t+=s.byteLength});let n=new Uint8Array(t),r=0;return e.forEach(s=>{n.set(new Uint8Array(s),r),r+=s.byteLength}),n.buffer}function l1(e){let t="/";for(e=e.trim();e.endsWith(t);)e=e.slice(0,e.length-1);let n=e.split(t);return n[n.length-1]}function d1(e,t){let n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};return e.signature!=null&&(n.signature=e.signature),e.userDefinedMetadata!=null&&(n.userDefinedMetadata=e.userDefinedMetadata),e.modelInitializer!=null&&(n.modelInitializer=e.modelInitializer),e.trainingConfig!=null&&(n.trainingConfig=e.trainingConfig),n}async function vy(e,t){let n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(e.trainingConfig!=null&&(n.trainingConfig=e.trainingConfig),e.weightsManifest!=null){let[r,s]=await t(e.weightsManifest);n.weightSpecs=r,n.weightData=s}return e.signature!=null&&(n.signature=e.signature),e.userDefinedMetadata!=null&&(n.userDefinedMetadata=e.userDefinedMetadata),e.modelInitializer!=null&&(n.modelInitializer=e.modelInitializer),n}function vd(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:e.modelTopology==null?0:c1(JSON.stringify(e.modelTopology)),weightSpecsBytes:e.weightSpecs==null?0:c1(JSON.stringify(e.weightSpecs)),weightDataBytes:e.weightData==null?0:e.weightData.byteLength}}function yR(){let e=n=>{let r=n<<13,s=0;for(;(r&8388608)==0;)s-=8388608,r<<=1;return r&=~8388608,s+=947912704,r|s},t=new Uint32Array(2048);t[0]=0;for(let n=1;n<1024;n++)t[n]=e(n);for(let n=1024;n<2048;n++)t[n]=939524096+(n-1024<<13);return t}function vR(){let e=new Uint32Array(64);e[0]=0,e[31]=1199570944,e[32]=2147483648,e[63]=3347054592;for(let t=1;t<31;t++)e[t]=t<<23;for(let t=33;t<63;t++)e[t]=2147483648+(t-32<<23);return e}function xR(){let e=new Uint32Array(64);for(let t=0;t<64;t++)e[t]=1024;return e[0]=e[32]=0,e}function wR(){let e=yR(),t=vR(),n=xR();return r=>{let s=new ArrayBuffer(4*r.length),a=new Uint32Array(s);for(let o=0;o<r.length;o++){let i=r[o],u=e[n[i>>10]+(i&1023)]+t[i>>10];a[o]=u}return new Float32Array(s)}}var Pt=class{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return Pt.instance==null&&(Pt.instance=new Pt),Pt.instance}static registerSaveRouter(e){Pt.getInstance().saveRouters.push(e)}static registerLoadRouter(e){Pt.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return Pt.getHandlers(e,"save")}static getLoadHandlers(e,t){return Pt.getHandlers(e,"load",t)}static getHandlers(e,t,n){let r=[];return(t==="load"?Pt.getInstance().loadRouters:Pt.getInstance().saveRouters).forEach(a=>{let o=a(e,n);o!==null&&r.push(o)}),r}},kR=e=>Pt.registerSaveRouter(e),IR=e=>Pt.registerLoadRouter(e),SR=e=>Pt.getSaveHandlers(e),CR=(e,t)=>Pt.getLoadHandlers(e,t),xy="tensorflowjs",wy=1,$i="models_store",co="model_info_store";function p1(){if(!X().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");let e=typeof window=="undefined"?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(t==null)throw new Error("The current browser does not appear to support IndexedDB.");return t}function ky(e){let t=e.result;t.createObjectStore($i,{keyPath:"modelPath"}),t.createObjectStore(co,{keyPath:"modelPath"})}var Fi=class{constructor(e){if(this.indexedDB=p1(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise((n,r)=>{let s=this.indexedDB.open(xy,wy);s.onupgradeneeded=()=>ky(s),s.onsuccess=()=>{let a=s.result;if(t==null){let o=a.transaction($i,"readonly"),u=o.objectStore($i).get(this.modelPath);u.onsuccess=()=>{if(u.result==null)return a.close(),r(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));n(u.result.modelArtifacts)},u.onerror=l=>(a.close(),r(u.error)),o.oncomplete=()=>a.close()}else{let o=vd(t),i=a.transaction(co,"readwrite"),u=i.objectStore(co),l=u.put({modelPath:this.modelPath,modelArtifactsInfo:o}),c;l.onsuccess=()=>{c=a.transaction($i,"readwrite");let p=c.objectStore($i).put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:o});p.onsuccess=()=>n({modelArtifactsInfo:o}),p.onerror=h=>{u=i.objectStore(co);let f=u.delete(this.modelPath);f.onsuccess=()=>(a.close(),r(p.error)),f.onerror=m=>(a.close(),r(p.error))}},l.onerror=d=>(a.close(),r(l.error)),i.oncomplete=()=>{c==null?a.close():c.oncomplete=()=>a.close()}}},s.onerror=a=>r(s.error)})}};Fi.URL_SCHEME="indexeddb://";var h1=e=>X().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Fi.URL_SCHEME)?TR(e.slice(Fi.URL_SCHEME.length)):null;Pt.registerSaveRouter(h1);Pt.registerLoadRouter(h1);function TR(e){return new Fi(e)}function NR(e){return e.startsWith(Fi.URL_SCHEME)?e.slice(Fi.URL_SCHEME.length):e}var _R=class{constructor(){this.indexedDB=p1()}async listModels(){return new Promise((e,t)=>{let n=this.indexedDB.open(xy,wy);n.onupgradeneeded=()=>ky(n),n.onsuccess=()=>{let r=n.result,s=r.transaction(co,"readonly"),o=s.objectStore(co).getAll();o.onsuccess=()=>{let i={};for(let u of o.result)i[u.modelPath]=u.modelArtifactsInfo;e(i)},o.onerror=i=>(r.close(),t(o.error)),s.oncomplete=()=>r.close()},n.onerror=r=>t(n.error)})}async removeModel(e){return e=NR(e),new Promise((t,n)=>{let r=this.indexedDB.open(xy,wy);r.onupgradeneeded=()=>ky(r),r.onsuccess=()=>{let s=r.result,a=s.transaction(co,"readwrite"),o=a.objectStore(co),i=o.get(e),u;i.onsuccess=()=>{if(i.result==null)return s.close(),n(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{let l=o.delete(e),c=()=>{u=s.transaction($i,"readwrite");let p=u.objectStore($i).delete(e);p.onsuccess=()=>t(i.result.modelArtifactsInfo),p.onerror=h=>n(i.error)};l.onsuccess=c,l.onerror=d=>(c(),s.close(),n(i.error))}},i.onerror=l=>(s.close(),n(i.error)),a.oncomplete=()=>{u==null?s.close():u.oncomplete=()=>s.close()}},r.onerror=s=>n(r.error)})}},$s="/",yc="tensorflowjs_models",f1="info",ER="model_topology",AR="weight_specs",$R="weight_data",FR="model_metadata";function m1(e){return{info:[yc,e,f1].join($s),topology:[yc,e,ER].join($s),weightSpecs:[yc,e,AR].join($s),weightData:[yc,e,$R].join($s),modelMetadata:[yc,e,FR].join($s)}}function g1(e){for(let t of Object.values(e))window.localStorage.removeItem(t)}function DR(e){let t=e.split($s);if(t.length<3)throw new Error(`Invalid key format: ${e}`);return t.slice(1,t.length-1).join($s)}function RR(e){return e.startsWith(Di.URL_SCHEME)?e.slice(Di.URL_SCHEME.length):e}var Di=class{constructor(e){if(!X().getBool("IS_BROWSER")||typeof window=="undefined"||typeof window.localStorage=="undefined")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=m1(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{let t=JSON.stringify(e.modelTopology),n=JSON.stringify(e.weightSpecs),r=vd(e);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,gR(e.weightData));let s={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(s)),{modelArtifactsInfo:r}}catch(s){throw g1(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){let e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");let t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(n==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=n;let r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(r==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=r;let s=this.LS.getItem(this.keys.modelMetadata);if(s!=null){let o=JSON.parse(s);t.format=o.format,t.generatedBy=o.generatedBy,t.convertedBy=o.convertedBy,o.signature!=null&&(t.signature=o.signature),o.userDefinedMetadata!=null&&(t.userDefinedMetadata=o.userDefinedMetadata),o.modelInitializer!=null&&(t.modelInitializer=o.modelInitializer),o.trainingConfig!=null&&(t.trainingConfig=o.trainingConfig)}let a=this.LS.getItem(this.keys.weightData);if(a==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=bR(a),t}};Di.URL_SCHEME="localstorage://";var b1=e=>X().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Di.URL_SCHEME)?PR(e.slice(Di.URL_SCHEME.length)):null;Pt.registerSaveRouter(b1);Pt.registerLoadRouter(b1);function PR(e){return new Di(e)}var OR=class{constructor(){P(X().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),P(typeof window=="undefined"||typeof window.localStorage!="undefined",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){let e={},t=yc+$s,n=$s+f1;for(let r=0;r<this.LS.length;++r){let s=this.LS.key(r);if(s.startsWith(t)&&s.endsWith(n)){let a=DR(s);e[a]=JSON.parse(this.LS.getItem(s))}}return e}async removeModel(e){e=RR(e);let t=m1(e);if(this.LS.getItem(t.info)==null)throw new Error(`Cannot find model at path '${e}'`);let n=JSON.parse(this.LS.getItem(t.info));return g1(t),n}},vc="://",fr=class{constructor(){this.managers={}}static getInstance(){return fr.instance==null&&(fr.instance=new fr),fr.instance}static registerManager(e,t){P(e!=null,()=>"scheme must not be undefined or null."),e.endsWith(vc)&&(e=e.slice(0,e.indexOf(vc))),P(e.length>0,()=>"scheme must not be an empty string.");let n=fr.getInstance();P(n.managers[e]==null,()=>`A model store manager is already registered for scheme '${e}'.`),n.managers[e]=t}static getManager(e){let t=this.getInstance().managers[e];if(t==null)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(this.getInstance().managers)}};function Xh(e){if(e.indexOf(vc)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${fr.getSchemes().join(",")}`);return{scheme:e.split(vc)[0],path:e.split(vc)[1]}}async function y1(e,t,n=!1){P(e!==t,()=>`Old path and new path are the same: '${e}'`);let r=Pt.getLoadHandlers(e);P(r.length>0,()=>`Copying failed because no load handler is found for source URL ${e}.`),P(r.length<2,()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${e}.`);let s=r[0],a=Pt.getSaveHandlers(t);P(a.length>0,()=>`Copying failed because no save handler is found for destination URL ${t}.`),P(a.length<2,()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${t}.`);let o=a[0],i=Xh(e).scheme,u=Xh(e).path,l=i===Xh(e).scheme,c=await s.load();n&&l&&await fr.getManager(i).removeModel(u);let d=await o.save(c);return n&&!l&&await fr.getManager(i).removeModel(u),d.modelArtifactsInfo}async function MR(){let e=fr.getSchemes(),t={};for(let n of e){let r=await fr.getManager(n).listModels();for(let s in r){let a=n+vc+s;t[a]=r[s]}}return t}async function LR(e){let t=Xh(e);return fr.getManager(t.scheme).removeModel(t.path)}async function BR(e,t){return y1(e,t,!1)}async function zR(e,t){return y1(e,t,!0)}var WR=class{fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}};if(X().get("IS_BROWSER")){X().setPlatform("browser",new WR);try{fr.registerManager(Di.URL_SCHEME,new OR)}catch(e){}try{fr.registerManager(Fi.URL_SCHEME,new _R)}catch(e){}}var VR={importFetch:()=>QF()},Iy,UR=class{constructor(){this.util=ZF(),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return X().global.fetch!=null?X().global.fetch(e,t):(Iy==null&&(Iy=VR.importFetch()),Iy(e,t))}now(){let e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return e.length===0?"":new this.util.TextDecoder(t).decode(e)}};X().get("IS_NODE")&&X().setPlatform("node",new UR);function $e(e,t="float32",n){return t=t||"float32",Qb(e),new Kt(e,t,n)}function GR(e,t){let n=$(e,"x","cast");if(!MI(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if(t==="string"&&n.dtype!=="string"||t!=="string"&&n.dtype==="string")throw new Error("Only strings can be casted to strings");let r={x:n},s={dtype:t};return z.runKernel(fa,r,s)}var ue=W({cast_:GR});function HR(e){let n={x:$(e,"x","clone","string_or_numeric")};return z.runKernel(_a,n)}var Fs=W({clone_:HR});function v1(e,t=!1){console.log(e.toString(t))}r1();var jR={buffer:$e,cast:ue,clone:Fs,print:v1};nR(jR);var tn={};Ee(tn,{browserFiles:()=>JR,browserHTTPRequest:()=>s3,concatenateArrayBuffers:()=>yy,copyModel:()=>BR,decodeWeights:()=>u1,encodeWeights:()=>fR,fromMemory:()=>o3,getLoadHandlers:()=>CR,getModelArtifactsForJSON:()=>vy,getModelArtifactsInfoForJSON:()=>vd,getSaveHandlers:()=>SR,http:()=>Ny,isHTTPScheme:()=>Ty,listModels:()=>MR,loadWeights:()=>e3,moveModel:()=>zR,registerLoadRouter:()=>IR,registerSaveRouter:()=>kR,removeModel:()=>LR,weightsLoaderFactory:()=>I1,withSaveHandler:()=>i3});var qR="model",KR=".json",XR=".weights.bin";function x1(e){return new Promise(t=>setTimeout(t)).then(e)}var Sy=class{constructor(e){if(!X().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(Sy.URL_SCHEME)&&(e=e.slice(Sy.URL_SCHEME.length)),(e==null||e.length===0)&&(e=qR),this.modelJsonFileName=e+KR,this.weightDataFileName=e+XR}async save(e){if(typeof document=="undefined")throw new Error("Browser downloads are not supported in this environment since `document` is not present");let t=window.URL.createObjectURL(new Blob([e.weightData],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{let n=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],r=d1(e,n),s=window.URL.createObjectURL(new Blob([JSON.stringify(r)],{type:"application/json"})),a=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(a.download=this.modelJsonFileName,a.href=s,await x1(()=>a.dispatchEvent(new MouseEvent("click"))),e.weightData!=null){let o=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;o.download=this.weightDataFileName,o.href=t,await x1(()=>o.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:vd(e)}}}},Yh=Sy;Yh.URL_SCHEME="downloads://";var YR=class{constructor(e){if(e==null||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,t)=>{let n=new FileReader;n.onload=r=>{let s=JSON.parse(r.target.result),a=s.modelTopology;if(a==null){t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(s.weightsManifest==null){t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){e({modelTopology:a});return}let i=vy(s,u=>this.loadWeights(u));e(i)},n.onerror=r=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),n.readAsText(this.jsonFile)})}loadWeights(e){let t=[],n=[];for(let a of e)t.push(...a.weights),n.push(...a.paths);let r=this.checkManifestAndWeightFiles(e),s=n.map(a=>this.loadWeightsFile(a,r[a]));return Promise.all(s).then(a=>[t,yy(a)])}loadWeightsFile(e,t){return new Promise((n,r)=>{let s=new FileReader;s.onload=a=>{let o=a.target.result;n(o)},s.onerror=a=>r(`Failed to weights data from file of path '${e}'.`),s.readAsArrayBuffer(t)})}checkManifestAndWeightFiles(e){let t=[],n=this.weightsFiles.map(s=>l1(s.name)),r={};for(let s of e)s.paths.forEach(a=>{let o=l1(a);if(t.indexOf(o)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${o}'`);if(t.push(o),n.indexOf(o)===-1)throw new Error(`Weight file with basename '${o}' is not provided.`);r[a]=this.weightsFiles[n.indexOf(o)]});if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return r}},QR=e=>X().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Yh.URL_SCHEME)?ZR(e.slice(Yh.URL_SCHEME.length)):null;Pt.registerSaveRouter(QR);function ZR(e="model"){return new Yh(e)}function JR(e){return new YR(e)}function w1(e,t,n,r){o(e),n=n==null?0:n,r=r==null?1:r,i(n,r);let s=0,a=u=>(u.then(l=>{let c=n+ ++s/e.length*(r-n);return t(c),l}),u);function o(u){P(u!=null&&Array.isArray(u)&&u.length>0,()=>"promises must be a none empty array")}function i(u,l){P(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${u}`),P(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${l}`),P(l>=u,()=>`startFraction must be no more than endFraction, but got startFraction ${u} and endFraction ${l}`)}return Promise.all(e.map(a))}async function k1(e,t){t==null&&(t={});let n=t.fetchFunc==null?X().platform.fetch:t.fetchFunc,r=e.map(d=>n(d,t.requestInit,{isBinary:!0})),s=0,a=.5,i=(t.onProgress==null?await Promise.all(r):await w1(r,t.onProgress,s,a)).map(d=>d.arrayBuffer()),u=.5,l=1;return t.onProgress==null?await Promise.all(i):await w1(i,t.onProgress,u,l)}async function e3(e,t="",n,r){return I1(o=>k1(o,{requestInit:r}))(e,t,n)}function I1(e){return async(t,n="",r)=>{let s=t.map(()=>!1),a={},o=r!=null?r.map(()=>!1):[],i=[];if(t.forEach((h,f)=>{let m=0;h.weights.forEach(g=>{let b="quantization"in g?g.quantization.dtype:g.dtype,y=gy[b]*wt(g.shape),v=()=>{s[f]=!0,a[f]==null&&(a[f]=[]),a[f].push({manifestEntry:g,groupOffset:m,sizeBytes:y})};r!=null?r.forEach((x,k)=>{x===g.name&&(v(),o[k]=!0)}):v(),i.push(g.name),m+=y})}),!o.every(h=>h)){let h=r.filter((f,m)=>!o[m]);throw new Error(`Could not find weights in manifest with names: ${h.join(", ")}. 
Manifest JSON has weights with names: ${i.join(", ")}.`)}let u=s.reduce((h,f,m)=>(f&&h.push(m),h),[]),l=[];u.forEach(h=>{t[h].paths.forEach(f=>{let m=n+(n.endsWith("/")?"":"/")+f;l.push(m)})});let c=await e(l),d={},p=0;return u.forEach(h=>{let f=t[h].paths.length,m=0;for(let x=0;x<f;x++)m+=c[p+x].byteLength;let g=new ArrayBuffer(m),b=new Uint8Array(g),y=0;for(let x=0;x<f;x++){let k=new Uint8Array(c[p+x]);b.set(k,y),y+=k.byteLength}a[h].forEach(x=>{let k=g.slice(x.groupOffset,x.groupOffset+x.sizeBytes),T=u1(k,[x.manifestEntry]);for(let C in T)d[C]=T[C]}),p+=f}),d}}var t3="application/octet-stream",n3="application/json",Cy=class{constructor(e,t){if(this.DEFAULT_METHOD="POST",t==null&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.onProgress=t.onProgress,this.weightUrlConverter=t.weightUrlConverter,t.fetchFunc!=null?(P(typeof t.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=X().platform.fetch,P(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&P(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,t.requestInit!=null&&t.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{}}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");let t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;let n=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],r=d1(e,n);t.body.append("model.json",new Blob([JSON.stringify(r)],{type:n3}),"model.json"),e.weightData!=null&&t.body.append("model.weights.bin",new Blob([e.weightData],{type:t3}),"model.weights.bin");let s=await this.fetch(this.path,t);if(s.ok)return{modelArtifactsInfo:vd(e),responses:[s]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${s.status}.`)}async load(){let e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch(s){let a=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?a+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":a+=" Please make sure the server is serving valid JSON for this request.",new Error(a)}let n=t.modelTopology,r=t.weightsManifest;if(n==null&&r==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return vy(t,s=>this.loadWeights(s))}async loadWeights(e){let t=Array.isArray(this.path)?this.path[1]:this.path,[n,r]=r3(t),s=this.weightPathPrefix||n,a=[];for(let l of e)a.push(...l.weights);let o=[],i=[];for(let l of e)for(let c of l.paths)this.weightUrlConverter!=null?i.push(this.weightUrlConverter(c)):o.push(s+c+r);this.weightUrlConverter&&o.push(...await Promise.all(i));let u=await k1(o,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress});return[a,yy(u)]}};Cy.URL_SCHEME_REGEX=/^https?:\/\//;function r3(e){let t=e.lastIndexOf("/"),n=e.lastIndexOf("?"),r=e.substring(0,t),s=n>t?e.substring(n):"";return[r+"/",s]}function Ty(e){return e.match(Cy.URL_SCHEME_REGEX)!=null}var S1=(e,t)=>{if(typeof fetch=="undefined"&&(t==null||t.fetchFunc==null))return null;{let n=!0;if(Array.isArray(e)?n=e.every(r=>Ty(r)):n=Ty(e),n)return Ny(e,t)}return null};Pt.registerSaveRouter(S1);Pt.registerLoadRouter(S1);function Ny(e,t){return new Cy(e,t)}function s3(e,t){return Ny(e,t)}var _y=class{constructor(e){this.modelArtifacts=e}async load(){return this.modelArtifacts}},a3=class{constructor(e){this.saveHandler=e}async save(e){return this.saveHandler(e)}};function o3(e,t,n,r){return arguments.length===1?e.modelTopology!=null||e.weightSpecs!=null?new _y(e):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new _y({modelTopology:e})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new _y({modelTopology:e,weightSpecs:t,weightData:n,trainingConfig:r}))}function i3(e){return new a3(e)}var C1={};Ee(C1,{confusionMatrix:()=>p3});function u3(e,t,n=!1,r=!1){let s=$(e,"a","matMul"),a=$(t,"b","matMul");[s,a]=At(s,a);let o={a:s,b:a},i={transposeA:n,transposeB:r};return z.runKernel(ha,o,i)}var Re=W({matMul_:u3});function c3(e,t,n=1,r=0){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);let a={indices:$(e,"indices","oneHot","int32")},o={depth:t,onValue:n,offValue:r};return z.runKernel(li,a,o)}var xd=W({oneHot_:c3});function l3(e,t){let n=$(e,"x","transpose");if(t==null&&(t=n.shape.map((a,o)=>o).reverse()),P(n.rank===t.length,()=>`Error in transpose: rank of input ${n.rank} must match length of perm ${t}.`),t.forEach(a=>{P(a>=0&&a<n.rank,()=>`All entries in 'perm' must be between 0 and ${n.rank-1} but got ${t}`)}),n.rank<=1)return n.clone();let r={x:n},s={perm:t};return z.runKernel(Ja,r,s)}var Oe=W({transpose_:l3});function d3(e,t,n){let r=$(e,"labels","confusionMatrix"),s=$(t,"predictions","confusionMatrix");P(n==null||n>0&&Number.isInteger(n),()=>`If provided, numClasses must be a positive integer, but got ${n}`),P(r.rank===1,()=>`Expected the rank of labels to be 1, but got ${r.rank}`),P(s.rank===1,()=>`Expected the rank of predictions to be 1, but got ${s.rank}`),P(r.shape[0]===s.shape[0],()=>`Mismatch in the number of examples: ${r.shape[0]} vs. ${s.shape[0]}. Labels and predictions should have the same number of elements.`),P(n>0&&Number.isInteger(n),()=>`numClasses is required to be a positive integer, but got ${n}`);let a=xd(ue(r,"int32"),n),o=xd(ue(s,"int32"),n),i=Oe(a),u=Re(i,o);return ue(u,"int32")}var p3=W({confusionMatrix_:d3}),Ri={};Ee(Ri,{assertAndGetBroadcastShape:()=>ht,getBroadcastDims:()=>T1,getReductionAxes:()=>zt});function T1(e,t){let n=e.length,r=[];for(let s=0;s<n;s++){let a=n-1-s,o=e[a]||1;(t[t.length-1-s]||1)>1&&o===1&&r.unshift(a)}return r}function zt(e,t){let n=[];for(let r=0;r<t.length;r++){let s=e[e.length-r-1],a=t.length-r-1,o=t[a];(s==null||s===1&&o>1)&&n.unshift(a)}return n}function ht(e,t){let n=[],r=Math.max(e.length,t.length);for(let s=0;s<r;s++){let a=e[e.length-s-1];a==null&&(a=1);let o=t[t.length-s-1];if(o==null&&(o=1),a===1)n.unshift(o);else if(o===1)n.unshift(a);else if(a!==o){let i=`Operands could not be broadcast together with shapes ${e} and ${t}.`;throw Error(i)}else n.unshift(a)}return n}var Pi={};Ee(Pi,{fromPixels:()=>v3,fromPixelsAsync:()=>b3,toPixels:()=>y3});function Qh(e,t,n){if(zo(e),t!=null&&t.length!==3)throw new Error("tensor3d() requires shape to have three numbers");let r=os(e,n);if(r.length!==3&&r.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return uo(e,t,r,n)}var Oi;function N1(e,t=3){if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(e==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,r=!1,s=!1,a=!1,o=!1,i=!1;if(e.data instanceof Uint8Array)n=!0;else if(typeof ImageData!="undefined"&&e instanceof ImageData)r=!0;else if(typeof HTMLVideoElement!="undefined"&&e instanceof HTMLVideoElement)s=!0;else if(typeof HTMLImageElement!="undefined"&&e instanceof HTMLImageElement)a=!0;else if(e.getContext!=null)o=!0;else if(typeof ImageBitmap!="undefined"&&e instanceof ImageBitmap)i=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${e.constructor.name}`);if(s){let f=2;if(s&&e.readyState<f)throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.")}if(Vh(cd,z.backendName)!=null){let f={pixels:e},m={numChannels:t};return z.runKernel(cd,f,m)}let[l,c]=s?[e.videoWidth,e.videoHeight]:[e.width,e.height],d;if(o)d=e.getContext("2d").getImageData(0,0,l,c).data;else if(r||n)d=e.data;else if(a||s||i){if(Oi==null)if(typeof document=="undefined")if(typeof OffscreenCanvas!="undefined"&&typeof OffscreenCanvasRenderingContext2D!="undefined")Oi=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else Oi=document.createElement("canvas").getContext("2d");Oi.canvas.width=l,Oi.canvas.height=c,Oi.drawImage(e,0,0,l,c),d=Oi.getImageData(0,0,l,c).data}let p;if(t===4)p=new Int32Array(d);else{let f=l*c;p=new Int32Array(f*t);for(let m=0;m<f;m++)for(let g=0;g<t;++g)p[m*t+g]=d[m*4+g]}return Qh(p,[c,l,t],"int32")}function h3(e){return e!=null&&e.data instanceof Uint8Array}function f3(){return typeof window!="undefined"&&typeof ImageBitmap!="undefined"&&window.hasOwnProperty("createImageBitmap")}function m3(e){return e!=null&&e.width!==0&&e.height!==0}function g3(e){return f3()&&!(e instanceof ImageBitmap)&&m3(e)&&!h3(e)}async function b3(e,t=3){let n=null;if(X().getBool("WRAP_TO_IMAGEBITMAP")&&g3(e)){let r;try{r=await createImageBitmap(e,{premultiplyAlpha:"none"})}catch(s){r=null}r!=null&&r.width===e.width&&r.height===e.height?n=r:n=e}else n=e;return N1(n,t)}async function y3(e,t){let n=$(e,"img","toPixels");if(!(e instanceof Ae)){let l=n;n=ue(l,"int32"),l.dispose()}if(n.rank!==2&&n.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${n.rank}.`);let[r,s]=n.shape.slice(0,2),a=n.rank===2?1:n.shape[2];if(a>4||a===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${a}`);if(n.dtype!=="float32"&&n.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${n.dtype}. Please use float32 or int32 tensors.`);let o=await n.data(),i=n.dtype==="float32"?255:1,u=new Uint8ClampedArray(s*r*4);for(let l=0;l<r*s;++l){let c=[0,0,0,255];for(let p=0;p<a;p++){let h=o[l*a+p];if(n.dtype==="float32"){if(h<0||h>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${h}.`)}else if(n.dtype==="int32"&&(h<0||h>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${h}.`);a===1?(c[0]=h*i,c[1]=h*i,c[2]=h*i):c[p]=h*i}let d=l*4;u[d+0]=Math.round(c[0]),u[d+1]=Math.round(c[1]),u[d+2]=Math.round(c[2]),u[d+3]=Math.round(c[3])}if(t!=null){t.width=s,t.height=r;let l=t.getContext("2d"),c=new ImageData(u,s,r);l.putImageData(c,0,0)}return n!==e&&n.dispose(),u}var v3=W({fromPixels_:N1}),Ey={};Ee(Ey,{prepareAndValidate:()=>_1});function _1(e,t){let n=e.shape.length,r=t.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if(t.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[r-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[r-1]} vs. ${n}`);if(wt(e.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);let s=t.shape,a=s[s.length-1],o=1;for(let d=0;d<s.length-1;++d)o*=s[d];let i=e.shape,u=s.slice();u.pop();let l=1;for(let d=a;d<n;++d)l*=i[d],u.push(i[d]);let c=[...Bu(e.shape).map(d=>d/l),1].slice(0,a);return[u,o,l,c]}var Ay={};Ee(Ay,{calculateShapes:()=>E1,validateInput:()=>Fy,validateUpdateShape:()=>$y});function $y(e,t,n){let r=t.rank>1?t.shape[t.rank-1]:1,s=t.rank>1?t.rank-1:1,a=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${r}, and batchDim: ${s}.`;if(n.rank<s)throw new Error(a+` update.rank < ${s}. `);if(e.length<r+(n.rank-s))throw new Error(a+` Output shape length < ${r+(n.rank-s)}`);if(n.rank!==s+e.length-r)throw new Error(a+` update.rank != ${s+e.length-r}`);for(let o=0;o<s;++o)if(n.shape[o]!==t.shape[o])throw new Error(a+` updates.shape[${o}] (${n.shape[o]}) != indices.shape[${o}] (${t.shape[o]}).`);for(let o=0;o<n.rank-s;++o)if(n.shape[o+s]!==e[o+r])throw new Error(a+` updates.shape[${o+s}] (${n.shape[o+s]}) != shape[${o+s}] (${e[o+s]})`)}function Fy(e,t,n){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if(t.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(n.length===0){if(t.size===0)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(e.size===0)throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`)}$y(n,t,e)}function E1(e,t,n){let r=t.shape.length,s=r>1?t.shape[r-1]:1,a=n.length,o=1;for(let d=s;d<a;++d)o*=n[d];let i=s<1?1:s,u=wt(t.shape)/i,l=[...Bu(n.slice(0,s)),1],c=wt(n);return{sliceRank:s,numUpdates:u,sliceSize:o,strides:l,outputSize:c}}var $t={};Ee($t,{assertParamsValid:()=>w3,computeFlatOffset:()=>T3,computeOutShape:()=>I3,getNormalizedAxes:()=>S3,isSliceContinous:()=>C3,maskToAxes:()=>k3,parseSliceParams:()=>L1,sliceInfo:()=>N3,startForAxis:()=>O1,startIndicesWithElidedDims:()=>D1,stopForAxis:()=>M1,stopIndicesWithElidedDims:()=>R1,stridesForAxis:()=>P1,stridesWithElidedDims:()=>A1});var Dy=-2,x3=-1;function w3(e,t,n){let r=e.shape.length;P(r===t.length,()=>`Error in slice${r}D: Length of begin ${t} must match the rank of the array (${r}).`),P(r===n.length,()=>`Error in slice${r}D: Length of size ${n} must match the rank of the array (${r}).`);for(let s=0;s<r;++s)P(t[s]+n[s]<=e.shape[s],()=>`Error in slice${r}D: begin[${s}] + size[${s}] (${t[s]+n[s]}) would overflow input.shape[${s}] (${e.shape[s]})`)}function k3(e){let t=[],n=0;for(;e>0;)e&1&&t.push(n),e/=2,n++;return t}function I3(e,t,n){let r=[];for(let s=0;s<e.length;s++)r[s]=Math.ceil((t[s]-e[s])/n[s]);return r}function A1(e,t,n,r){let s=[...e];for(let a=s.length;a<r.length;a++)s.push(1);for(let a=0;a<n;a++)a===0?s[t]=1:(s.splice(t,0,1),s.pop());return s}function $1(e,t,n){return n<=e?n:n-(t-1)}function F1(e,t){let n=[];for(let r=0;r<e;r++)n.push(t+r);return n}function S3(e,t,n,r,s,a,o,i,u){let l=e.length,c=new Array(l),d=new Array(l),p=new Array(l);if(t.length&&n>0){let h=t[0],f=n+1;c=D1(o,h,f,r,e),d=R1(i,h,f,s,e),p=A1(a,h,f,e)}else for(let h=0;h<l;h++)c[h]=O1(o,r,a,e,h,u),d[h]=M1(i,s,a,e,h,u),p[h]=P1(a,h,u);return{begin:c,end:d,strides:p}}function D1(e,t,n,r,s){let a=[...s],o=F1(n,t);for(let i=0;i<a.length;i++)if(o.indexOf(i)>-1)a[i]=0;else{let u=$1(t,n,i),l=r[u];e&1<<u&&(l=0),a[i]=l}return a}function R1(e,t,n,r,s){let a=[...s],o=F1(n,t);for(let i=0;i<a.length;i++)if(o.indexOf(i)>-1)a[i]=Number.MAX_SAFE_INTEGER;else{let u=$1(t,n,i),l=r[u];e&1<<u&&(l=Number.MAX_SAFE_INTEGER),a[i]=l}for(let i=0;i<a.length;i++){let u=s[i];a[i]<0&&(a[i]+=u),a[i]=Gl(0,a[i],s[i])}return a}function P1(e,t,n){let r=e[t];return(n&1<<t||r==null)&&(r=1),r}function O1(e,t,n,r,s,a){let o=t[s],i=n[s]||1;(e&1<<s||a&1<<s||o==null)&&(i>0?o=Number.MIN_SAFE_INTEGER:o=Number.MAX_SAFE_INTEGER);let u=r[s];return o<0&&(o+=u),o=Gl(0,o,u-1),o}function M1(e,t,n,r,s,a){let o=t[s],i=n[s]||1;(e&1<<s||a&1<<s||o==null)&&(i>0?o=Number.MAX_SAFE_INTEGER:o=Number.MIN_SAFE_INTEGER);let u=r[s];return o<0&&(o+=u),i>0?o=Gl(0,o,u):o=Gl(-1,o,u-1),o}function C3(e,t,n){let r=n.length;for(let s=0;s<n.length;s++)if(n[s]>1){r=s;break}for(let s=r+1;s<n.length;s++)if(t[s]>0||n[s]!==e[s])return!1;return!0}function T3(e,t){let n=e.length>0?e[e.length-1]:1;for(let r=0;r<e.length-1;r++)n+=e[r]*t[r];return n}function L1(e,t,n){let r,s=e.shape.length;typeof t=="number"?r=[t,...new Array(s-1).fill(0)]:t.length<s?r=t.concat(new Array(s-t.length).fill(0)):r=t.slice(),r.forEach(o=>{P(o!==-1,()=>"slice() does not support negative begin indexing.")});let a;return n==null?a=new Array(s).fill(-1):typeof n=="number"?a=[n,...new Array(s-1).fill(-1)]:n.length<s?a=n.concat(new Array(s-n.length).fill(-1)):a=n,a=a.map((o,i)=>o>=0?o:(P(o===-1,()=>`Negative size values should be exactly -1 but got ${o} for the slice() size at index ${i}.`),e.shape[i]-r[i])),[r,a]}function N3(e,t,n,r,s,a,o,i,u){let l;if(r==null?(l=new Array(t.length),l.fill(1)):l=r,o!=null&&(o&o-1)!=0)throw new Error("Multiple ellipses in slice is not allowed.");let c=!1,d={dims:l.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:n.slice(),strides:l.slice(),beginMask:s,endMask:a,ellipsisMask:o,newAxisMask:i,shrinkAxisMask:u};for(let v=0;v<d.dims;v++)c&&(1<<v&i)!=0&&d.numAddAxisAfterEllipsis++,1<<v&o&&(c=!0);c||(d.ellipsisMask|=1<<d.dims,d.dims++);let p={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};_3(d,p);let h=!0,f=!0,m=!0,g=[],b=[];for(let v=0;v<e.length;++v){if(p.strides[v]===0)throw Error(`strides[${v}] must be non-zero`);let x=!!(p.shrinkAxisMask&1<<v),k=e[v];if(k===-1){g.push(x?1:-1);continue}let T=[p.beginMask&1<<v,p.endMask&1<<v],C=[p.strides[v]>0?0:-1,p.strides[v]>0?k:k-1];if(x&&p.strides[v]<=0)throw Error("only stride 1 allowed on non-range indexing.");m=m&&p.strides[v]===1;let E=!!(p.beginMask&1<<v&&p.endMask&1<<v);if(p.beginValid&&p.endValid){if(x){let R=p.begin[v]<0?k+p.begin[v]:p.begin[v];if(p.begin[v]=R,p.end[v]=p.begin[v]+1,R<0||R>=k)throw Error(`slice index ${p.begin[v]} of dimension ${v} out of bounds.`)}else p.begin[v]=B1(p.begin[v],0,p.strides[v],k,T,C),p.end[v]=B1(p.end[v],1,p.strides[v],k,T,C);let D=p.strides[v]===1&&p.begin[v]===0&&p.end[v]===k;h=h&&D,f=f&&(v===0&&p.strides[v]===1||D)}else h=h&&p.strides[v]===1&&E,f=f&&(v===0&&p.strides[v]===1||E);let F,O=!1;if(p.beginValid&&p.endValid?(F=p.end[v]-p.begin[v],O=!0):x?(F=1,O=!0):E&&k>=0&&(p.strides[v]<0?F=-k:F=k,O=!0),O){let D;F===0||F<0!=p.strides[v]<0?D=0:D=Math.trunc(F/p.strides[v])+(F%p.strides[v]!=0?1:0),g.push(D)}else g.push(-1)}for(let v=0;v<p.finalShapeGatherIndices.length;++v){let x=p.finalShapeGatherIndices[v];x>=0?b.push(g[x]):x===Dy&&b.push(1)}return{finalShapeSparse:b.filter((v,x)=>p.finalShapeGatherIndices[x]!==Dy),finalShape:b,isIdentity:h,sliceDim0:f,isSimpleSlice:m,begin:p.begin,end:p.end,strides:p.strides}}function _3(e,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let n=0;t.beginValid=e.begin!=null,t.endValid=e.end!=null,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let r=0;r<e.dims;r++)if(1<<r&e.ellipsisMask){let s=Math.min(t.dims-(e.dims-r)+1+e.numAddAxisAfterEllipsis,t.dims);for(;n<s;n++)t.begin[n]=0,t.end[n]=0,t.strides[n]=1,t.beginMask|=1<<n,t.endMask|=1<<n,t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[n]=r}else if(1<<r&e.newAxisMask)t.finalShapeGatherIndices.push(Dy),t.finalShapeGatherIndicesSparse.push(-1);else{if(n===t.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${t.dims} dims, ${t.begin.length}.`);e.begin!=null&&(t.begin[n]=e.begin[r]),e.end!=null&&(t.end[n]=e.end[r]),t.strides[n]=e.strides[r],e.beginMask&1<<r&&(t.beginMask|=1<<n),e.endMask&1<<r&&(t.endMask|=1<<n),e.shrinkAxisMask&1<<r?(t.finalShapeGatherIndices.push(x3),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<n):(t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(r)),t.inputShapeGatherIndicesSparse[n]=r,n++}}function B1(e,t,n,r,s,a){if(s[t])return n>0?a[t]:a[t+1&1];{let o=e<0?r+e:e;return o<a[0]?a[0]:o>a[1]?a[1]:o}}var oe={};Ee(oe,{Serializable:()=>z1,SerializationMap:()=>Mi,registerClass:()=>lo});var z1=class{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}},Mi=class{constructor(){this.classNameMap={}}static getMap(){return Mi.instance==null&&(Mi.instance=new Mi),Mi.instance}static register(e){Mi.getMap().classNameMap[e.className]=[e,e.fromConfig]}};function lo(e){P(e.className!=null,()=>"Class being registered does not have the static className property defined."),P(typeof e.className=="string",()=>"className is required to be a string, but got type "+typeof e.className),P(e.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),Mi.register(e)}var W1={};Ee(W1,{TEST_EPSILON_FLOAT16:()=>V1,encodeStrings:()=>U1,expectArrayBuffersEqual:()=>P3,expectArraysClose:()=>A3,expectArraysEqual:()=>F3,expectNumbersClose:()=>D3,expectPromiseToFail:()=>$3,expectValuesInRange:()=>R3,testEpsilon:()=>Ry});var E3=.001,V1=.1;function A3(e,t,n){return n==null&&(n=Ry()),Py(e,t,(r,s)=>Oy(r,s,n))}function Ry(){return z.backend.floatPrecision()===32?E3:V1}function Py(e,t,n){let r=!0;if((yn(e)||yn(t))&&(r=!1),yn(e)&&yn(t)&&(r=!0),r){let o=e.constructor.name,i=t.constructor.name;if(o!==i)throw new Error(`Arrays are of different type. Actual: ${o}. Expected: ${i}`)}if(Array.isArray(e)&&Array.isArray(t)){let o=os(e),i=os(t);if(!ia(o,i))throw new Error(`Arrays have different shapes. Actual: [${o}]. Expected: [${i}]`)}let s=yn(e)?e:Wo(e),a=yn(t)?t:Wo(t);if(s.length!==a.length)throw new Error(`Arrays have different lengths actual: ${s.length} vs expected: ${a.length}.
Actual:   ${s}.
Expected: ${a}.`);for(let o=0;o<a.length;++o){let i=s[o],u=a[o];if(!n(i,u))throw new Error(`Arrays differ: actual[${o}] = ${i}, expected[${o}] = ${u}.
Actual:   ${s}.
Expected: ${a}.`)}}function $3(e,t){e().then(()=>t.fail(),()=>t())}function F3(e,t){let n=typeof t=="string"||typeof t=="number"||typeof t=="boolean"?[t]:t;return ua(e)||ua(e[0])||ua(t)||ua(t[0])?Py(e,n,(r,s)=>r==s):Py(e,t,(r,s)=>Oy(r,s,0))}function D3(e,t,n){if(n==null&&(n=Ry()),!Oy(e,t,n))throw new Error(`Numbers differ: actual === ${e}, expected === ${t}`)}function Oy(e,t,n){return!isFinite(e)&&!isFinite(t)?!0:!(isNaN(e)||isNaN(t)||Math.abs(e-t)>n)}function R3(e,t,n){for(let r=0;r<e.length;r++)if(e[r]<t||e[r]>n)throw new Error(`Value out of range:${e[r]} low: ${t}, high: ${n}`)}function P3(e,t){expect(new Float32Array(e)).toEqual(new Float32Array(t))}function U1(e){for(let t=0;t<e.length;t++){let n=e[t];Array.isArray(n)?U1(n):e[t]=hd(n)}return e}var O3="0.0.0";function M3(){X().set("PROD",!0)}function L3(){X().set("DEBUG",!0)}function B3(){X().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function My(e){X().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(e+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}rR(My);function z3(){z.disposeVariables()}function is(){return z}function Zh(){return z.memory()}function W3(e){return z.profile(e)}function M(e,t){return z.tidy(e,t)}function Fe(e){dy(e).forEach(n=>n.dispose())}function nn(e){return z.keep(e)}function V3(e){return z.time(e)}function U3(e){return z.setBackend(e)}function G3(){return z.ready()}function H3(){return z.backendName}function j3(e){z.removeBackend(e)}function q3(e){return z.findBackend(e)}function K3(e){return z.findBackendFactory(e)}function wd(e,t,n=1){return z.registerBackend(e,t,n)}function G1(){return z.backend}function X3(e,t){X().setPlatform(e,t)}function Y3(e,t){let n=$(e,"a","add"),r=$(t,"b","add");[n,r]=At(n,r);let s={a:n,b:r};return z.runKernel(_s,s)}var Z=W({add_:Y3});function Q3(e,t){let n=$(e,"a","floorDiv"),r=$(t,"b","floorDiv");[n,r]=At(n,r);let s={a:n,b:r};return z.runKernel(Ca,s)}var Ly=W({floorDiv_:Q3});function Z3(e,t){let n=$(e,"a","div"),r=$(t,"b","div");if([n,r]=At(n,r),n.dtype==="int32"&&r.dtype==="int32")return Ly(n,r);let s={a:n,b:r},a={};return z.runKernel(wa,s,a)}var me=W({div_:Z3});function J3(e,t){let n=$(e,"a","mul"),r=$(t,"b","mul");[n,r]=At(n,r);let s={a:n,b:r};return z.runKernel(Ma,s)}var V=W({mul_:J3});function eP(e){let t=$(e,"x","abs");if(t.dtype==="complex64"){let n={x:t};return z.runKernel(Kl,n)}else{let n={x:t};return z.runKernel(Vo,n)}}var Xt=W({abs_:eP});function tP(e){let n={x:$(e,"x","acos")};return z.runKernel(Wu,n)}var H1=W({acos_:tP});function nP(e){let n={x:$(e,"x","acosh")};return z.runKernel(Vu,n)}var j1=W({acosh_:nP});function rP(e){P(Array.isArray(e),()=>"The argument passed to tf.addN() must be a list of tensors"),P(e.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${e.length}`);let t=e.map((s,a)=>$(s,`tensors${a}`,"addN")),n=t[0];t.forEach(s=>{if(s.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),t.forEach(s=>{if(!ia(s.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});let r=t;return z.runKernel(la,r)}var q1=W({addN_:rP});function sP(e,t=null,n=!1){let s={x:$(e,"x","all","bool")},a={axis:t,keepDims:n};return z.runKernel(Uu,s,a)}var By=W({all_:sP});function aP(e,t=null,n=!1){let s={x:$(e,"x","any","bool")},a={axis:t,keepDims:n};return z.runKernel(Gu,s,a)}var Jh=W({any_:aP});function oP(e,t=0){let r={x:$(e,"x","argMax")},s={axis:t};return z.runKernel(da,r,s)}var xc=W({argMax_:oP});function iP(e,t=0){let r={x:$(e,"x","argMin")},s={axis:t};return z.runKernel(Hu,r,s)}var K1=W({argMin_:iP});function uP(e){let n={x:$(e,"x","asin")};return z.runKernel(ju,n)}var X1=W({asin_:uP});function cP(e){let n={x:$(e,"x","asinh")};return z.runKernel(qu,n)}var Y1=W({asinh_:cP});function lP(e){let n={x:$(e,"x","atan")};return z.runKernel(Ku,n)}var Q1=W({atan_:lP});function dP(e,t){let n=$(e,"a","atan2"),r=$(t,"b","atan2");[n,r]=At(n,r);let s={a:n,b:r};return z.runKernel(Yu,s)}var Z1=W({atan2_:dP});function pP(e){let n={x:$(e,"x","atanh")};return z.runKernel(Xu,n)}var J1=W({atanh_:pP});function hP(e,t,n,r,s="NHWC",a){let o=e[3],i=[...t,o],u=nS(s);return kd(e,i,n,a,r,null,null,u)}function eS(e,t,n,r,s,a,o="channelsLast"){let[i,u]=ef(t),l;if(o==="channelsLast")l=[i,u,e[3],e[3]];else if(o==="channelsFirst")l=[i,u,e[1],e[1]];else throw new Error(`Unknown dataFormat ${o}`);return kd(e,l,n,r,s,a,!1,o)}function fP(e,t,n,r,s,a,o="NDHWC"){let[i,u,l]=Wy(t),c,d;if(o==="NDHWC")d="channelsLast",c=[i,u,l,e[4],e[4]];else if(o==="NCDHW")d="channelsFirst",c=[i,u,l,e[1],e[1]];else throw new Error(`Unknown dataFormat ${o}`);return tS(e,c,n,r,s,!1,d,a)}function kd(e,t,n,r,s,a,o=!1,i="channelsLast"){let[u,l,c,d]=[-1,-1,-1,-1];if(i==="channelsLast")[u,l,c,d]=e;else if(i==="channelsFirst")[u,d,l,c]=e;else throw new Error(`Unknown dataFormat ${i}`);let[p,h,,f]=t,[m,g]=ef(n),[b,y]=ef(r),v=wc(p,b),x=wc(h,y),{padInfo:k,outHeight:T,outWidth:C}=bP(s,l,c,m,g,v,x,a,i),E=o?f*d:f,F;return i==="channelsFirst"?F=[u,E,T,C]:i==="channelsLast"&&(F=[u,T,C,E]),{batchSize:u,dataFormat:i,inHeight:l,inWidth:c,inChannels:d,outHeight:T,outWidth:C,outChannels:E,padInfo:k,strideHeight:m,strideWidth:g,filterHeight:p,filterWidth:h,effectiveFilterHeight:v,effectiveFilterWidth:x,dilationHeight:b,dilationWidth:y,inShape:e,outShape:F,filterShape:t}}function tS(e,t,n,r,s,a=!1,o="channelsLast",i){let[u,l,c,d,p]=[-1,-1,-1,-1,-1];if(o==="channelsLast")[u,l,c,d,p]=e;else if(o==="channelsFirst")[u,p,l,c,d]=e;else throw new Error(`Unknown dataFormat ${o}`);let[h,f,m,,g]=t,[b,y,v]=Wy(n),[x,k,T]=Wy(r),C=wc(h,x),E=wc(f,k),F=wc(m,T),{padInfo:O,outDepth:D,outHeight:R,outWidth:_}=yP(s,l,c,d,b,y,v,C,E,F,i),L=a?g*p:g,U;return o==="channelsFirst"?U=[u,L,D,R,_]:o==="channelsLast"&&(U=[u,D,R,_,L]),{batchSize:u,dataFormat:o,inDepth:l,inHeight:c,inWidth:d,inChannels:p,outDepth:D,outHeight:R,outWidth:_,outChannels:L,padInfo:O,strideDepth:b,strideHeight:y,strideWidth:v,filterDepth:h,filterHeight:f,filterWidth:m,effectiveFilterDepth:C,effectiveFilterHeight:E,effectiveFilterWidth:F,dilationDepth:x,dilationHeight:k,dilationWidth:T,inShape:e,outShape:U,filterShape:t}}function mP(e,t,n,r,s){r==null&&(r=zy(e,t,n));let a=e[0],o=e[1],i=Li((a-t+2*r)/n+1,s),u=Li((o-t+2*r)/n+1,s);return[i,u]}function gP(e,t,n,r,s,a){s==null&&(s=zy(e,t,r));let o=e[0],i=e[1],u=e[2],l=Li((o-t+2*s)/r+1,a),c=Li((i-t+2*s)/r+1,a),d=Li((u-t+2*s)/r+1,a);return[l,c,d,n]}function zy(e,t,n,r=1){let s=wc(t,r);return Math.floor((e[0]*(n-1)-n+s)/2)}function ef(e){return typeof e=="number"?[e,e,e]:e.length===2?[e[0],e[1],1]:e}function Wy(e){return typeof e=="number"?[e,e,e]:e}function wc(e,t){return t<=1?e:e+(e-1)*(t-1)}function bP(e,t,n,r,s,a,o,i,u){let l,c,d;if(typeof e=="number"){l={top:e,bottom:e,left:e,right:e,type:e===0?"VALID":"NUMBER"};let h=mP([t,n],a,r,e,i);c=h[0],d=h[1]}else if(e==="same"){c=Math.ceil(t/r),d=Math.ceil(n/s);let p=Math.max(0,(c-1)*r+a-t),h=Math.max(0,(d-1)*s+o-n),f=Math.floor(p/2),m=p-f,g=Math.floor(h/2),b=h-g;l={top:f,bottom:m,left:g,right:b,type:"SAME"}}else if(e==="valid")l={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((t-a+1)/r),d=Math.ceil((n-o+1)/s);else if(typeof e=="object"){let p=u==="channelsLast"?e[1][0]:e[2][0],h=u==="channelsLast"?e[1][1]:e[2][1],f=u==="channelsLast"?e[2][0]:e[3][0],m=u==="channelsLast"?e[2][1]:e[3][1];l={top:p,bottom:h,left:f,right:m,type:p===0&&h===0&&f===0&&m===0?"VALID":"EXPLICIT"},c=Li((t-a+p+h)/r+1,i),d=Li((n-o+f+m)/s+1,i)}else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:l,outHeight:c,outWidth:d}}function yP(e,t,n,r,s,a,o,i,u,l,c){let d,p,h,f;if(typeof e=="number"){d={top:e,bottom:e,left:e,right:e,front:e,back:e,type:e===0?"VALID":"NUMBER"};let g=gP([t,n,r,1],i,1,s,e,c);p=g[0],h=g[1],f=g[2]}else if(e==="same"){p=Math.ceil(t/s),h=Math.ceil(n/a),f=Math.ceil(r/o);let m=(p-1)*s+i-t,g=(h-1)*a+u-n,b=(f-1)*o+l-r,y=Math.floor(m/2),v=m-y,x=Math.floor(g/2),k=g-x,T=Math.floor(b/2),C=b-T;d={top:x,bottom:k,left:T,right:C,front:y,back:v,type:"SAME"}}else if(e==="valid")d={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},p=Math.ceil((t-i+1)/s),h=Math.ceil((n-u+1)/a),f=Math.ceil((r-l+1)/o);else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:d,outDepth:p,outHeight:h,outWidth:f}}function Li(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error(`Unknown roundingMode ${t}`)}}function po(e){let[t,n,r]=ef(e);return t===1&&n===1&&r===1}function us(e,t){return po(e)||po(t)}function nS(e){if(e==="NHWC")return"channelsLast";if(e==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${e}`)}function Sn(e,t,n){if(n!=null){if(typeof t=="string")throw Error(`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);if(typeof t=="number")P(Lu(t),()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);else if(typeof t=="object")t.forEach(r=>{r.forEach(s=>{P(Lu(s),()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${s}.`)})});else throw Error(`Error in ${e}: Unknown padding parameter: ${t}`)}}function vP(e,t){let r={x:$(e,"x","reshape","string_or_numeric")},s={shape:t};return z.runKernel(hi,r,s)}var G=W({reshape_:vP});function xP(e,t,n,r,s){let a=$(e,"x","avgPool","float32"),o=1;P(us(n,o),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`);let i=a,u=!1;a.rank===3&&(u=!0,i=G(a,[1,a.shape[0],a.shape[1],a.shape[2]])),P(i.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${i.rank}.`),Sn("avgPool",r,s);let l={x:i},c={filterSize:t,strides:n,pad:r,dimRoundingMode:s},d=z.runKernel(pa,l,c);return d=ue(d,a.dtype),u?G(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var Ar=W({avgPool_:xP});function wP(e,t,n,r,s,a="NDHWC"){let o=$(e,"x","avgPool3d","float32"),i=o,u=!1;o.rank===4&&(u=!0,i=G(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),P(i.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${i.rank}.`),P(a==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`),Sn("avgPool3d",r,s);let l={x:i},c={filterSize:t,strides:n,pad:r,dimRoundingMode:s,dataFormat:a},d=z.runKernel(jl,l,c);return d=ue(d,i.dtype),u?G(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}var Vy=W({avgPool3d_:wP});function kP(e,t=0){P(e.length>=1,()=>"Pass at least one tensor to concat");let n=yd(e,"tensors","concat","string_or_numeric");if(n[0].dtype==="complex64"&&n.forEach(a=>{if(a.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${a.dtype}. `)}),n.length===1)return Fs(n[0]);let r=n,s={axis:t};return z.runKernel(Go,r,s)}var ot=W({concat_:kP});function IP(e){let n={x:$(e,"x","sigmoid","float32")};return z.runKernel(ja,n)}var $r=W({sigmoid_:IP});function SP(e,t,n){let r=$(e,"x","slice","string_or_numeric");if(r.rank===0)throw new Error("Slicing scalar is not possible");let s={x:r},a={begin:t,size:n};return z.runKernel(yi,s,a)}var Ve=W({slice_:SP});function CP(e){let n={x:$(e,"x","tanh","float32")};return z.runKernel(Za,n)}var kc=W({tanh_:CP});function TP(e,t,n,r,s,a){let o=$(e,"forgetBias","basicLSTMCell"),i=$(t,"lstmKernel","basicLSTMCell"),u=$(n,"lstmBias","basicLSTMCell"),l=$(r,"data","basicLSTMCell"),c=$(s,"c","basicLSTMCell"),d=$(a,"h","basicLSTMCell"),p=ot([l,d],1),h=Re(p,i),f=Z(h,u),m=f.shape[0],g=f.shape[1]/4,b=[m,g],y=Ve(f,[0,0],b),v=Ve(f,[0,g],b),x=Ve(f,[0,g*2],b),k=Ve(f,[0,g*3],b),T=Z(V($r(y),kc(v)),V(c,$r(Z(o,x)))),C=V(kc(T),$r(k));return[T,C]}var NP=W({basicLSTMCell_:TP});function _P(e,t,n){let r=$(e,"x","batchToSpaceND"),s=t.reduce((i,u)=>i*u);P(r.rank>=1+t.length,()=>`input rank is ${r.rank} but should be > than blockShape.length ${t.length}`),P(n.length===t.length,()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${t.length}`),P(r.shape[0]%s==0,()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${s}`);let a={x:r},o={blockShape:t,crops:n};return z.runKernel(Uo,a,o)}var tf=W({batchToSpaceND_:_P});function EP(e){let t;return e.rank===0||e.rank===1?t=G(e,[1,1,1,e.size]):e.rank===2?t=G(e,[1,1,e.shape[0],e.shape[1]]):e.rank===3?t=G(e,[1,e.shape[0],e.shape[1],e.shape[2]]):t=e,t}function AP(e,t,n,r,s,a){a==null&&(a=.001);let o=$(e,"x","batchNorm"),i=$(t,"mean","batchNorm"),u=$(n,"variance","batchNorm"),l;s!=null&&(l=$(s,"scale","batchNorm"));let c;r!=null&&(c=$(r,"offset","batchNorm")),P(i.rank===u.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),P(c==null||i.rank===c.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),P(l==null||i.rank===l.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let p={x:EP(o),scale:l,offset:c,mean:i,variance:u},h={varianceEpsilon:a},f=z.runKernel(Ta,p,h);return G(f,o.shape)}var ho=W({batchNorm_:AP});function $P(e,t,n,r,s,a){let o=$(e,"x","batchNorm"),i=$(t,"mean","batchNorm"),u=$(n,"variance","batchNorm"),l;s!=null&&(l=$(s,"scale","batchNorm"));let c;return r!=null&&(c=$(r,"offset","batchNorm")),P(o.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${o.rank}.`),P(i.rank===2||i.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${i.rank}.`),P(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${u.rank}.`),l!=null&&P(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${l.rank}.`),c!=null&&P(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`),ho(o,i,u,c,l,a)}var rS=W({batchNorm2d_:$P});function FP(e,t,n,r,s,a){let o=$(e,"x","batchNorm"),i=$(t,"mean","batchNorm"),u=$(n,"variance","batchNorm"),l;s!=null&&(l=$(s,"scale","batchNorm"));let c;return r!=null&&(c=$(r,"offset","batchNorm")),P(o.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${o.rank}.`),P(i.rank===3||i.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${i.rank}.`),P(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${u.rank}.`),l!=null&&P(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${l.rank}.`),c!=null&&P(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`),ho(o,i,u,c,l,a)}var sS=W({batchNorm3d_:FP});function DP(e,t,n,r,s,a){let o=$(e,"x","batchNorm"),i=$(t,"mean","batchNorm"),u=$(n,"variance","batchNorm"),l;s!=null&&(l=$(s,"scale","batchNorm"));let c;return r!=null&&(c=$(r,"offset","batchNorm")),P(o.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${o.rank}.`),P(i.rank===4||i.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${i.rank}.`),P(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${u.rank}.`),l!=null&&P(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${l.rank}.`),c!=null&&P(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`),ho(o,i,u,c,l,a)}var aS=W({batchNorm4d_:DP});function RP(e,t,n){let r=$(e,"x","bincount"),s=$(t,"weights","bincount");P(r.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`),P(n>=0,()=>`size must be non-negative, but got ${n}.`),P(s.size===r.size||s.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${s.shape}.`);let a={x:r,weights:s},o={size:n};return z.runKernel(bh,a,o)}var Uy=W({bincount_:RP});function PP(e,t){let n=$(e,"s0","broadcastArgs","int32"),r=$(t,"s1","broadcastArgs","int32");if(n.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${n.rank}`);if(r.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);let s={s0:n,s1:r};return z.runKernel(yh,s)}var oS=W({broadcastArgs_:PP});function OP(e,t){let n=$(e,"broadcastTo","x"),r=n.shape;if(t.some(l=>!(l>0)||l%1!=0))throw new Error(`broadcastTo(): Invalid broadcast shape [${t}].`);if(t.length<n.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${n.rank}.`);if(t.length>n.rank){let l=n.shape.slice();for(;l.length<t.length;)l.unshift(1);n=G(n,l)}let s=n.shape,a=Array.from(t);for(let l=t.length-1;l>=0;l--)if(s[l]===t[l])a[l]=1;else if(n.shape[l]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${t}].`);if(a.map((l,c)=>l>1?c:-1).filter(l=>l>=0).length===0)return Fs(n);let i={x:n},u={reps:a};return z.runKernel(As,i,u)}var Id=W({broadcastTo_:OP});function MP(e){let n={x:$(e,"x","ceil","float32")};return z.runKernel(ma,n)}var iS=W({ceil_:MP});function LP(e,t,n){let r=$(e,"x","clipByValue");P(t<=n,()=>`Error in clip: min (${t}) must be less than or equal to max (${n}).`);let s={x:r},a={clipValueMin:t,clipValueMax:n};return z.runKernel(Es,s,a)}var dn=W({clipByValue_:LP});function BP(e){return ot(e,0)}var uS=W({concat1d_:BP});function zP(e,t){return ot(e,t)}var cS=W({concat2d_:zP});function WP(e,t){return ot(e,t)}var lS=W({concat3d_:WP});function VP(e,t){return ot(e,t)}var dS=W({concat4d_:VP});function UP(e,t,n,r,s="NHWC",a=[1,1],o){let i=$(e,"x","conv2d","float32"),u=$(t,"filter","conv2d","float32"),l=i,c=!1;i.rank===3&&(c=!0,l=G(i,[1,i.shape[0],i.shape[1],i.shape[2]])),P(l.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${l.rank}.`),P(u.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${u.rank}.`),Sn("conv2d",r,o);let d=s==="NHWC"?l.shape[3]:l.shape[1];P(d===u.shape[2],()=>`Error in conv2d: depth of input (${d}) must match input depth for filter ${u.shape[2]}.`),P(us(n,a),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`);let p={x:l,filter:u},h={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:o},f=z.runKernel(ga,p,h);return c?G(f,[f.shape[1],f.shape[2],f.shape[3]]):f}var Wt=W({conv2d_:UP});function GP(e,t,n,r,s="NWC",a=1,o){let i=$(e,"x","conv1d"),u=$(t,"filter","conv1d"),l=i,c=!1;i.rank===2&&(c=!0,l=G(i,[1,i.shape[0],i.shape[1]])),P(l.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${l.rank}.`),P(u.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${u.rank}.`),Sn("conv1d",r,o),P(l.shape[2]===u.shape[1],()=>`Error in conv1d: depth of input (${l.shape[2]}) must match input depth for filter ${u.shape[1]}.`),P(us(n,a),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${a}'`),P(s==="NWC",()=>`Error in conv1d: got dataFormat of ${s} but only NWC is currently supported.`);let d=G(u,[1,u.shape[0],u.shape[1],u.shape[2]]),p=G(l,[l.shape[0],1,l.shape[1],l.shape[2]]),g=Wt(p,d,[1,n],r,"NHWC",[1,a],o);return c?G(g,[g.shape[2],g.shape[3]]):G(g,[g.shape[0],g.shape[2],g.shape[3]])}var Gy=W({conv1d_:GP});function HP(e,t,n,r,s,a="NHWC",o){P(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let i=e,u=t,l=!1;t.rank===3&&(l=!0,u=G(t,[1,t.shape[0],t.shape[1],t.shape[2]]),i=[1,e[0],e[1],e[2]]),P(i.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${i.length}.`),P(u.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${u.rank}`),P(n.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`);let c=a==="NHWC"?i[3]:i[1],d=a==="NHWC"?u.shape[3]:u.shape[1];P(c===n.shape[2],()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${n.shape[2]}.`),P(d===n.shape[3],()=>`Error in conv2dDerInput: depth of output (${d}) must match output depth for filter ${n.shape[3]}.`),Sn("conv2dDerInput",s,o);let p={dy:u,filter:n},h={strides:r,pad:s,dataFormat:a,dimRoundingMode:o,inputShape:i},f=z.runKernel(ba,p,h);return l?G(f,[f.shape[1],f.shape[2],f.shape[3]]):f}var Hy=W({conv2DBackpropInput_:HP});function jP(e,t,n,r,s,a){let o=$(e,"x","conv2dTranspose"),i=$(t,"filter","conv2dTranspose");return Hy(n,o,i,r,s,"NHWC",a)}var jy=W({conv2dTranspose_:jP});function qP(e,t,n,r,s="NDHWC",a=[1,1,1]){let o=$(e,"x","conv3d"),i=$(t,"filter","conv3d"),u=o,l=!1;o.rank===4&&(l=!0,u=G(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),P(u.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${u.rank}.`),P(i.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${i.rank}.`),P(u.shape[4]===i.shape[3],()=>`Error in conv3d: depth of input (${u.shape[4]}) must match input depth for filter ${i.shape[3]}.`),P(us(n,a),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`),P(s==="NDHWC",()=>`Error in conv3d: got dataFormat of ${s} but only NDHWC is currently supported.`);let c={x:u,filter:i},d={strides:n,pad:r,dataFormat:s,dilations:a},p=z.runKernel(Xl,c,d);return l?G(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}var qy=W({conv3d_:qP});function KP(e,t,n,r,s){P(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let a=e,o=t,i=!1;t.rank===4&&(i=!0,o=G(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),a=[1,e[0],e[1],e[2],e[3]]);let u=a[4],l=o.shape[4];P(a.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${a.length}.`),P(o.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${o.rank}`),P(n.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`),P(u===n.shape[3],()=>`Error in conv3dDerInput: depth of input (${u}) must match input depth for filter ${n.shape[3]}.`),P(l===n.shape[4],()=>`Error in conv3dDerInput: depth of output (${l}) must match output depth for filter ${n.shape[4]}.`);let c={dy:o,filter:n},d={pad:s,strides:r,inputShape:a},p=z.runKernel(wh,c,d);return i?G(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}var pS=W({conv3DBackpropInput_:KP});function XP(e,t,n,r,s){let a=$(e,"x","conv3dTranspose"),o=$(t,"filter","conv3dTranspose");return pS(n,a,o,r,s)}var hS=W({conv3dTranspose_:XP});function YP(e){let n={x:$(e,"x","cos","float32")};return z.runKernel(ya,n)}var nf=W({cos_:YP});function QP(e){let n={x:$(e,"x","cosh","float32")};return z.runKernel(va,n)}var Ky=W({cosh_:QP});function ZP(e,t=0,n=!1,r=!1){let a={x:$(e,"x","cumsum")},o={axis:t,exclusive:n,reverse:r};return z.runKernel(Ho,a,o)}var Xy=W({cumsum_:ZP});function JP(e,t,n,r=!1){let s=$(e,"x","denseBincount"),a=$(t,"weights","denseBincount");P(s.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${s.dtype}`),P(s.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${s.rank}.`),P(n>=0,()=>`size must be non-negative, but got ${n}.`),P(a.size===s.size||a.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${s.shape}, weights shape: ${a.shape}.`);let o={x:s,weights:a},i={size:n,binaryOutput:r};return z.runKernel(kh,o,i)}var fS=W({denseBincount_:JP});function eO(e,t,n="NHWC"){let r=$(e,"x","depthToSpace","float32"),s=n==="NHWC"?r.shape[1]:r.shape[2],a=n==="NHWC"?r.shape[2]:r.shape[3],o=n==="NHWC"?r.shape[3]:r.shape[1];P(t>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`),P(s*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${s} and ${t}  for depthToSpace with input shape
    ${r.shape}`),P(a*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${a} and ${t} for depthToSpace with input shape
        ${r.shape}`),P(o%(t*t)==0,()=>`Dimension size must be evenly divisible by ${t*t} but is ${o} for depthToSpace with input shape ${r.shape}`);let i={x:r},u={blockSize:t,dataFormat:n};return z.runKernel(qo,i,u)}var mS=W({depthToSpace_:eO});function tO(e,t,n,r,s="NHWC",a=[1,1],o){let i=$(e,"x","depthwiseConv2d","float32"),u=$(t,"filter","depthwiseConv2d","float32"),l=i,c=!1;i.rank===3&&(c=!0,l=G(i,[1,i.shape[0],i.shape[1],i.shape[2]])),P(l.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${l.rank}.`),P(u.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${u.rank}.`),P(l.shape[3]===u.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`),Sn("depthwiseConv2d",r,o);let d={x:l,filter:u},p={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:o},h=z.runKernel(xa,d,p);return c?G(h,[h.shape[1],h.shape[2],h.shape[3]]):h}var Bi=W({depthwiseConv2d_:tO});function nO(e){let n={x:$(e,"x","diag")};return z.runKernel(Ch,n)}var rO=W({diag_:nO});function sO(e,t,n,r,s=[1,1],a="NHWC"){let o=$(e,"x","dilation2d"),i=$(t,"filter","dilation2d");P(o.rank===3||o.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${o.rank}.`),P(i.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${i.rank}.`),P(a==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${a}`);let u=o,l=!1;o.rank===3&&(u=G(o,[1,o.shape[0],o.shape[1],o.shape[2]]),l=!0);let c={x:u,filter:i},d={strides:n,pad:r,dilations:s},p=z.runKernel(Yl,c,d);return l?G(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var gS=W({dilation2d_:sO});function aO(e,t){let n=$(e,"a","equal","string_or_numeric"),r=$(t,"b","equal","string_or_numeric");[n,r]=At(n,r),ht(n.shape,r.shape);let s={a:n,b:r};return z.runKernel(Ko,s)}var mr=W({equal_:aO});function oO(e,t,n){let r=$(t,"a","where"),s=$(n,"b","where"),a=$(e,"condition","where","bool"),o=ht(ht(a.shape,r.shape),s.shape),i=Id(a,o),u=Id(r,o),l=Id(s,o),c={condition:i,t:u,e:l};return z.runKernel(bi,c)}var Cn=W({where_:oO});function iO(e){let n={x:$(e,"x","zerosLike")};return z.runKernel(Ni,n)}var Xe=W({zerosLike_:iO});function uO(e,t){let n=$(e,"a","div"),r=$(t,"b","div");[n,r]=At(n,r);let s=me(n,r),a=Xe(s),o=mr(r,a);return Cn(o,a,s)}var bS=W({divNoNan_:uO});function cO(e,t){let n=$(e,"t1","dot"),r=$(t,"t2","dot");P((n.rank===1||n.rank===2)&&(r.rank===1||r.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${r.rank}.`);let s=n.rank===1?n.size:n.shape[1],a=r.rank===1?r.size:r.shape[0];if(P(s===a,()=>`Error in dot: inner dimensions of inputs must match, but got ${s} and ${a}.`),n.rank===1&&r.rank===1){let o=G(n,[1,-1]),i=G(r,[-1,1]),u=Re(o,i);return G(u,[])}else if(n.rank===1&&r.rank===2){let o=G(n,[1,-1]),i=G(r,[r.shape[0],r.shape[1]]),u=Re(o,i);return G(u,[u.size])}else if(n.rank===2&&r.rank===1){let o=G(r,[-1,1]),i=Re(n,o);return G(i,[i.size])}else{let o=G(r,[r.shape[0],r.shape[1]]);return Re(n,o)}}var lO=W({dot_:cO});function dO(e,...t){let n=t.map((s,a)=>$(s,`tensors${a}`,"einsum")),r={equation:e};return z.runKernel(Ql,n,r)}var yS=W({einsum_:dO});function pO(e){let n={x:$(e,"x","elu","float32")};return z.runKernel(ka,n)}var Sd=W({elu_:pO});function hO(e){let t=$(e,"x","erf");P(t.dtype==="int32"||t.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),t.dtype==="int32"&&(t=ue(t,"float32"));let n={x:t};return z.runKernel(Qu,n)}var vS=W({erf_:hO});function fO(e){let n={x:$(e,"x","exp")};return z.runKernel(Ia,n)}var Tn=W({exp_:fO});function mO(e,t=0){let n=$(e,"x","expandDims","string_or_numeric");P(t<=n.rank,()=>"Axis must be <= rank of the tensor");let r={input:n},s={dim:t};return z.runKernel(Xo,r,s)}var Nn=W({expandDims_:mO});function gO(e){let n={x:$(e,"x","expm1")};return z.runKernel(Yo,n)}var xS=W({expm1_:gO});function bO(e,t){let n=$(e,"x","tile","string_or_numeric");P(n.rank===t.length,()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`);let r={x:n},s={reps:t};return z.runKernel(As,r,s)}var tr=W({tile_:bO});function yO(e,t,n,r="float32"){t==null&&(t=e);let s=$e([e,t],r),a=e<=t?e:t;for(let i=0;i<a;++i)s.set(1,i,i);let o=G(s.toTensor(),[e,t]);if(n==null)return o;if(n.length===1)return tr(Nn(o,0),[n[0],1,1]);if(n.length===2)return tr(Nn(Nn(o,0),0),[n[0],n[1],1,1]);if(n.length===3)return tr(Nn(Nn(Nn(o,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}var Yy=W({eye_:yO});function _n(e,t,n){let r={shape:e,value:t,dtype:n};return z.runKernel(Zu,{},r)}function vO(e){let n={x:$(e,"x","floor","float32")};return z.runKernel(Sa,n)}var Cd=W({floor_:vO});function xO(e,t,n=0,r=0){let s=$(e,"x","gather"),a=$(t,"indices","gather","int32"),o={x:s,indices:a},i={axis:n,batchDims:r};return z.runKernel(Zo,o,i)}var Ic=W({gather_:xO});function wO(e,t){let n=$(e,"a","greater","string_or_numeric"),r=$(t,"b","greater","string_or_numeric");[n,r]=At(n,r),ht(n.shape,r.shape);let s={a:n,b:r};return z.runKernel(ei,s)}var nr=W({greater_:wO});function kO(e,t){let n=$(e,"a","greaterEqual","string_or_numeric"),r=$(t,"b","greaterEqual","string_or_numeric");[n,r]=At(n,r),ht(n.shape,r.shape);let s={a:n,b:r};return z.runKernel(Na,s)}var zi=W({greaterEqual_:kO});function IO(e){let n={input:$(e,"input","imag")};return z.runKernel(Zl,n)}var rf=W({imag_:IO});function SO(e){let n={x:$(e,"x","isFinite")};return z.runKernel(Ju,n)}var CO=W({isFinite_:SO});function TO(e){let n={x:$(e,"x","isInf")};return z.runKernel(ec,n)}var NO=W({isInf_:TO});function _O(e){let n={x:$(e,"x","isNaN")};return z.runKernel(tc,n)}var wS=W({isNaN_:_O});function EO(e,t=.2){let r={x:$(e,"x","leakyRelu")},s={alpha:t};return z.runKernel(ti,r,s)}var sf=W({leakyRelu_:EO});function AO(e,t){let n=$(e,"a","less","string_or_numeric"),r=$(t,"b","less","string_or_numeric");[n,r]=At(n,r),ht(n.shape,r.shape);let s={a:n,b:r};return z.runKernel(ni,s)}var Qy=W({less_:AO});function $O(e,t){let n=$(e,"a","lessEqual","string_or_numeric"),r=$(t,"b","lessEqual","string_or_numeric");[n,r]=At(n,r),ht(n.shape,r.shape);let s={a:n,b:r};return z.runKernel(ri,s)}var Wi=W({lessEqual_:$O});function kS(e,t,n){if(n<=0)throw new Error("The number of values should be positive.");let r={start:e,stop:t,num:n};return z.runKernel($h,{},r)}function FO(e,t=5,n=1,r=1,s=.5){let a=$(e,"x","localResponseNormalization");P(a.rank===4||a.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${a.rank}.`),P(Lu(t),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);let o=a,i=!1;a.rank===3&&(i=!0,o=G(a,[1,a.shape[0],a.shape[1],a.shape[2]]));let u={x:o},l={depthRadius:t,bias:n,alpha:r,beta:s},c=z.runKernel(ed,u,l);return i?G(c,[c.shape[1],c.shape[2],c.shape[3]]):c}var IS=W({localResponseNormalization_:FO});function DO(e){let n={x:$(e,"x","log","float32")};return z.runKernel(Ea,n)}var gr=W({log_:DO});function RO(e){let n={x:$(e,"x","log1p")};return z.runKernel(nc,n)}var af=W({log1p_:RO});function PO(e){return P(ca(e),()=>"The f passed in grad(f) must be a function"),(t,n)=>{let r=$(t,"x","tf.grad","string_or_numeric"),s=n!=null?$(n,"dy","tf.grad"):null;return z.tidy(()=>{let{value:a,grads:o}=z.gradients(()=>e(r),[r],s);return s!=null&&wn(a.shape,s.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),of(o),o[0]})}}function OO(e){return P(ca(e),()=>"The f passed in grads(f) must be a function"),(t,n)=>{P(Array.isArray(t),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");let r=yd(t,"args","tf.grads","string_or_numeric"),s=n!=null?$(n,"dy","tf.grads"):null;return z.tidy(()=>{let{value:a,grads:o}=z.gradients(()=>e(...r),r,s);return s!=null&&wn(a.shape,s.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),of(o),o})}}function MO(e){return P(ca(e),()=>"The f passed in valueAndGrad(f) must be a function"),(t,n)=>{P(t instanceof Ae,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),P(n==null||n instanceof Ae,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");let{grads:r,value:s}=z.gradients(()=>e(t),[t],n);return of(r),{grad:r[0],value:s}}}function LO(e){return P(ca(e),()=>"The f passed in valueAndGrads(f) must be a function"),(t,n)=>{P(Array.isArray(t)&&t.every(s=>s instanceof Ae),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),P(n==null||n instanceof Ae,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");let r=z.gradients(()=>e(...t),t,n);return n!=null&&wn(r.value.shape,n.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),of(r.grads),r}}function SS(e,t){P(ca(e),()=>"The f passed in variableGrads(f) must be a function"),P(t==null||Array.isArray(t)&&t.every(l=>l instanceof oo),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");let n=t!=null;if(!n){t=[];for(let l in z.registeredVariables)t.push(z.registeredVariables[l])}let r=n?t.filter(l=>!l.trainable):null,s=t.length;t=t.filter(l=>l.trainable),P(t.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${s} variables is trainable.`);let a=!0,{value:o,grads:i}=z.gradients(e,t,null,a);P(i.some(l=>l!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),P(o.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${o.rank} tensor`);let u={};return t.forEach((l,c)=>{i[c]!=null&&(u[l.name]=i[c])}),r!=null&&r.forEach(l=>u[l.name]=null),{value:o,grads:u}}function cs(e){return z.customGrad(e)}function of(e){if(e.filter(n=>n==null).length>0)throw new Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`)}function BO(e){let n={x:$(e,"x","neg")};return z.runKernel(ai,n)}var Ft=W({neg_:BO});function zO(e){let n={x:$(e,"x","softplus")};return z.runKernel(dc,n)}var Sc=W({softplus_:zO});function WO(e){let t=$(e,"x","logSigmoid");return cs(r=>({value:Ft(Sc(Ft(r))),gradFunc:o=>V(o,$r(Ft(r)))}))(t)}var VO=W({logSigmoid_:WO});function UO(e,t=null,n=!1){let s={x:$(e,"x","max")},a={reductionIndices:t,keepDims:n};return z.runKernel(Aa,s,a)}var Gr=W({max_:UO});function GO(e,t){let n=$(e,"a","sub"),r=$(t,"b","sub");[n,r]=At(n,r);let s={a:n,b:r};return z.runKernel(Qa,s)}var he=W({sub_:GO});function HO(e,t=null,n=!1){let r=$(e,"x","sum");r.dtype==="bool"&&(r=ue(r,"int32"));let s={x:r},a={axis:t,keepDims:n};return z.runKernel(Ka,s,a)}var ve=W({sum_:HO});function jO(e,t=-1){let n=$(e,"logits","logSoftmax");if(t===-1&&(t=n.rank-1),t!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${t}`);return cs((s,a)=>{let o=!0,i=Gr(s,t,!0),u=he(s,i),l=he(ue(u,"float32"),gr(ve(Tn(u),t,o)));return a([l]),{value:l,gradFunc:(d,p)=>{let[h]=p,f=!0,m=Tn(h);return he(d,V(ve(d,t,f),m))}}})(n)}var Zy=W({logSoftmax_:jO});function Jy(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function CS(e,t,n){let r=e.length+t.length,s=[],a=0,o=0;for(let i=0;i<r;i++)n.indexOf(i)===-1?s.push(e[a++]):s.push(t[o++]);return s}function TS(e,t){let n=[],r=e.length;for(let a=0;a<r;a++)t.indexOf(a)===-1&&n.push(e[a]);let s=t.map(a=>e[a]);return[n,s]}function Vi(e,t){let n=t.map(r=>1);return CS(e,n,t)}function qO(e,t,n){P(Jy(t,n),()=>`${e} supports only inner-most axes for now. Got axes ${t} and rank-${n} input.`)}function NS(e,t){if(Jy(e,t))return null;let n=[];for(let r=0;r<t;++r)e.indexOf(r)===-1&&n.push(r);return e.forEach(r=>n.push(r)),n}function ev(e){return e.map((t,n)=>[n,t]).sort((t,n)=>t[1]-n[1]).map(t=>t[0])}function KO(e,t){let n=[];for(let r=t-e;r<t;++r)n.push(r);return n}function XO(e,t=null,n=!1){let r=$(e,"x","logSumExp"),s=Er(t,r.shape),a=Gr(r,s,!0),o=he(r,a),i=Tn(o),u=ve(i,s),l=gr(u),c=Z(G(a,l.shape),l);if(n){let d=Vi(c.shape,s);return G(c,d)}return c}var _S=W({logSumExp_:XO});function YO(e,t){let n=$(e,"a","logicalAnd","bool"),r=$(t,"b","logicalAnd","bool");ht(n.shape,r.shape);let s={a:n,b:r};return z.runKernel(si,s)}var Hr=W({logicalAnd_:YO});function QO(e){let n={x:$(e,"x","logicalNot","bool")};return z.runKernel(rc,n)}var uf=W({logicalNot_:QO});function ZO(e,t){let n=$(e,"a","logicalOr","bool"),r=$(t,"b","logicalOr","bool");ht(n.shape,r.shape);let s={a:n,b:r};return z.runKernel(Jl,s)}var tv=W({logicalOr_:ZO});function JO(e,t){let n=$(e,"a","logicalXor","bool"),r=$(t,"b","logicalXor","bool");return ht(n.shape,r.shape),Hr(tv(e,t),uf(Hr(e,t)))}var eM=W({logicalXor_:JO});function tM(e,t,n,r,s){let a=$(e,"x","maxPool"),o=1,i=a,u=!1;a.rank===3&&(u=!0,i=G(a,[1,a.shape[0],a.shape[1],a.shape[2]])),P(i.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${i.rank}.`),P(us(n,o),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`),Sn("maxPool",r,s);let l={x:i},c={filterSize:t,strides:n,pad:r,dimRoundingMode:s},d=z.runKernel(Fa,l,c);return u?G(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var Vt=W({maxPool_:tM});function nM(e,t=[1,1,1],n,r,s,a="NDHWC"){let o=$(e,"x","maxPool3d"),i=o,u=!1;o.rank===4&&(u=!0,i=G(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),P(i.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${i.rank}.`),P(a==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`),Sn("maxPool3d",r,s);let l={x:i},c={filterSize:t,strides:n,pad:r,dimRoundingMode:s,dataFormat:a},d=z.runKernel(td,l,c);return u?G(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}var nv=W({maxPool3d_:nM});function rM(e,t,n,r,s=!1){let o={x:$(e,"x","maxPoolWithArgmax")},i={filterSize:t,strides:n,pad:r,includeBatchInIndex:s},u=z.runKernel(Ph,o,i);return{result:u[0],indexes:u[1]}}var ES=W({maxPoolWithArgmax_:rM});function sM(e,t){let n=$(e,"a","maximum"),r=$(t,"b","maximum");[n,r]=At(n,r),n.dtype==="bool"&&(n=ue(n,"int32"),r=ue(r,"int32")),ht(n.shape,r.shape);let s={a:n,b:r};return z.runKernel($a,s)}var Ds=W({maximum_:sM});function aM(e,t=null,n=!1){let s={x:$(e,"x","mean")},a={axis:t,keepDims:n};return z.runKernel(Da,s,a)}var Ot=W({mean_:aM});function kt(e,t="float32"){if(t==="complex64"){let r=kt(e,"float32"),s=kt(e,"float32");return io(r,s)}let n=fh(wt(e),t);return z.makeTensor(n,e,t)}function rr(e,t="float32"){if(t==="complex64"){let r=rr(e,"float32"),s=kt(e,"float32");return io(r,s)}let n=Yb(wt(e),t);return z.makeTensor(n,e,t)}function oM(e,t,{indexing:n="xy"}={}){if(n!=="xy"&&n!=="ij")throw new TypeError(`${n} is not a valid third argument to meshgrid`);if(e===void 0)return[];let r=$(e,"x","meshgrid",e instanceof Ae?e.dtype:"float32");if(t===void 0)return[r];let s=$(t,"y","meshgrid",t instanceof Ae?t.dtype:"float32"),a=wt(r.shape),o=wt(s.shape);return n==="xy"?(r=G(r,[1,-1]),s=G(s,[-1,1]),[Re(rr([o,1],r.dtype),r),Re(s,rr([1,a],s.dtype))]):(r=G(r,[-1,1]),s=G(s,[1,-1]),[Re(r,rr([1,o],r.dtype)),Re(rr([a,1],s.dtype),s)])}function iM(e,t=null,n=!1){let s={x:$(e,"x","min")},a={axis:t,keepDims:n};return z.runKernel(Ra,s,a)}var cf=W({min_:iM});function uM(e,t){let n=$(e,"a","minimum"),r=$(t,"b","minimum");[n,r]=At(n,r),n.dtype==="bool"&&(n=ue(n,"int32"),r=ue(r,"int32")),ht(n.shape,r.shape);let s={a:n,b:r};return z.runKernel(Pa,s)}var Td=W({minimum_:uM});function cM(e,t,n){P(n==="reflect"||n==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`);let r=$(e,"x","mirrorPad");if(r.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");P(t.length===r.rank,()=>`Padding doesn't match input. Must be ${r.rank}. Got ${t.length}.`);let s=n==="reflect"?1:0;for(let i=0;i<r.rank;i++)P(t[i].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),P(t[i][0]>=0&&t[i][0]<=r.shape[i]-s&&t[i][1]>=0&&t[i][1]<=r.shape[i]-s,()=>`Padding in dimension ${i} cannot be greater than or equal to ${r.shape[i]-s} or less than 0 for input of shape ${r.shape}`);let a={paddings:t,mode:n},o={x:r};return z.runKernel(Oa,o,a)}var AS=W({mirrorPad_:cM});function lM(e,t){let n=$(e,"a","mod"),r=$(t,"b","mod");[n,r]=At(n,r);let s={a:n,b:r};return z.runKernel(sc,s)}var $S=W({mod_:lM});function dM(e){let t=$(e,"x","square"),n={};return z.runKernel("Square",{x:t},n)}var ft=W({square_:dM});function pM(e,t=null,n=!1){e=$(e,"x","moments");let r=Er(t,e.shape),s=Ot(e,r,n),a=s.shape;n||(a=Vi(s.shape,r));let o=ft(he(ue(e,"float32"),G(s,a))),i=Ot(o,r,n);return{mean:s,variance:i}}var lf=W({moments_:pM});function hM(e,t,n,r){let s=$(t,"data","multiRNNCell"),a=yd(n,"c","multiRNNCell"),o=yd(r,"h","multiRNNCell"),i=s,u=[];for(let d=0;d<e.length;d++){let p=e[d](i,a[d],o[d]);u.push(p[0]),u.push(p[1]),i=p[1]}let l=[],c=[];for(let d=0;d<u.length;d+=2)l.push(u[d]),c.push(u[d+1]);return[l,c]}var fM=W({multiRNNCell_:hM});function mM(e,t,n,r=!1){let s=$(e,"logits","multinomial"),a=s.size,o=s.rank;if(a<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${a}.`);if(o>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${o}`);n=n||Math.random();let u={logits:o===1?G(s,[1,-1]):s},l={numSamples:t,seed:n,normalized:r},c=z.runKernel(Oh,u,l);return o===1?G(c,[c.size]):c}var FS=W({multinomial_:mM});function gM(e,t){let n=$(e,"a","notEqual","string_or_numeric"),r=$(t,"b","notEqual","string_or_numeric");[n,r]=At(n,r),ht(n.shape,r.shape);let s={a:n,b:r};return z.runKernel(oi,s)}var Cc=W({notEqual_:gM});function bM(e){let n={x:$(e,"x","onesLike")};return z.runKernel(ci,n)}var br=W({onesLike_:bM});function yM(e,t){let n=$(e,"v1","outerProduct"),r=$(t,"v2","outerProduct");P(n.rank===1&&r.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${r.rank}.`);let s=G(n,[-1,1]),a=G(r,[1,-1]);return Re(s,a)}var vM=W({outerProduct_:yM});function xM(e,t,n=0){let r=$(e,"x","pad");if(r.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");let s={paddings:t,constantValue:n},a={x:r};return z.runKernel(La,a,s)}var Fr=W({pad_:xM});function wM(e,t,n=0){return P(t.length===2,()=>"Invalid number of paddings. Must be length of 2."),Fr(e,[t],n)}var kM=W({pad1d_:wM});function IM(e,t,n=0){return P(t.length===2&&t[0].length===2&&t[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Fr(e,t,n)}var SM=W({pad2d_:IM});function CM(e,t,n=0){return P(t.length===3&&t[0].length===2&&t[1].length===2&&t[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Fr(e,t,n)}var TM=W({pad3d_:CM});function NM(e,t,n=0){return P(t.length===4&&t[0].length===2&&t[1].length===2&&t[2].length===2&&t[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Fr(e,t,n)}var _M=W({pad4d_:NM});function EM(e,t,n){let r=$(e,"x","spaceToBatchND");P(r.rank>=1+t.length,()=>`input rank ${r.rank} should be > than [blockShape] ${t.length}`),P(n.length===t.length,()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${t.length}`),P(r.shape.reduce((o,i,u)=>u>0&&u<=t.length?o&&(i+n[u-1][0]+n[u-1][1])%t[u-1]==0:o,!0),()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${t.toString()}`);let s={x:r},a={blockShape:t,paddings:n};return z.runKernel(xi,s,a)}var df=W({spaceToBatchND_:EM});function AM(e,t,n,r,s,a,o){s==null&&(s=[1,1]),a==null&&(a=1),r===0&&(r="valid");let i=$(e,"x","maxPool"),u=i,l=!1;i.rank===3&&(l=!0,u=G(i,[1,i.shape[0],i.shape[1],i.shape[2]])),P(us(a,s),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${a} and dilations '${s}'`);let c=eS(u.shape,t,a,s,r),d=[c.dilationHeight,c.dilationWidth],p;r==="same"?p=FM([c.filterHeight,c.filterWidth],d):p=[[0,0],[0,0]];let h=d[0]===1&&d[1]===1,[f,m]=$M([c.inHeight,c.inWidth],d,p),g=h?r:"valid",b=h?u:df(u,d,f),v=(n==="avg"?()=>Ar(b,t,a,g,o):()=>Vt(b,t,a,g,o))(),x=h?v:tf(v,d,m);return l?G(x,[x.shape[1],x.shape[2],x.shape[3]]):x}function $M(e,t,n){let r=n.map(c=>c[0]),s=n.map(c=>c[1]),a=e.concat(r,s),o=t.map((c,d)=>(c-a[d]%c)%c),i=s.map((c,d)=>c+o[d]),u=t.map((c,d)=>[r[d],i[d]]),l=t.map((c,d)=>[0,o[d]]);return[u,l]}function FM(e,t){let r=e.map((o,i)=>o+(o-1)*(t[i]-1)).map(o=>o-1),s=r.map(o=>Math.floor(o/2)),a=r.map((o,i)=>o-s[i]);return r.map((o,i)=>[s[i],a[i]])}var DM=W({pool_:AM});function RM(e,t){let n=$(e,"base","pow"),r=$(t,"exp","pow");[n,r]=At(n,r);let s={a:n,b:r};return z.runKernel(Ba,s)}var fo=W({pow_:RM});function PM(e,t){let n=$(e,"x","prelu"),r=$(t,"alpha","prelu"),s={x:n,alpha:r};return z.runKernel(za,s)}var pf=W({prelu_:PM});function OM(e,t=null,n=!1){let r=$(e,"x","prod");r.dtype==="bool"&&(r=ue(r,"int32"));let s={x:r},a={axis:t,keepDims:n};return z.runKernel(pi,s,a)}var rv=W({prod_:OM});function MM(e,t,n){let r=wt(e),s=null;if(n==null||n==="float32")s=new Float32Array(r);else if(n==="int32")s=new Int32Array(r);else if(n==="bool")s=new Uint8Array(r);else throw new Error(`Unknown data type ${n}`);for(let a=0;a<r;a++)s[a]=t();return z.makeTensor(s,e,n)}var LM=W({rand_:MM}),sv=Bo(ch()),av=class{constructor(e,t,n,r,s){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);let a=s||Math.random();this.random=sv.alea(a.toString())}nextValue(){if(!isNaN(this.nextVal)){let r=this.nextVal;return this.nextVal=NaN,r}let e,t,n=!1;for(;!n;){let r,s,a;do r=2*this.random()-1,s=2*this.random()-1,a=r*r+s*s;while(a>=1||a===0);let o=Math.sqrt(-2*Math.log(a)/a);e=this.mean+this.stdDev*r*o,t=this.mean+this.stdDev*s*o,(!this.truncated||this.isValidTruncated(e))&&(n=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}},BM=class{constructor(e,t,n,r){this.alpha=e,this.beta=1/t,this.dtype=n;let s=r||Math.random();this.randu=sv.alea(s.toString()),this.randn=new av(0,1,n,!1,this.randu()),e<1?this.d=e+2/3:this.d=e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,n,r,s,a;for(;;){do r=this.randn.nextValue(),a=1+this.c*r;while(a<=0);if(a*=a*a,e=r*r,t=1-.331*e*e,n=.5*e+this.d*(1-a+Math.log(a)),s=this.randu(),s<t||Math.log(s)<n)break}return a=1/this.beta*this.d*a,this.alpha<1&&(a*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(a)}convertValue(e){return this.dtype==="float32"?e:Math.round(e)}},zM=class{constructor(e=0,t=1,n,r){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=t-e,this.dtype=n,r==null&&(r=Math.random()),typeof r=="number"&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=sv.alea(r)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}};function WM(e,t,n=1,r="float32",s){if(n==null&&(n=1),r==null&&(r="float32"),r!=="float32"&&r!=="int32")throw new Error(`Unsupported data type ${r}`);let a=new BM(t,n,r,s),o=$e(e,r);for(let i=0;i<o.values.length;i++)o.values[i]=a.nextValue();return o.toTensor()}var VM=W({randomGamma_:WM});function UM(e,t=0,n=1,r,s){if(r!=null&&r==="bool")throw new Error(`Unsupported data type ${r}`);let a=new av(t,n,r,!1,s),o=$e(e,r);for(let i=0;i<o.values.length;i++)o.values[i]=a.nextValue();return o.toTensor()}var DS=W({randomNormal_:UM});function GM(e,t=0,n=1,r="float32",s){let a=$e(e,r),o=new zM(t,n,null,s);for(let i=0;i<a.values.length;i++)a.values[i]=o.nextValue();return a.toTensor()}var Tc=W({randomUniform_:GM});function Nc(e,t,n=1,r="float32"){if(n===0)throw new Error("Cannot have a step of zero");let s={start:e,stop:t,step:n,dtype:r};return z.runKernel(oc,{},s)}function HM(e){let n={input:$(e,"input","real")};return z.runKernel(nd,n)}var Nd=W({real_:HM});function jM(e){let n={x:$(e,"x","reciprocal")};return z.runKernel(ic,n)}var RS=W({reciprocal_:jM});function qM(e){let n={x:$(e,"x","relu")};return z.runKernel(Wa,n)}var Qe=W({relu_:qM});function KM(e){let n={x:$(e,"x","relu6")};return z.runKernel(Ua,n)}var ov=W({relu6_:KM});function XM(e,t){let r={x:$(e,"x","reverse")},s={dims:t};return z.runKernel(fi,r,s)}var yr=W({reverse_:XM});function YM(e){let t=$(e,"x","reverse");return P(t.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`),yr(t,0)}var QM=W({reverse1d_:YM});function ZM(e,t){let n=$(e,"x","reverse");return P(n.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`),yr(n,t)}var JM=W({reverse2d_:ZM});function eL(e,t){let n=$(e,"x","reverse");return P(n.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`),yr(n,t)}var tL=W({reverse3d_:eL});function nL(e,t){let n=$(e,"x","reverse");return P(n.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`),yr(n,t)}var rL=W({reverse4d_:nL});function sL(e){let n={x:$(e,"x","round")};return z.runKernel(mi,n)}var iv=W({round_:sL});function aL(e){let n={x:$(e,"x","rsqrt","float32")};return z.runKernel(Ga,n)}var uv=W({rsqrt_:aL});function ke(e,t){if((yn(e)&&t!=="string"||Array.isArray(e))&&t!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(t==="string"&&yn(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return uo(e,[],[],t)}function oL(e){let n={x:$(e,"x","selu")};return z.runKernel(cc,n)}var cv=W({selu_:oL});function iL(e,t,n,r,s,a=[1,1],o="NHWC"){let i=$(e,"x","separableConv2d"),u=$(t,"depthwiseFilter","separableConv2d"),l=$(n,"pointwiseFilter","separableConv2d"),c=i,d=!1;if(i.rank===3&&(d=!0,c=G(i,[1,i.shape[0],i.shape[1],i.shape[2]])),o==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");P(c.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`),P(u.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${u.rank}.`),P(l.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${u.rank}.`),P(l.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${l.shape[0]}.`),P(l.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${l.shape[1]}.`);let p=u.shape[2],h=u.shape[3];P(l.shape[2]===p*h,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${p*h}, but got ${l.shape[2]}.`);let f=Bi(c,u,r,s,o,a),g=Wt(f,l,1,"valid",o);return d?G(g,[g.shape[1],g.shape[2],g.shape[3]]):g}var _c=W({separableConv2d_:iL});async function uL(e,t){let n=$(e,"x","setdiff1d"),r=$(t,"y","setdiff1d");P(n.dtype===r.dtype,()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${r.dtype}).`),P(n.rank===1,()=>`x should be 1D tensor, but got x (${n.shape}).`),P(r.rank===1,()=>`y should be 1D tensor, but got y (${r.shape}).`);let s=await n.data(),a=await r.data(),o=new Set(a),i=0;for(let c=0;c<s.length;c++)o.has(s[c])||i++;let u=new Kt([i],n.dtype),l=new Kt([i],"int32");for(let c=0,d=0;c<s.length;c++)o.has(s[c])||(u.values[d]=s[c],l.values[d]=c,d++);return[u.toTensor(),l.toTensor()]}var PS=uL;function cL(e){let n={x:$(e,"x","sign")};return z.runKernel(lc,n)}var OS=W({sign_:cL});function lL(e){let n={x:$(e,"x","sin","float32")};return z.runKernel(Ha,n)}var lv=W({sin_:lL});function dL(e){let n={x:$(e,"x","sinh")};return z.runKernel(vi,n)}var dv=W({sinh_:dL});function pL(e,t,n){let r=$(e,"x","slice1d");return P(r.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`),Ve(r,[t],[n])}var hf=W({slice1d_:pL});function hL(e,t,n){let r=$(e,"x","slice2d");return P(r.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`),Ve(r,t,n)}var pv=W({slice2d_:hL});function fL(e,t,n){let r=$(e,"x","slice3d");return P(r.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`),Ve(r,t,n)}var Ec=W({slice3d_:fL});function mL(e,t,n){let r=$(e,"x","slice4d");return P(r.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`),Ve(r,t,n)}var _d=W({slice4d_:mL});function gL(e,t=-1){let n=$(e,"logits","softmax","float32");if(t===-1&&(t=n.rank-1),t!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${t}`);let r={logits:n},s={dim:t};return z.runKernel(Xa,r,s)}var ls=W({softmax_:gL});function bL(e){P(e.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`);let t={input:e};return z.runKernel(Eh,t)}var ff=W({fft_:bL});function yL(e){P(e.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`);let t={input:e};return z.runKernel(Ah,t)}var Ed=W({ifft_:yL});function vL(e){let t=e.shape[e.shape.length-1],n=e.size/t,r;if(t<=2){let s=G(e,[n,t]);r=Ed(s)}else{let s=[n,2*(t-1)],a=G(Nd(e),[n,t]),o=G(rf(e),[n,t]),i=yr(Ve(a,[0,1],[n,t-2]),1),u=V(yr(Ve(o,[0,1],[n,t-2]),1),ke(-1)),l=ot([a,i],1),c=ot([o,u],1),d=G(io(l,c),[s[0],s[1]]);r=Ed(d)}if(r=Nd(r),e.rank===3&&e.shape[0]!==0){let s=r,a=e.shape[0];r=G(r,[a,r.shape[0]/a,r.shape[1]]),s.dispose()}return r}var hv=W({irfft_:vL});function xL(e,t,n=0){let s={x:$(e,"x","split")},a={numOrSizeSplits:t,axis:n};return z.runKernel(wi,s,a)}var sr=W({split_:xL});function wL(e,t){P(e.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${e.dtype}`);let n=e.shape[e.shape.length-1],r=e.size/n,s;if(t!=null&&t<n){let f=e.shape.map(g=>0),m=e.shape.map(g=>g);m[e.shape.length-1]=t,s=Ve(e,f,m),n=t}else if(t!=null&&t>n){let f=e.shape.map(m=>m);f[e.shape.length-1]=t-n,s=ot([e,kt(f)],e.shape.length-1),n=t}else s=e;let a=Xe(s),o=G(io(s,a),[r,n]),i=ff(o),u=Math.floor(n/2)+1,l=Nd(i),c=rf(i),d=sr(l,[u,n-u],l.shape.length-1),p=sr(c,[u,n-u],c.shape.length-1),h=s.shape.slice();return h[s.shape.length-1]=u,G(io(d[0],p[0]),h)}var mf=W({rfft_:wL});function kL(e){let n={x:$(e,"x","sqrt","float32")};return z.runKernel(qa,n)}var vn=W({sqrt_:kL});function IL(e,t){let n=$(e,"a","squaredDifference"),r=$(t,"b","squaredDifference");[n,r]=At(n,r),ht(n.shape,r.shape);let s={a:n,b:r},a={};return z.runKernel(Ya,s,a)}var fv=W({squaredDifference_:IL});function SL(e,t){let n=$(e,"x","squeeze");return G(n,DI(n.shape,t).newShape)}var Rs=W({squeeze_:SL});function CL(e,t=0){let n=yd(e,"tensors","stack","string_or_numeric");P(n.length>=1,()=>"Pass at least one tensor to tf.stack"),n.length>0&&P(t<=n[0].rank,()=>"Axis must be <= rank of the tensor");let r=n,s={axis:t};return z.runKernel(di,r,s)}var Ut=W({stack_:CL});function TL(e,t=0){let r={x:$(e,"x","step")},s={alpha:t};return z.runKernel(eo,r,s)}var Ad=W({step_:TL});function NL(e,t,n,r,s=0,a=0,o=0,i=0,u=0){let c={x:$(e,"x","stridedSlice","string_or_numeric")},d={begin:t,end:n,strides:r,beginMask:s,endMask:a,ellipsisMask:o,newAxisMask:i,shrinkAxisMask:u};return z.runKernel(ki,c,d)}var MS=W({stridedSlice_:NL});function _L(e){let n={x:$(e,"x","tan","float32")};return z.runKernel(Ii,n)}var LS=W({tan_:_L});function je(e,t){zo(e);let n=os(e,t);if(n.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return uo(e,null,n,t)}function jr(e,t,n){if(zo(e),t!=null&&t.length!==2)throw new Error("tensor2d() requires shape to have two numbers");let r=os(e,n);if(r.length!==2&&r.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return uo(e,t,r,n)}function qr(e,t,n){if(zo(e),t!=null&&t.length!==4)throw new Error("tensor4d() requires shape to have four numbers");let r=os(e,n);if(r.length!==4&&r.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return uo(e,t,r,n)}function EL(e,t,n){if(zo(e),t!=null&&t.length!==5)throw new Error("tensor5d() requires shape to have five numbers");let r=os(e,n);if(r.length!==5&&r.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return uo(e,t,r,n)}function AL(e,t,n){if(zo(e),t!=null&&t.length!==6)throw new Error("tensor6d() requires shape to have six numbers");let r=os(e,n);if(r.length!==6&&r.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return t=t||r,uo(e,t,r,n)}function $L(e,t=1,n=!0){let r=$(e,"x","topk");if(r.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");let s=r.shape[r.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>s)throw new Error(`'k' passed to topk() must be <= the last dimension (${s}) but got ${t}`);let a={x:r},o={k:t,sorted:n},[i,u]=z.runKernel(Si,a,o);return{values:i,indices:u}}var BS=W({topk_:$L});function FL(e,t=0,n=1,r,s){if(r!=null&&r==="bool")throw new Error("Unsupported data type $ { dtype }");let a=new av(t,n,r,!0,s),o=$e(e,r);for(let i=0;i<o.values.length;i++)o.values[i]=a.nextValue();return o.toTensor()}var gf=W({truncatedNormal_:FL});function DL(e,t=0){let n=$(e,"x","unique","string_or_numeric");P(n.rank>0,()=>"The input tensor must be at least 1D");let r={x:n},s={axis:t},[a,o]=z.runKernel(Wh,r,s);return{values:a,indices:o}}var mv=W({unique_:DL});function RL(e,t,n){let r=$(e,"x","unsortedSegmentSum"),s=$(t,"segmentIds","unsortedSegmentSum","int32");P(Lu(n),()=>"numSegments must be of dtype int");let a={x:r,segmentIds:s},o={numSegments:n};return z.runKernel(ud,a,o)}var zS=W({unsortedSegmentSum_:RL});function PL(e,t=0){let n=$(e,"x","unstack","string_or_numeric");P(t>=-n.shape.length&&t<n.shape.length,()=>`Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`);let r={value:n},s={axis:t};return z.runKernel(Ti,r,s)}var vt=W({unstack_:PL});function WS(e,t=!0,n,r){return z.makeVariable(e,t,n,r)}function VS(e,t){let n=[];for(let a=0;a<t.length;a++)t[a]&&n.push(a);let r=$e(e,"int32"),s=$e([n.length,e.length],"int32");for(let a=0;a<n.length;a++){let o=r.indexToLoc(n[a]),i=a*e.length;s.values.set(o,i)}return s.toTensor()}async function OL(e){let t=$(e,"condition","whereAsync","bool"),n=await t.data(),r=VS(t.shape,n);return e!==t&&t.dispose(),r}var gv=OL;async function ML(e,t,n){let r=$(e,"tensor","boolMask"),s=$(t,"mask","boolMask","bool"),a=n==null?0:n,o=s.rank,i=r.shape;P(o>0,()=>"mask cannot be scalar"),wn(i.slice(a,a+o),s.shape,"mask's shape must match the first K dimensions of tensor's shape,");let u=1;for(let m=a;m<a+o;m++)u*=i[m];let l=i.slice(0,a).concat([u],i.slice(a+o)),c=G(r,l),d=G(s,[-1]),p=await gv(d),h=Rs(p,[1]),f=Ic(c,h,a);return e!==r&&r.dispose(),t!==s&&s.dispose(),h.dispose(),c.dispose(),d.dispose(),p.dispose(),f}var LL=ML;function BL(e,t="euclidean",n=null,r=!1){e=$(e,"x","norm");let s=US(e,t,n),a=s.shape;if(r){let o=Er(n,e.shape);a=Vi(s.shape,o)}return G(s,a)}function US(e,t,n=null){if(e.rank===0)return Xt(e);if(e.rank!==1&&n===null)return US(G(e,[-1]),t,n);if(e.rank===1||typeof n=="number"||Array.isArray(n)&&n.length===1){if(t===1)return ve(Xt(e),n);if(t===1/0)return Gr(Xt(e),n);if(t===-1/0)return cf(Xt(e),n);if(t==="euclidean"||t===2)return vn(ve(fo(Xt(e),ke(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(n)&&n.length===2){if(t===1)return Gr(ve(Xt(e),n[0]),n[1]-1);if(t===1/0)return Gr(ve(Xt(e),n[1]),n[0]);if(t===-1/0)return cf(ve(Xt(e),n[1]),n[0]);if(t==="fro"||t==="euclidean")return vn(ve(ft(e),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}var bv=W({norm_:BL});function zL(e,t,n,r,s=!0){let a=$(e,"v","movingAverage"),o=$(t,"x","movingAverage"),i=$(n,"decay","movingAverage");e1(a,o),P(ia(a.shape,o.shape),()=>"Shape mismatch in v and x");let u=ke(1),l=he(u,i),c=V(he(o,a),l);if(s){P(r!=null,()=>"When using zeroDebias: true, step is required.");let d=$(r,"step","movingAverage");c=me(c,he(u,fo(i,d)))}return Z(a,c)}var WL=W({movingAverage_:zL});function VL(e,t,n){let r=$(e,"indices","scatterND","int32"),s=$(t,"updates","scatterND");Fy(s,r,n);let a={indices:r,updates:s},o={shape:n};return z.runKernel(gi,a,o)}var GS=W({scatterND_:VL});function UL(e,t,n,r){if(e.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${e.shape}.`);let s=e.rank>0?e.shape[0]:1,a=e.rank>1?e.shape[1]:1;if(n.length!==a)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${a}.`);let o=t.size;if(!(t.rank===0||t.rank===1&&o===s))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${s}]`);if(t.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}function GL(e,t,n,r=0){let s=$(e,"sparseIndices","sparseToDense","int32"),a=$(t,"sparseValues","sparseToDense"),o=$(r,"defaultValue","sparseToDense",a.dtype);UL(s,a,n,o);let i={sparseIndices:s,sparseValues:a,defaultValue:o},u={outputShape:n};return z.runKernel(od,i,u)}var yv=W({sparseToDense_:GL});function HL(e,t){let n=$(t,"indices","gatherND","int32"),s={params:$(e,"x","gatherND","string_or_numeric"),indices:n};return z.runKernel(Jo,s)}var HS=W({gatherND_:HL});function jL(e,t){if(t==null)return e.shape.slice();if(ia(e.shape,t))return t;if(e.shape.length===t.length){let n=[];for(let r=0;r<e.shape.length;r++)t[r]==null&&e.shape[r]!=null?n.push(e.shape[r]):n.push(t[r]);return n}return t}function qL(e,t,n,r){let s=$(e,"x","dropout");if(P(s.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${s.dtype} tensor instead.`),P(t>=0&&t<1,()=>`rate must be a float in the range [0, 1), but got ${t}.`),t===0)return e instanceof Ae?s.clone():s;let a=jL(s,n),o=1-t,i=me(Cd(Z(Tc(a,0,1,"float32",r),o)),o);return V(s,i)}var jS=W({dropout_:qL});function qS(e){return Math.floor(Math.pow(2,Math.ceil(Math.log(e)/Math.log(2))))}function vv(e,t,n){let r=1-e%2,s=new Float32Array(e);for(let a=0;a<e;++a){let o=2*Math.PI*a/(e+r-1);s[a]=t-n*Math.cos(o)}return je(s,"float32")}async function KL(e,t,n=1){let r=$(e,"predictions","inTopK"),s=$(t,"targets","inTopK");P(r.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${r.rank}`),P(r.rank-1===s.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${s.rank}`),wn(r.shape.slice(0,r.shape.length-1),s.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");let a=r.shape[r.shape.length-1];P(n>0&&n<=a,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${a}), but got ${n}`);let o=await r.data(),i=await s.data(),[u,l]=[o.length/a,a],c=RI("bool",u);for(let d=0;d<u;d++){let p=d*l,h=o.subarray(p,p+l),f=[];for(let m=0;m<h.length;m++)f.push({value:h[m],index:m});f.sort((m,g)=>g.value-m.value),c[d]=0;for(let m=0;m<n;m++)if(f[m].index===i[d]){c[d]=1;break}}return e!==r&&r.dispose(),t!==s&&s.dispose(),er(c,s.shape,"bool")}var XL=KL,mo={};Ee(mo,{conv2d:()=>ZL,depthwiseConv2d:()=>nB,matMul:()=>sB});function YL(e,t,n,r,s,a="NHWC",o){let i=e;e.rank===3&&(i=G(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let u=t;u.rank===3&&(u=G(t,[1,t.shape[0],t.shape[1],t.shape[2]])),P(i.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${i.shape}.`),P(u.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${u.shape}.`),P(n.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`);let l=a==="NHWC"?i.shape[3]:i.shape[1],c=a==="NHWC"?u.shape[3]:u.shape[1];P(l===n[2],()=>`Error in conv2dDerFilter: depth of input ${l}) must match input depth in filter (${n[2]}.`),P(c===n[3],()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${n[3]}).`),Sn("conv2dDerFilter",s,o);let d={x:i,dy:u},p={strides:r,pad:s,dataFormat:a,dimRoundingMode:o,filterShape:n};return z.runKernel(vh,d,p)}var xv=W({conv2DBackpropFilter_:YL});function bf(e,t,n){if(n==null||n==="linear")return e;if(n==="relu")return V(e,Ad(t));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function yf(e,t){let n=t,r=zt(e.shape,t.shape);return r.length>0&&(n=ve(n,r)),G(n,e.shape)}function vf(e,t,n,r){if(t==="linear")return e;if(t==="relu")return Qe(e);if(t==="elu")return Sd(e);if(t==="relu6")return ov(e);if(t==="prelu")return pf(e,n);if(t==="leakyrelu")return sf(e,r);if(t==="sigmoid")return $r(e);throw new Error(`Unknown fused activation ${t}.`)}var xf=(e,t)=>!(e>0)||t==="linear";function QL({x:e,filter:t,strides:n,pad:r,dataFormat:s="NHWC",dilations:a=[1,1],dimRoundingMode:o,bias:i,activation:u="linear",preluActivationWeights:l,leakyreluAlpha:c}){if(u=u||"linear",xf(z.state.gradientDepth,u)===!1){let k=Wt(e,t,n,r,s,a,o);return i!=null&&(k=Z(k,i)),vf(k,u,l,c)}let d=$(e,"x","conv2d","float32"),p=$(t,"filter","conv2d","float32"),h=d,f=!1;d.rank===3&&(f=!0,h=G(d,[1,d.shape[0],d.shape[1],d.shape[2]])),P(h.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${h.rank}.`),P(p.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${p.rank}.`),Sn("fused conv2d",r,o),P(h.shape[3]===p.shape[2],()=>`Error in conv2d: depth of input (${h.shape[3]}) must match input depth for filter ${p.shape[2]}.`),P(us(n,a),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`),P(s==="NHWC",()=>`Error in conv2d: got dataFormat of ${s} but only NHWC is currently supported.`);let m=kd(h.shape,p.shape,n,a,r,o),g;i!=null&&(g=$(i,"bias","fused conv2d"),[g]=At(g,d),ht(m.outShape,g.shape));let b;l!=null&&(b=$(l,"prelu weights","fused conv2d"));let y=(k,T)=>{let[C,E,F,O]=T,D=bf(k,F,u);P(po(a),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`);let R=Hy(E.shape,D,C,n,r),_=xv(E,D,C.shape,n,r),L=[R,_];if(O!=null){let U=yf(O,D);L.push(U)}return L},v={x:h,filter:p,bias:g,preluActivationWeights:b},x={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:o,activation:u,leakyreluAlpha:c};return i==null?cs((T,C,E)=>{let F=z.runKernel(no,v,x);return E([C,T,F]),f&&(F=G(F,[F.shape[1],F.shape[2],F.shape[3]])),{value:F,gradFunc:y}})(h,p):cs((T,C,E,F)=>{let O=z.runKernel(no,v,x);return F([C,T,O,E]),f&&(O=G(O,[O.shape[1],O.shape[2],O.shape[3]])),{value:O,gradFunc:y}})(h,p,g)}var ZL=W({fusedConv2d_:QL});function JL(e,t,n,r,s,a=[1,1],o){let i=e;e.rank===3&&(i=G(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let u=t;u.rank===3&&(u=G(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let l={x:i,dy:u},c={strides:r,pad:s,dimRoundingMode:o,dilations:a,filterShape:n};return z.runKernel(Ih,l,c)}var KS=W({depthwiseConv2dNativeBackpropFilter_:JL});function eB(e,t,n,r,s,a=[1,1],o){let i=t,u=!1;t.rank===3&&(u=!0,i=G(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let l={dy:i,filter:n},c={strides:r,pad:s,dimRoundingMode:o,dilations:a,inputShape:e},d=z.runKernel(Sh,l,c);return u?G(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var XS=W({depthwiseConv2dNativeBackpropInput_:eB});function tB({x:e,filter:t,strides:n,pad:r,dataFormat:s="NHWC",dilations:a=[1,1],dimRoundingMode:o,bias:i,activation:u="linear",preluActivationWeights:l,leakyreluAlpha:c}){if(xf(z.state.gradientDepth,u)===!1){let k=Bi(e,t,n,r,s,a,o);return i!=null&&(k=Z(k,i)),vf(k,u,l,c)}let d=$(e,"x","depthwiseConv2d","float32"),p=$(t,"filter","depthwiseConv2d","float32"),h=d,f=!1;d.rank===3&&(f=!0,h=G(d,[1,d.shape[0],d.shape[1],d.shape[2]])),P(h.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${h.rank}.`),P(p.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${p.rank}.`),P(h.shape[3]===p.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${h.shape[3]}) must match the inChannels dimension in filter ${p.shape[2]}.`),a==null&&(a=[1,1]),P(us(n,a),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`),Sn("fused depthwiseConv2d",r,o);let m=kd(h.shape,p.shape,n,a,r,o,!0),g;i!=null&&(g=$(i,"bias","fused conv2d"),[g]=At(g,d),ht(m.outShape,g.shape));let b;l!=null&&(b=$(l,"prelu weights","fused depthwiseConv2d"));let y=(k,T)=>{P(po(a),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);let[C,E,F,O]=T,D=bf(k,F,u),R=XS(E.shape,D,C,n,r,a,o),_=KS(E,D,C.shape,n,r,a,o);if(O!=null){let L=yf(g,D);return[R,_,L]}return[R,_]},v={x:h,filter:p,bias:g,preluActivationWeights:b},x={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:o,activation:u,leakyreluAlpha:c};return i==null?cs((T,C,E)=>{let F=z.runKernel(ro,v,x);return E([C,T,F]),f&&(F=G(F,[F.shape[1],F.shape[2],F.shape[3]])),{value:F,gradFunc:y}})(h,p):cs((T,C,E,F)=>{let O=z.runKernel(ro,v,x);return F([C,T,O,E]),f&&(O=G(O,[O.shape[1],O.shape[2],O.shape[3]])),{value:O,gradFunc:y}})(h,p,g)}var nB=W({fusedDepthwiseConv2d_:tB});function rB({a:e,b:t,transposeA:n=!1,transposeB:r=!1,bias:s,activation:a="linear",preluActivationWeights:o,leakyreluAlpha:i}){if(xf(z.state.gradientDepth,a)===!1){let D=Re(e,t,n,r);return s!=null&&(D=Z(D,s)),vf(D,a,o,i)}let u=$(e,"a","fused matMul"),l=$(t,"b","fused matMul");[u,l]=At(u,l);let c=n?u.shape[u.rank-2]:u.shape[u.rank-1],d=r?l.shape[l.rank-1]:l.shape[l.rank-2],p=n?u.shape[u.rank-1]:u.shape[u.rank-2],h=r?l.shape[l.rank-2]:l.shape[l.rank-1],f=u.shape.slice(0,-2),m=l.shape.slice(0,-2),g=wt(f),b=wt(m);P(c===d,()=>`Error in fused matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${u.shape} and ${l.shape} and transposeA=${n} and transposeB=${r} must match.`);let v=ht(u.shape.slice(0,-2),l.shape.slice(0,-2)).concat([p,h]),x=n?G(u,[g,c,p]):G(u,[g,p,c]),k=r?G(l,[b,h,d]):G(l,[b,d,h]),T;s!=null&&(T=$(s,"bias","fused matMul"),[T]=At(T,u),ht(v,T.shape));let C;o!=null&&(C=$(o,"prelu weights","fused matMul"));let E=(D,R)=>{let[_,L,U,j]=R,K=bf(G(D,U.shape),U,a),q,Q;if(!n&&!r?(q=Re(K,L,!1,!0),Q=Re(_,K,!0,!1)):!n&&r?(q=Re(K,L,!1,!1),Q=Re(K,_,!0,!1)):n&&!r?(q=Re(L,K,!1,!0),Q=Re(_,K,!1,!1)):(q=Re(L,K,!0,!0),Q=Re(K,_,!0,!0)),s!=null){let ee=yf(j,K);return[q,Q,ee]}else return[q,Q]},F={a:x,b:k,bias:T,preluActivationWeights:C},O={transposeA:n,transposeB:r,activation:a,leakyreluAlpha:i};return s==null?cs((R,_,L)=>{let U=z.runKernel(to,F,O);return L([R,_,U]),{value:G(U,v),gradFunc:E}})(x,k):cs((R,_,L,U)=>{let j=z.runKernel(to,F,O);return U([R,_,j,L]),{value:G(j,v),gradFunc:E}})(x,k,T)}var sB=W({fusedMatMul_:rB});function aB(e){return vv(e,.54,.46)}var oB=W({hammingWindow_:aB});function iB(e){return vv(e,.5,.5)}var YS=W({hannWindow_:iB});function uB(e,t,n,r=!1,s=0){let a=0,o=[];for(;a+t<=e.size;)o.push(Ve(e,a,t)),a+=n;if(r)for(;a<e.size;){let i=a+t-e.size,u=ot([Ve(e,a,t-i),_n([i],s)]);o.push(u),a+=n}return o.length===0?jr([],[0,t]):G(ot(o),[o.length,t])}var QS=W({frame_:uB});function cB(e,t,n,r,s=YS){r==null&&(r=qS(t));let a=QS(e,t,n),o=V(a,s(t));return mf(o,r)}var lB=W({stft_:cB});function dB(e,t,n,r,s="bilinear",a=0){let o=$(e,"image","cropAndResize"),i=$(t,"boxes","cropAndResize","float32"),u=$(n,"boxInd","cropAndResize","int32"),l=i.shape[0];P(o.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${o.rank}.`),P(i.rank===2&&i.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${l},4] but had shape ${i.shape}.`),P(u.rank===1&&u.shape[0]===l,()=>`Error in cropAndResize: boxInd must be have size [${l}] but had shape ${i.shape}.`),P(r.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`),P(r[0]>=1&&r[1]>=1,()=>`cropSize must be atleast [1,1], but was ${r}`),P(s==="bilinear"||s==="nearest",()=>`method must be bilinear or nearest, but was ${s}`);let c={image:o,boxes:i,boxInd:u},d={method:s,extrapolationValue:a,cropSize:r};return z.runKernel(jo,c,d)}var pB=W({cropAndResize_:dB});function hB(e){let t=$(e,"image","flipLeftRight","float32");P(t.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`);let n={image:t};return z.runKernel(Qo,n,{})}var fB=W({flipLeftRight_:hB});function mB(e){let t=$(e,"image","grayscaleToRGB"),n=t.rank-1,r=t.shape[n];P(t.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`),P(r===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`);let s=new Array(t.rank);return s.fill(1,0,n),s[n]=3,tr(t,s)}var gB=W({grayscaleToRGB_:mB});function bB(e,t,n=0,r=.5){let s=$(e,"image","rotateWithOffset","float32");P(s.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${s.rank}.`);let a={image:s},o={radians:t,fillValue:n,center:r};return z.runKernel(_i,a,o)}var yB=W({rotateWithOffset_:bB});function Ac(e,t,n,r,s,a){r==null&&(r=.5),s==null&&(s=Number.NEGATIVE_INFINITY),a==null&&(a=0);let o=e.shape[0];return n=Math.min(n,o),P(0<=r&&r<=1,()=>`iouThreshold must be in [0, 1], but was '${r}'`),P(e.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`),P(e.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`),P(t.rank===1,()=>"scores must be a 1D tensor"),P(t.shape[0]===o,()=>`scores has incompatible shape with boxes. Expected ${o}, but was ${t.shape[0]}`),P(0<=a&&a<=1,()=>`softNmsSigma must be in [0, 1], but was '${a}'`),{maxOutputSize:n,iouThreshold:r,scoreThreshold:s,softNmsSigma:a}}function vB(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY){let a=$(e,"boxes","nonMaxSuppression","float32"),o=$(t,"scores","nonMaxSuppression","float32"),i=Ac(a,o,n,r,s);n=i.maxOutputSize,r=i.iouThreshold,s=i.scoreThreshold;let u={maxOutputSize:n,iouThreshold:r,scoreThreshold:s};return z.runKernel(ii,{boxes:a,scores:o},u)}var xB=W({nonMaxSuppression_:vB});function wB(e,t,n){let r=kB(e,t,n),s=r<0?-(r+1):r;e.splice(s,0,t)}function kB(e,t,n){return SB(e,t,n||IB)}function IB(e,t){return e>t?1:e<t?-1:0}function SB(e,t,n){let r=0,s=e.length,a=0,o=!1;for(;r<s;){a=r+(s-r>>>1);let i=n(t,e[a]);i>0?r=a+1:(s=a,o=!i)}return o?r:-r-1}function ZS(e,t,n,r,s){return wv(e,t,n,r,s,0)}function JS(e,t,n,r,s,a){return wv(e,t,n,r,s,0,!1,a,!0)}function e0(e,t,n,r,s,a){return wv(e,t,n,r,s,a,!0)}function wv(e,t,n,r,s,a,o=!1,i=!1,u=!1){let l=[];for(let g=0;g<t.length;g++)t[g]>s&&l.push({score:t[g],boxIndex:g,suppressBeginIndex:0});l.sort(t0);let c=a>0?-.5/a:0,d=[],p=[];for(;d.length<n&&l.length>0;){let g=l.pop(),{score:b,boxIndex:y,suppressBeginIndex:v}=g;if(b<s)break;let x=!1;for(let k=d.length-1;k>=v;--k){let T=CB(e,y,d[k]);if(T>=r){x=!0;break}if(g.score=g.score*TB(r,c,T),g.score<=s)break}g.suppressBeginIndex=d.length,x||(g.score===b?(d.push(y),p.push(g.score)):g.score>s&&wB(l,g,t0))}let h=d.length,f=n-h;i&&f>0&&(d.push(...new Array(f).fill(0)),p.push(...new Array(f).fill(0)));let m={selectedIndices:d};return o&&(m.selectedScores=p),u&&(m.validOutputs=h),m}function CB(e,t,n){let r=e.subarray(t*4,t*4+4),s=e.subarray(n*4,n*4+4),a=Math.min(r[0],r[2]),o=Math.min(r[1],r[3]),i=Math.max(r[0],r[2]),u=Math.max(r[1],r[3]),l=Math.min(s[0],s[2]),c=Math.min(s[1],s[3]),d=Math.max(s[0],s[2]),p=Math.max(s[1],s[3]),h=(i-a)*(u-o),f=(d-l)*(p-c);if(h<=0||f<=0)return 0;let m=Math.max(a,l),g=Math.max(o,c),b=Math.min(i,d),y=Math.min(u,p),v=Math.max(b-m,0)*Math.max(y-g,0);return v/(h+f-v)}function TB(e,t,n){let r=Math.exp(t*n*n);return n<=e?r:0}function t0(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}async function NB(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY){let a=$(e,"boxes","nonMaxSuppressionAsync"),o=$(t,"scores","nonMaxSuppressionAsync"),i=Ac(a,o,n,r,s);n=i.maxOutputSize,r=i.iouThreshold,s=i.scoreThreshold;let u=await Promise.all([a.data(),o.data()]),l=u[0],c=u[1],{selectedIndices:d}=ZS(l,c,n,r,s);return a!==e&&a.dispose(),o!==t&&o.dispose(),je(d,"int32")}var _B=NB;function EB(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,a=0){let o=$(e,"boxes","nonMaxSuppression"),i=$(t,"scores","nonMaxSuppression"),u=Ac(o,i,n,r,s,a);n=u.maxOutputSize,r=u.iouThreshold,s=u.scoreThreshold,a=u.softNmsSigma;let l={boxes:o,scores:i},c={maxOutputSize:n,iouThreshold:r,scoreThreshold:s,softNmsSigma:a},d=z.runKernel(ui,l,c);return{selectedIndices:d[0],selectedScores:d[1]}}var AB=W({nonMaxSuppressionWithScore_:EB});async function $B(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,a=0){let o=$(e,"boxes","nonMaxSuppressionAsync"),i=$(t,"scores","nonMaxSuppressionAsync"),u=Ac(o,i,n,r,s,a);n=u.maxOutputSize,r=u.iouThreshold,s=u.scoreThreshold,a=u.softNmsSigma;let l=await Promise.all([o.data(),i.data()]),c=l[0],d=l[1],{selectedIndices:p,selectedScores:h}=e0(c,d,n,r,s,a);return o!==e&&o.dispose(),i!==t&&i.dispose(),{selectedIndices:je(p,"int32"),selectedScores:je(h)}}var FB=$B;function DB(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,a=!1){let o=$(e,"boxes","nonMaxSuppression"),i=$(t,"scores","nonMaxSuppression"),u=Ac(o,i,n,r,s,null),l=u.maxOutputSize,c=u.iouThreshold,d=u.scoreThreshold,p={boxes:o,scores:i},h={maxOutputSize:l,iouThreshold:c,scoreThreshold:d,padToMaxOutputSize:a},f=z.runKernel(ac,p,h);return{selectedIndices:f[0],validOutputs:f[1]}}var RB=W({nonMaxSuppressionPadded_:DB});async function PB(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,a=!1){let o=$(e,"boxes","nonMaxSuppressionAsync"),i=$(t,"scores","nonMaxSuppressionAsync"),u=Ac(o,i,n,r,s,null),l=u.maxOutputSize,c=u.iouThreshold,d=u.scoreThreshold,[p,h]=await Promise.all([o.data(),i.data()]),{selectedIndices:f,validOutputs:m}=JS(p,h,l,c,d,a);return o!==e&&o.dispose(),i!==t&&i.dispose(),{selectedIndices:je(f,"int32"),validOutputs:ke(m,"int32")}}var OB=PB;function MB(e,t,n=!1,r=!1){let s=$(e,"images","resizeBilinear");P(s.rank===3||s.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${s.rank}.`),P(t.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`),P(r===!1||n===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let a=s,o=!1;s.rank===3&&(o=!0,a=G(s,[1,s.shape[0],s.shape[1],s.shape[2]]));let[]=t,i={images:a},u={alignCorners:n,halfPixelCenters:r,size:t},l=z.runKernel(Va,i,u);return o?G(l,[l.shape[1],l.shape[2],l.shape[3]]):l}var LB=W({resizeBilinear_:MB});function BB(e,t,n=!1,r=!1){let s=$(e,"images","resizeNearestNeighbor");P(s.rank===3||s.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${s.rank}.`),P(t.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`),P(s.dtype==="float32"||s.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),P(r===!1||n===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let a=s,o=!1;s.rank===3&&(o=!0,a=G(s,[1,s.shape[0],s.shape[1],s.shape[2]]));let[]=t,i={images:a},u={alignCorners:n,halfPixelCenters:r,size:t},l=z.runKernel(uc,i,u);return o?G(l,[l.shape[1],l.shape[2],l.shape[3]]):l}var zB=W({resizeNearestNeighbor_:BB});function WB(e,t="binary",n=!1,r=.5){let s=$(e,"image","threshold"),a=.2989,o=.587,i=.114,u=s.shape[0]*s.shape[1],l=V(je([r]),255),c,d,p,h;if(P(s.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${s.rank}.`),P(s.shape[2]===3||s.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${s.shape[2]}.`),P(s.dtype==="int32"||s.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${s.dtype}.`),P(t==="otsu"||t==="binary",()=>`Method must be binary or otsu, but was ${t}`),s.shape[2]===3){[c,d,p]=sr(s,[1,1,1],-1);let g=V(c,a),b=V(d,o),y=V(p,i);h=Z(Z(g,b),y)}else h=e;if(t==="otsu"){let g=Uy(ue(iv(h),"int32"),er([]),256);l=VB(g,u)}let f=n?Wi(h,l):nr(h,l);return ue(V(f,255),"int32")}function VB(e,t){let n=je([-1]),r=je([0]),s=je([0]),a,o,i,u,l,c;for(let d=0;d<e.size-1;d++){a=Ve(e,0,d+1),o=Ve(e,d+1),l=me(ve(a),t),c=me(ve(o),t);let p=ve(V(a,Nc(0,a.size)));i=me(p,ve(a));let h=_n(o.shape,a.size),f=Z(Nc(0,o.size),h),m=V(o,f);u=me(ve(m),ve(o));let g=he(i,u),b=he(i,u),y=V(l,c);s=V(V(y,g),b);let v=nr(s,r);r=Cn(v,s,r),n=Cn(v,je([d]),n)}return n}var UB=W({threshold_:WB});function GB(e,t,n="nearest",r="constant",s=0,a){let o=$(e,"image","transform","float32"),i=$(t,"transforms","transform","float32");P(o.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${o.rank}.`),P(i.rank===2&&(i.shape[0]===o.shape[0]||i.shape[0]===1)&&i.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),P(a==null||a.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${a}.`);let u={image:o,transforms:i},l={interpolation:n,fillMode:r,fillValue:s,outputShape:a};return z.runKernel(Ci,u,l)}var HB=W({transform_:GB});function jB(e,t,n){P(t%1==0,()=>`bandPart(): numLower must be an integer, got ${t}.`),P(n%1==0,()=>`bandPart(): numUpper must be an integer, got ${n}.`);let r=$(e,"a","bandPart");P(r.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`);let s=r.shape,[a,o]=r.shape.slice(-2);if(!(t<=a))throw new Error(`bandPart(): numLower (${t}) must not be greater than the number of rows (${a}).`);if(!(n<=o))throw new Error(`bandPart(): numUpper (${n}) must not be greater than the number of columns (${o}).`);t<0&&(t=a),n<0&&(n=o);let i=G(Nc(0,a,1,"int32"),[-1,1]),u=Nc(0,o,1,"int32"),l=he(i,u),c=Hr(Wi(l,ke(+t,"int32")),zi(l,ke(-n,"int32"))),d=kt([a,o],r.dtype);return G(Ut(vt(G(r,[-1,a,o])).map(p=>Cn(c,p,d))),s)}var qB=W({bandPart_:jB});function KB(e){let t;if(Array.isArray(e)){t=!1,P(e!=null&&e.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");let s=e[0].shape[0];for(let a=1;a<e.length;++a)P(e[a].shape[0]===s,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[a].shape[0]} vs. ${s})`)}else t=!0,e=sr(e,e.shape[0],0).map(s=>Rs(s,[0]));P(e.length<=e[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`);let n=[],r=e;for(let s=0;s<e.length;++s)n.push(z.tidy(()=>{let a=r[s];if(s>0)for(let o=0;o<s;++o){let i=V(ve(V(n[o],a)),n[o]);a=he(a,i)}return me(a,bv(a,"euclidean"))}));return t?Ut(n,0):n}var XB=W({gramSchmidt_:KB});function YB(e,t=!1){if(P(e.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`),e.rank===2)return n0(e,t);{let n=e.shape.slice(0,e.shape.length-2).reduce((u,l)=>u*l),r=vt(G(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),s=[],a=[];r.forEach(u=>{let[l,c]=n0(u,t);s.push(l),a.push(c)});let o=G(Ut(s,0),e.shape),i=G(Ut(a,0),e.shape);return[o,i]}}function n0(e,t=!1){return z.tidy(()=>{P(e.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`);let n=e.shape[0],r=e.shape[1],s=Yy(n),a=Fs(e),o=jr([[1]],[1,1]),i=Fs(o),u=n>=r?r:n;for(let l=0;l<u;++l){let c=a,d=i,p=s;[i,a,s]=z.tidy(()=>{let h=Ve(a,[l,l],[n-l,1]),f=bv(h),m=Ve(a,[l,l],[1,1]),g=Cn(nr(m,0),jr([[-1]]),jr([[1]])),b=he(m,V(g,f)),y=me(h,b);y.shape[0]===1?i=Fs(o):i=ot([o,Ve(y,[1,0],[y.shape[0]-1,y.shape[1]])],0);let v=Ft(me(Re(g,b),f)),x=Ve(a,[l,0],[n-l,r]),k=V(v,i),T=Oe(i);if(l===0)a=he(x,Re(k,Re(T,x)));else{let F=he(x,Re(k,Re(T,x)));a=ot([Ve(a,[0,0],[l,r]),F],0)}let C=Oe(k),E=Ve(s,[0,l],[n,s.shape[1]-l]);if(l===0)s=he(E,Re(Re(E,i),C));else{let F=he(E,Re(Re(E,i),C));s=ot([Ve(s,[0,0],[n,l]),F],1)}return[i,a,s]}),Fe([c,d,p])}return!t&&n>r&&(s=Ve(s,[0,0],[n,r]),a=Ve(a,[0,0],[r,r])),[s,a]})}var QB=W({qr_:YB}),En;(function(e){e[e.NONE=0]="NONE",e[e.MEAN=1]="MEAN",e[e.SUM=2]="SUM",e[e.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(En||(En={}));function ZB(e,t,n=En.SUM_BY_NONZERO_WEIGHTS){let r=$(e,"losses","computeWeightedLoss"),s=null;t!=null&&(s=$(t,"weights","computeWeightedLoss"));let a=s==null?r:V(r,s);if(n===En.NONE)return a;if(n===En.SUM)return ve(a);if(n===En.MEAN){if(s==null)return Ot(a);{let o=r.size/s.size,i=me(ve(a),ve(s));return o>1?me(i,ke(o)):i}}if(n===En.SUM_BY_NONZERO_WEIGHTS){if(s==null)return me(ve(a),ke(r.size));{let o=V(s,rr(r.shape)),i=ue(ve(Cc(o,ke(0))),"float32");return me(ve(a),i)}}throw Error(`Unknown reduction: ${n}`)}var Ps=W({computeWeightedLoss_:ZB});function JB(e,t,n,r=En.SUM_BY_NONZERO_WEIGHTS){let s=$(e,"labels","absoluteDifference"),a=$(t,"predictions","absoluteDifference"),o=null;n!=null&&(o=$(n,"weights","absoluteDifference")),wn(s.shape,a.shape,"Error in absoluteDifference: ");let i=Xt(he(s,a));return Ps(i,o,r)}var ez=W({absoluteDifference_:JB});function tz(e,t,n,r,s=En.SUM_BY_NONZERO_WEIGHTS){let a=$(e,"labels","cosineDistance"),o=$(t,"predictions","cosineDistance"),i=null;r!=null&&(i=$(r,"weights","cosineDistance")),wn(a.shape,o.shape,"Error in cosineDistance: ");let u=ke(1),l=he(u,ve(V(a,o),n,!0));return Ps(l,i,s)}var nz=W({cosineDistance_:tz});function rz(e,t,n,r=En.SUM_BY_NONZERO_WEIGHTS){let s=$(e,"labels","hingeLoss"),a=$(t,"predictions","hingeLoss"),o=null;n!=null&&(o=$(n,"weights","hingeLoss")),wn(s.shape,a.shape,"Error in hingeLoss: ");let i=ke(1);s=he(V(ke(2),s),i);let u=Qe(he(i,V(s,a)));return Ps(u,o,r)}var sz=W({hingeLoss_:rz});function az(e,t,n,r=1,s=En.SUM_BY_NONZERO_WEIGHTS){let a=$(e,"labels","huberLoss"),o=$(t,"predictions","huberLoss"),i=null;n!=null&&(i=$(n,"weights","huberLoss")),wn(a.shape,o.shape,"Error in huberLoss: ");let u=ke(r),l=Xt(he(o,a)),c=Td(l,u),d=he(l,c),p=Z(V(ke(.5),ft(c)),V(u,d));return Ps(p,i,s)}var oz=W({huberLoss_:az});function iz(e,t,n,r=1e-7,s=En.SUM_BY_NONZERO_WEIGHTS){let a=$(e,"labels","logLoss"),o=$(t,"predictions","logLoss"),i=null;n!=null&&(i=$(n,"weights","logLoss")),wn(a.shape,o.shape,"Error in logLoss: ");let u=ke(1),l=ke(r),c=Ft(V(a,gr(Z(o,l)))),d=V(he(u,a),gr(Z(he(u,o),l))),p=he(c,d);return Ps(p,i,s)}var uz=W({logLoss_:iz});function cz(e,t,n,r=En.SUM_BY_NONZERO_WEIGHTS){let s=$(e,"labels","meanSquaredError"),a=$(t,"predictions","meanSquaredError"),o=null;n!=null&&(o=$(n,"weights","meanSquaredError")),wn(s.shape,a.shape,"Error in meanSquaredError: ");let i=fv(s,a);return Ps(i,o,r)}var lz=W({meanSquaredError_:cz});function dz(e,t){let n=$(e,"labels","sigmoidCrossEntropyWithLogits"),r=$(t,"logits","sigmoidCrossEntropyWithLogits");wn(n.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");let s=Qe(r),a=V(r,n),o=af(Tn(Ft(Xt(r))));return Z(he(s,a),o)}function pz(e,t,n,r=0,s=En.SUM_BY_NONZERO_WEIGHTS){let a=$(e,"multiClassLabels","sigmoidCrossEntropy"),o=$(t,"logits","sigmoidCrossEntropy"),i=null;if(n!=null&&(i=$(n,"weights","sigmoidCrossEntropy")),wn(a.shape,o.shape,"Error in sigmoidCrossEntropy: "),r>0){let l=ke(r),c=ke(1),d=ke(.5);a=Z(V(a,he(c,l)),V(d,l))}let u=dz(a,o);return Ps(u,i,s)}var hz=W({sigmoidCrossEntropy_:pz});function fz(e,t,n=-1){if(n===-1&&(n=t.rank-1),n!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${n}`);return cs((s,a,o)=>{let u=_S(a,[n],!0),l=he(ue(a,"float32"),u);o([s,l]);let c=Ft(V(l,s));return{value:ve(c,[n]),gradFunc:(h,f)=>{let[m,g]=f,b=Vi(h.shape,[n]);return[V(G(h,b),he(ue(m,"float32"),Tn(g))),V(G(h,b),he(Tn(g),ue(m,"float32")))]}}})(e,t)}function mz(e,t,n,r=0,s=En.SUM_BY_NONZERO_WEIGHTS){let a=$(e,"onehotLabels","softmaxCrossEntropy"),o=$(t,"logits","softmaxCrossEntropy"),i=null;if(n!=null&&(i=$(n,"weights","softmaxCrossEntropy")),wn(a.shape,o.shape,"Error in softmaxCrossEntropy: "),r>0){let l=ke(r),c=ke(1),d=ke(a.shape[1]);a=Z(V(a,he(c,l)),me(l,d))}let u=fz(a,o);return Ps(u,i,s)}var gz=W({softmaxCrossEntropy_:mz});function bz(e,t,n,r){let s=$(e,"indices","sparseFillEmptyRows","int32"),a=$(t,"values","sparseFillEmptyRows"),o=$(n,"denseShape","sparseFillEmptyRows","int32"),i=$(r,"defaultValue","sparseFillEmptyRows",a.dtype);if(s.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${s.shape}`);if(a.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${a.shape}`);if(o.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${o.shape}`);if(i.rank!==0)throw new Error(`Default value should be a scalar but received shape ${i.shape}`);let u={indices:s,values:a,denseShape:o,defaultValue:i},l=z.runKernel(rd,u);return{outputIndices:l[0],outputValues:l[1],emptyRowIndicator:l[2],reverseIndexMap:l[3]}}var yz=W({sparseFillEmptyRows_:bz});function vz(e,t,n){let r=$(e,"inputIndices","sparseReshape","int32"),s=$(t,"inputShape","sparseReshape","int32"),a=$(n,"newShape","sparseReshape","int32");if(r.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${r.shape}`);if(s.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${s.shape}`);if(a.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${a.shape}`);let o={inputIndices:r,inputShape:s,newShape:a},i=z.runKernel(pc,o);return{outputIndices:i[0],outputShape:i[1]}}var xz=W({sparseReshape_:vz});function wz(e,t,n){let r=$(e,"data","sparseSegmentMean"),s=$(t,"indices","sparseSegmentMean","int32"),a=$(n,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${s.shape}`);if(a.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${a.shape}`);let o={data:r,indices:s,segmentIds:a};return z.runKernel(sd,o)}var kz=W({sparseSegmentMean_:wz});function Iz(e,t,n){let r=$(e,"data","sparseSegmentSum"),s=$(t,"indices","sparseSegmentSum","int32"),a=$(n,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${s.shape}`);if(a.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${a.shape}`);let o={data:r,indices:s,segmentIds:a};return z.runKernel(ad,o)}var Sz=W({sparseSegmentSum_:Iz});function Cz(e,t,n,r,s,a,o,i){let u=$(e,"data","stringNGrams","string");if(u.dtype!=="string")throw new Error("Data must be of datatype string");if(u.shape.length!==1)throw new Error(`Data must be a vector, saw: ${u.shape}`);let l=$(t,"dataSplits","stringNGrams");if(l.dtype!=="int32")throw new Error("Data splits must be of datatype int32");let c={separator:n,nGramWidths:r,leftPad:s,rightPad:a,padWidth:o,preserveShortSequences:i},d={data:u,dataSplits:l},p=z.runKernel(id,d,c);return{nGrams:p[0],nGramsSplits:p[1]}}var Tz=W({stringNGrams_:Cz});function Nz(e,t,n=!0){let r=$(e,"input","stringSplit","string"),s=$(t,"delimiter","stringSplit","string");if(r.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(s.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${s.shape}`);let a={skipEmpty:n},o={input:r,delimiter:s},i=z.runKernel(Bh,o,a);return{indices:i[0],values:i[1],shape:i[2]}}var _z=W({stringSplit_:Nz});function Ez(e,t){let n=$(e,"input","stringToHashBucketFast","string"),r={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");let s={input:n};return z.runKernel(zh,s,r)}var Az=W({stringToHashBucketFast_:Ez}),$z={fft:ff,ifft:Ed,rfft:mf,irfft:hv},Fz={hammingWindow:oB,hannWindow:YS,frame:QS,stft:lB},ar={flipLeftRight:fB,grayscaleToRGB:gB,resizeNearestNeighbor:zB,resizeBilinear:LB,rotateWithOffset:yB,cropAndResize:pB,nonMaxSuppression:xB,nonMaxSuppressionAsync:_B,nonMaxSuppressionWithScore:AB,nonMaxSuppressionWithScoreAsync:FB,nonMaxSuppressionPadded:RB,nonMaxSuppressionPaddedAsync:OB,threshold:UB,transform:HB},r0={bandPart:qB,gramSchmidt:XB,qr:QB},Dz={absoluteDifference:ez,computeWeightedLoss:Ps,cosineDistance:nz,hingeLoss:sz,huberLoss:oz,logLoss:uz,meanSquaredError:lz,sigmoidCrossEntropy:hz,softmaxCrossEntropy:gz},$d={sparseFillEmptyRows:yz,sparseReshape:xz,sparseSegmentMean:kz,sparseSegmentSum:Sz},wf={stringNGrams:Tz,stringSplit:_z,stringToHashBucketFast:Az},Os=class extends z1{minimize(e,t=!1,n){let{value:r,grads:s}=this.computeGradients(e,n);if(n!=null){let a=n.map(o=>({name:o.name,tensor:s[o.name]}));this.applyGradients(a)}else this.applyGradients(s);return Fe(s),t?r:(r.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return SS(e,t)}dispose(){this.iterations_!=null&&Fe(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:ke(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}};Object.defineProperty(Os,Symbol.hasInstance,{value:e=>e.minimize!=null&&e.computeGradients!=null&&e.applyGradients!=null});var kf=class extends Os{constructor(e,t,n=null){super();this.learningRate=e,this.rho=t,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],n==null&&(this.epsilon=z.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(n=>n.name):Object.keys(e)).forEach((n,r)=>{let s=z.registeredVariables[n],a=!1;this.accumulatedGrads[r]==null&&(this.accumulatedGrads[r]={originalName:`${n}/accum_grad`,variable:M(()=>Xe(s).variable(a))}),this.accumulatedUpdates[r]==null&&(this.accumulatedUpdates[r]={originalName:`${n}/accum_var`,variable:M(()=>Xe(s).variable(a))});let o=Array.isArray(e)?e[r].tensor:e[n];if(o==null)return;let i=this.accumulatedGrads[r].variable,u=this.accumulatedUpdates[r].variable;M(()=>{let l=Z(V(i,this.rho),V(ft(o),1-this.rho)),c=V(me(vn(Z(u,this.epsilon)),vn(Z(i,this.epsilon))),o),d=Z(V(u,this.rho),V(ft(c),1-this.rho));i.assign(l),u.assign(d);let p=Z(V(c,-this.learningRate),s);s.assign(p)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(Fe(this.accumulatedGrads.map(e=>e.variable)),Fe(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){let e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=e.length/2,n=!1;this.accumulatedGrads=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(n)})),this.accumulatedUpdates=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}};kf.className="Adadelta";lo(kf);var If=class extends Os{constructor(e,t=.1){super();this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(n=>n.name):Object.keys(e)).forEach((n,r)=>{let s=z.registeredVariables[n];if(this.accumulatedGrads[r]==null){let i=!1;this.accumulatedGrads[r]={originalName:`${n}/accumulator`,variable:M(()=>_n(s.shape,this.initialAccumulatorValue).variable(i))}}let a=Array.isArray(e)?e[r].tensor:e[n];if(a==null)return;let o=this.accumulatedGrads[r].variable;M(()=>{let i=Z(o,ft(a));o.assign(i);let u=Z(V(me(a,vn(Z(i,z.backend.epsilon()))),-this.learningRate),s);s.assign(u)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&Fe(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=!1;this.accumulatedGrads=e.map(n=>({originalName:n.name,variable:n.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}};If.className="Adagrad";lo(If);var Sf=class extends Os{constructor(e,t,n,r=null){super();this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],M(()=>{this.accBeta1=ke(t).variable(),this.accBeta2=ke(n).variable()}),r==null&&(this.epsilon=z.backend.epsilon())}applyGradients(e){let t=Array.isArray(e)?e.map(n=>n.name):Object.keys(e);M(()=>{let n=he(1,this.accBeta1),r=he(1,this.accBeta2);t.forEach((s,a)=>{let o=z.registeredVariables[s],i=!1;this.accumulatedFirstMoment[a]==null&&(this.accumulatedFirstMoment[a]={originalName:`${s}/m`,variable:M(()=>Xe(o).variable(i))}),this.accumulatedSecondMoment[a]==null&&(this.accumulatedSecondMoment[a]={originalName:`${s}/v`,variable:M(()=>Xe(o).variable(i))});let u=Array.isArray(e)?e[a].tensor:e[s];if(u==null)return;let l=this.accumulatedFirstMoment[a].variable,c=this.accumulatedSecondMoment[a].variable,d=Z(V(l,this.beta1),V(u,1-this.beta1)),p=Z(V(c,this.beta2),V(ft(u),1-this.beta2)),h=me(d,n),f=me(p,r);l.assign(d),c.assign(p);let m=Z(V(me(h,Z(vn(f),this.epsilon)),-this.learningRate),o);o.assign(m)}),this.accBeta1.assign(V(this.accBeta1,this.beta1)),this.accBeta2.assign(V(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&Fe(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedSecondMoment!=null&&Fe(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){let e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e),M(()=>{this.accBeta1.assign(fo(this.beta1,this.iterations_+1)),this.accBeta2.assign(fo(this.beta2,this.iterations_+1))});let t=e.length/2,n=!1;this.accumulatedFirstMoment=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(n)})),this.accumulatedSecondMoment=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}};Sf.className="Adam";lo(Sf);var Cf=class extends Os{constructor(e,t,n,r=null,s=0){super();this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.decay=s,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],M(()=>{this.iteration=ke(0).variable(),this.accBeta1=ke(t).variable()}),r==null&&(this.epsilon=z.backend.epsilon())}applyGradients(e){let t=Array.isArray(e)?e.map(n=>n.name):Object.keys(e);M(()=>{let n=he(1,this.accBeta1),r=me(-this.learningRate,Z(V(this.iteration,this.decay),1));t.forEach((s,a)=>{let o=z.registeredVariables[s],i=!1;this.accumulatedFirstMoment[a]==null&&(this.accumulatedFirstMoment[a]={originalName:`${s}/m`,variable:Xe(o).variable(i)}),this.accumulatedWeightedInfNorm[a]==null&&(this.accumulatedWeightedInfNorm[a]={originalName:`${s}/v`,variable:Xe(o).variable(i)});let u=Array.isArray(e)?e[a].tensor:e[s];if(u==null)return;let l=this.accumulatedFirstMoment[a].variable,c=this.accumulatedWeightedInfNorm[a].variable,d=Z(V(l,this.beta1),V(u,1-this.beta1)),p=V(c,this.beta2),h=Xt(u),f=Ds(p,h);l.assign(d),c.assign(f);let m=Z(V(me(r,n),me(d,Z(f,this.epsilon))),o);o.assign(m)}),this.iteration.assign(Z(this.iteration,1)),this.accBeta1.assign(V(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&Fe(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedWeightedInfNorm!=null&&Fe(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}};Cf.className="Adamax";lo(Cf);var Fd=class extends Os{constructor(e){super();this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(n=>n.name):Object.keys(e)).forEach((n,r)=>{let s=Array.isArray(e)?e[r].tensor:e[n];if(s==null)return;let a=z.registeredVariables[n];M(()=>{let o=Z(V(this.c,s),a);a.assign(o)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,this.c!=null&&this.c.dispose(),this.c=nn(ke(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),e.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}};Fd.className="SGD";lo(Fd);var Tf=class extends Fd{constructor(e,t,n=!1){super(e);this.learningRate=e,this.momentum=t,this.useNesterov=n,this.accumulations=[],this.m=ke(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(n=>n.name):Object.keys(e)).forEach((n,r)=>{let s=z.registeredVariables[n];if(this.accumulations[r]==null){let i=!1;this.accumulations[r]={originalName:`${n}/momentum`,variable:M(()=>Xe(s).variable(i))}}let a=this.accumulations[r].variable,o=Array.isArray(e)?e[r].tensor:e[n];o!=null&&M(()=>{let i,u=Z(V(this.m,a),o);this.useNesterov?i=Z(V(this.c,Z(o,V(u,this.m))),s):i=Z(V(this.c,u),s),a.assign(u),s.assign(i)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&Fe(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=!1;this.accumulations=e.map(n=>({originalName:n.name,variable:n.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}};Tf.className="Momentum";lo(Tf);var Nf=class extends Os{constructor(e,t=.9,n=0,r=null,s=!1){super();if(this.learningRate=e,this.decay=t,this.momentum=n,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=s,r==null&&(this.epsilon=z.backend.epsilon()),e==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(n=>n.name):Object.keys(e)).forEach((n,r)=>{let s=z.registeredVariables[n],a=!1;this.accumulatedMeanSquares[r]==null&&(this.accumulatedMeanSquares[r]={originalName:`${n}/rms`,variable:M(()=>Xe(s).variable(a))}),this.accumulatedMoments[r]==null&&(this.accumulatedMoments[r]={originalName:`${n}/momentum`,variable:M(()=>Xe(s).variable(a))}),this.accumulatedMeanGrads[r]==null&&this.centered&&(this.accumulatedMeanGrads[r]={originalName:`${n}/mg`,variable:M(()=>Xe(s).variable(a))});let o=Array.isArray(e)?e[r].tensor:e[n];if(o==null)return;let i=this.accumulatedMeanSquares[r].variable,u=this.accumulatedMoments[r].variable;M(()=>{let l=Z(V(i,this.decay),V(ft(o),1-this.decay));if(this.centered){let c=this.accumulatedMeanGrads[r].variable,d=Z(V(c,this.decay),V(o,1-this.decay)),p=me(V(o,this.learningRate),vn(he(l,Z(ft(d),this.epsilon)))),h=Z(V(u,this.momentum),p);i.assign(l),c.assign(d),u.assign(h);let f=he(s,h);s.assign(f)}else{let c=Z(V(i,this.decay),V(ft(o),1-this.decay)),d=Z(V(u,this.momentum),me(V(o,this.learningRate),vn(Z(c,this.epsilon))));i.assign(c),u.assign(d);let p=he(s,d);s.assign(p)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&Fe(this.accumulatedMeanSquares.map(e=>e.variable)),this.accumulatedMeanGrads!=null&&this.centered&&Fe(this.accumulatedMeanGrads.map(e=>e.variable)),this.accumulatedMoments!=null&&Fe(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){let e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=this.centered?e.length/3:e.length/2,n=!1;this.accumulatedMeanSquares=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(n)})),this.accumulatedMoments=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(n)})),this.centered&&(this.accumulatedMeanGrads=e.slice(t*2,t*3).map(r=>({originalName:r.name,variable:r.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}};Nf.className="RMSProp";lo(Nf);var go=class{static sgd(e){return new Fd(e)}static momentum(e,t,n=!1){return new Tf(e,t,n)}static rmsprop(e,t=.9,n=0,r=null,s=!1){return new Nf(e,t,n,r,s)}static adam(e=.001,t=.9,n=.999,r=null){return new Sf(e,t,n,r)}static adadelta(e=.001,t=.95,n=null){return new kf(e,t,n)}static adamax(e=.002,t=.9,n=.999,r=null,s=0){return new Cf(e,t,n,r,s)}static adagrad(e,t=.1){return new If(e,t)}},Ui={sgd:go.sgd,momentum:go.momentum,adadelta:go.adadelta,adagrad:go.adagrad,rmsprop:go.rmsprop,adamax:go.adamax,adam:go.adam},Rz=(()=>typeof requestAnimationFrame!="undefined"?requestAnimationFrame:typeof setImmediate!="undefined"?setImmediate:e=>e())();function s0(){return new Promise(e=>Rz(()=>e()))}var N={};Ee(N,{ERF_A1:()=>Hz,ERF_A2:()=>jz,ERF_A3:()=>qz,ERF_A4:()=>Kz,ERF_A5:()=>Xz,ERF_P:()=>Gz,PARALLELIZE_THRESHOLD:()=>kv,SELU_SCALE:()=>o0,SELU_SCALEALPHA:()=>a0,applyActivation:()=>vf,assertAndGetBroadcastShape:()=>ht,assertAxesAreInnerMostDims:()=>qO,assertParamsConsistent:()=>Pz,assignToTypedArray:()=>tW,axesAreInnerMostDims:()=>Jy,calculateShapes:()=>E1,checkEinsumDimSizes:()=>iW,checkPadOnDimRoundingMode:()=>Sn,combineLocations:()=>CS,complexWithEvenIndex:()=>Zz,complexWithOddIndex:()=>Jz,computeConv2DInfo:()=>kd,computeConv3DInfo:()=>tS,computeDefaultPad:()=>zy,computeDilation2DInfo:()=>hP,computeOptimalWindowSize:()=>Mz,computeOutAndReduceShapes:()=>TS,computeOutShape:()=>Oz,computePool2DInfo:()=>eS,computePool3DInfo:()=>fP,convertConv2DDataFormat:()=>nS,decodeEinsumEquation:()=>aW,eitherStridesOrDilationsAreOne:()=>us,expandShapeToKeepDim:()=>Vi,exponent:()=>rW,exponents:()=>nW,fromStringArrayToUint8:()=>_W,fromUint8ToStringArray:()=>NW,getAxesPermutation:()=>NS,getBroadcastDims:()=>T1,getComplexWithIndex:()=>eW,getEinsumComputePath:()=>uW,getEinsumPermutation:()=>oW,getFusedBiasGradient:()=>yf,getFusedDyActivation:()=>bf,getImageCenter:()=>Lz,getInnerMostAxes:()=>KO,getPermuted:()=>zz,getReductionAxes:()=>zt,getReshaped:()=>Bz,getReshapedPermuted:()=>Wz,getSliceBeginCoords:()=>Vz,getSliceSize:()=>Uz,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>pW,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>hW,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>fW,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>bW,getSparseReshapeInputOutputMismatchErrorMessage:()=>vW,getSparseReshapeInputOutputMultipleErrorMessage:()=>yW,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>mW,getSparseReshapeNegativeOutputDimErrorMessage:()=>gW,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>IW,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>xW,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>wW,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>kW,getUndoAxesPermutation:()=>ev,isIdentityPermutation:()=>cW,log:()=>PD,mergeRealAndImagArrays:()=>Yz,prepareAndValidate:()=>_1,prepareSplitSize:()=>dW,segment_util:()=>c0,shouldFuse:()=>xf,slice_util:()=>$t,splitRealAndImagArrays:()=>Qz,tupleValuesAreOne:()=>po,upcastType:()=>In,validateInput:()=>Fy,validateUpdateShape:()=>$y,warn:()=>so});function Pz(e,t){let n=e[0].length;e.forEach((s,a)=>{P(s.length===n,()=>`Error in concat${n}D: rank of tensors[${a}] must be the same as the rank of the rest (${n})`)}),P(t>=0&&t<n,()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`);let r=e[0];e.forEach((s,a)=>{for(let o=0;o<n;o++)P(o===t||s[o]===r[o],()=>`Error in concat${n}D: Shape of tensors[${a}] (${s}) does not match the shape of the rest (${r}) along the non-concatenated axis ${a}.`)})}function Oz(e,t){let n=e[0].slice();for(let r=1;r<e.length;r++)n[t]+=e[r][t];return n}var kv=30;function Mz(e){return e<=kv?e:hh(e,Math.floor(Math.sqrt(e)))}function Lz(e,t,n){let r=n*(typeof e=="number"?e:e[0]),s=t*(typeof e=="number"?e:e[1]);return[r,s]}function Bz(e,t,n,r=!0){let s=[];if(r)s=s.concat(t.slice(0)),s.push(e[0]/n),s=s.concat(e.slice(1));else{s=s.concat(e[0]);let a=t.length;for(let o=0;o<a;++o)s=s.concat([e[o+1]/t[o],t[o]]);s=s.concat(e.slice(a+1))}return s}function zz(e,t,n=!0){let r=[];if(n){r.push(t);for(let s=t+1;s<e;++s)s<=2*t?(r.push(s),r.push(s-(t+1))):r.push(s)}else{let s=[],a=[];for(let o=1;o<e;++o)o>=t*2+1||o%2==1?a.push(o):s.push(o);r.push(...s),r.push(0),r.push(...a)}return r}function Wz(e,t,n,r=!0){let s=[];r?s.push(e[0]/n):s.push(e[0]*n);for(let a=1;a<e.length;++a)a<=t.length?r?s.push(t[a-1]*e[a]):s.push(e[a]/t[a-1]):s.push(e[a]);return s}function Vz(e,t){let n=[0];for(let r=0;r<t;++r)n.push(e[r][0]);return n}function Uz(e,t,n){let r=e.slice(0,1);for(let s=0;s<n;++s)r.push(e[s+1]-t[s][0]-t[s][1]);return r}var a0=1.7580993408473768,o0=1.0507009873554805,Gz=.3275911,Hz=.254829592,jz=-.284496736,qz=1.421413741,Kz=-1.453152027,Xz=1.061405429;function Yz(e,t){if(e.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`);let n=new Float32Array(e.length*2);for(let r=0;r<n.length;r+=2)n[r]=e[r/2],n[r+1]=t[r/2];return n}function Qz(e){let t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let r=0;r<e.length;r+=2)t[r/2]=e[r],n[r/2]=e[r+1];return{real:t,imag:n}}function Zz(e){let t=Math.ceil(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let s=0;s<e.length;s+=4)n[Math.floor(s/4)]=e[s],r[Math.floor(s/4)]=e[s+1];return{real:n,imag:r}}function Jz(e){let t=Math.floor(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let s=2;s<e.length;s+=4)n[Math.floor(s/4)]=e[s],r[Math.floor(s/4)]=e[s+1];return{real:n,imag:r}}function eW(e,t){let n=e[t*2],r=e[t*2+1];return{real:n,imag:r}}function tW(e,t,n,r){e[r*2]=t,e[r*2+1]=n}function nW(e,t){let n=new Float32Array(e/2),r=new Float32Array(e/2);for(let s=0;s<Math.ceil(e/2);s++){let a=(t?2:-2)*Math.PI*(s/e);n[s]=Math.cos(a),r[s]=Math.sin(a)}return{real:n,imag:r}}function rW(e,t,n){let r=(n?2:-2)*Math.PI*(e/t),s=Math.cos(r),a=Math.sin(r);return{real:s,imag:a}}var Iv="->",sW=/->/g,i0=",",u0="...";function aW(e,t){e=e.replace(/\s/g,"");let n=(e.length-e.replace(sW,"").length)/Iv.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error(`Equation must contain exactly one arrow ("${Iv}").`);let[r,s]=e.split(Iv);P(r.indexOf(u0)===-1,()=>`The ellipsis notation ("${u0}") is not supported yet.`);let a=r.split(i0),o=a.length;if(t!==o)throw new Error(`Expected ${o} input tensors, received ${t}`);if(o>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");let i=[];for(let p=0;p<s.length;++p){let h=s[p];if(!a.some(f=>f.indexOf(h)!==-1))throw new Error(`Output subscripts contain the label ${h} not present in the input subscripts.`);i.indexOf(h)===-1&&i.push(h)}for(let p=0;p<r.length;++p){let h=r[p];i.indexOf(h)===-1&&h!==i0&&i.push(h)}let u=new Array(a.length);for(let p=0;p<o;++p){if(new Set(a[p].split("")).size!==a[p].length)throw new Error(`Found duplicate axes in input component ${a[p]}. Support for duplicate axes in input is not implemented yet.`);u[p]=[];for(let h=0;h<a[p].length;++h)u[p].push(i.indexOf(a[p][h]))}let l=i.length,c=s.length,d=[];for(let p=c;p<l;++p)d.push(p);return{allDims:i,summedDims:d,idDims:u}}function oW(e,t){let n=new Array(e);n.fill(-1);for(let s=0;s<t.length;++s)n[t[s]]=s;let r=[];for(let s=0;s<e;++s)n[s]===-1&&r.push(s);return n=n.filter(s=>s!==-1),{permutationIndices:n,expandDims:r}}function iW(e,t,n){let r=new Array(e);for(let s=0;s<n.length;++s){let a=n[s].shape;for(let o=0;o<t[s].length;++o)r[t[s][o]]===void 0?r[t[s][o]]=a[o]:P(r[t[s][o]]===a[o],()=>`Expected dimension ${r[t[s][o]]} at axis ${o} of input shaped ${JSON.stringify(a)}, but got dimension ${a[o]}`)}}function uW(e,t){let n=e,r=[],s=0;e.length===0&&n.push(-1),s=e.length+1;for(let o=0;o<s;++o)r.push([]);let a=[];for(let o=0;o<n.length;++o){let i=n[o],u=lW(t,i);for(let l of u)a.indexOf(l)===-1&&(r[o].push(l),a.push(l))}return{path:n,steps:r}}function cW(e){return e.every((t,n)=>t===n)}function lW(e,t){let n=[];for(let r=0;r<e.length;++r)(e[r].length===0||e[r].indexOf(t)!==-1||t===-1)&&n.push(r);return n}function dW(e,t,n=0){let r=[];if(typeof t=="number")P(e.shape[n]%t==0,()=>"Number of splits must evenly divide the axis."),r=new Array(t).fill(e.shape[n]/t);else{let s=t.reduce((o,i)=>(i===-1&&(o+=1),o),0);P(s<=1,()=>"There should be only one negative value in split array.");let a=t.indexOf(-1);if(a!==-1){let o=t.reduce((i,u)=>u>0?i+u:i);t[a]=e.shape[n]-o}P(e.shape[n]===t.reduce((o,i)=>o+i),()=>"The sum of sizes must match the size of the axis dimension."),r=t}return r}function pW(e){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${e}`}function hW(e,t){return`indices(${e}, 0) is invalid: ${t} < 0`}function fW(e,t,n){return`indices(${e}, 0) is invalid: ${t} >= ${n}`}function mW(e,t){return`only one output dimension may be -1, not both ${e} and ${t}`}function gW(e,t){return`size ${e} must be non-negative, not ${t}`}function bW(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function yW(e,t){let n=wt(e),r=wt(t);return`Input to reshape is a SparseTensor with ${n}
  dense values, but the requested shape requires a multiple of ${r}. inputShape=${e} outputShape= ${t}`}function vW(e,t){let n=wt(e),r=wt(t);return`Input to reshape is a tensor with ${n} dense values, but the requested shape has ${r}. inputShape=${e} outputShape=${t}`}function xW(){return"segment ids must be >= 0"}function wW(){return"segment ids are not increasing"}function kW(e,t){return`Segment id ${e} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function IW(e,t,n){return`Bad: indices[${e}] == ${t} out of range [0, ${n})`}var c0={};Ee(c0,{collectGatherOpShapeInfo:()=>TW,computeOutShape:()=>CW,segOpComputeOptimalWindowSize:()=>SW});function SW(e,t){let n=!1,r;for(e<=kv?(r=e,n=!0):r=hh(e,Math.floor(Math.sqrt(e)));!n;)r>t||r===e?n=!0:r=hh(e,r+1);return r}function CW(e,t,n){let r=[],s=e.length;for(let a=0;a<s;a++)a!==t?r.push(e[a]):r.push(n);return r}function TW(e,t,n,r){let s=t.shape.length,a=e.shape.length;if(r!==0&&(r<-s||r>s))throw new Error(`Expect batchDims in the range of [-${s}, ${s}], but got ${r}`);if(r<0&&(r+=s),r>a)throw new Error(`batchDims (${r}) must be less than rank(x) (
    ${a}).`);if(n<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${n}).`);for(let d=0;d<r;++d)if(e.shape[d]!==t.shape[d])throw new Error(`x.shape[${d}]: ${e.shape[d]} should be equal to indices.shape[${d}]: ${t.shape[d]}.`);let o=e.shape[n],i=[],u=1,l=1,c=1;for(let d=0;d<r;++d)i.push(e.shape[d]),u*=e.shape[d];for(let d=r;d<n;d++)i.push(e.shape[d]),l*=e.shape[d];for(let d=r;d<s;d++)i.push(t.shape[d]);for(let d=n+1;d<a;d++)i.push(e.shape[d]),c*=e.shape[d];return{batchSize:u,sliceSize:c,outerSize:l,dimSize:o,outputShape:i}}function NW(e){try{return e.map(t=>jh(t))}catch(t){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`)}}function _W(e){return e.map(t=>hd(t))}var Dr={};Ee(Dr,{nonMaxSuppressionV3Impl:()=>ZS,nonMaxSuppressionV4Impl:()=>JS,nonMaxSuppressionV5Impl:()=>e0,whereImpl:()=>VS});var l0={kernelName:Vo,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>V(e,Ad(ue(n,"float32"),-1))}}},EW={kernelName:Wu,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let r=ft(ue(n,"float32")),s=vn(he(ke(1),r));return Ft(me(e,s))}}}},AW={kernelName:Vu,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let r=vn(he(ft(ue(n,"float32")),1));return me(e,r)}}}},$W={kernelName:_s,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,s=ht(n.shape,r.shape);return{a:()=>{let i=e,u=zt(n.shape,s);return u.length>0&&(i=ve(i,u)),G(i,n.shape)},b:()=>{let i=e,u=zt(r.shape,s);return u.length>0&&(i=ve(i,u)),G(i,r.shape)}}}},FW={kernelName:la,saveAllInputs:!0,gradFunc:(e,t)=>{let n={};return t.forEach((r,s)=>{n[s]=()=>e.clone()}),n}},DW={kernelName:da,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Xe(n)}}},RW={kernelName:Hu,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Xe(n)}}},PW={kernelName:ju,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>me(e,vn(he(ke(1),ft(ue(n,"float32")))))}}},OW={kernelName:qu,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let r=vn(Z(ke(1),ft(ue(n,"float32"))));return me(e,r)}}}},MW={kernelName:Yu,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,s=ht(n.shape,r.shape);return{a:()=>{let i=Z(ft(n),ft(r)),u=V(e,me(r,i)),l=zt(n.shape,s);return l.length>0&&(u=ve(u,l)),G(u,n.shape)},b:()=>{let i=Z(ft(n),ft(r)),u=Ft(V(e,me(n,i))),l=zt(r.shape,s);return l.length>0&&(u=ve(u,l)),G(u,r.shape)}}}},LW={kernelName:Ku,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>me(e,Z(ft(ue(n,"float32")),1))}}},BW={kernelName:Xu,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>me(e,he(ke(1),ft(ue(n,"float32"))))}}};function zW(e,t,n,r,s,a){let o=$(e,"dy","avgPool3dGrad"),i=$(t,"input","avgPool3dGrad"),u=o,l=i,c=!1;i.rank===4&&(c=!0,u=G(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),l=G(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),P(u.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${u.rank}.`),P(l.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${l.rank}.`),Sn("avgPool3dGrad",s,a);let d={dy:u,input:l},p={filterSize:n,strides:r,pad:s,dimRoundingMode:a},h=z.runKernel(gh,d,p);return c?G(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}var WW=W({avgPool3dGrad_:zW}),VW={kernelName:jl,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{filterSize:s,strides:a,pad:o,dimRoundingMode:i}=n;return{x:()=>WW(e,r,s,a,o,i)}}};function UW(e,t,n,r,s){let a=$(e,"dy","avgPoolGrad"),o=$(t,"input","avgPoolGrad");P(o.rank===a.rank,()=>`Rank of input (${o.rank}) does not match rank of dy (${a.rank})`);let i=o,u=a,l=!1;o.rank===3&&(l=!0,i=G(o,[1,o.shape[0],o.shape[1],o.shape[2]]),u=G(a,[1,a.shape[0],a.shape[1],a.shape[2]])),P(u.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${u.rank}.`),P(i.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${i.rank}.`);let c={dy:u,input:i},d={filterSize:n,strides:r,pad:s},p=z.runKernel(mh,c,d);return l?G(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var GW=W({avgPoolGrad_:UW}),HW={kernelName:pa,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{filterSize:s,strides:a,pad:o}=n;return{x:()=>GW(e,r,s,a,o)}}},jW={kernelName:ha,inputsToSave:["a","b"],gradFunc:(e,t,n)=>{let[r,s]=t,{transposeA:a,transposeB:o}=n;return!a&&!o?{a:()=>Re(e,s,!1,!0),b:()=>Re(r,e,!0,!1)}:!a&&o?{a:()=>Re(e,s,!1,!1),b:()=>Re(e,r,!0,!1)}:a&&!o?{a:()=>Re(s,e,!1,!0),b:()=>Re(r,e,!1,!1)}:{a:()=>Re(s,e,!0,!0),b:()=>Re(e,r,!0,!0)}}},qW={kernelName:Uo,gradFunc:(e,t,n)=>{let{blockShape:r,crops:s}=n;return{x:()=>df(e,r,s)}}},KW={kernelName:HI,gradFunc:(e,t,n)=>{let r=n,s=r.inputShape,a=r.shape,o=Array.from(a);for(let u=s.length-1;u>=0;u--)if(s[u]===a[u])o[u]=1;else if(s[u]!==1)throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${a}].`);let i=[];for(let u=0;u<o.length;u++)o[u]>1&&i.push(u);return{x:()=>ve(e,i,!0)}}},XW={kernelName:fa,gradFunc:e=>({x:()=>e.clone()})},YW={kernelName:ma,gradFunc:e=>({x:()=>Xe(e)})},QW={kernelName:Es,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{clipValueMin:s,clipValueMax:a}=n;return{x:()=>Cn(Hr(zi(r,s),Wi(r,a)),e,Xe(e))}}},ZW={kernelName:Kl,inputsToSave:["x"],gradFunc:l0.gradFunc},JW={kernelName:Go,saveAllInputs:!0,gradFunc:(e,t,n)=>{let r=t.map(u=>u.shape),{axis:s}=n,a=Er(s,t[0].shape)[0],o=r.map(u=>u[a]);return sr(e,o,a).map(u=>()=>u)}},e4={kernelName:ga,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let[r,s]=t,{dilations:a,strides:o,pad:i,dataFormat:u}=n;return P(po(a),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`),{x:()=>Hy(r.shape,e,s,o,i,u),filter:()=>xv(r,e,s.shape,o,i,u)}}},t4={kernelName:ba,inputsToSave:["dy","filter"],gradFunc:(e,t,n)=>{let[r,s]=t,{strides:a,pad:o,dataFormat:i,dimRoundingMode:u}=n;return{dy:()=>Wt(e,s,a,o,i,1,u),filter:()=>xv(e,r,s.shape,a,o,i,u)}}};function n4(e,t,n,r,s){let a=e;e.rank===4&&(a=G(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]));let o=t;o.rank===4&&(o=G(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),P(a.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${a.shape}.`),P(o.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${o.shape}.`),P(n.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`),P(a.shape[4]===n[3],()=>`Error in conv3dDerFilter: depth of input ${a.shape[4]}) must match input depth in filter (${n[3]}.`),P(o.shape[4]===n[4],()=>`Error in conv3dDerFilter: depth of dy (${o.shape[4]}) must match output depth for filter (${n[4]}).`);let i={x:a,dy:o},u={strides:r,pad:s,filterShape:n};return z.runKernel(xh,i,u)}var r4=W({conv3DBackpropFilter_:n4}),s4={kernelName:Xl,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let{dilations:r,strides:s,pad:a}=n;P(po(r),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`);let[o,i]=t;return{x:()=>pS(o.shape,e,i,s,a),filter:()=>r4(o,e,i.shape,s,a)}}},a4={kernelName:ya,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>V(Ft(lv(ue(n,"float32"))),e)}}},o4={kernelName:va,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>V(dv(ue(n,"float32")),e)}}},i4={kernelName:Ho,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{axis:s,exclusive:a,reverse:o}=n;return{x:()=>{let i=NS([s],r.rank),u=Xy(e,s,a,!o);return i!=null&&(u=Oe(u,i)),u}}}},u4={kernelName:xa,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let{dilations:r,strides:s,pad:a,dimRoundingMode:o}=n,i=r==null?[1,1]:r;P(po(i),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${i}'`);let[u,l]=t;return P(u.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${u.rank}.`),P(l.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${l.rank}.`),P(u.shape[3]===l.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${u.shape[3]}) must match the inChannels dimension in filter ${l.shape[2]}.`),P(us(s,i),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${s} and dilations '${i}'.`),Sn("depthwiseConv2d",a,o),{x:()=>XS(u.shape,e,l,s,a,i,o),filter:()=>KS(u,e,l.shape,s,a,i,o)}}},c4={kernelName:Yl,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let[r,s]=t,a={x:r,filter:s,dy:e},o={x:r,filter:s,dy:e};return{x:()=>z.runKernel(Th,a,n),filter:()=>z.runKernel(Nh,o,n)}}},l4={kernelName:ka,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t,r={dy:e,y:n};return{x:()=>z.runKernel(_h,r)}}},d4={kernelName:Qu,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t,r=V(Tn(Ft(ft(n))),2/Math.sqrt(Math.PI));return{x:()=>V(e,r)}}},p4={kernelName:Ia,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>V(e,n)}}},h4={kernelName:Xo,inputsToSave:["input"],gradFunc:(e,t)=>{let[n]=t;return{input:()=>G(e,n.shape)}}},f4={kernelName:Yo,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>V(e,Tn(n))}}},m4={kernelName:Sa,gradFunc:e=>({x:()=>Xe(e)})},g4={kernelName:Ca,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,s=ht(n.shape,r.shape);return{a:()=>{let i=me(e,ue(r,"float32")),u=zt(n.shape,s);return u.length>0?G(ve(i,u),n.shape):i},b:()=>{let i=V(e,ue(n,"float32")),u=zt(r.shape,s);u.length>0&&(i=G(ve(i,u),r.shape));let l=ft(r);return Ft(me(i,ue(l,"float32")))}}}},b4={kernelName:Ta,inputsToSave:["x","mean","variance","scale"],gradFunc:(e,t,n)=>{let{varianceEpsilon:r}=n,[s,a,o,i]=t,u=i==null?ke(1):i,l=zt(a.shape,s.shape),c=[];if(a.rank===1){for(let x=0;x<s.shape.length-1;++x)c.push(s.shape[x]);c.push(1)}let d=he(s,a),p=V(e,u),h=uv(Z(o,ke(r))),f=V(V(V(h,h),h),ke(-.5));return{x:()=>a.rank===1?G(V(V(e,tr(G(h,[1,1,1,a.shape[0]]),c)),u),s.shape):G(V(V(e,h),u),s.shape),mean:()=>{let x=V(V(h,ke(-1)),p);return a.rank===1&&(x=ve(x,l)),G(x,a.shape)},variance:()=>{let x=V(V(f,d),p);return a.rank===1&&(x=ve(x,l)),G(x,a.shape)},scale:()=>{let x=V(d,h),k=V(e,x);return a.rank===1&&(k=ve(k,l)),G(k,a.shape)},offset:()=>{let x=e;return a.rank===1&&(x=ve(x,l)),G(x,a.shape)}}}},y4={kernelName:Zo,inputsToSave:["x","indices"],gradFunc:(e,t,n)=>{let[r,s]=t,{axis:a}=n,o=Er(a,r.shape)[0];return{x:()=>{let u=r.shape,l=s.size,c=u.slice(0,o),d=c.length,p=u.slice(a,u.length).slice(1),h=p.length,f=d0(0,d),m=d0(d+1,d+1+h),g=p0([c,[l],p]),b=G(e,g),y=G(s,[l]),v=p0([[d],f,m]),x=Oe(b,v),k=zS(x,y,r.shape[o]),T=ev(v);return k=Oe(k,T),k},indices:()=>s}}};function d0(e,t){let n=[];for(let r=e;r<t;++r)n.push(r);return n}function p0(e){let t=[];for(let n=0;n<e.length;++n)for(let r=0;r<e[n].length;++r)t.push(e[n][r]);return t}var v4={kernelName:Na,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t;return{a:()=>Xe(n),b:()=>Xe(r)}}},x4={kernelName:_a,gradFunc:e=>({x:()=>ue(e,"float32")})},w4={kernelName:Ju,gradFunc:e=>({x:()=>Xe(e)})},k4={kernelName:ec,gradFunc:e=>({x:()=>Xe(e)})},I4={kernelName:tc,gradFunc:e=>({x:()=>Xe(e)})},S4={kernelName:ti,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{alpha:s}=n,a=nr(r,0);return{x:()=>Cn(a,e,V(e,s))}}},C4={kernelName:nc,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>me(e,Z(n,1))}}},T4={kernelName:Ea,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>me(e,ue(n,"float32"))}}},N4={kernelName:jI,inputsToSave:[],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r]=t,{axis:s}=n;return{logits:()=>{let a=!0,o=Tn(r);return he(e,V(ve(e,s,a),o))}}}};function _4(e,t,n,r=5,s=1,a=1,o=.5){let i={x:e,y:t,dy:n},u={depthRadius:r,bias:s,alpha:a,beta:o};return z.runKernel(Fh,i,u)}var E4=W({localResponseNormalizationBackprop_:_4}),A4={kernelName:ed,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r,s]=t,{depthRadius:a,bias:o,alpha:i,beta:u}=n;return{x:()=>E4(r,s,e,a,o,i,u)}}};function h0(e,t,n,r){return t.rank<n.rank&&(t=G(t,Vi(t.shape,r))),e.rank<n.rank&&(e=G(e,Vi(e.shape,r))),{x:()=>V(e,ue(mr(n,t),e.dtype))}}var f0={kernelName:Aa,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let r=n,{reductionIndices:s}=r,a=t[0],o=t[1],i=Er(s,a.shape),u=h0(e,o,a,i);return{x:()=>u.x()}}},$4={kernelName:$a,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t;return{a:()=>V(e,ue(zi(n,r),"float32")),b:()=>V(e,ue(Qy(n,r),"float32"))}}};function F4(e,t,n,r,s,a,o){let i=$(e,"dy","maxPool3dGrad"),u=$(t,"input","maxPool3dGrad"),l=$(n,"output","maxPool3dGrad"),c=i,d=u,p=l,h=!1;u.rank===4&&(h=!0,c=G(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),d=G(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]]),p=G(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]])),P(c.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`),P(d.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${d.rank}.`),P(p.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${p.rank}.`),Sn("maxPool3dGrad",a,o);let f={dy:c,input:d,output:p},m={filterSize:r,strides:s,pad:a,dimRoundingMode:o},g=z.runKernel(Rh,f,m);return h?G(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}var D4=W({maxPool3dGrad_:F4}),R4={kernelName:td,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r,s]=t,{filterSize:a,strides:o,pad:i,dimRoundingMode:u}=n;return{x:()=>D4(e,r,s,a,o,i,u)}}};function P4(e,t,n,r,s,a,o){let i=$(e,"dy","maxPoolGrad"),u=$(t,"input","maxPoolGrad"),l=$(n,"output","maxPoolGrad");P(u.rank===i.rank,()=>`Rank of input (${u.rank}) does not match rank of dy (${i.rank})`),P(i.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${i.rank}.`),P(u.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${u.rank}.`),Sn("maxPoolGrad",a,o);let c={dy:i,input:u,output:l},d={filterSize:r,strides:s,pad:a,dimRoundingMode:o};return z.runKernel(Dh,c,d)}var O4=W({maxPoolGrad_:P4}),M4={kernelName:Fa,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r,s]=t,{filterSize:a,strides:o,pad:i}=n;return{x:()=>O4(e,r,s,a,o,i)}}},L4={kernelName:Da,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{axis:s}=n,a=Er(s,r.shape),i=TS(r.shape,a)[1],u=wt(i);return{x:()=>{let c=r.shape.slice();a.forEach(h=>{c[h]=1});let d=G(e,c);return me(V(d,rr(r.shape,"float32")),u)}}}},B4={kernelName:Ra,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let r=n,{axis:s}=r,[a,o]=t,i=Er(s,a.shape),u=h0(e,o,a,i);return{x:()=>u.x()}}},z4={kernelName:Pa,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t;return{a:()=>V(e,ue(Wi(n,r),"float32")),b:()=>V(e,ue(nr(n,r),"float32"))}}},W4={kernelName:Oa,inputsToSave:["x"],gradFunc:(e,t,n)=>{let r=t[0],{paddings:s}=n,a=s.map(o=>o[0]);return{x:()=>Ve(e,a,r.shape)}}},V4={kernelName:sc,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,s=ht(n.shape,r.shape);return{a:()=>{let i=zt(n.shape,s);return i.length>0?G(ve(e,i),n.shape):e},b:()=>{let i=V(e,Ft(Cd(me(n,r)))),u=zt(r.shape,s);return u.length>0?G(ve(i,u),r.shape):i}}}},U4={kernelName:Ma,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,s=ht(n.shape,r.shape);return{a:()=>{let i=V(e,ue(r,"float32")),u=zt(n.shape,s);return u.length>0?G(ve(i,u),n.shape):i},b:()=>{let i=V(e,ue(n,"float32")),u=zt(r.shape,s);return u.length>0?G(ve(i,u),r.shape):i}}}},G4={kernelName:ai,gradFunc:e=>({x:()=>Ft(e)})},H4={kernelName:li,inputsToSave:["indices"],gradFunc:(e,t)=>{let n=t[0];return{indices:()=>kt(n.shape,"float32")}}},j4={kernelName:ci,gradFunc:e=>({x:()=>Xe(e)})},q4={kernelName:di,saveAllInputs:!0,gradFunc:(e,t,n)=>{let{axis:r}=n;return vt(e,r).map(a=>()=>a)}},m0={kernelName:La,inputsToSave:["x"],gradFunc:(e,t,n)=>{let r=t[0],{paddings:s}=n,a=s.map(o=>o[0]);return{x:()=>Ve(e,a,r.shape)}}},K4={kernelName:Ba,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(e,t)=>{let[n,r,s]=t,a=n,o=r,i=ht(a.shape,o.shape);return{a:()=>{let c=ue(o,"float32"),d=V(e,V(c,fo(a,he(c,ke(1))))),p=zt(a.shape,i);return p.length>0&&(d=ve(d,p)),G(d,a.shape)},b:()=>{let c=nr(a,0),d=Cn(c,gr(a),Xe(a)),p=V(e,V(s,d)),h=zt(o.shape,i);return h.length>0&&(p=ve(p,h)),G(p,o.shape)}}}},X4={kernelName:za,inputsToSave:["x","alpha"],gradFunc:(e,t)=>{let[n,r]=t,s=nr(n,0);return{x:()=>Cn(s,e,V(e,r)),alpha:()=>{let a=Cn(s,Xe(e),V(e,n)),o=zt(r.shape,e.shape);return o.length>0&&(a=ve(a,o)),G(a,r.shape)}}}},Y4={kernelName:wa,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,s=ht(n.shape,r.shape);return{a:()=>{let i=me(e,ue(r,"float32")),u=zt(n.shape,s);return u.length>0?G(ve(i,u),n.shape):i},b:()=>{let i=V(e,ue(n,"float32")),u=zt(r.shape,s);u.length>0&&(i=G(ve(i,u),r.shape));let l=ft(r);return Ft(me(i,ue(l,"float32")))}}}},Q4={kernelName:ic,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>me(e,Ft(ft(n)))}}},Z4={kernelName:Ua,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t,r=V(Wi(n,6),Ad(n));return{x:()=>V(e,ue(r,"float32"))}}},J4={kernelName:Wa,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>V(e,ue(Ad(n),"float32"))}}},eV={kernelName:hi,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>G(e,n.shape)}}},tV={kernelName:Va,inputsToSave:["images"],gradFunc:(e,t,n)=>{let[r]=t,s={dy:e,images:r};return{images:()=>z.runKernel(Lh,s,n)}}},nV={kernelName:uc,inputsToSave:["images"],gradFunc:(e,t,n)=>{let[r]=t,s={dy:e,images:r};return{images:()=>z.runKernel(Mh,s,n)}}},rV={kernelName:fi,gradFunc:(e,t,n)=>{let{dims:r}=n,s=Er(r,e.shape);return{x:()=>yr(e,s)}}},sV={kernelName:mi,gradFunc:e=>({x:()=>Xe(e)})},aV={kernelName:Ga,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Ft(me(e,V(fo(n,1.5),2)))}}},oV={kernelName:bi,inputsToSave:["condition"],gradFunc:(e,t)=>{let[n]=t;return{condition:()=>ue(Xe(n),"float32"),t:()=>V(e,ue(n,e.dtype)),e:()=>V(e,ue(uf(n),e.dtype))}}},iV={kernelName:cc,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let r=nr(n,ke(0)),s=ke(a0),a=ke(o0),o=V(e,a),i=V(V(e,s),Tn(ue(n,"float32")));return Cn(r,o,i)}}}},uV={kernelName:ja,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>V(e,V(n,he(ke(1),n)))}}},cV={kernelName:lc,gradFunc:e=>({x:()=>Xe(e)})},lV={kernelName:Ha,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>V(nf(ue(n,"float32")),e)}}},dV={kernelName:vi,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>V(Ky(ue(n,"float32")),e)}}},pV={kernelName:yi,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{begin:s,size:a}=n,o=r.shape,[i,u]=L1(r,s,a),l=[];for(let c=0;c<e.rank;c++)l.push([i[c],o[c]-i[c]-u[c]]);return{x:()=>Fr(e,l)}}},hV={kernelName:Xa,outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r]=t,{dim:s}=n,a=!0,o=V(e,r);return{logits:()=>he(o,V(ve(o,[s],a),r))}}},fV={kernelName:dc,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>V(e,$r(n))}}},g0={kernelName:xi,gradFunc:(e,t,n)=>{let{blockShape:r,paddings:s}=n;return{x:()=>tf(e,r,s)}}},b0={kernelName:wi,gradFunc:(e,t,n)=>{let{axis:r}=n;return{x:()=>ot(e,r)}}},mV={kernelName:qa,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>me(e,V(vn(ue(n,"float32")),2))}}},gV={kernelName:hc,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>V(e,V(ue(n,"float32"),2))}}},bV={kernelName:Ya,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,s=ke(2);return{a:()=>V(e,V(s,he(n,r))),b:()=>V(e,V(s,he(r,n)))}}},yV={kernelName:eo,gradFunc:e=>({x:()=>Xe(e)})},vV={kernelName:Qa,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,s=ht(n.shape,r.shape);return{a:()=>{let i=e,u=zt(n.shape,s);return u.length>0&&(i=ve(i,u)),G(i,n.shape)},b:()=>{let i=e,u=zt(r.shape,s);return u.length>0&&(i=ve(i,u)),G(Ft(i),r.shape)}}}},xV={kernelName:Ka,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,s=r.shape.slice(),{axis:a}=n;Er(a,r.shape).forEach(l=>{s[l]=1});let i=G(e,s),u=V(i,rr(r.shape,"float32"));return{x:()=>u}}},wV={kernelName:Ii,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>me(e,ft(nf(n)))}}},kV={kernelName:Za,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>V(he(ke(1),ft(n)),e)}}},IV={kernelName:As,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{reps:s}=n;return{x:()=>{let o=Xe(r);if(r.rank===1)for(let i=0;i<s[0];++i)o=Z(o,Ve(e,[i*r.shape[0]],[r.shape[0]]));else if(r.rank===2)for(let i=0;i<s[0];++i)for(let u=0;u<s[1];++u)o=Z(o,Ve(e,[i*r.shape[0],u*r.shape[1]],[r.shape[0],r.shape[1]]));else if(r.rank===3)for(let i=0;i<s[0];++i)for(let u=0;u<s[1];++u)for(let l=0;l<s[2];++l)o=Z(o,Ve(e,[i*r.shape[0],u*r.shape[1],l*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else if(r.rank===4)for(let i=0;i<s[0];++i)for(let u=0;u<s[1];++u)for(let l=0;l<s[2];++l)for(let c=0;c<s[3];++c)o=Z(o,Ve(e,[i*r.shape[0],u*r.shape[1],l*r.shape[2],c*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);return o}}}},SV={kernelName:Ja,gradFunc:(e,t,n)=>{let r=n,{perm:s}=r,a=ev(s);return{x:()=>Oe(e,a)}}},CV={kernelName:Ti,gradFunc:(e,t,n)=>{let r=n,{axis:s}=r;return{value:()=>Ut(e,s)}}},TV={kernelName:ud,inputsToSave:["segmentIds"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>NV(e,n)}}};function NV(e,t){let n=Ds(t,Xe(t)),r=Ic(e,n),s=zi(t,ke(0,"int32")),a=r.rank-s.rank;for(let i=0;i<a;++i)s=Nn(s,i+1);s=Hr(s,rr(r.shape,"bool"));let o=Xe(r);return Cn(s,r,o)}var _V={kernelName:Ni,gradFunc:e=>({x:()=>Xe(e)})},EV=[l0,EW,AW,$W,FW,DW,RW,PW,OW,MW,LW,BW,VW,HW,jW,qW,KW,XW,YW,QW,ZW,JW,t4,e4,s4,a4,o4,i4,u4,c4,Y4,l4,d4,p4,h4,f4,g4,m4,b4,y4,v4,x4,w4,k4,I4,S4,C4,T4,N4,A4,f0,f0,$4,R4,M4,L4,B4,z4,W4,V4,U4,G4,H4,j4,q4,m0,m0,K4,X4,Q4,Z4,J4,eV,tV,nV,rV,sV,aV,oV,iV,uV,cV,lV,dV,pV,hV,fV,g0,g0,b0,b0,mV,bV,gV,yV,vV,xV,wV,kV,IV,SV,CV,TV,_V];for(let e of EV)qI(e);var y0={};Ee(y0,{maxNorm:()=>DV,minMaxNorm:()=>OV,nonNeg:()=>PV,unitNorm:()=>RV});var Sv;function Yt(){return Sv==null&&(Sv=G1().epsilon()),Sv}function Kr(){return"channelsLast"}var Ms=class extends Error{constructor(e){super(e);Object.setPrototypeOf(this,Ms.prototype)}},Xr=class extends Error{constructor(e){super(e);Object.setPrototypeOf(this,Xr.prototype)}},H=class extends Error{constructor(e){super(e);Object.setPrototypeOf(this,H.prototype)}},De=class extends Error{constructor(e){super(e);Object.setPrototypeOf(this,De.prototype)}},v0=class extends Error{constructor(e){super(e);Object.setPrototypeOf(this,v0.prototype)}};function Gi(e,t){if(Array.isArray(e)){let n=[];for(let r=0;r<t;r++)n=n.concat(e);return n}else{let n=new Array(t);return n.fill(e),n}}function ds(e,t){if(!e)throw new v0(t)}function x0(e,t){let n=0;for(let r of e)r===t&&n++;return n}function Gn(e){return e.length===1?e[0]:e}function It(e){return Array.isArray(e)?e:[e]}function Ls(e){let n=e.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return n[0]!=="_"?n:"private"+n}function Hi(e){return e.length<=1||e.indexOf("_")===-1?e:e.replace(/[_]+(\w|$)/g,(t,n)=>n.toUpperCase())}var Rr={};function Cv(e){if(e==null)return null;let t={};return t.className=e.getClassName(),t.config=e.getConfig(),t}function Tv(e){if(!(e==null||typeof e!="object"))if(Array.isArray(e))e.forEach(t=>Tv(t));else{let t=Object.keys(e);for(let n of t){let r=e[n];r!=null&&typeof r=="object"&&(!Array.isArray(r)&&r.type==="ndarray"&&typeof r.value=="number"?e[n]=r.value:Tv(r))}}}function Dd(e,t={},n={},r="object",s=!1){if(typeof e=="string"){let a=e,o;if(a in n)o=n[a];else if(a in Rr)o=Rr[a];else if(o=t[a],o==null)throw new H(`Unknown ${r}: ${e}. This may be due to one of the following reasons:
1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return o}else{let a=e;if(a.className==null||a.config==null)throw new H(`${r}: Improper config format: ${JSON.stringify(a)}.
'className' and 'config' must set.`);let o=a.className,i,u;if(o in n?[i,u]=n[o]:o in Rr?[i,u]=Rr.className:o in t&&([i,u]=t[o]),i==null)throw new H(`Unknown ${r}: ${o}. This may be due to one of the following reasons:
1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(u!=null){let l={};for(let h of Object.keys(Rr))l[h]=Rr[h];for(let h of Object.keys(n))l[h]=n[h];let c=a.config;c.customObjects=l;let d={...Rr};for(let h of Object.keys(n))Rr[h]=n[h];Tv(a.config);let p=u(i,a.config,n,s);return Rr={...d},p}else{let l={...Rr};for(let d of Object.keys(n))Rr[d]=n[d];let c=new i(a.config);return Rr={...l},c}}}function AV(e,t){return e<t?-1:e>t?1:0}function _f(e,t){return-1*AV(e,t)}function bo(e){if(e==null)return e;let t=[];for(let n of e)t.indexOf(n)===-1&&t.push(n);return t}function $V(e){if(e==null)throw new H(`Invalid value in obj: ${JSON.stringify(e)}`);for(let t in e)if(e.hasOwnProperty(t))return!1;return!0}function ji(e,t,n){if(n!=null&&e.indexOf(n)<0)throw new H(`${n} is not a valid ${t}.  Valid values are ${e} or null/undefined.`)}function Nv(e,t,n=0,r=1/0){return ds(n>=0),ds(r>=n),Array.isArray(e)&&e.length>=n&&e.length<=r&&e.every(s=>typeof s===t)}function rn(e,t){Array.isArray(e)?(w.assert(e.length>0,()=>`${t} is unexpectedly an empty array.`),e.forEach((n,r)=>rn(n,`element ${r+1} of ${t}`))):w.assert(Number.isInteger(e)&&e>0,()=>`Expected ${t} to be a positive integer, but got ${w0(e)}.`)}function w0(e){return e===null?"null":Array.isArray(e)?"["+e.map(t=>w0(t)).join(",")+"]":typeof e=="string"?`"${e}"`:`${e}`}function FV(e,t,n){let r=n!=null?n():w.now(),s;return(...o)=>{let i=n!=null?n():w.now();return i-r<t||(r=i,s=e(...o)),s}}function k0(e){return e==="relu"?"relu":e==="linear"?"linear":e==="elu"?"elu":null}function _v(e,t){return M(()=>vn(ve(V(e,e),t,!0)))}var Rd=class extends oe.Serializable{getConfig(){return{}}},Ev=class extends Rd{constructor(e){super();this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return M(()=>{let t=_v(e,this.axis),n=dn(t,0,this.maxValue);return V(e,me(n,Z(Yt(),t)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}};Ev.className="MaxNorm";oe.registerClass(Ev);var Av=class extends Rd{constructor(e){super();this.defaultAxis=0,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return M(()=>me(e,Z(Yt(),_v(e,this.axis))))}getConfig(){return{axis:this.axis}}};Av.className="UnitNorm";oe.registerClass(Av);var $v=class extends Rd{apply(e){return Qe(e)}};$v.className="NonNeg";oe.registerClass($v);var Fv=class extends Rd{constructor(e){super();this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=e.minValue!=null?e.minValue:this.defaultMinValue,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.rate=e.rate!=null?e.rate:this.defaultRate,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return M(()=>{let t=_v(e,this.axis),n=Z(V(this.rate,dn(t,this.minValue,this.maxValue)),V(1-this.rate,t));return V(e,me(n,Z(Yt(),t)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}};Fv.className="MinMaxNorm";oe.registerClass(Fv);var I0={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function Qt(e){return Cv(e)}function S0(e,t={}){return Dd(e,oe.SerializationMap.getMap().classNameMap,t,"constraint")}function Zt(e){if(e==null)return null;if(typeof e=="string"){let n={className:e in I0?I0[e]:e,config:{}};return S0(n)}else return e instanceof Rd?e:S0(e)}function DV(e){return new Ev(e)}function RV(e){return new Av(e)}function PV(){return new $v}function OV(e){return new Fv(e)}var C0={};Ee(C0,{constant:()=>aU,glorotNormal:()=>pU,glorotUniform:()=>dU,heNormal:()=>hU,heUniform:()=>fU,identity:()=>cU,leCunNormal:()=>mU,leCunUniform:()=>gU,ones:()=>sU,orthogonal:()=>bU,randomNormal:()=>iU,randomUniform:()=>oU,truncatedNormal:()=>uU,varianceScaling:()=>lU,zeros:()=>rU});var MV=["channelsFirst","channelsLast"],LV=["nearest","bilinear"],BV=["valid","same","causal"],zV=["max","avg"],WV=["sum","mul","concat","ave"],$c=new Map;function Bt(e){ji(MV,"DataFormat",e)}function VV(e){ji(LV,"InterpolationFormat",e)}function vr(e){ji(BV,"PaddingMode",e)}function T0(e){ji(zV,"PoolMode",e)}var Pd=[],N0="/";function qi(e,t){Pd.push(e);try{let n=t();return Pd.pop(),n}catch(n){throw Pd.pop(),n}}function UV(){return Pd.length===0?"":Pd.join(N0)+N0}function _0(e){if(!A0(e))throw new Error("Not a valid tensor name: '"+e+"'");return UV()+e}function E0(e){if(!A0(e))throw new Error("Not a valid tensor name: '"+e+"'");$c.has(e)||$c.set(e,0);let t=$c.get(e);if($c.set(e,$c.get(e)+1),t>0){let n=`${e}_${t}`;return $c.set(n,1),n}else return e}var GV=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function A0(e){return!!e.match(GV)}function HV(e){return e===parseInt(e.toString(),10)}function yo(e,t,n){t==null&&(t=0),n==null&&(n=e.length);let r=1;for(let s=t;s<n;++s)r*=e[s];return r}function Fc(e){if(e.length===0)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let n=0;n<e.length;n++){let r=e[n];r<t&&(t=r)}return t}function vo(e){if(e.length===0)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let n=0;n<e.length;n++){let r=e[n];r>t&&(t=r)}return t}function Yr(e,t){if(t<e)throw new H(`end (${t}) < begin (${e}) is forbidden.`);let n=[];for(let r=e;r<t;++r)n.push(r);return n}function Ef(e,t){return ue(e,t)}function Od(e,t=-1){let n=e.shape.slice();return t<0&&(t=n.length+t+1),n.splice(t,0,1),G(e,n)}function jV(e,t){return M(()=>{if(e.shape.length!==2)throw new H(`repeat() expects a rank-2 tensor, but received a rank-${e.shape.length} tensor.`);let n=Od(e,1);return Pv(n,[1,t,1])})}function qV(e){let t=[yo(e.shape)];return G(e,t)}function KV(e){if(e.rank<=1)throw new H(`batchFlatten requires a minimum rank of 2. Got rank: ${e.rank}.`);let t=[e.shape[0],yo(e.shape,1)];return G(e,t)}function Ki(e,t,n){return M(()=>{switch(e.rank){case 1:return hf(e,t,n);case 2:return pv(e,[t,0],[n,e.shape[1]]);case 3:return Ec(e,[t,0,0],[n,e.shape[1],e.shape[2]]);case 4:return _d(e,[t,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3]]);case 5:return Ve(e,[t,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4]]);case 6:return Ve(e,[t,0,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4],e.shape[5]]);default:throw new H(`sliceAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}})}function Dv(e,t,n){return M(()=>{switch(e.rank){case 1:return hf(e,t,n);case 2:return pv(e,[0,t],[e.shape[0],n]);case 3:return Ec(e,[0,0,t],[e.shape[0],e.shape[1],n]);case 4:return _d(e,[0,0,0,t],[e.shape[0],e.shape[1],e.shape[2],n]);default:throw new H(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}})}function Af(e,t,n,r){return M(()=>{switch(e.rank){case 1:return hf(e,t,n);case 2:switch(r){case 1:return Ki(e,t,n);case 2:return Dv(e,t,n);default:throw new H(`The axis is not within the rank of the tensor ${r}`)}case 3:switch(r){case 1:return Ki(e,t,n);case 2:return Ec(e,[0,t,0],[e.shape[0],n,e.shape[2]]);case 3:return Dv(e,t,n);default:throw new H(`The axis is not within the rank of the tensor ${r}`)}case 4:switch(r){case 1:return Ki(e,t,n);case 2:return _d(e,[0,t,0,0],[e.shape[0],n,e.shape[2],e.shape[3]]);case 3:return _d(e,[0,0,t,0],[e.shape[0],e.shape[1],n,e.shape[3]]);case 4:return Dv(e,t,n);default:throw new H(`The axis is not within the rank of the tensor ${r}`)}default:throw new H(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}})}function Rv(e,t=-1){let n;return t<0&&(n=e[0].rank,n!==0?t=n:t=0),t===e[0].rank&&(t=-1),ot(e,t)}function $0(e,t){switch(e.rank){case 1:return uS([e,t]);case 2:return cS([e,t],0);case 3:return lS([e,t],0);case 4:return dS([e,t],0);default:throw new H(`concatAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}function Pv(e,t){if(Array.isArray(t)||(t=[t]),e.rank!==t.length)throw new H(`The length of input n (${t.length}) does not match the number of dimensions in input x (${e.rank})`);return tr(e,t)}function $f(e,t=0,n=1,r,s){return DS(e,t,n,r,s)}function ps(e,t,n,r){if(e.rank<2||t.rank<2)throw new De(`dot requires both inputs to be rank >= 2 but got x shape = ${e.shape} and y shape = ${t.shape}`);if(t.rank>=3){let s=e.shape.slice(-1)[0],a=t.shape.slice(-2)[0];if(s!==a)throw new De(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${e.shape} and  y shape = ${t.shape}`)}if(e.rank===2&&t.rank===2){let s=!1,a=!1;return mo.matMul({a:e,b:t,transposeA:s,transposeB:a,bias:r?Ov(e.rank,r,Kr()):null,activation:n})}else{let s=e.shape.slice(),a=s.pop();e=G(e,[-1,a]);let o=t.shape.slice(),i=o.pop(),u=o.pop(),l=[...o,i],c=Array.from({length:t.rank},(f,m)=>m===0?t.rank-2:m<=t.rank-2?m-1:m);t=G(Oe(t,c),[u,-1]);let d=[...s,...l],p=!1,h=!1;return G(mo.matMul({a:e,b:t,transposeA:p,transposeB:h,bias:r?Ov(e.rank,r,Kr()):null,activation:n}),d)}}function F0(e,t,n){return M(()=>(Array.isArray(t)?t=je(t,"int32"):t=ue(t,"int32"),Ic(e,t,n)))}function Md(e){return V(e,e)}function Ov(e,t,n){let r=t.shape;if(t.rank!==1&&t.rank!==e)throw new H(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${e}`);if(e===5){if(n==="channelsFirst")return r.length===1?G(t,[1,r[0],1,1,1]):G(t,[1,r[3],r[0],r[1],r[2]]);if(n==="channelsLast")return r.length===1?G(t,[1,1,1,1,r[0]]):G(t,[1].concat(r))}else if(e===4){if(n==="channelsFirst")return r.length===1?G(t,[1,r[0],1,1]):G(t,[1,r[2],r[0],r[1]]);if(n==="channelsLast")return r.length===1?G(t,[1,1,1,r[0]]):G(t,[1].concat(r))}else if(e===3){if(n==="channelsFirst")return r.length===1?G(t,[1,r[0],1]):G(t,[1,r[1],r[0]]);if(n==="channelsLast")return r.length===1?G(t,[1,1,r[0]]):G(t,[1].concat(r))}else if(e<3)return t;throw new H(`Unsupported input rank by biasAdd: ${t.rank}`)}function Qr(e,t,n){return M(()=>(n==null&&(n=Kr()),Bt(n),Z(e,Ov(e.rank,t,n))))}function XV(e,t=1){if(t!==1)throw new De(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return Sd(e)}function YV(e){return M(()=>me(e,Z(Xt(e),1)))}function D0(e,t,n,r){return M(()=>jS(e,t,n,r))}function QV(e){return M(()=>{let t=Z(.5,V(.2,e));return dn(t,0,1)})}function Ld(e,t,n=!1){return n?e():t()}var ZV=["fanIn","fanOut","fanAvg"],JV=["normal","uniform","truncatedNormal"];function eU(e){ji(ZV,"FanMode",e)}function tU(e){ji(JV,"Distribution",e)}var Pr=class extends oe.Serializable{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}},Mv=class extends Pr{apply(e,t){return kt(e,t)}};Mv.className="Zeros";oe.registerClass(Mv);var Ff=class extends Pr{apply(e,t){return rr(e,t)}};Ff.className="Ones";oe.registerClass(Ff);var Lv=class extends Pr{constructor(e){super();if(typeof e!="object")throw new H(`Expected argument of type ConstantConfig but got ${e}`);if(e.value===void 0)throw new H(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return M(()=>V(ke(this.value),rr(e,t)))}getConfig(){return{value:this.value}}};Lv.className="Constant";oe.registerClass(Lv);var Bv=class extends Pr{constructor(e){super();this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return Tc(e,this.minval,this.maxval,t)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}};Bv.className="RandomUniform";oe.registerClass(Bv);var zv=class extends Pr{constructor(e){super();this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new De(`randomNormal does not support dType ${t}.`);return $f(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};zv.className="RandomNormal";oe.registerClass(zv);var Wv=class extends Pr{constructor(e){super();this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new De(`truncatedNormal does not support dType ${t}.`);return gf(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};Wv.className="TruncatedNormal";oe.registerClass(Wv);var Vv=class extends Pr{constructor(e){super();this.gain=e.gain!=null?e.gain:1}apply(e,t){return M(()=>{if(e.length!==2||e[0]!==e[1])throw new H("Identity matrix initializer can only be used for 2D square matrices.");return V(this.gain,Yy(e[0]))})}getConfig(){return{gain:this.gain}}};Vv.className="Identity";oe.registerClass(Vv);function nU(e,t="channelsLast"){let n,r;if(Bt(t),e.length===2)n=e[0],r=e[1];else if([3,4,5].indexOf(e.length)!==-1){if(t==="channelsFirst"){let s=yo(e,2);n=e[1]*s,r=e[0]*s}else if(t==="channelsLast"){let s=yo(e,0,e.length-2);n=e[e.length-2]*s,r=e[e.length-1]*s}}else{let s=yo(e);n=Math.sqrt(s),r=Math.sqrt(s)}return[n,r]}var Hn=class extends Pr{constructor(e){super();if(e.scale<0)throw new H(`scale must be a positive float. Got: ${e.scale}`);this.scale=e.scale==null?1:e.scale,this.mode=e.mode==null?"fanIn":e.mode,eU(this.mode),this.distribution=e.distribution==null?"normal":e.distribution,tU(this.distribution),this.seed=e.seed}apply(e,t){let n=nU(e),r=n[0],s=n[1],a=this.scale;if(this.mode==="fanIn"?a/=Math.max(1,r):this.mode==="fanOut"?a/=Math.max(1,s):a/=Math.max(1,(r+s)/2),this.distribution==="normal"){let o=Math.sqrt(a);if(t=t||"float32",t!=="float32"&&t!=="int32")throw new De(`${this.getClassName()} does not support dType ${t}.`);return gf(e,0,o,t,this.seed)}else{let o=Math.sqrt(3*a);return Tc(e,-o,o,t)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}};Hn.className="VarianceScaling";oe.registerClass(Hn);var Df=class extends Hn{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Hn.className}};Df.className="GlorotUniform";oe.registerClass(Df);var Rf=class extends Hn{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Hn.className}};Rf.className="GlorotNormal";oe.registerClass(Rf);var Pf=class extends Hn{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Hn.className}};Pf.className="HeNormal";oe.registerClass(Pf);var Of=class extends Hn{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Hn.className}};Of.className="HeUniform";oe.registerClass(Of);var Mf=class extends Hn{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Hn.className}};Mf.className="LeCunNormal";oe.registerClass(Mf);var Lf=class extends Hn{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Hn.className}};Lf.className="LeCunNormal";oe.registerClass(Lf);var Uv=class extends Pr{constructor(e){super();if(this.DEFAULT_GAIN=1,this.gain=e.gain==null?this.DEFAULT_GAIN:e.gain,this.seed=e.seed,this.seed!=null)throw new De("Random seed is not implemented for Orthogonal Initializer yet.")}apply(e,t){return M(()=>{if(e.length<2)throw new De("Shape must be at least 2D.");e[0]*e[1]>2e3&&console.warn(`Orthogonal initializer is being called on a matrix with more than 2000 (${e[0]*e[1]}) elements: Slowness may result.`);let n=e[0]>e[1]?[e[1],e[0]]:e,r=$f(n,0,1,"float32"),s=r0.gramSchmidt(r);return e[0]>e[1]&&(s=Oe(s)),V(this.gain,s)})}getConfig(){return{gain:this.gain,seed:this.seed}}};Uv.className="Orthogonal";oe.registerClass(Uv);var R0={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function P0(e,t={}){return Dd(e,oe.SerializationMap.getMap().classNameMap,t,"initializer")}function Dt(e){return Cv(e)}function Nt(e){if(typeof e=="string"){let t=e in R0?R0[e]:e;if(t==="GlorotNormal")return new Rf;if(t==="GlorotUniform")return new Df;if(t==="HeNormal")return new Pf;if(t==="HeUniform")return new Of;if(t==="LeCunNormal")return new Mf;if(t==="LeCunUniform")return new Lf;{let n={};return n.className=t,n.config={},P0(n)}}else return e instanceof Pr?e:P0(e)}function rU(){return new Mv}function sU(){return new Ff}function aU(e){return new Lv(e)}function oU(e){return new Bv(e)}function iU(e){return new zv(e)}function uU(e){return new Wv(e)}function cU(e){return new Vv(e)}function lU(e){return new Hn(e)}function dU(e){return new Df(e)}function pU(e){return new Rf(e)}function hU(e){return new Pf(e)}function fU(e){return new Of(e)}function mU(e){return new Mf(e)}function gU(e){return new Lf(e)}function bU(e){return new Uv(e)}var O0={};Ee(O0,{Layer:()=>Ye,RNN:()=>zs,RNNCell:()=>Hd,activation:()=>ZG,add:()=>iH,alphaDropout:()=>GH,average:()=>uH,averagePooling1d:()=>lw,averagePooling2d:()=>dw,averagePooling3d:()=>pw,avgPool1d:()=>bH,avgPool2d:()=>vH,avgPool3d:()=>wH,avgPooling1d:()=>yH,avgPooling2d:()=>xH,avgPooling3d:()=>kH,batchNormalization:()=>fH,bidirectional:()=>OH,concatenate:()=>cH,conv1d:()=>UG,conv2d:()=>GG,conv2dTranspose:()=>HG,conv3d:()=>jG,conv3dTranspose:()=>qG,convLstm2d:()=>FH,convLstm2dCell:()=>DH,cropping2D:()=>XG,dense:()=>JG,depthwiseConv2d:()=>QG,dot:()=>hH,dropout:()=>eH,elu:()=>MG,embedding:()=>oH,flatten:()=>nH,gaussianDropout:()=>UH,gaussianNoise:()=>VH,globalAveragePooling1d:()=>IH,globalAveragePooling2d:()=>SH,globalMaxPool1d:()=>LH,globalMaxPool2d:()=>BH,globalMaxPooling1d:()=>X2,globalMaxPooling2d:()=>Y2,gru:()=>TH,gruCell:()=>NH,input:()=>m2,inputLayer:()=>OG,layerNormalization:()=>mH,leakyReLU:()=>BG,lstm:()=>_H,lstmCell:()=>EH,masking:()=>HH,maxPool1d:()=>zH,maxPool2d:()=>WH,maxPooling1d:()=>Q2,maxPooling2d:()=>Z2,maxPooling3d:()=>CH,maximum:()=>lH,minimum:()=>dH,multiply:()=>pH,permute:()=>aH,prelu:()=>zG,reLU:()=>LG,repeatVector:()=>rH,reshape:()=>sH,rnn:()=>RH,separableConv2d:()=>KG,simpleRNN:()=>AH,simpleRNNCell:()=>$H,softmax:()=>WG,spatialDropout1d:()=>tH,stackedRNNCells:()=>PH,thresholdedReLU:()=>VG,timeDistributed:()=>MH,upSampling2d:()=>YG,zeroPadding2d:()=>gH});var yU=0;function M0(){return yU++}var Bf={};function zf(e=""){return e in Bf||(Bf[e]=0),Bf[e]+=1,e+Bf[e].toString()}function Gv(e){return Array.isArray(e)&&Array.isArray(e[0])}function Wf(e){return e.length===0?[]:Array.isArray(e[0])?e:[e]}function Me(e){let t;if(Array.isArray(e)){if(e.length!==1)throw new H(`Expected Tensor length to be 1; got ${e.length}`);t=e[0]}else t=e;return t}function ut(e){if(Array.isArray(e)&&Array.isArray(e[0])){if(e.length===1)return e=e,e[0];throw new H(`Expected exactly 1 Shape; got ${e.length}`)}else return e}function Vf(e){let t=0;for(let n of e)n.shape.length===0?t+=1:t+=n.shape.reduce((r,s)=>r*s);return t}var L0="Variable",B0=class{constructor(e,t="float32",n=L0,r=!0,s=null){this.dtype=t==null?"float32":t,this.shape=e.shape,this.id=M0(),n=n==null?L0:n,this.originalName=_0(n),this.name=E0(this.originalName),this.trainable_=r,this.constraint=s,this.val=WS(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),vU(this.val,e),this.val.id!==e.id&&(this.val.assign(e),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}};function vU(e,t){if(e.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(e.shape)+" vs. "+JSON.stringify(t.shape))}function Hv(e){return e.map(t=>t.read())}function jv(e){e.forEach(t=>{t[0].write(t[1])})}var Gt=class{constructor(e){this.dtype=e.dtype,this.shape=e.shape,e.shape!=null?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}},Zr=class{constructor(e,t,n,r,s,a,o){this.dtype=e,this.shape=t,this.sourceLayer=n,this.inputs=r,this.callArgs=s,this.outputTensorIndex=o,this.id=M0(),a!=null&&(this.originalName=_0(a),this.name=E0(this.originalName)),this.rank=t.length}},xU=0,Uf=class{constructor(e,t){this.callArgs=t,this.id=xU++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(let n of e.inboundLayers)n!=null&&n.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){let e=[];for(let t of this.inboundLayers)t!=null?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}},wU=0,Ye=class extends oe.Serializable{constructor(e={}){super();this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=wU++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){let n=this.getClassName();t=Ls(n)+"_"+zf(n)}if(this.name=t,this.trainable_=e.trainable==null?!0:e.trainable,e.inputShape!=null||e.batchInputShape!=null){let n;if(e.batchInputShape!=null)n=e.batchInputShape;else if(e.inputShape!=null){let s=null;e.batchSize!=null&&(s=e.batchSize),n=[s].concat(e.inputShape)}this.batchInputShape=n;let r=e.dtype;r==null&&(r=e.inputDType),r==null&&(r="float32"),this.dtype=r}e.weights!=null?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(this.inboundNodes.length===0)throw new Xr(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new H(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return Gn(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return Gn(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new Ms(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new Ms(`Layer ${this.name} is not connected, no input to return.`);return Gn(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new Ms(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new Ms(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return Gn(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(e=>e())}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach(t=>t.trainable=e),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(e=>e.trainable):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(e=>!e.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){if(e=It(e),this.inputSpec==null||this.inputSpec.length===0)return;let t=It(this.inputSpec);if(e.length!==t.length)throw new H(`Layer ${this.name} expects ${t.length} inputs, but it received ${e.length} input tensors. Input received: ${e}`);for(let n=0;n<e.length;n++){let r=e[n],s=t[n];if(s==null)continue;let a=r.rank;if(s.ndim!=null&&a!==s.ndim)throw new H(`Input ${n} is incompatible with layer ${this.name}: expected ndim=${s.ndim}, found ndim=${a}`);if(s.maxNDim!=null&&a>s.maxNDim)throw new H(`Input ${n} is incompatible with layer ${this.name}: expected max_ndim=${s.maxNDim}, found ndim=${a}`);if(s.minNDim!=null&&a<s.minNDim)throw new H(`Input ${n} is incompatible with layer ${this.name}: expected min_ndim=${s.minNDim}, found ndim=${a}.`);if(s.dtype!=null&&r.dtype!==s.dtype)throw new H(`Input ${n} is incompatible with layer ${this.name} : expected dtype=${s.dtype}, found dtype=${r.dtype}.`);if(s.axes){let o=r.shape;for(let i in s.axes){let u=Number(i),l=s.axes[i],c=u>=0?o[u]:o[o.length+u];if(l!=null&&[l,null].indexOf(c)===-1)throw new H(`Input ${n} is incompatible with layer ${this.name}: expected axis ${u} of input shape to have value ${l} but got shape ${o}.`)}}if(s.shape!=null)for(let o=0;o<s.shape.length;++o){let i=s.shape[o],u=r.shape[o];if(i!=null&&u!=null&&i!==u)throw new H(`Input ${n} is incompatible with layer ${this.name}: expected shape=${s.shape}, found shape=${r.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){this._callHook!=null&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();let n=It(e),r=!0;for(let a of n)if(!(a instanceof Zr)){r=!1;break}let s=!0;for(let a of n)if(a instanceof Zr){s=!1;break}if(r===s)throw new H("Arguments to apply() must be all SymbolicTensors or all Tensors");return qi(this.name,()=>{if(!this.built){this.assertInputCompatibility(e);let a=[];for(let o of It(e))a.push(o.shape);this.build(Gn(a)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&s&&(this._refCount=1)}if(this.assertInputCompatibility(e),s){let a=this.call(e,t),o=It(a),i=[];for(let u of o)n.indexOf(u)!==-1&&(u=u.clone()),i.push(u);if(a=Gn(i),this.activityRegularizer!=null)throw new De("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return a}else{let a=kU(e),o=this.computeOutputShape(a),i,u=IU(e);if(this.warnOnIncompatibleInputShape(Array.isArray(e)?a[0]:a),o!=null&&o.length>0&&Array.isArray(o[0])?i=o.map((l,c)=>new Zr(u,l,this,It(e),t,this.name,c)):i=new Zr(u,o,this,It(e),t,this.name),this.addInboundNode(e,i,null,null,a,o,t),this._refCount++,this.activityRegularizer!=null)throw new De("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return i}})}warnOnIncompatibleInputShape(e){if(this.batchInputShape!=null)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach((n,r)=>{n!=null&&e[r]!=null&&e[r]!==n&&(t=!0)}),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new Ms(`The layer ${this.name} has never been called and thus has no defined output shape.`);let e=[];for(let t of this.inboundNodes){let n=JSON.stringify(t.outputShapes);e.indexOf(n)===-1&&e.push(n)}if(e.length===1){let t=this.inboundNodes[0].outputShapes;return Array.isArray(t)&&Array.isArray(t[0])&&t.length===1?t[0]:t}else throw new Ms(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new Xr(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return Vf(this.weights)}build(e){this.built=!0}getWeights(e=!1){return Hv(e?this.trainableWeights:this.weights)}setWeights(e){M(()=>{let t=this.weights;if(t.length!==e.length)throw new H(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(t.length===0)return;let n=[],r=Hv(t);for(let s=0;s<r.length;++s){let a=r[s],o=t[s],i=e[s];if(!w.arraysEqual(a.shape,i.shape))throw new H(`Layer weight shape ${a.shape} not compatible with provided weight shape ${i.shape}`);n.push([o,i])}jv(n)})}addWeight(e,t,n,r,s,a,o,i){if(this._addedWeightNames.indexOf(e)!==-1)throw new H(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),n==null&&(n="float32"),this.fastWeightInitDuringBuild&&(r=i!=null?i():Nt("zeros"));let u=r.apply(t,n),l=new B0(u,n,e,a,o);return u.dispose(),s!=null&&this.addLoss(()=>s.apply(l.read())),a==null&&(a=!0),a?this._trainableWeights.push(l):this._nonTrainableWeights.push(l),l}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){e==null||Array.isArray(e)&&e.length===0||(e=It(e),this._losses!==void 0&&this._losses!==null&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(t!=null)if(Array.isArray(t))t.forEach(n=>{if(n!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return t}addInboundNode(e,t,n,r,s,a,o=null){let i=It(e);t=It(t),n=It(n),r=It(r),s=Wf(s),a=Wf(a);let u=[],l=[],c=[];for(let d of i)u.push(d.sourceLayer),l.push(d.nodeIndex),c.push(d.tensorIndex);new Uf({outboundLayer:this,inboundLayers:u,nodeIndices:l,tensorIndices:c,inputTensors:i,outputTensors:t,inputMasks:n,outputMasks:r,inputShapes:s,outputShapes:a},o);for(let d=0;d<t.length;d++)t[d].sourceLayer=this,t[d].nodeIndex=this.inboundNodes.length-1,t[d].tensorIndex=d}getConfig(){let e={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(e.batchInputShape=this.batchInputShape),this.dtype!=null&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach(e=>e.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return--this._refCount==0&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}};function kU(e){e=It(e);let t=[];for(let n of e)t.push(n.shape);return Gn(t)}function IU(e){return"float32"}function z0(e,t,n){if((t==null||n!=null&&n>0)&&(t=e.sourceLayer,n=e.nodeIndex),t.inboundNodes.length===0)return[e];{let r=t.inboundNodes[n];if(r.inboundLayers.length===0)return r.inputTensors;{let s=[];for(let a=0;a<r.inboundLayers.length;a++){let o=r.inputTensors[a],i=r.inboundLayers[a],u=r.nodeIndices[a],l=z0(o,i,u);for(let c of l)s.indexOf(c)===-1&&s.push(c)}return s}}}var Dc=class extends Ye{constructor(e){super({dtype:e.dtype,name:e.name!=null?e.name:zf("input").toString()});if(e.batchSize==null&&(e.batchSize=null),e.sparse==null&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,e.inputShape!=null&&e.batchInputShape!=null)throw new H("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(t==null){if(e.inputShape==null)throw new H("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(e.batchSize!=null)throw new H("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");let n=e.dtype||"float32";this.batchInputShape=t,this.dtype=n,this.inputSpec=[{shape:t}];let r=new Zr(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new Uf({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new H(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}};Dc.className="InputLayer";oe.registerClass(Dc);function W0(e){if(e.batchShape==null&&e.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(e.batchShape!=null&&e.shape!=null)throw new H("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=e.batchShape;e.shape!=null&&t==null&&(t=[null].concat(e.shape));let n=e.dtype;return n==null&&(n="float32"),new Dc({batchInputShape:t,name:e.name,dtype:n,sparse:e.sparse}).inboundNodes[0].outputTensors[0]}async function xo(e){if(e==null)return;let t=[],n=[],r=[];for(let s in e){let a=e[s];if(typeof a!="number"){let o=a;t.push(o.data()),n.push(s),r.push(o)}}if(t.length>0){let s=await Promise.all(t);for(let a=0;a<s.length;++a)e[n[a]]=s[a][0];Fe(r)}}function V0(e){if(e!=null)for(let t in e){let n=e[t];typeof n!="number"&&n.dispose()}}var U0;(function(e){e[e.SILENT=0]="SILENT",e[e.VERBOSE=1]="VERBOSE"})(U0||(U0={}));var SU=125,Rc=class{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}},G0=class{constructor(e,t=10){e==null&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(let t of this.callbacks)t.setParams(e)}setModel(e){for(let t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onEpochBegin(e,t)}async onEpochEnd(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onEpochEnd(e,t)}async onBatchBegin(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onBatchBegin(e,t)}async onBatchEnd(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onBatchEnd(e,t)}async onTrainBegin(e){e==null&&(e={});for(let t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){e==null&&(e={});for(let t of this.callbacks)await t.onTrainEnd(e)}},CU=class extends Rc{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){t==null&&(t={});let n=t.size==null?0:t.size;this.seen+=n;for(let r in t){let s=t[r];if(typeof s=="number")this.totals.hasOwnProperty(r)||(this.totals[r]=0),this.totals[r]=this.totals[r]+s*n;else{let a;r in this.totals?a=this.totals[r]:this.totals[r]=0;let o=M(()=>Z(this.totals[r],V(s,n)));this.totals[r]=o,a!=null&&a.dispose()}}}async onEpochEnd(e,t){if(t!=null)for(let n of this.params.metrics)this.totals[n]!=null&&(typeof this.totals[n]=="number"?t[n]=this.totals[n]/this.seen:M(()=>{let r=V(me(1,this.seen),this.totals[n]);t[n]=r,this.totals[n].dispose(),nn(t[n])}))}},H0=class extends Rc{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){t==null&&(t={}),this.epoch.push(e);for(let n in t)this.history[n]==null&&(this.history[n]=[]),this.history[n].push(t[n])}async syncData(){let e=[],t=[],n=[];for(let s in this.history){let a=this.history[s];for(let o=0;o<a.length;++o)if(typeof a[o]!="number"){let i=a[o];e.push(i.data()),t.push(s),n.push(o)}}let r=await Promise.all(e);for(let s=0;s<r.length;++s)this.history[t[s]][n[s]].dispose(),this.history[t[s]][n[s]]=r[s][0]}},j0=class extends Rc{constructor(e,t){super();if(this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||s0,this.yieldEvery=t||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=SU),this.yieldEvery==="never"&&e.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");w.isNumber(this.yieldEvery)&&(this.maybeWait=FV(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,n){let r=[];this.yield!=null&&(await xo(n),r.push(this.yield(e,t,n))),r.push(this.nextFrameFunc()),await Promise.all(r)}async onEpochBegin(e,t){this.currentEpoch=e,this.epochBegin!=null&&(await xo(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){let n=[];this.epochEnd!=null&&(await xo(t),n.push(this.epochEnd(e,t))),this.yieldEvery==="epoch"&&n.push(this.nextFrameFunc()),await Promise.all(n)}async onBatchBegin(e,t){this.batchBegin!=null&&(await xo(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){let n=[];this.batchEnd!=null&&(await xo(t),n.push(this.batchEnd(e,t))),this.yieldEvery==="batch"?n.push(this.nextFrameFunc()):w.isNumber(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(n)}async onTrainBegin(e){this.trainBegin!=null&&(await xo(e),await this.trainBegin(e))}async onTrainEnd(e){this.trainEnd!=null&&(await xo(e),await this.trainEnd(e))}};function q0(e,t){return e==null&&(e={}),e instanceof Rc?[e]:Array.isArray(e)&&e[0]instanceof Rc?e:It(e).map(r=>new j0(r,t))}var hs=class{constructor(){}static registerCallbackConstructor(e,t){w.assert(e>=0&&Number.isInteger(e),()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`),hs.checkForDuplicate(t),hs.constructors[e]==null&&(hs.constructors[e]=[]),hs.constructors[e].push(t)}static checkForDuplicate(e){for(let t in hs.constructors)hs.constructors[+t].forEach(r=>{if(r===e)throw new H("Duplicate callback constructor.")})}static clear(){hs.constructors={}}static createCallbacks(e){let t=[];for(let n in hs.constructors){let r=+n;e>=r&&t.push(...hs.constructors[r])}return t.map(n=>new n)}},qv=hs;qv.constructors={};function K0(e,t,n,r,s,a,o,i,u){let l=new H0,c=[new CU,...qv.createCallbacks(t)];e!=null&&c.push(...e),c.push(l);let d=new G0(c);return d.setParams({epochs:n,initialEpoch:r,samples:s,steps:a,batchSize:o,verbose:t,doValidation:i,metrics:u}),{callbackList:d,history:l}}function Jr(e,t={},n=!1){return Dd(e,oe.SerializationMap.getMap().classNameMap,t,"layer",n)}function Gf(e,t){return M(()=>{e.dtype!=="float32"&&(e=ue(e,"float32"));let n=ve(Md(e),t,!0),r=_n(n.shape,Yt()),s=vn(Ds(n,r));return me(e,s)})}function Xi(e,t){return M(()=>Ot(Md(he(t,e)),-1))}function Hf(e,t){return M(()=>Ot(Xt(he(t,e)),-1))}function Pc(e,t){return M(()=>{let n=he(e,t),r=dn(Xt(e),Yt(),Number.MAX_VALUE),s=Xt(me(n,r));return V(100,Ot(s,-1))})}function TU(e,t){return M(()=>{let n=dn(t,Yt(),Number.MAX_VALUE),r=gr(Z(1,n)),s=dn(e,Yt(),Number.MAX_VALUE),a=gr(Z(1,s));return Ot(Md(he(r,a)),-1)})}function NU(e,t){return M(()=>{let n=Ds(0,he(1,V(e,t)));return Ot(Md(n),-1)})}function _U(e,t){return M(()=>{let n=Ds(0,he(1,V(e,t)));return Ot(n,-1)})}function EU(e,t){return M(()=>{let n=ve(V(e,t),-1),r=Gr(V(he(1,e),t),-1);return Ds(0,Z(1,he(r,n)))})}function AU(e,t){return M(()=>{let n=Math.log(2),r=he(t,e),s=he(Z(r,Sc(V(-2,r))),n);return Ot(s,-1)})}function Bd(e,t,n=!1){return M(()=>{if(n)t=ls(t);else{let r=ve(t,t.shape.length-1,!0);t=me(t,r)}return t=dn(t,Yt(),1-Yt()),Ft(ve(V(ue(e,"float32"),gr(t)),t.shape.length-1))})}function jf(e,t,n=!1){return M(()=>{let r=ue(Cd(qV(e)),"int32");t=dn(t,Yt(),1-Yt());let s=t.shape,a=G(xd(r,s[s.length-1]),s);return Bd(a,t,n)})}function $U(e,t){if(!w.arraysEqual(e.shape,t.shape))throw new H(`logits and labels must have the same shape, but got shapes ${JSON.stringify(e.shape)} and ${JSON.stringify(t.shape)}`);return M(()=>{let n=Qe(t),r=Ft(Xt(t));return Z(he(n,V(t,e)),af(Tn(r)))})}function qf(e,t){return M(()=>{let n;return n=dn(t,Yt(),1-Yt()),n=gr(me(n,he(1,n))),Ot($U(e,n),-1)})}function FU(e,t){return M(()=>{let n=dn(e,Yt(),1),r=dn(t,Yt(),1);return ve(V(e,gr(me(n,r))),-1)})}function DU(e,t){return M(()=>{let n=gr(Z(Yt(),t));return Ot(he(t,V(e,n)),-1)})}function Kv(e,t){return M(()=>{let n=Gf(e,-1),r=Gf(t,-1),s=V(n,r);return Ft(ve(s,-1))})}var Kf={meanSquaredError:Xi,meanAbsoluteError:Hf,meanAbsolutePercentageError:Pc,meanSquaredLogarithmicError:TU,squaredHinge:NU,hinge:_U,categoricalHinge:EU,logcosh:AU,categoricalCrossentropy:Bd,sparseCategoricalCrossentropy:jf,binaryCrossentropy:qf,kullbackLeiblerDivergence:FU,poisson:DU,cosineProximity:Kv};function Xv(e){if(typeof e=="string"){if(e in Kf)return Kf[e];let t=`Unknown loss ${e}`;throw e.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${e}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new H(t)}else return e}function Yv(e,t){return M(()=>{let n=V(.5,br(t)),r=Ef(nr(t,n),e.dtype);return Ot(mr(e,r),-1)})}function Qv(e,t){return M(()=>Ef(mr(xc(e,-1),xc(t,-1)),"float32"))}function X0(e,t){return M(()=>ue(ve(Hr(mr(e,1),mr(t,1))),"float32"))}function RU(e,t){return M(()=>ue(ve(Hr(mr(e,1),mr(t,0))),"float32"))}function PU(e,t){return M(()=>ue(ve(Hr(mr(e,0),mr(t,1))),"float32"))}function Y0(e,t){return M(()=>{let n=X0(e,t),r=PU(e,t),s=Z(n,r);return ue(Cn(nr(s,0),me(n,s),0),"float32")})}function OU(e,t){return M(()=>{let n=X0(e,t),r=RU(e,t),s=Z(n,r);return ue(Cn(nr(s,0),me(n,s),0),"float32")})}function Q0(e,t){return qf(e,t)}function Z0(e,t){return e.rank===t.rank&&(e=Rs(e,[e.rank-1])),t=xc(t,-1),t.dtype!==e.dtype&&(t=ue(t,e.dtype)),ue(mr(e,t),"float32")}var MU=Xi,LU=Xi,BU=Hf,zU=Hf,WU=Pc,VU=Pc,Zv=Bd,UU=Kv,J0=jf,Xf={binaryAccuracy:Yv,categoricalAccuracy:Qv,precision:Y0,categoricalCrossentropy:Zv,sparseCategoricalCrossentropy:J0,mse:MU,MSE:LU,mae:BU,MAE:zU,mape:WU,MAPE:VU,cosine:UU};function GU(e){if(typeof e=="string"&&e in Xf)return Xf[e];if(typeof e!="string"&&e!=null)return e;throw new H(`Unknown metric ${e}`)}function Yf(e){if(ds(e!==null,`Unknown LossOrMetricFn ${e}`),typeof e=="string")return e;{let t;for(let n of Object.keys(Kf))if(Kf[n]===e){t=n;break}if(t!==void 0)return t;for(let n of Object.keys(Xf))if(Xf[n]===e){t=n;break}return t!==void 0?t:e.name}}function HU(e){let t={Adagrad:()=>Ui.adagrad(.01),Adadelta:()=>Ui.adadelta(1,.95,Yt()),Adam:()=>Ui.adam(.001,.9,.999,Yt()),Adamax:()=>Ui.adamax(.002,.9,.999,Yt(),0),RMSProp:()=>Ui.rmsprop(.001,.9,0,Yt()),SGD:()=>Ui.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,e in t)return t[e]();throw new H(`Unknown Optimizer ${e}`)}var e2=1*1024*1024;function t2(e,t,n=!1){if(e==null||typeof e!="object"||Object.getPrototypeOf(e)!==Object.prototype||!Jv(e))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){let r=JSON.stringify(e);r.length>e2&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${r.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${e2}.`)}}function Jv(e){if(e===null)return!0;if(typeof e=="object")if(Object.getPrototypeOf(e)===Object.prototype){let t=Object.keys(e);for(let n of t)if(typeof n!="string"||!Jv(e[n]))return!1;return!0}else if(Array.isArray(e)){for(let t of e)if(!Jv(t))return!1;return!0}else return!1;else{let t=typeof e;return t==="string"||t==="number"||t==="boolean"}}function jU(e,t,n,r=console.log){let s=KU(e),a=["Layer (type)","Output shape","Param #"];s?(t=t||65,n=n||[.45,.85,1]):(t=t||98,n=n||[.33,.55,.67,1]),n[n.length-1]<=1&&(n=n.map(c=>Math.floor(t*c)));let o;if(!s){a.push("Receives inputs"),o=[];for(let c in e.nodesByDepth)o.push(...e.nodesByDepth[c])}r("_".repeat(t)),Qf(a,n,r),r("=".repeat(t));let i=e.layers;for(let c=0;c<i.length;++c)s?XU(i[c],n,r):YU(i[c],n,o,r),r((c===i.length-1?"=":"_").repeat(t));e.checkTrainableWeightsConsistency();let u=qU(e),l=Vf(e.nonTrainableWeights);r(`Total params: ${u+l}`),r(`Trainable params: ${u}`),r(`Non-trainable params: ${l}`),r("_".repeat(t))}function qU(e){let t;return e.collectedTrainableWeights!=null?t=Vf(e.collectedTrainableWeights):t=Vf(e.trainableWeights),t}function KU(e){let t=!0,n=[],r=[];for(let s in e.nodesByDepth)n.push(e.nodesByDepth[s]);for(let s of n){if(s.length>1||s.length===1&&s[0].inboundLayers.length>1){t=!1;break}r.push(...s)}if(t)for(let s of e.layers){let a=!1;for(let o of s.inboundNodes)if(r.indexOf(o)!==-1)if(a){t=!1;break}else a=!0;if(!t)break}return t}function Qf(e,t,n=console.log){let r="";for(let s=0;s<e.length;++s)s>0&&(r=r.slice(0,r.length-1)+" "),r+=e[s],r=r.slice(0,t[s]),r+=" ".repeat(t[s]-r.length);n(r)}function XU(e,t,n){let r;try{r=JSON.stringify(e.outputShape)}catch(i){r="multiple"}let s=e.name,a=e.getClassName(),o=[`${s} (${a})`,r,e.countParams().toString()];Qf(o,t,n)}function YU(e,t,n,r){let s;try{s=JSON.stringify(e.outputShape)}catch(c){s="multiple"}let a=[];for(let c of e.inboundNodes)if(!(n!=null&&n.length>0&&n.indexOf(c)===-1))for(let d=0;d<c.inboundLayers.length;++d){let p=c.inboundLayers[d].name,h=c.nodeIndices[d],f=c.tensorIndices[d];a.push(`${p}[${h}][${f}]`)}let o=e.name,i=e.getClassName(),u=a.length===0?"":a[0],l=[`${o} (${i})`,s,e.countParams().toString(),u];Qf(l,t,r);for(let c=1;c<a.length;++c)Qf(["","","",a[c]],t,r)}function n2(e,t,n){return(e==="inboundNodes"||e==="outputLayers"||e==="inputLayers")&&t===0&&typeof n=="string"}function zd(e,t){if(e===null)return null;if(typeof e=="string")return Hi(e);if(typeof e=="number"||typeof e=="boolean")return e;if(e instanceof Array){let n=[],r=e.length;for(let s=0;s<r;++s){let a=e[s];n2(t,s,a)?n.push(a):n.push(zd(a,t))}return n}else{let n={};for(let r of Object.keys(e)){let s=e[r];if(r==="name"&&typeof s=="string")n[r]=s;else{let a=Hi(r);n[a]=zd(s,a)}}return n}}function ex(e,t){if(e==null)return null;if(typeof e=="string")return Ls(e);if(typeof e=="number"||typeof e=="boolean")return e;if(e instanceof Array){let n=[],r=e.length;for(let s=0;s<r;++s){let a=e[s];n2(t,s,a)?n.push(a):n.push(ex(a,t))}return n}else{let n={};for(let r of Object.keys(e)){let s=e[r],a=Ls(r);(r==="name"||r==="className")&&typeof s=="string"?n[a]=s:n[a]=ex(s,r)}return n}}var tx="0.0.0";function QU(e,t){if(e.dtype==null||e.dtype===t.dtype)return t;try{return ue(t,e.dtype)}catch(n){throw new H(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${e.name}' (${e.dtype}).`)}}var Yi=class{constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof Yi)for(let t in e.id2Value)this.id2Value[t]=e.id2Value[t],t in e.id2Mask&&(this.id2Mask[t]=e.id2Mask[t]);else{if(e==null)return;for(let t of e)this.add(t.key,t.value)}}add(e,t,n){if(this.id2Value[e.id]==null)this.id2Value[e.id]=QU(e,t),this.name2Id[e.name]=e.id,n!=null&&(this.id2Mask[e.id]=n);else throw new H(`Duplicate key: name=${e.name}, id=${e.id}`);return this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return this.id2Value[e.id]!=null}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof Zr){if(this.id2Value[e.id]==null)throw new H(`Nonexistent key: ${e.name}`);return this.id2Value[e.id]}else{let t=this.name2Id[e];if(t==null)throw new H(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[t]}}getMask(e){if(e instanceof Zr){if(this.id2Value[e.id]==null)throw new H(`Nonexistent key: ${e.name}`);return this.id2Mask[e.id]}else{let t=this.name2Id[e];if(t==null)throw new H(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[t]}}disposeMasks(){this.id2Mask!=null&&Fe(this.id2Mask)}},nx={},r2={};function Wd(e,t,n,r){let s=n==null?!1:n.training,a=Array.isArray(e),o=a?e:[e],i=o.map(f=>f.name),u=[],l=t.names();for(let f of i)l.indexOf(f)!==-1?u.push(t.getValue(f)):u.push(null);r!=null&&(r.maxNumTensors=-1/0,r.minNumTensors=1/0);let c=i.join(",")+"|"+t.names().join(","),d,p;if(nx[c]==null){let f=ZU(o,t);d=f.sorted,p=f.recipientCounts,nx[c]=d,r2[c]=p}d=nx[c],p={},s||Object.assign(p,r2[c]);let h=new Yi(t);for(let f=0;f<d.length;++f){if(r!=null){let F=Zh().numTensors;F>r.maxNumTensors&&(r.maxNumTensors=F),F<r.minNumTensors&&(r.minNumTensors=F)}let m=d[f],g=m.sourceLayer;if(g instanceof Dc)continue;let b=[],y=[],v=[],x=!1;for(let F of m.inputs){let O=h.getValue(F),D=h.getMask(F);b.push(O),y.push(D),D!=null&&(x=!0),s||(p[F.name]--,p[F.name]===0&&!t.hasKey(F)&&i.indexOf(F.name)===-1&&!O.isDisposed&&F.sourceLayer.stateful!==!0&&v.push(O))}x&&(n=n||{},n.mask=y[0]);let k=It(g.apply(b,n)),T=null;g.supportsMasking&&(T=g.computeMask(b,y));let C=eG(m),E=Array.isArray(C)?C:[C];for(let F=0;F<E.length;++F){h.hasKey(E[F])||h.add(E[F],k[F],Array.isArray(T)?T[0]:T);let O=i.indexOf(E[F].name);O!==-1&&(u[O]=k[F])}s||Fe(v)}return h.disposeMasks(),a?u:u[0]}function ZU(e,t){w.assert(e!=null&&e.length>0,()=>"Expected at least one fetch, got none");let n=[],r={};if(e.length===1){let s=s2(e[0],t);n=s.sorted,r=s.recipientMap}else{let s=new Set;for(let a of e){let{sorted:o,recipientMap:i}=s2(a,t);for(let u of o)s.has(u.name)||(n.push(u),s.add(u.name));for(let u in i)r[u]==null&&(r[u]=new Set),i[u].forEach(l=>r[u].add(l))}}return{sorted:n,recipientCounts:JU(r)}}function JU(e){let t={};for(let n in e)t[n]=e[n].size;return t}function s2(e,t){let n=new Set,r=[],s={};for(let i of t.names())n.add(i);let a=[],o=[];for(a.push(e);a.length>0;){let i=a[a.length-1];if(n.has(i.name)){a.pop();continue}let u=o[o.length-1]===a.length-1;if(i.inputs.length===0||u)a.pop(),r.push(i),n.add(i.name),u&&o.pop();else{o.push(a.length-1);for(let l of i.inputs)s[l.name]==null&&(s[l.name]=new Set),s[l.name].add(i.name),!n.has(l.name)&&a.push(l)}}return{sorted:r,recipientMap:s}}function eG(e){let t;if(e.sourceLayer.inboundNodes.length===1)t=e.sourceLayer.output;else{let n=null;for(let r=0;r<e.sourceLayer.inboundNodes.length;++r)for(let s of e.sourceLayer.inboundNodes[r].outputTensors)if(s.id===e.id){n=r;break}t=e.sourceLayer.getOutputAt(n)}return t}var fs=class extends Ye{constructor(e){super({});if(this.containerNodes=new Set,this.name=e.name,this.name==null){let b=this.getClassName().toLowerCase();this.name=zf(b)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],bo(this.inputs).length!==this.inputs.length)throw new H(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(b=>b.name)}`);bo(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(b=>b.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(let b of this.outputs){let y=b.sourceLayer,v=b.nodeIndex,x=b.tensorIndex;this.outputLayers.push(y),this.outputLayersNodeIndices.push(v),this.outputLayersTensorIndices.push(x)}for(let b of this.inputs){let y=b.sourceLayer,v=b.nodeIndex,x=b.tensorIndex;ds(v===0,"input layer has >1 nodes"),ds(x===0,"input layer has >1 tensors"),this.inputLayers.push(y),this.inputLayersNodeIndices.push(v),this.inputLayersTensorIndices.push(x)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let b=0;b<this.inputLayers.length;b++){let y=this.inputLayers[b];if(!(y instanceof Dc))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${b} (0-based) originates from layer type ${y.getClassName()}.`);this.inputNames.push(y.name),this.feedInputShapes.push(y.batchInputShape),this.feedInputNames.push(y.name)}for(let b of this.outputLayers)this.outputNames.push(b.name);this.internalInputShapes=this.inputs.map(b=>b.shape),this.internalOutputShapes=this.outputs.map(b=>b.shape);let t={},n={},r={},s={},a={},o=[],i=(b,y,v,x,k,T)=>{(x==null||k==null||T==null)&&(x=b.sourceLayer,k=b.nodeIndex,T=b.tensorIndex);let C=x.inboundNodes[k];if(v.indexOf(C)!==-1)throw new Xr(`The tensor ${b.name} at layer "${x.name}" is part of a cycle.`);if(y.indexOf(C)!==-1)return;this.containerNodes.add(fs.nodeKey(x,k)),x.id in a||(a[x.id]=Object.keys(a).length),v.indexOf(C)===-1&&v.push(C);let E=C.inboundLayers.length;for(let F=0;F<E;F++){let O=C.inputTensors[F],D=C.inboundLayers[F],R=C.nodeIndices[F],_=C.tensorIndices[F];i(O,y,v,D,R,_)}for(y.push(C);v.indexOf(C)>=0;)v.splice(v.indexOf(C),1);o.push(C)},u=[],l=[];for(let b of this.outputs)i(b,u,l);let c=o.slice().reverse();for(let b of c){n[b.id]=b,b.id in t||(t[b.id]=0);let y=t[b.id],v=r[b.outboundLayer.id]==null?0:r[b.outboundLayer.id];y=Math.max(y,v),r[b.outboundLayer.id]=y,s[b.outboundLayer.id]=b.outboundLayer,t[b.id]=y;for(let x=0;x<b.inboundLayers.length;x++){let k=b.inboundLayers[x],T=b.nodeIndices[x],C=k.inboundNodes[T],E=t[C.id]==null?0:t[C.id];t[C.id]=Math.max(y+1,E),n[C.id]=C}}let d={};for(let b in t){let y=t[b];y in d||(d[y]=[]),d[y].push(n[b])}let p={};for(let b in r){let y=r[b];y in p||(p[y]=[]),p[y].push(s[b])}let h=Object.keys(p).map(b=>parseInt(b,10)).sort(_f);this.layers=[];for(let b of h){let y=p[b];y.sort((v,x)=>{let k=a[v.id],T=a[x.id];return k<T?-1:k>T?1:0});for(let v of y)v instanceof fs&&this.internalContainerRefs.push(v),this.layers.push(v)}this.layersByDepth=p,h=Object.keys(d).map(b=>parseInt(b,10)).sort(_f);let f=this.inputs.slice(),m=[];for(let b of h)for(let y of d[b]){let v=y.outboundLayer;if(v!=null){for(let x of y.inputTensors)if(f.indexOf(x)===-1)throw new Xr(`Graph disconnected: cannot obtain value for tensor ${x} at layer "${v.name}". The following previous layers were accessed without issue: ${m}`);for(let x of y.outputTensors)f.push(x);m.push(v.name)}}this.nodesByDepth=d;let g=this.layers.map(b=>b.name);for(let b of g){let y=g.filter(v=>v===b).length;if(y!==1)throw new Xr(`The name "${b}" is used ${y} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(g))}this.outboundNodes=[],this.inboundNodes=[],new Uf({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(b=>null),outputMasks:this.outputs.map(b=>null),inputShapes:this.inputs.map(b=>b.shape),outputShapes:this.outputs.map(b=>b.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();let e={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount==0){for(let t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(let t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach(t=>{t._trainableWeights.forEach(n=>n.trainable=e)}),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new H("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(let t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){let e=[];for(let t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){let t=[];for(let n of this.layers)t.push(...n.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e,t=!0){let n={},r=0;for(let a of this.layers)for(let o of a.weights){if(n[o.originalName]!=null)throw new H(`Duplicate weight name: ${o.originalName}`);n[o.originalName]=o,r++}let s=[];for(let a in e){let o=a;if(n[a]==null){let i=a.split("/");o=i.slice(0,-2).concat([i[i.length-1]]).join("/")}if(n[o]!=null)s.push([n[o],e[a]]);else if(t)throw new H(`Provided weight data has no target variable: ${a}`);delete n[o]}if(t){let a=[];for(let o in n)a.push(o);if(a.length>0)throw new H(`${a.length} of ${r} weights are not set: ${a}`)}jv(s)}updatedConfig(){let e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion=`tfjs-layers ${tx}`,t.backend="TensorFlow.js",t}toJSON(e,t=!0){let n=ex(this.updatedConfig());return t?JSON.stringify(n):n}call(e,t){return M(()=>{e=It(e);let n=new Yi;for(let r=0;r<this.inputs.length;++r)n.add(this.inputs[r],e[r]);return Wd(this.outputs,n,t)})}computeMask(e,t){return M(()=>{e=It(e);let n;return t==null?n=Gi(null,e.length):n=It(t),this.runInternalGraph(e,n)[1]})}computeOutputShape(e){let t=Wf(e);if(t.length!==this.inputLayers.length)throw new H(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);let n={};for(let o=0;o<t.length;o++){let i=this.inputLayers[o],u=t[o],l=i.name+"_0_0";n[l]=u}let r=Object.keys(this.nodesByDepth).map(o=>parseInt(o,10)).sort(_f);if(r.length>1)for(let o of r){let i=this.nodesByDepth[o];for(let u of i){let l=u.outboundLayer;if(this.inputLayers.map(f=>f.id).indexOf(l.id)!==-1)continue;let c=[];for(let f=0;f<u.inboundLayers.length;f++){let m=u.inboundLayers[f],g=u.nodeIndices[f],b=u.tensorIndices[f],y=`${m.name}_${g}_${b}`,v=n[y];c.push(v)}let d=l.computeOutputShape(Gn(c)),p=Wf(d),h=l.inboundNodes.indexOf(u);for(let f=0;f<p.length;f++){let m=`${l.name}_${h}_${f}`;n[m]=p[f]}}}let s=[],a=[];for(let o=0;o<this.outputLayers.length;o++){let i=this.outputLayers[o],u=this.outputLayersNodeIndices[o],l=this.outputLayersTensorIndices[o],c=`${i.name}_${u}_${l}`;a.push(c)}for(let o=0;o<a.length;o++){let i=a[o];ds(i in n),s.push(n[i])}return Gn(s)}runInternalGraph(e,t){t==null&&(t=Gi(null,e.length));let n={};for(let i=0;i<this.inputs.length;++i){let u=this.inputs[i],l=e[i],c=t[i];n[u.id]=[l,c]}let r=Object.keys(this.nodesByDepth).map(i=>parseInt(i,10)).sort(_f);for(let i of r){let u=this.nodesByDepth[i];for(let l of u){let c=l.outboundLayer,d=l.inputTensors,p=l.outputTensors,h=new Array;for(let f of d)f.id in n&&h.push(n[f.id]);if(h.length===d.length){let f={},m,g,b,y;if(l.callArgs!=null&&(f=l.callArgs),h.length===1){let[v,x]=h[0];f.mask==null&&(f.mask=x),b=It(c.call(v,f)),y=It(c.computeMask(v,x)),m=[v],g=[x]}else m=h.map(v=>v[0]),g=h.map(v=>v[1]),f.mask==null&&(f.mask=g),b=It(c.call(m,f)),y=It(c.computeMask(m,g));if(c.activityRegularizer)throw new De("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let v=0;v<p.length;++v){let x=p[v],k=b[v],T=y[v];n[x.id]=[k,T]}}}}let s=[],a=[],o=[];for(let i of this.outputs){ds(i.id in n,`Could not compute output ${i.name} : ${i.id}`);let[u,l]=n[i.id];o.push(u.shape),s.push(u),a.push(l)}return[s,a,o]}buildNodeConversionMap(e){let t={},n;for(let r of this.layers){n=r instanceof fs?1:0;for(let s=0;s<r.inboundNodes.length;s++){let a=fs.nodeKey(r,s);this.containerNodes.has(a)&&(t[a]=n,n+=1)}}return t}getLayer(e,t){if(t!=null){if(this.layers.length<=t)throw new H(`Was asked to retrieve layer at index ${t}, but model only has ${this.layers.length} layer(s).`);return this.layers[t]}else if(e==null)throw new H("Provide either a layer name or layer index");for(let n of this.layers)if(n.name===e)return n;throw new H(`No such layer: ${e}`)}calculateLosses(){return M(()=>{let e=[];for(let t of this.layers)for(let n=0;n<t.inboundNodes.length;++n){let r=fs.nodeKey(t,n);this.containerNodes.has(r)&&e.push(...t.calculateLosses())}return e})}getConfig(){let e={name:this.name},t=this.buildNodeConversionMap(this.layers),n=[];for(let a of this.layers){let o=a.getClassName(),i=a.getConfig(),u=[];for(let c=0;c<a.inboundNodes.length;c++){let d=a.inboundNodes[c],p=fs.nodeKey(a,c),h={};if(this.containerNodes.has(p)){if(d.callArgs)try{JSON.stringify(d.callArgs),h=d.callArgs}catch(f){console.warn(`Layer ${a.name} was passed non-serializable keyword arguments: ${d.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),h={}}if(d.inboundLayers.length>0){let f=[];for(let m=0;m<d.inboundLayers.length;m++){let g=d.inboundLayers[m],b=d.nodeIndices[m],y=d.tensorIndices[m],v=fs.nodeKey(g,b),x=t[v];x==null&&(x=0),f.push([g.name,x,y,h])}u.push(f)}}}let l={};l.name=a.name,l.className=o,l.config=i,l.inboundNodes=u,n.push(l)}e.layers=n;let r=[];for(let a=0;a<this.inputLayers.length;a++){let o=this.inputLayers[a],i=this.inputLayersNodeIndices[a],u=fs.nodeKey(o,i);if(!this.containerNodes.has(u))continue;let l=t[u];l==null&&(l=0);let c=this.inputLayersTensorIndices[a];r.push([o.name,l,c])}e.inputLayers=r;let s=[];for(let a=0;a<this.outputLayers.length;a++){let o=this.outputLayers[a],i=this.outputLayersNodeIndices[a],u=fs.nodeKey(o,i);if(!this.containerNodes.has(u))continue;let l=t[u];l==null&&(l=0);let c=this.outputLayersTensorIndices[a];s.push([o.name,l,c])}return e.outputLayers=s,e}static fromConfig(e,t,n={},r=!1){let s={},a={};function o(m,g){m.name in a?a[m.name].push(g):a[m.name]=[g]}function i(m,g){let b=[],y;for(let v of g){let x=v[0],k=v[1],T=v[2];if(y=v[3]==null?{}:v[3],!(x in s)){o(m,g);return}let C=s[x];if(C.inboundNodes.length<=k){o(m,g);return}let E=C.inboundNodes[k];b.push(E.outputTensors[T])}b.length>0&&m.apply(Gn(b),y)}function u(m){let g=m.name,b=Jr(m,t.customObjects!=null?t.customObjects:{});b.setFastWeightInitDuringBuild(r),s[g]=b,m.inboundNodes.forEach(v=>{if(!(v instanceof Array))throw new H(`Corrupted configuration, expected array for nodeData: ${v}`);o(b,v)})}let l=t.name,c=t.layers;for(let m of c)u(m);for(;!$V(a);)for(let m of c){let g=s[m.name];if(g.name in a){let b=a[g.name];delete a[g.name];for(let y of b)i(g,y)}}let d=[],p=[],h=t.inputLayers;for(let m of h){let g=m[0],b=m[1],y=m[2];ds(g in s);let x=s[g].inboundNodes[b].outputTensors;d.push(x[y])}let f=t.outputLayers;for(let m of f){let g=m[0],b=m[1],y=m[2];ds(g in s);let x=s[g].inboundNodes[b].outputTensors;p.push(x[y])}return new e({inputs:d,outputs:p,name:l})}get stateful(){if(this._stateful)throw new H("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(let e of this.layers)if(e.stateful)return!0;return!1}resetStates(){M(()=>{this.layers.forEach(e=>{e.stateful&&e.resetStates()})})}};function tG(e,t,n){let r=t.length;if(e==null||Array.isArray(e)&&e.length===0)return t.map(s=>null);if(r===1)return Array.isArray(e)&&e.length===1?e:typeof e=="object"&&t[0]in e?[e[t[0]]]:[e];if(Array.isArray(e)){if(e.length!==r)throw new Error(`Provided ${n} is an array of ${e.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);return e}else if(typeof e=="object"&&Object.keys(e).length>0&&typeof e[Object.keys(e)[0]]=="object"){let s=[];return t.forEach(a=>{a in e?s.push(e[a]):s.push(null)}),s}else throw new Error(`The model has multiple (${r}) outputs, so ${n} must be either an array with ${r} elements or an object with ${t} keys. Provided ${n} not understood: ${JSON.stringify(e)}`)}function a2(e,t){return tG(e,t,"classWeight")}async function o2(e,t,n,r){if(t!=null||r!=null)throw new Error("Support sampleWeight is not implemented yet");if(n!=null){let s=M(()=>{if(e.shape.length===1)return Fs(e);if(e.shape.length===2){if(e.shape[1]>1)return xc(e,1);if(e.shape[1]===1)return G(e,[e.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${e.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${e.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),a=Array.from(await s.data());Fe(s);let o=[];return a.forEach(i=>{if(n[i]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${i} exists in the data but not in classWeight`);o.push(n[i])}),je(o,"float32")}else return null}function nG(e,t){return V(e,t)}var rG=32;function i2(e,t){let n,r,s=t;n=s.xs,r=s.ys,w.assert(n!=null&&r!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`);let a=u2("input",e.inputNames,n),o=u2("output",e.outputNames,r),i=a[0].shape[0];w.assert(a.length===e.inputs.length,()=>`LayersModel has ${e.inputs.length} inputs, but the dataset provides ${a.length} inputs.  (Expected input keys: ${JSON.stringify(e.inputNames)})`),w.assert(o.length===e.outputs.length,()=>`LayersModel has ${e.outputs.length} outputs, but the dataset provides ${o.length} outputs.  (Expected output keys: ${JSON.stringify(e.outputNames)})`);for(let u=0;u<a.length;u++)w.assert(a[u].shape[0]===i,()=>`Batch size mismatch: input ${e.inputNames[u]} has ${a[u].shape[0]}; expected  ${i} based on input ${e.inputNames[0]}.`);for(let u=0;u<o.length;u++)w.assert(o[u].shape[0]===i,()=>`Batch size mismatch: output ${e.outputNames[u]} has ${o[u].shape[0]}; expected  ${i} based on input ${e.inputNames[0]}.`);return{xs:a,ys:o}}function u2(e,t,n){if(n instanceof Ae)return[n];if(Array.isArray(n))return w.assert(n.length===t.length,()=>`Received an array of ${n.length} Tensors, but expected ${t.length} to match the ${e} keys ${t}.`),n;{let r=[];for(let s of t){if(n[s]==null)throw new H(`The feature data generated by the dataset lacks the required ${e} key '${s}'.`);r.push(n[s])}return r}}function sG(e){if(e.length===3)throw new De("Validation with sample weights is not implemented yet.");return{xs:e[0],ys:e[1]}}async function aG(e,t,n){let r=n.batchesPerEpoch!=null;if(w.assert(e.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),w.assert(n!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),w.assert(n.epochs!=null&&n.epochs>0&&Number.isInteger(n.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${n.epochs}`),w.assert(!r||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${n.batchesPerEpoch}`),w.assert(n.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0;try{let s=n.validationData!=null,a,o;if(s)if(c2(n.validationData))w.assert(n.validationBatches==null||n.validationBatches>0&&Number.isInteger(n.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${n.validationBatches}`);else{let g=sG(n.validationData);a=g.xs,o=g.ys}let i=e.makeTrainFunction(),u=e.getDedupedMetricsNames(),l;s?l=u.slice().concat(u.map(g=>"val_"+g)):l=u.slice();let c=q0(n.callbacks,n.yieldEvery),d=n.verbose==null?1:n.verbose,{callbackList:p,history:h}=K0(c,d,n.epochs,null,null,oG(t,n),null,s,l);p.setModel(e),e.history=h,await p.onTrainBegin(),e.stopTraining_=!1;let f=n.initialEpoch==null?0:n.initialEpoch,m=await t.iterator();for(;f<n.epochs;){let g={};await p.onEpochBegin(f);let b=0,y=0;for(r||(m=await t.iterator());r?b<n.batchesPerEpoch:!0;){let v=await m.next();if(r&&v.done){console.warn(`You provided \`batchesPerEpoch\` as ${n.batchesPerEpoch}, but your dataset iterator ran out of data after ${b} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${n.batchesPerEpoch*n.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(v.value!=null){let{xs:x,ys:k}=i2(e,v.value),T={};T.batch=y,T.size=x[0].shape[0],await p.onBatchBegin(y,T);let C=[];if(n.classWeight!=null){let O=a2(n.classWeight,e.outputNames);for(let D=0;D<O.length;++D)C.push(await o2(k[D],null,O[D]))}let E=x.concat(k).concat(C),F=i(E);Fe(E);for(let O=0;O<u.length;++O){let D=u[O],R=F[O];T[D]=R,nn(R)}await p.onBatchEnd(y,T),V0(T),y++,b++}if(r?b>=n.batchesPerEpoch:v.done){if(s){let x;c2(n.validationData)?x=It(await e.evaluateDataset(n.validationData,{batches:n.validationBatches})):x=It(e.evaluate(a,o,{batchSize:n.validationBatchSize==null?rG:n.validationBatchSize,verbose:0}));for(let k=0;k<e.metricsNames.length;++k)g[`val_${e.metricsNames[k]}`]=x[k]}break}if(e.stopTraining_)break}if(await p.onEpochEnd(f,g),f++,e.stopTraining_)break}return await p.onTrainEnd(),await e.history.syncData(),e.history}finally{e.isTraining=!1}}function oG(e,t){let n=null;return t.batchesPerEpoch!=null?n=t.batchesPerEpoch:Number.isFinite(e.size)&&(n=e.size),n}function c2(e){return typeof e.iterator=="function"}function iG(e){return typeof e.next=="function"}async function uG(e,t,n){n=n||{};let r=n.batches!=null,s=e.testFunction,a=[];if(n.verbose>0)throw new De("Verbose mode is not implemented yet.");w.assert(!r||n.batches>0&&Number.isInteger(n.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(n.batches)}`);let o=iG(t)?t:await t.iterator(),i=0,u=0;for(;r?u<n.batches:!0;){let l=await o.next();if(a=M(()=>{if(l.value){let{xs:c,ys:d}=i2(e,l.value),p=c.concat(d),h=M(()=>s(p));if(Fe(p),u===0)for(let m=0;m<h.length;++m)a.push(ke(0));let f=p[0].shape[0];for(let m=0;m<h.length;++m){let g=h[m],b=a[m];a[m]=M(()=>Z(a[m],V(f,g))),u>0&&Fe(b)}Fe(h),i+=f,++u}return a}),l.done){r&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${n.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let l=0;l<a.length;++l){let c=a[l];a[l]=me(a[l],i),Fe(c)}return Gn(a)}function rx(e){w.assert(e>0&&Number.isInteger(e),()=>`batchSize is required to be a positive integer, but got ${e}`)}function Vd(e,t,n){return e==null?[null]:Array.isArray(e)?e.map(r=>Ki(r,t,n-t)):Ki(e,t,n-t)}function sx(e,t){return M(()=>e==null?null:Array.isArray(e)?e.map(n=>sx(n,t)):F0(e,t.dtype==="int32"?t:ue(t,"int32")))}function ax(e,t){let n=[],r=0,s=null;for(;r<e;)s=r+t,s>=e&&(s=e),n.push([r,s]),r=s;return n}async function cG(e,t,n,r,s,a,o,i,u,l,c,d,p,h,f){s==null&&(s=32),a==null&&(a=1),c==null&&(c=!0),p==null&&(p=0);let m=!1;if(u!=null&&l!=null&&(m=!0),f!=null&&(m=!0,h==null))throw new H("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");let g=e.checkNumSamples(n,s,h,"steps_per_epoch"),b;g!=null&&(b=Yr(0,g)),o==null&&(o=1);let{callbackList:y,history:v}=K0(i,o,a,p,g,h,s,m,d);y.setModel(e),e.history=v,await y.onTrainBegin(),e.stopTraining_=!1;for(let x=p;x<a;++x){await y.onEpochBegin(x);let k={};if(h!=null)throw new De("stepsPerEpoch mode is not implemented yet.");{if(c==="batch")throw new De("batch shuffling is not implemneted yet");c&&w.shuffle(b);let T=je(b),C=ax(g,s);for(let E=0;E<C.length;++E){let F={};if(await y.onBatchBegin(E,F),M(()=>{let O=C[E][0],D=C[E][1],R=Ki(T,O,D-O);F.batch=E,F.size=D-O;let _=sx(n,R),L=t(_);for(let U=0;U<r.length;++U){let j=r[U],K=L[U];F[j]=K,nn(K)}if(E===C.length-1&&m){let U=e.testLoop(u,l,s);for(let j=0;j<r.length;++j){let K=r[j],q=U[j];nn(q),k["val_"+K]=q}}}),await y.onBatchEnd(E,F),V0(F),e.stopTraining_)break}T.dispose()}if(await y.onEpochEnd(x,k),e.stopTraining_)break}return await y.onTrainEnd(),await e.history.syncData(),e.history}async function lG(e,t,n,r={}){if(e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0;let s,a,o,i,u,l,c;try{let d=r.batchSize==null?32:r.batchSize;rx(d);let p=!1,h=await e.standardizeUserData(t,n,r.sampleWeight,r.classWeight,p,d);s=h[0],a=h[1],c=h[2];let f=!1,m;if(r.validationData!=null&&r.validationData.length>0){if(f=!0,r.validationData.length===2)o=r.validationData[0],i=r.validationData[1];else throw r.validationData.length===3?new De("validationData including sample weights is not supported yet."):new H(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${r.validationData} is invalid.`);let C=!0,E=await e.standardizeUserData(o,i,null,null,C,d);u=E[0],l=E[1],m=u.concat(l)}else if(r.validationSplit!=null&&r.validationSplit>0&&r.validationSplit<1){f=!0;let C=Math.floor(s[0].shape[0]*(1-r.validationSplit)),E=s[0].shape[0];u=Vd(s,C,E),s=Vd(s,0,C),l=Vd(a,C,E),a=Vd(a,0,C),m=u.concat(l)}else r.validationSteps!=null&&(f=!0);let g=s.concat(a).concat(c);e.checkTrainableWeightsConsistency();let b=e.makeTrainFunction(),y=e.getDedupedMetricsNames(),v,x;f?(e.makeTestFunction(),v=e.testFunction,x=y.slice().concat(y.map(C=>"val_"+C))):(v=null,m=[],x=y.slice());let k=q0(r.callbacks,r.yieldEvery);return await cG(e,b,g,y,d,r.epochs,r.verbose,k,v,m,r.shuffle,x,r.initialEpoch,null,null)}finally{e.isTraining=!1,Qi(s,t),Qi(a,n),Qi(u,o),Qi(l,i),c!=null&&Fe(c)}}function l2(e){let t=[];e instanceof Ae&&(e=[e]);for(let n=0;n<e.length;++n){let r=e[n];if(r.rank===1)t.push(Od(r,1));else{if(r.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(r)}}return t}function Qi(e,t){if(e==null)return;let n=[];if(t instanceof Ae)n.push(t.id);else if(Array.isArray(t))t.forEach(s=>n.push(s.id));else if(t!=null)for(let s in t){let a=t[s];n.push(a.id)}let r=[];if(e instanceof Ae)n.indexOf(e.id)===-1&&r.push(e);else if(Array.isArray(e))e.forEach(s=>{n.indexOf(s.id)===-1&&r.push(s)});else if(e!=null)for(let s in e){let a=e[s];n.indexOf(a.id)===-1&&r.push(a)}r.forEach(s=>{s.isDisposed||s.dispose()})}function dG(e){return e instanceof Ae}function ox(e){return Array.isArray(e)}function d2(e){return!dG(e)&&!ox(e)}function p2(e,t,n,r=!0,s=""){if(t==null||t.length===0){if(e!=null){let o=!1;if(ox(e)&&e.length>0)o=!0;else if(d2(e)){for(let i in e)if(e.hasOwnProperty(i)){o=!0;break}}else o=!0;if(o)throw new H(`Error when checking model ${s} expected no data, but got ${e}`)}return[]}if(e==null)return t.map(o=>null);let a;if(d2(e)){e=e,a=[];for(let o of t){if(e[o]==null)throw new H(`No data provided for "${o}". Need data for each key in: ${t}`);a.push(e[o])}}else if(ox(e)){if(e=e,e.length!==t.length)throw new H(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${e}`);a=e}else{if(e=e,t.length>1)throw new H(`The model ${s} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${e.shape}`);a=[e]}if(a=l2(a),n!=null)for(let o=0;o<t.length;++o){if(n[o]==null)continue;let i=a[o];if(i.shape.length!==n[o].length)throw new H(`Error when checking ${s}: expected ${t[o]} to have ${n[o].length} dimension(s). but got array with shape ${i.shape}`);for(let u=0;u<n[o].length;++u){if(u===0&&!r)continue;let l=i.shape[u],c=n[o][u];if(c!=null&&c>=0&&l!==c)throw new H(`${s} expected a batch of elements where each example has shape [${n[o].slice(1,n[o].length)}] (i.e.,tensor shape [*,${n[o].slice(1,n[o].length)}]) but the ${s} received an input with ${i.shape[0]} examples, each with shape [${i.shape.slice(1,i.shape.length)}] (tensor shape [${i.shape}])`)}}return a}function pG(e,t,n){let r=bo(e.map(a=>a.shape[0]));r.sort();let s=bo(t.map(a=>a.shape[0]));if(s.sort(),r.length>1)throw new H(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(a=>a.shape))}`);if(s.length>1)throw new H(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(a=>a.shape))}`);if(r.length>0&&s.length>0&&!w.arraysEqual(r,s))throw new H(`Input Tensors should have the same number of samples as target Tensors. Found ${r[0]} input sample(s) and ${s[0]} target sample(s).`)}function hG(e,t,n){let r=[Xi,qf,Bd];for(let s=0;s<e.length;++s){let a=e[s],o=t[s],i=n[s];if(o!=null){if(o===Bd&&a.shape[a.shape.length-1]===1)throw new H(`You are passing a target array of shape ${a.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(r.indexOf(o)!==-1){let u=a.shape.slice(1),l=i.slice(1);for(let c=0;c<u.length;++c){let d=u[c],p=l[c];if(p!=null&&d!==p)throw new H(`A target Tensor with shape ${a.shape} was passed for an output of shape ${i}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function h2(e,t,n,r=!0,s=""){let a;if(Array.isArray(e)){if(e.length!==t.length)throw new H(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${e.length} Tensors(s).`);a=e}else{if(t.length>1)throw new H(`The model expects ${t.length} ${s} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(e.shape)}.`);a=[e]}if(n!=null)for(let o=0;o<t.length;++o){if(n[o]==null)continue;let i=a[o];if(i.shape.length!==n[o].length)throw new H(`Error when checking ${s}: expected ${t[o]} to have ${n[o].length} dimension(s), but got array with shape ${JSON.stringify(i.shape)}`);for(let u=0;u<n[o].length;++u){if(u===0&&!r)continue;let l=i.shape[u],c=n[o][u];if(c!=null&&c!==l)throw new H(`Error when checking ${s}: expected ${t[o]} to have shape ${JSON.stringify(n[o])} but got array with shape ${JSON.stringify(i.shape)}.`)}}}function fG(e,t){if(e==null||Array.isArray(e)&&e.length===0)return t.map(r=>[]);let n;if(typeof e=="string"||typeof e=="function")n=[e];else if(Array.isArray(e)||typeof e=="object")n=e;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${e}`);if(Array.isArray(n))return t.map(r=>n);{let r=[];for(let s of t){let a=n.hasOwnProperty(s)?n[s]:[];Array.isArray(a)||(a=[a]),r.push(a)}return r}}var mG="layers-model",Bs=class extends fs{constructor(e){super(e);this.isTraining=!1}summary(e,t,n=console.log){if(!this.built)throw new H("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");jU(this,e,t,n)}compile(e){if(e.loss==null&&(e.loss=[]),this.loss=e.loss,typeof e.optimizer=="string")this.optimizer_=HU(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof Os))throw new H("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(!Array.isArray(e.loss)&&typeof e.loss!="string"&&typeof e.loss!="function"){e.loss=e.loss;for(let a in e.loss)if(this.outputNames.indexOf(a)===-1)throw new H(`Unknown entry in loss dictionary: "${a}". Only expected the following keys: ${this.outputNames}`);for(let a of this.outputNames)e.loss[a]==null&&console.warn(`Output "${a}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${a} during training`),t.push(Xv(e.loss[a]))}else if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new H(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);t=e.loss.map(o=>Xv(o))}else{let a=Xv(e.loss);this.outputs.forEach(o=>{t.push(a)})}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let a=0;a<this.outputs.length;++a){let o=this.internalOutputShapes[a],i=this.outputNames[a];this.feedOutputNames.push(i),this.feedOutputShapes.push(o),this.feedLossFns.push(this.lossFunctions[a])}let n=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],qi("loss",()=>{for(let a=0;a<this.outputs.length;++a){if(n.indexOf(a)!==-1)continue;let o=this.lossFunctions[a];this.outputs.length>1&&(this.metricsTensors.push([o,a]),this.metricsNames.push(this.outputNames[a]+"_loss"))}});let r=fG(e.metrics,this.outputNames),s=(a,o,i)=>{this.outputNames.length>1&&(o=this.outputNames[a]+"_"+o),this.metricsNames.push(o),this.metricsTensors.push([i,a])};qi("metric",()=>{for(let a=0;a<this.outputs.length;++a){if(n.indexOf(a)!==-1)continue;let o=r[a];(u=>{let l="",c,d,p;for(let h of u){if(typeof h=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(h)!==-1){let m=this.internalOutputShapes[a];m[m.length-1]===1||this.lossFunctions[a]===qf?["accuracy","acc"].indexOf(h)!==-1?d=Yv:["crossentropy","ce"].indexOf(h)!==-1&&(d=Q0):this.lossFunctions[a]===jf?["accuracy","acc"].indexOf(h)!==-1?d=Z0:["crossentropy","ce"].indexOf(h)!==-1&&(d=J0):["accuracy","acc"].indexOf(h)!==-1?d=Qv:["crossentropy","ce"].indexOf(h)!==-1&&(d=Zv);let g;["accuracy","acc"].indexOf(h)!==-1?g="acc":["crossentropy","ce"].indexOf(h)!==-1&&(g="ce"),p=d,c=l+g}else p=GU(h),c=l+Yf(h);let f;qi(c,()=>{f=p}),s(a,c,f)}})(o)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t,n={}){let r=n.batchSize==null?32:n.batchSize;rx(r);let s=!0,a=this.standardizeUserDataXY(e,t,s,r);try{let o=a[0].concat(a[1]);this.makeTestFunction();let i=this.testFunction,u=this.testLoop(i,o,r,n.verbose,n.steps);return Gn(u)}finally{Qi(a[0],e),Qi(a[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),uG(this,e,t)}checkNumSamples(e,t,n,r="steps"){let s;if(n!=null){if(s=null,t!=null)throw new H(`If ${r} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else if(e!=null)Array.isArray(e)?s=e[0].shape[0]:s=e.shape[0];else throw new H(`Either the input data should have a defined shape, or ${r} shoud be specified.`);return s}execute(e,t){if(Array.isArray(t)&&t.length===0)throw new H("`outputs` is an empty Array, which is not allowed.");let n=Array.isArray(t),r=n?t:[t],s=this.retrieveSymbolicTensors(r),a=new Yi;if(e instanceof Ae&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new H(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let i=0;i<this.inputs.length;++i)a.add(this.inputs[i],e[i])}else for(let i of this.inputs){let u=e[i.name];if(u==null)throw new H(`No value is provided for the model's input ${i.name}`);a.add(i,u)}let o=Wd(s,a);return n?o:o[0]}retrieveSymbolicTensors(e){let t=Gi(null,e.length),n=e.length;for(let r of this.layers){let s=Array.isArray(r.output)?r.output:[r.output],a=s.map(o=>o.name);for(let o=0;o<e.length;++o){let i=a.indexOf(e[o]);if(i!==-1&&(t[o]=s[i],n--),n===0)break}if(n===0)break}if(n>0){let r=[];throw t.forEach((s,a)=>{s==null&&r.push(e[a])}),new H(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(r)}`)}return t}predictLoop(e,t=32,n=!1){return M(()=>{let r=this.checkNumSamples(e);if(n)throw new De("Verbose predictLoop() is not implemented yet.");let s=ax(r,t),a=this.outputs.map(o=>[]);for(let o=0;o<s.length;++o)M(()=>{let u=s[o][0],l=s[o][1],c=Vd(e,u,l),d=[];if(Array.isArray(c))for(let h=0;h<c.length;++h)d.push({key:this.inputs[h],value:c[h]});else d.push({key:this.inputs[0],value:c});let p=new Yi(d);return Wd(this.outputs,p)}).forEach((u,l)=>a[l].push(u));return Gn(a.map(o=>ot(o,0)))})}predict(e,t={}){let n=l2(e);h2(n,this.inputNames,this.feedInputShapes,!1);try{let r=t.batchSize==null?32:t.batchSize;return rx(r),this.predictLoop(n,r)}finally{Qi(n,e)}}predictOnBatch(e){h2(e,this.inputNames,this.feedInputShapes,!0);let t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t,n=!0,r){if(this.optimizer_==null)throw new Xr("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");let s=[];for(let a=0;a<this.feedOutputShapes.length;++a){let o=this.feedOutputShapes[a];this.feedLossFns[a]===jf?s.push(o.slice(0,o.length-1).concat([1])):s.push(o)}if(e=p2(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=p2(t,this.feedOutputNames,s,!1,"target"),pG(e,t,null),hG(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&r!=null&&r>0&&e[0].shape[0]%r!=0)throw new H(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${r}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,n,r,s=!0,a){let[o,i]=this.standardizeUserDataXY(e,t,s,a);if(n!=null)throw new Error("sample weight is not supported yet.");let u=null;if(r!=null){let l=a2(r,this.outputNames);u=[];for(let c=0;c<l.length;++c)u.push(await o2(i[c],null,l[c]))}return[o,i,u]}testLoop(e,t,n,r=0,s){return M(()=>{let a=this.checkNumSamples(t,n,s,"steps"),o=[];if(r>0)throw new De("Verbose mode is not implemented yet.");if(s!=null)throw new De("steps mode in testLoop() is not implemented yet");{let i=ax(a,n),u=je(Yr(0,a));for(let l=0;l<i.length;++l){let c=i[l][0],d=i[l][1],p=Ki(u,c,d-c),h=sx(t,p),f=e(h);if(l===0)for(let m=0;m<f.length;++m)o.push(ke(0));for(let m=0;m<f.length;++m){let g=f[m];o[m]=Z(o[m],V(d-c,g))}}for(let l=0;l<o.length;++l)o[l]=me(o[l],a)}return o})}getDedupedMetricsNames(){let e=this.metricsNames,t=[];for(let n=0;n<e.length;++n){let r=e[n],s=r;x0(e,r)>1&&(s+=`_${x0(e.slice(0,n),r)}`),t.push(s)}return t}makeTrainFunction(){return e=>{let t=[],n=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),s=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),a=[],o=()=>{let c=[];for(let f=0;f<this.inputs.length;++f)c.push({key:this.inputs[f],value:n[f]});let d=new Yi(c),p=Wd(this.outputs,d,{training:!0}),h;for(let f=0;f<this.lossFunctions.length;++f){let g=this.lossFunctions[f](r[f],p[f]);s[f]!=null&&(g=nG(g,s[f]));let b=Ot(g);t.push(b),f===0?h=g:h=Z(h,g)}for(let f=0;f<this.metricsTensors.length;++f){let m;if(this.outputs.length>1&&f<this.outputs.length)m=t[f];else{let g=this.metricsTensors[f][0],b=this.metricsTensors[f][1];m=Ot(g(r[b],p[b]))}nn(m),a.push(m)}return h=Ot(h),this.calculateLosses().forEach(f=>{h=Z(h,f)}),h},i=this.collectedTrainableWeights.map(c=>c.read()),u=!0;return[this.optimizer_.minimize(o,u,i)].concat(a)}}makeTestFunction(){this.testFunction=e=>M(()=>{let t=[],n,r=e.slice(0,this.inputs.length),s=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=[];for(let u=0;u<this.inputs.length;++u)a.push({key:this.inputs[u],value:r[u]});let o=new Yi(a),i=Wd(this.outputs,o);for(let u=0;u<this.lossFunctions.length;++u){let l=this.lossFunctions[u],c=Ot(l(s[u],i[u]));u===0?n=c:n=Z(n,c),t.push(n)}for(let u=0;u<this.metricsTensors.length;++u){let l=this.metricsTensors[u][0],c=this.metricsTensors[u][1],d=Ot(l(s[c],i[c]));t.push(d)}return t})}async fit(e,t,n={}){return lG(this,e,t,n)}async fitDataset(e,t){return aG(this,e,t)}async trainOnBatch(e,t){let n=await this.standardizeUserData(e,t),r=n[0],s=n[1],o=this.makeTrainFunction()(r.concat(s)),i=[];for(let u of o){let l=await u.data();i.push(l[0])}return Fe(o),Gn(i)}getNamedWeights(e){let t=[],n=e!=null&&e.trainableOnly,r=n?this.trainableWeights:this.weights,s=this.getWeights(n);for(let a=0;a<r.length;++a)n&&!r[a].trainable||t.push({name:r[a].originalName,tensor:s[a]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){let e=super.dispose();if(e.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){let t=Zh().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-Zh().numTensors}return e}getLossIdentifiers(){let e;if(typeof this.loss=="string")e=Ls(this.loss);else if(Array.isArray(this.loss)){for(let t of this.loss)if(typeof t!="string")throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(t=>Ls(t))}else{let t=Object.keys(this.loss);e={};let n=this.loss;for(let r of t)if(typeof n[r]=="string")e[r]=Ls(n[r]);else throw new Error("Serialization of non-string loss is not supported.")}return e}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[Ls(Yf(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>Ls(Yf(e)));{let e={};for(let t in this.metrics)e[t]=Ls(Yf(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(e.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(e.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(e.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");let t=zd(e.optimizer_config),n=Jr(t),r;if(typeof e.loss=="string")r=Hi(e.loss);else if(Array.isArray(e.loss))r=e.loss.map(a=>Hi(a));else if(e.loss!=null){r={};for(let a in e.loss)r[a]=Hi(e.loss[a])}let s;if(Array.isArray(e.metrics))s=e.metrics.map(a=>Hi(a));else if(e.metrics!=null){s={};for(let a in e.metrics)s[a]=Hi(e.metrics[a])}this.compile({loss:r,metrics:s,optimizer:n})}async save(e,t){if(typeof e=="string"){let u=tn.getSaveHandlers(e);if(u.length===0)throw new H(`Cannot find any save handlers for URL '${e}'`);if(u.length>1)throw new H(`Found more than one (${u.length}) save handlers for URL '${e}'`);e=u[0]}if(e.save==null)throw new H("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");let n=await tn.encodeWeights(this.getNamedWeights(t)),r=!1,s=null,o={modelTopology:this.toJSON(s,r),format:mG,generatedBy:`TensorFlow.js tfjs-layers v${tx}`,convertedBy:null};if((t==null?!1:t.includeOptimizer)&&this.optimizer!=null){o.trainingConfig=this.getTrainingConfig();let u="optimizer",{data:l,specs:c}=await tn.encodeWeights(await this.optimizer.getWeights(),u);n.specs.push(...c),n.data=tn.concatenateArrayBuffers([n.data,l])}if(this.userDefinedMetadata!=null){let u=!0;t2(this.userDefinedMetadata,this.name,u),o.userDefinedMetadata=this.userDefinedMetadata}return o.weightData=n.data,o.weightSpecs=n.specs,e.save(o)}setUserDefinedMetadata(e){t2(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}};Bs.className="Model";oe.registerClass(Bs);var f2=class extends Bs{};f2.className="Functional";oe.registerClass(f2);async function gG(e,t){"modelTopology"in e||(e={modelTopology:e}),e=e;let n=e.modelTopology;n.model_config!=null&&(n=n.model_config);let r=zd(n),s=Jr(r,t);if(e.weightsManifest!=null){let a=await tn.loadWeights(e.weightsManifest,e.pathPrefix,s.weights.map(i=>i.originalName)),o={};for(let i of s.weights)o[i.originalName]=a[i.originalName];s.loadWeights(o),Fe(a)}return s}async function bG(e,t){if(t==null&&(t={}),typeof e=="string"){let n=tn.getLoadHandlers(e,t);if(n.length===0)n.push(tn.browserHTTPRequest(e,t));else if(n.length>1)throw new H(`Found more than one (${n.length}) load handlers for URL '${e}'`);e=n[0]}return yG(e,void 0,t)}async function yG(e,t,n){if(n==null&&(n={}),e.load==null)throw new H("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let r=await e.load(),s=r.modelTopology;s.model_config!=null&&(s=s.model_config);let a=n.strict==null?!0:n.strict,o=r.weightData!=null&&r.weightSpecs!=null&&a,i=Jr(zd(s),t,o),u=r.trainingConfig;if(u!=null&&i.loadTrainingConfig(u),r.userDefinedMetadata!=null&&i.setUserDefinedMetadata(r.userDefinedMetadata),r.weightData!=null){if(r.weightSpecs==null)throw new H("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");let{modelWeights:l,optimizerWeights:c}=vG(r.weightData,r.weightSpecs);i.loadWeights(l,a),i.optimizer!=null&&c.length>0&&await i.optimizer.setWeights(c),Fe(l),Fe(c.map(d=>d.tensor))}return i}function vG(e,t){let n=tn.decodeWeights(e,t),r={},s=[];return t.forEach(a=>{a.group==="optimizer"?s.push({name:a.name,tensor:n[a.name]}):r[a.name]=n[a.name]}),{modelWeights:r,optimizerWeights:s}}var ix=class extends Bs{constructor(e){super({inputs:[],outputs:[]});if(e=e||{},this.trainable=!0,this.built=!1,this.name=e.name!=null?e.name:zf("sequential_"),e.layers!=null)for(let t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(n=>n<0))throw new H(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){let t=e instanceof ix||e instanceof Bs,n;if(t){if(n=e,n.outputs.length!==1)throw new H("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(n.inputs.length!==1)throw new H("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(e.inboundNodes.length===0){if(e.batchInputShape==null)throw new H("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");let r=W0({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(r)}if(t)this.outputs=n.outputs,this.inputs=n.inputs;else{if(e.inboundNodes.length!==1)throw new H(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(e.inboundNodes[0].outputTensors.length!==1)throw new H("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=z0(this.outputs[0])}this.inboundNodes=[],new Uf({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:Gi(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(r=>r.shape),outputShapes:this.outputs[0].shape})}else{let r=e.apply(this.outputs[0]);if(Array.isArray(r))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[r],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{let e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return this.model==null&&this.build(),this.model.call(e,t)}build(e){if(ut(e),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new Bs({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t,n=console.log){this.built||this.build(),super.summary(e,t,n)}setWeights(e){this.model==null&&this.build(),this.model.setWeights(e)}evaluate(e,t,n={}){if(!this.built)throw new Xr("The model needs to be compiled before being used.");return this.model.evaluate(e,t,n)}async evaluateDataset(e,t){if(!this.built)throw new Xr("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,t)}predict(e,t={}){return this.model==null&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return this.model==null&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t,n={}){if(!this.built)throw new Xr("The model needs to be compiled before being used.");return this.model.fit(e,t,n)}async fitDataset(e,t){if(!this.built)throw new Xr("The model needs to be compiled before being used.");return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(e,t,n={},r=!1){let s,a={};if(t instanceof Array){if(t[0].className==null||t[0].className==="Merge")throw new H("Legacy serialization format not supported yet.");s=t}else w.assert(t.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),s=t.layers,delete t.layers,a=t;let o=new e(a);if(!(o instanceof ix))throw new De(`Sequential.fromConfig called on non-Sequential input: ${o}`);for(let i of s){let l=Jr(i,void 0,r);r&&l.setFastWeightInitDuringBuild(!0),o.add(l)}return o}set stopTraining(e){if(this.model==null)throw new H("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(this.model==null)throw new H("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){let e=[];for(let t of this.layers){let n={};n.className=t.getClassName(),n.config=t.getConfig(),e.push(n)}return{name:this.name,layers:e}}},Zf=ix;Zf.className="Sequential";oe.registerClass(Zf);function xG(e){return new Bs(e)}function wG(e){return new Zf(e)}function kG(e,t){return t==null&&(t={}),bG(e,t)}function m2(e){return W0(e)}function IG(e,t){qv.registerCallbackConstructor(e,t)}var jn=class extends oe.Serializable{getConfig(){return{}}},g2=class extends jn{apply(e,t=1){return XV(e,t)}};g2.className="elu";oe.registerClass(g2);var b2=class extends jn{apply(e){return cv(e)}};b2.className="selu";oe.registerClass(b2);var y2=class extends jn{apply(e){return Qe(e)}};y2.className="relu";oe.registerClass(y2);var v2=class extends jn{apply(e){return M(()=>Td(6,Qe(e)))}};v2.className="relu6";oe.registerClass(v2);var x2=class extends jn{apply(e){return e}};x2.className="linear";oe.registerClass(x2);var w2=class extends jn{apply(e){return $r(e)}};w2.className="sigmoid";oe.registerClass(w2);var k2=class extends jn{apply(e){return QV(e)}};k2.className="hardSigmoid";oe.registerClass(k2);var I2=class extends jn{apply(e){return Sc(e)}};I2.className="softplus";oe.registerClass(I2);var S2=class extends jn{apply(e){return YV(e)}};S2.className="softsign";oe.registerClass(S2);var C2=class extends jn{apply(e){return kc(e)}};C2.className="tanh";oe.registerClass(C2);var ux=class extends jn{apply(e,t=-1){return ls(e,t)}};ux.className="softmax";oe.registerClass(ux);var T2=class extends jn{apply(e,t=-1){return Zy(e,t)}};T2.className="logSoftmax";oe.registerClass(T2);var N2=class extends jn{apply(e,t=1){return M(()=>V($r(V(e,t)),e))}};N2.className="swish";oe.registerClass(N2);var _2=class extends jn{apply(e){return M(()=>V(e,kc(Sc(e))))}};_2.className="mish";oe.registerClass(_2);function wo(e){return e.getClassName()}function cx(e,t={}){return Dd(e,oe.SerializationMap.getMap().classNameMap,t,"activation")}function ko(e){if(e==null){let t={};return t.className="linear",t.config={},cx(t)}if(typeof e=="string"){let t={};return t.className=e,t.config={},cx(t)}else return e instanceof jn?e:cx(e)}function lx(e){if(e!=null&&typeof e!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${e}`)}var E2=class extends oe.Serializable{},Ud=class extends E2{constructor(e){super();lx(e),this.l1=e==null||e.l1==null?.01:e.l1,this.l2=e==null||e.l2==null?.01:e.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(e){return M(()=>{let t=kt([1]);return this.hasL1&&(t=Z(t,ve(V(this.l1,Xt(e))))),this.hasL2&&(t=Z(t,ve(V(this.l2,Md(e))))),G(t,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}};Ud.className="L1L2";oe.registerClass(Ud);function SG(e){return lx(e),new Ud({l1:e!=null?e.l1:null,l2:0})}function CG(e){return lx(e),new Ud({l2:e!=null?e.l2:null,l1:0})}var A2={l1l2:"L1L2"};function mt(e){return Cv(e)}function $2(e,t={}){return Dd(e,oe.SerializationMap.getMap().classNameMap,t,"regularizer")}function _t(e){if(e==null)return null;if(typeof e=="string"){let n={className:e in A2?A2[e]:e,config:{}};return $2(n)}else return e instanceof E2?e:$2(e)}var dx=class extends Ye{constructor(e){super(e==null?{}:e);this.supportsMasking=!0,e!=null&&(this.maxValue=e.maxValue)}call(e,t){e=Me(e);let n=Qe(e);return this.maxValue!=null&&(n=dn(n,0,this.maxValue)),n}computeOutputShape(e){return e}getConfig(){let e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}};dx.className="ReLU";oe.registerClass(dx);var px=class extends Ye{constructor(e){super(e==null?{}:e);this.DEFAULT_ALPHA=.3,e==null&&(e={}),this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){let n=Me(e);return sf(n,this.alpha)}computeOutputShape(e){return e}getConfig(){let e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};px.className="LeakyReLU";oe.registerClass(px);var hx=class extends Ye{constructor(e){super(e==null?{}:e);if(this.DEFAULT_ALPHA_INITIALIZER="zeros",e==null&&(e={}),this.supportsMasking=!0,this.alphaInitializer=Nt(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=_t(e.alphaRegularizer),this.alphaConstraint=Zt(e.alphaConstraint),e.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else if(typeof e.sharedAxes=="number")this.sharedAxes=[e.sharedAxes];else throw new H(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`)}build(e){e=ut(e);let t=e.slice(1);if(this.sharedAxes!=null)for(let r of this.sharedAxes)t[r-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);let n={};if(this.sharedAxes!=null)for(let r=1;r<e.length;++r)n[r]=e[r];this.inputSpec=[new Gt({ndim:e.length,axes:n})],this.built=!0}call(e,t){return e=Me(e),pf(e,this.alpha.read())}getConfig(){let e={alphaInitializer:Dt(this.alphaInitializer),alphaRegularizer:mt(this.alphaRegularizer),alphaConstraint:Qt(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}};hx.className="PReLU";oe.registerClass(hx);var fx=class extends Ye{constructor(e){super(e==null?{}:e);if(this.DEFAULT_ALPHA=1,e==null&&(e={}),e.alpha!=null&&e.alpha!==this.DEFAULT_ALPHA)throw new De(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){let n=Me(e);return Sd(n)}computeOutputShape(e){return e}getConfig(){let e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};fx.className="ELU";oe.registerClass(fx);var mx=class extends Ye{constructor(e){super(e==null?{}:e);this.DEFAULT_THETA=1,e==null&&(e={}),this.theta=e.theta==null?this.DEFAULT_THETA:e.theta}call(e,t){let n=Me(e);return V(n,ue(nr(n,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){let e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}};mx.className="ThresholdedReLU";oe.registerClass(mx);var gx=class extends Ye{constructor(e){super(e==null?{}:e);this.DEFAULT_AXIS=1,e==null&&(e={}),this.softmax=new ux().apply,this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis}call(e,t){let n=Me(e);return this.softmax(n,this.axis)}computeOutputShape(e){return e}getConfig(){let e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}};gx.className="Softmax";oe.registerClass(gx);function Oc(e,t,n){if(typeof e=="number")return Gi(e,t);if(e.length!==t)throw new H(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${e.length} elements.`);for(let r=0;r<t;++r){let s=e[r];if(!HV(s))throw new H(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(e)} including a non-integer number ${s}`)}return e}function es(e,t,n,r,s=1){if(e==null)return e;let a=t+(t-1)*(s-1),o;return n==="same"?o=e:o=e-a+1,Math.floor((o+r-1)/r)}function ms(e,t,n,r){if(e==null)return null;if(r==="valid")e=e*t+vo([n-t,0]);else if(r==="same")e=e*t;else throw new H(`Unsupport padding mode: ${r}.`);return e}function bx(e,t){return M(()=>(Bt(t),t==="channelsFirst"?Oe(e,[0,2,3,1]):e))}function F2(e,t){return M(()=>(Bt(t),t==="channelsFirst"?Oe(e,[0,2,3,4,1]):e))}function TG(e,t,n,r=1,s="valid",a,o=1){return M(()=>{if(a==null&&(a=Kr()),Bt(a),e.shape.length!==3)throw new H(`The input of a conv1dWithBias operation should be 3, but is ${e.shape.length} instead.`);if(t.shape.length!==3)throw new H(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(n!=null&&n.shape.length!==1)throw new H(`The bias for a conv1dWithBias operation should be 1, but is ${t.shape.length} instead`);if(a==="channelsFirst"&&(e=Oe(e,[0,2,1])),s==="causal")throw new De("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let i=Gy(e,t,r,s==="same"?"same":"valid","NWC",o);return n!=null&&(i=Qr(i,n)),i})}function D2(e,t,n,r=[1,1],s="valid",a,o,i=null){return M(()=>{if(a==null&&(a=Kr()),Bt(a),e.rank!==3&&e.rank!==4)throw new H(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${e.rank}.`);if(t.rank!==3&&t.rank!==4)throw new H(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${e.rank}.`);let u=bx(e,a);if(s==="causal")throw new De("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return u=mo.conv2d({x:u,filter:t,strides:r,pad:s==="same"?"same":"valid",dilations:o,dataFormat:"NHWC",bias:n,activation:i}),a==="channelsFirst"&&(u=Oe(u,[0,3,1,2])),u})}function NG(e,t,n,r=[1,1,1],s="valid",a,o){return M(()=>{if(a==null&&(a=Kr()),Bt(a),e.rank!==4&&e.rank!==5)throw new H(`conv3dWithBias expects input to be of rank 4 or 5, but received ${e.rank}.`);if(t.rank!==4&&t.rank!==5)throw new H(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${e.rank}.`);let i=F2(e,a);if(s==="causal")throw new De("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return i=qy(i,t,r,s==="same"?"same":"valid","NDHWC",o),n!=null&&(i=Qr(i,n)),a==="channelsFirst"&&(i=Oe(i,[0,4,1,2,3])),i})}var yx=class extends Ye{constructor(e,t){super(t);if(this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",yx.verifyArgs(t),this.rank=e,rn(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new De(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=Oc(t.kernelSize,e,"kernelSize"),this.strides=Oc(t.strides==null?1:t.strides,e,"strides"),this.padding=t.padding==null?"valid":t.padding,vr(this.padding),this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,Bt(this.dataFormat),this.activation=ko(t.activation),this.useBias=t.useBias==null?!0:t.useBias,this.biasInitializer=Nt(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=Zt(t.biasConstraint),this.biasRegularizer=_t(t.biasRegularizer),this.activityRegularizer=_t(t.activityRegularizer),this.dilationRate=Oc(t.dilationRate==null?1:t.dilationRate,e,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new H(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new H(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new H(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(e){if(ds("kernelSize"in e,"required key 'kernelSize' not in config"),typeof e.kernelSize!="number"&&!Nv(e.kernelSize,"number",1,3))throw new H(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){let e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:wo(this.activation),useBias:this.useBias,biasInitializer:Dt(this.biasInitializer),biasRegularizer:mt(this.biasRegularizer),activityRegularizer:mt(this.activityRegularizer),biasConstraint:Qt(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}},Gd=class extends yx{constructor(e,t){super(e,t);this.kernel=null,Gd.verifyArgs(t),this.filters=t.filters,rn(this.filters,"filters"),this.kernelInitializer=Nt(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=Zt(t.kernelConstraint),this.kernelRegularizer=_t(t.kernelRegularizer)}build(e){e=ut(e);let t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new H(`The channel dimension of the input should be defined. Found ${e[t]}`);let n=e[t],r=this.kernelSize.concat([n,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:n}}],this.built=!0}call(e,t){return M(()=>{e=Me(e);let n,r=this.bias==null?null:this.bias.read(),s=k0(this.activation.getClassName());if(s!=null&&this.rank===2)n=D2(e,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate,s);else{if(this.rank===1)n=TG(e,this.kernel.read(),r,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)n=D2(e,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)n=NG(e,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new De("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(n=this.activation.apply(n))}return n})}computeOutputShape(e){e=ut(e);let t=[],n=this.dataFormat==="channelsLast"?e.slice(1,e.length-1):e.slice(2);for(let s=0;s<n.length;++s){let a=es(n[s],this.kernelSize[s],this.padding,this.strides[s],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[s]);t.push(a)}let r=[e[0]];return this.dataFormat==="channelsLast"?(r=r.concat(t),r.push(this.filters)):(r.push(this.filters),r=r.concat(t)),r}getConfig(){let e={filters:this.filters,kernelInitializer:Dt(this.kernelInitializer),kernelRegularizer:mt(this.kernelRegularizer),kernelConstraint:Qt(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!("filters"in e)||typeof e.filters!="number"||e.filters<1)throw new H(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}},R2=class extends Gd{constructor(e){super(2,e);R2.verifyArgs(e)}getConfig(){let e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!Nv(e.kernelSize,"number",1,2))throw new H(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}},Jf=R2;Jf.className="Conv2D";oe.registerClass(Jf);var P2=class extends Gd{constructor(e){super(3,e);P2.verifyArgs(e)}getConfig(){let e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!(Array.isArray(e.kernelSize)&&(e.kernelSize.length===1||e.kernelSize.length===3)))throw new H(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}},em=P2;em.className="Conv3D";oe.registerClass(em);var vx=class extends Jf{constructor(e){super(e);if(this.inputSpec=[new Gt({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new H(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=ut(e),e.length!==4)throw new H("Input should have rank 4; Received input shape: "+JSON.stringify(e));let t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new H("The channel dimension of the inputs should be defined. Found `None`.");let n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Gt({ndim:4,axes:{[t]:n}})],this.built=!0}call(e,t){return M(()=>{let n=Me(e);if(n.shape.length!==4)throw new H(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${n.shape.length}`);let r=n.shape,s=r[0],a,o;this.dataFormat==="channelsFirst"?(a=2,o=3):(a=1,o=2);let i=r[a],u=r[o],l=this.kernelSize[0],c=this.kernelSize[1],d=this.strides[0],p=this.strides[1],h=ms(i,d,l,this.padding),f=ms(u,p,c,this.padding),m=[s,h,f,this.filters];this.dataFormat!=="channelsLast"&&(n=Oe(n,[0,2,3,1]));let g=jy(n,this.kernel.read(),m,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(g=Oe(g,[0,3,1,2])),this.bias!=null&&(g=Qr(g,this.bias.read(),this.dataFormat)),this.activation!=null&&(g=this.activation.apply(g)),g})}computeOutputShape(e){e=ut(e);let t=e.slice(),n,r,s;this.dataFormat==="channelsFirst"?(n=1,r=2,s=3):(n=3,r=1,s=2);let a=this.kernelSize[0],o=this.kernelSize[1],i=this.strides[0],u=this.strides[1];return t[n]=this.filters,t[r]=ms(t[r],i,a,this.padding),t[s]=ms(t[s],u,o,this.padding),t}getConfig(){let e=super.getConfig();return delete e.dilationRate,e}};vx.className="Conv2DTranspose";oe.registerClass(vx);var xx=class extends em{constructor(e){super(e);if(this.inputSpec=[new Gt({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new H(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=ut(e),e.length!==5)throw new H("Input should have rank 5; Received input shape: "+JSON.stringify(e));let t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new H("The channel dimension of the inputs should be defined. Found `None`.");let n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Gt({ndim:5,axes:{[t]:n}})],this.built=!0}call(e,t){return M(()=>{let n=Me(e);if(n.shape.length!==5)throw new H(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${n.shape.length}`);let r=n.shape,s=r[0],a,o,i;this.dataFormat==="channelsFirst"?(i=2,a=3,o=4):(i=1,a=2,o=3);let u=r[i],l=r[a],c=r[o],d=this.kernelSize[0],p=this.kernelSize[1],h=this.kernelSize[2],f=this.strides[0],m=this.strides[1],g=this.strides[2],b=ms(u,f,d,this.padding),y=ms(l,m,p,this.padding),v=ms(c,g,h,this.padding),x=[s,b,y,v,this.filters];this.dataFormat!=="channelsLast"&&(n=Oe(n,[0,2,3,4,1]));let k=hS(n,this.kernel.read(),x,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(k=Oe(k,[0,4,1,2,3])),this.bias!==null&&(k=Qr(k,this.bias.read(),this.dataFormat)),this.activation!==null&&(k=this.activation.apply(k)),k})}computeOutputShape(e){e=ut(e);let t=e.slice(),n,r,s,a;this.dataFormat==="channelsFirst"?(n=1,r=2,s=3,a=4):(n=4,r=1,s=2,a=3);let o=this.kernelSize[0],i=this.kernelSize[1],u=this.kernelSize[2],l=this.strides[0],c=this.strides[1],d=this.strides[2];return t[n]=this.filters,t[r]=ms(t[r],l,o,this.padding),t[s]=ms(t[s],c,i,this.padding),t[a]=ms(t[a],d,u,this.padding),t}getConfig(){let e=super.getConfig();return delete e.dilationRate,e}};xx.className="Conv3DTranspose";oe.registerClass(xx);var O2=class extends Gd{constructor(e,t){super(e,t);if(this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,t.filters==null)throw new H("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(t.kernelInitializer!=null||t.kernelRegularizer!=null||t.kernelConstraint!=null)throw new H("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(t.padding!=null&&t.padding!=="same"&&t.padding!=="valid")throw new H(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier,this.depthwiseInitializer=Nt(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=_t(t.depthwiseRegularizer),this.depthwiseConstraint=Zt(t.depthwiseConstraint),this.pointwiseInitializer=Nt(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=_t(t.pointwiseRegularizer),this.pointwiseConstraint=Zt(t.pointwiseConstraint)}build(e){if(e=ut(e),e.length<this.rank+2)throw new H(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);let t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null||e[t]<0)throw new H(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);let n=e[t],r=this.kernelSize.concat([n,this.depthMultiplier]),s=[];for(let o=0;o<this.rank;++o)s.push(1);s.push(n*this.depthMultiplier,this.filters);let a=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,a,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",s,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,a,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,a,this.biasConstraint):this.bias=null,this.inputSpec=[new Gt({ndim:this.rank+2,axes:{[t]:n}})],this.built=!0}call(e,t){return M(()=>{e=Me(e);let n;if(this.rank===1)throw new De("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(e=Oe(e,[0,2,3,1])),n=_c(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(n=Qr(n,this.bias.read(),this.dataFormat)),this.activation!=null&&(n=this.activation.apply(n)),this.dataFormat==="channelsFirst"&&(n=Oe(n,[0,3,1,2])),n})}getConfig(){let e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=Dt(this.depthwiseInitializer),e.pointwiseInitializer=Dt(this.pointwiseInitializer),e.depthwiseRegularizer=mt(this.depthwiseRegularizer),e.pointwiseRegularizer=mt(this.pointwiseRegularizer),e.depthwiseConstraint=Qt(this.depthwiseConstraint),e.pointwiseConstraint=Qt(this.pointwiseConstraint),e}};O2.className="SeparableConv";var wx=class extends O2{constructor(e){super(2,e)}};wx.className="SeparableConv2D";oe.registerClass(wx);var M2=class extends Gd{constructor(e){super(1,e);M2.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){let e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!Nv(e.kernelSize,"number",1,1))throw new H(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}},kx=M2;kx.className="Conv1D";oe.registerClass(kx);var Ix=class extends Ye{constructor(e){super(e);typeof e.cropping=="number"?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:typeof e.cropping[0]=="number"?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=e.dataFormat===void 0?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return this.dataFormat==="channelsFirst"?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return M(()=>{if(e=Me(e),this.dataFormat==="channelsLast"){let n=Af(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return Af(n,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{let n=Af(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return Af(n,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){let e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}};Ix.className="Cropping2D";oe.registerClass(Ix);var Sx=class extends Ye{constructor(e){super(e);this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=e.size==null?this.DEFAULT_SIZE:e.size,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Bt(this.dataFormat),this.interpolation=e.interpolation==null?"nearest":e.interpolation,VV(this.interpolation)}computeOutputShape(e){if(this.dataFormat==="channelsFirst"){let t=e[2]==null?null:this.size[0]*e[2],n=e[3]==null?null:this.size[1]*e[3];return[e[0],e[1],t,n]}else{let t=e[1]==null?null:this.size[0]*e[1],n=e[2]==null?null:this.size[1]*e[2];return[e[0],t,n,e[3]]}}call(e,t){return M(()=>{let n=Me(e),r=n.shape;if(this.dataFormat==="channelsFirst"){n=Oe(n,[0,2,3,1]);let s=this.size[0]*r[2],a=this.size[1]*r[3],o=this.interpolation==="nearest"?ar.resizeNearestNeighbor(n,[s,a]):ar.resizeBilinear(n,[s,a]);return Oe(o,[0,3,1,2])}else{let s=this.size[0]*r[1],a=this.size[1]*r[2];return this.interpolation==="nearest"?ar.resizeNearestNeighbor(n,[s,a]):ar.resizeBilinear(n,[s,a])}})}getConfig(){let e={size:this.size,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}};Sx.className="UpSampling2D";oe.registerClass(Sx);function _G(e,t,n=[1,1],r="valid",s,a){return M(()=>{s==null&&(s=Kr()),Bt(s);let o=bx(e,s);if(e.rank!==4)throw new H(`Input for depthwiseConv2d is required to be 4-D, but is instead ${e.rank}-D`);if(t.rank!==4)throw new H(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return o=Bi(o,t,n,r==="same"?"same":"valid","NHWC",a),s==="channelsFirst"&&(o=Oe(o,[0,3,1,2])),o})}var Cx=class extends yx{constructor(e){super(2,e);this.depthwiseKernel=null,this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=Nt(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=Zt(e.depthwiseConstraint),this.depthwiseRegularizer=_t(e.depthwiseRegularizer)}build(e){if(e=ut(e),e.length<4)throw new H(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);let t=this.dataFormat==="channelsFirst"?1:3;if(e[t]==null||e[t]<0)throw new H(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);let n=e[t],r=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return M(()=>{e=Me(e);let n=_G(e,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(n=Qr(n,this.bias.read(),this.dataFormat)),this.activation!=null&&(n=this.activation.apply(n)),n})}computeOutputShape(e){e=ut(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],n=this.dataFormat==="channelsFirst"?e[3]:e[2],r=this.dataFormat==="channelsFirst"?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,s=es(t,this.kernelSize[0],this.padding,this.strides[0]),a=es(n,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[e[0],r,s,a]:[e[0],s,a,r]}getConfig(){let e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=Dt(this.depthwiseInitializer),e.depthwiseRegularizer=mt(this.depthwiseRegularizer),e.depthwiseConstraint=Qt(this.depthwiseRegularizer),e}};Cx.className="DepthwiseConv2D";oe.registerClass(Cx);function L2(e,t,n,r){if(Array.isArray(e)){if(t!=null||n!=null)throw new H("When inputs is an array, neither initialState or constants should be provided");r!=null&&(n=e.slice(e.length-r,e.length),e=e.slice(0,e.length-r)),e.length>1&&(t=e.slice(1,e.length)),e=e[0]}function s(a){return a==null||Array.isArray(a)?a:[a]}return t=s(t),n=s(n),{inputs:e,initialState:t,constants:n}}function B2(e,t,n,r=!1,s,a,o=!1,i=!1){return M(()=>{let u=t.shape.length;if(u<3)throw new H(`Input should be at least 3D, but is ${u}D.`);let l=[1,0].concat(Yr(2,u));if(t=Oe(t,l),a!=null)throw new De("The rnn() functoin of the deeplearn.js backend does not support constants yet.");o&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),s!=null&&(s=ue(ue(s,"bool"),"float32"),s.rank===u-1&&(s=Nn(s,-1)),s=Oe(s,l)),r&&(t=yr(t,0),s!=null&&(s=yr(s,0)));let c=[],d,p=n,h=t.shape[0],f=vt(t),m;s!=null&&(m=vt(s));for(let b=0;b<h;++b){let y=f[b],v=M(()=>e(y,p));if(s==null)d=v[0],p=v[1];else{let x=M(()=>{let k=m[b],T=he(br(k),k),C=Z(V(v[0],k),V(p[0],T)),E=p.map((F,O)=>Z(V(v[1][O],k),V(F,T)));return{output:C,newStates:E}});d=x.output,p=x.newStates}i&&c.push(d)}let g;return i&&(g=Ut(c,1)),[d,g,p]})}var z2=class extends Ye{constructor(e){super(e);let t;if(e.cell==null)throw new H("cell property is missing for the constructor of RNN.");if(Array.isArray(e.cell)?t=new rm({cells:e.cell}):t=e.cell,t.stateSize==null)throw new H("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=e.returnSequences==null?!1:e.returnSequences,this.returnState=e.returnState==null?!1:e.returnState,this.goBackwards=e.goBackwards==null?!1:e.goBackwards,this._stateful=e.stateful==null?!1:e.stateful,this.unroll=e.unroll==null?!1:e.unroll,this.supportsMasking=!0,this.inputSpec=[new Gt({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){let e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return Yr(0,e).map(t=>null)}else return this.states_}setStates(e){this.states_=e}computeOutputShape(e){Gv(e)&&(e=e[0]),e=e;let t=this.cell.stateSize;Array.isArray(t)||(t=[t]);let n=t[0],r;if(this.returnSequences?r=[e[0],e[1],n]:r=[e[0],n],this.returnState){let s=[];for(let a of t)s.push([e[0],a]);return[r].concat(s)}else return r}computeMask(e,t){return M(()=>{Array.isArray(t)&&(t=t[0]);let n=this.returnSequences?t:null;if(this.returnState){let r=this.states.map(s=>null);return[n].concat(r)}else return n})}get states(){if(this.states_==null){let e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let n=0;n<e;++n)t.push(null);return t}else return this.states_}set states(e){this.states_=e}build(e){let t=null;if(this.numConstants!=null)throw new De("Constants support is not implemented in RNN yet.");Gv(e)&&(e=e[0]),e=e;let n=this.stateful?e[0]:null,r=e.slice(2);this.inputSpec[0]=new Gt({shape:[n,null,...r]});let s=[e[0]].concat(e.slice(2));if(t!=null)throw new De("Constants support is not implemented in RNN yet.");this.cell.build(s);let a;if(Array.isArray(this.cell.stateSize)?a=this.cell.stateSize:a=[this.cell.stateSize],this.stateSpec!=null){if(!w.arraysEqual(this.stateSpec.map(o=>o.shape[o.shape.length-1]),a))throw new H(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=a.map(o=>new Gt({shape:[null,o]}));this.stateful&&this.resetStates()}resetStates(e,t=!1){M(()=>{if(!this.stateful)throw new Ms("Cannot call resetStates() on an RNN Layer that is not stateful.");let n=this.inputSpec[0].shape[0];if(n==null)throw new H("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(r=>kt([n,r])):this.states_=[kt([n,this.cell.stateSize])];else if(e==null)Fe(this.states_),this.keptStates!=null&&(Fe(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(r=>kt([n,r])):this.states_[0]=kt([n,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new H(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t===!0?this.keptStates.push(this.states_.slice()):Fe(this.states_);for(let r=0;r<this.states_.length;++r){let s=e[r],a=Array.isArray(this.cell.stateSize)?this.cell.stateSize[r]:this.cell.stateSize,o=[n,a];if(!w.arraysEqual(s.shape,o))throw new H(`State ${r} is incompatible with layer ${this.name}: expected shape=${o}, received shape=${s.shape}`);this.states_[r]=s}}this.states_=this.states_.map(r=>nn(r.clone()))})}apply(e,t){let n=t==null?null:t.initialState,r=t==null?null:t.constants;t==null&&(t={});let s=L2(e,n,r,this.numConstants);e=s.inputs,n=s.initialState,r=s.constants;let a=[],o=[];if(n!=null){t.initialState=n,a=a.concat(n),this.stateSpec=[];for(let u of n)this.stateSpec.push(new Gt({shape:u.shape}));o=o.concat(this.stateSpec)}if(r!=null&&(t.constants=r,a=a.concat(r),this.numConstants=r.length),a[0]instanceof Zr){let u=[e].concat(a),l=this.inputSpec.concat(o),c=this.inputSpec;this.inputSpec=l;let d=super.apply(u,t);return this.inputSpec=c,d}else return super.apply(e,t)}call(e,t){return M(()=>{let n=t==null?null:t.mask,r=t==null?null:t.training,s=t==null?null:t.initialState;e=Me(e),s==null&&(this.stateful?s=this.states_:s=this.getInitialState(e));let a=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(s.length!==a)throw new H(`RNN Layer has ${a} state(s) but was passed ${s.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");let o={training:r},u=B2((h,f)=>{let m=this.cell.call([h].concat(f),o);return[m[0],m.slice(1)]},e,s,this.goBackwards,n,null,this.unroll,this.returnSequences),l=u[0],c=u[1],d=u[2];this.stateful&&this.resetStates(d,r);let p=this.returnSequences?c:l;return this.returnState?[p].concat(d):p})}getInitialState(e){return M(()=>{let t=kt(e.shape);return t=ve(t,[1,2]),t=Od(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(n=>n>1?Pv(t,[1,n]):t):this.cell.stateSize>1?[Pv(t,[1,this.cell.stateSize])]:[t]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){let e=super.getConfig(),t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(t.numConstants=this.numConstants);let n=this.cell.getConfig();return this.getClassName()===z2.className&&(t.cell={className:this.cell.getClassName(),config:n}),{...n,...e,...t}}static fromConfig(e,t,n={}){let r=t.cell,s=Jr(r,n);return new e(Object.assign(t,{cell:s}))}},zs=z2;zs.className="RNN";oe.registerClass(zs);var Hd=class extends Ye{},tm=class extends Hd{constructor(e){super(e);this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,rn(this.units,"units"),this.activation=ko(e.activation==null?this.DEFAULT_ACTIVATION:e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=Nt(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Nt(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Nt(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=_t(e.kernelRegularizer),this.recurrentRegularizer=_t(e.recurrentRegularizer),this.biasRegularizer=_t(e.biasRegularizer),this.kernelConstraint=Zt(e.kernelConstraint),this.recurrentConstraint=Zt(e.recurrentConstraint),this.biasConstraint=Zt(e.biasConstraint),this.dropout=Fc([1,vo([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Fc([1,vo([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=ut(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return M(()=>{if(e=e,e.length!==2)throw new H(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let n=e[1];e=e[0];let r=t.training==null?!1:t.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Io({ones:()=>br(e),rate:this.dropout,training:r,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Io({ones:()=>br(n),rate:this.recurrentDropout,training:r,dropoutFunc:this.dropoutFunc}));let s,a=this.dropoutMask,o=this.recurrentDropoutMask;a!=null?s=ps(V(e,a),this.kernel.read()):s=ps(e,this.kernel.read()),this.bias!=null&&(s=Qr(s,this.bias.read())),o!=null&&(n=V(n,o));let i=Z(s,ps(n,this.recurrentKernel.read()));return this.activation!=null&&(i=this.activation.apply(i)),[i,i]})}getConfig(){let e=super.getConfig(),t={units:this.units,activation:wo(this.activation),useBias:this.useBias,kernelInitializer:Dt(this.kernelInitializer),recurrentInitializer:Dt(this.recurrentInitializer),biasInitializer:Dt(this.biasInitializer),kernelRegularizer:mt(this.kernelRegularizer),recurrentRegularizer:mt(this.recurrentRegularizer),biasRegularizer:mt(this.biasRegularizer),activityRegularizer:mt(this.activityRegularizer),kernelConstraint:Qt(this.kernelConstraint),recurrentConstraint:Qt(this.recurrentConstraint),biasConstraint:Qt(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return{...e,...t}}};tm.className="SimpleRNNCell";oe.registerClass(tm);var Tx=class extends zs{constructor(e){e.cell=new tm(e);super(e)}call(e,t){return M(()=>{this.cell.dropoutMask!=null&&(Fe(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Fe(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=t==null?null:t.mask,r=t==null?null:t.training,s=t==null?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:s})})}static fromConfig(e,t){return new e(t)}};Tx.className="SimpleRNN";oe.registerClass(Tx);var nm=class extends Hd{constructor(e){super(e);if(this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new H("GRUCell does not support reset_after parameter set to true.");this.units=e.units,rn(this.units,"units"),this.activation=ko(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=ko(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=Nt(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Nt(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Nt(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=_t(e.kernelRegularizer),this.recurrentRegularizer=_t(e.recurrentRegularizer),this.biasRegularizer=_t(e.biasRegularizer),this.kernelConstraint=Zt(e.kernelConstraint),this.recurrentConstraint=Zt(e.recurrentConstraint),this.biasConstraint=Zt(e.biasConstraint),this.dropout=Fc([1,vo([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Fc([1,vo([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=ut(e);let t=e[e.length-1];this.kernel=this.addWeight("kernel",[t,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return M(()=>{if(e=e,e.length!==2)throw new H(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);let n=t.training==null?!1:t.training,r=e[1];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Io({ones:()=>br(e),rate:this.dropout,training:n,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Io({ones:()=>br(r),rate:this.recurrentDropout,training:n,count:3,dropoutFunc:this.dropoutFunc}));let s=this.dropoutMask,a=this.recurrentDropoutMask,o,i,u;0<this.dropout&&this.dropout<1&&(e=V(e,s[0]));let l=ps(e,this.kernel.read());this.useBias&&(l=Qr(l,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(r=V(r,a[0]));let c=this.recurrentKernel.read(),[d,p]=sr(c,[2*this.units,this.units],c.rank-1),h=ps(r,d),[f,m,g]=sr(l,3,l.rank-1),[b,y]=sr(h,2,h.rank-1);o=this.recurrentActivation.apply(Z(f,b)),i=this.recurrentActivation.apply(Z(m,y));let v=ps(V(i,r),p);u=this.activation.apply(Z(g,v));let x=Z(V(o,r),V(Z(1,Ft(o)),u));return[x,x]})}getConfig(){let e=super.getConfig(),t={units:this.units,activation:wo(this.activation),recurrentActivation:wo(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Dt(this.kernelInitializer),recurrentInitializer:Dt(this.recurrentInitializer),biasInitializer:Dt(this.biasInitializer),kernelRegularizer:mt(this.kernelRegularizer),recurrentRegularizer:mt(this.recurrentRegularizer),biasRegularizer:mt(this.biasRegularizer),activityRegularizer:mt(this.activityRegularizer),kernelConstraint:Qt(this.kernelConstraint),recurrentConstraint:Qt(this.recurrentConstraint),biasConstraint:Qt(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return{...e,...t}}};nm.className="GRUCell";oe.registerClass(nm);var Nx=class extends zs{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new nm(e);super(e)}call(e,t){return M(()=>{this.cell.dropoutMask!=null&&(Fe(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Fe(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=t==null?null:t.mask,r=t==null?null:t.training,s=t==null?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:s})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}};Nx.className="GRU";oe.registerClass(Nx);var jd=class extends Hd{constructor(e){super(e);this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,rn(this.units,"units"),this.activation=ko(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=ko(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=Nt(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Nt(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Nt(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=_t(e.kernelRegularizer),this.recurrentRegularizer=_t(e.recurrentRegularizer),this.biasRegularizer=_t(e.biasRegularizer),this.kernelConstraint=Zt(e.kernelConstraint),this.recurrentConstraint=Zt(e.recurrentConstraint),this.biasConstraint=Zt(e.biasConstraint),this.dropout=Fc([1,vo([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Fc([1,vo([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;e=ut(e);let n=e[e.length-1];this.kernel=this.addWeight("kernel",[n,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let r;if(this.useBias){if(this.unitForgetBias){let s=this.biasInitializer,a=this.units;r=new(t=class extends Pr{apply(o,i){let u=s.apply([a]),l=new Ff().apply([a]),c=s.apply([a*2]);return $0($0(u,l),c)}},t.className="CustomInit",t)}else r=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,r,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return M(()=>{let n=t.training==null?!1:t.training;if(e=e,e.length!==3)throw new H(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let r=e[1],s=e[2];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Io({ones:()=>br(e),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Io({ones:()=>br(r),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));let a=this.dropoutMask,o=this.recurrentDropoutMask,i,u,l,c;0<this.dropout&&this.dropout<1&&(e=V(e,a[0]));let d=ps(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(r=V(r,o[0])),d=Z(d,ps(r,this.recurrentKernel.read())),this.useBias&&(d=Qr(d,this.bias.read()));let[p,h,f,m]=sr(d,4,d.rank-1);i=this.recurrentActivation.apply(p),u=this.recurrentActivation.apply(h),l=Z(V(u,s),V(i,this.activation.apply(f))),c=this.recurrentActivation.apply(m);let g=V(c,this.activation.apply(l));return[g,g,l]})}getConfig(){let e=super.getConfig(),t={units:this.units,activation:wo(this.activation),recurrentActivation:wo(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Dt(this.kernelInitializer),recurrentInitializer:Dt(this.recurrentInitializer),biasInitializer:Dt(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:mt(this.kernelRegularizer),recurrentRegularizer:mt(this.recurrentRegularizer),biasRegularizer:mt(this.biasRegularizer),activityRegularizer:mt(this.activityRegularizer),kernelConstraint:Qt(this.kernelConstraint),recurrentConstraint:Qt(this.recurrentConstraint),biasConstraint:Qt(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return{...e,...t}}};jd.className="LSTMCell";oe.registerClass(jd);var _x=class extends zs{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new jd(e);super(e)}call(e,t){return M(()=>{this.cell.dropoutMask!=null&&(Fe(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Fe(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=t==null?null:t.mask,r=t==null?null:t.training,s=t==null?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:s})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}};_x.className="LSTM";oe.registerClass(_x);var rm=class extends Hd{constructor(e){super(e);this.cells=e.cells}get stateSize(){let e=[];for(let t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return M(()=>{e=e;let n=e.slice(1),r=[];for(let o of this.cells.slice().reverse())Array.isArray(o.stateSize)?r.push(n.splice(0,o.stateSize.length)):r.push(n.splice(0,1));r.reverse();let s=[],a;for(let o=0;o<this.cells.length;++o){let i=this.cells[o];n=r[o],o===0?a=[e[0]].concat(n):a=[a[0]].concat(n),a=i.call(a,t),s.push(a.slice(1))}n=[];for(let o of s.slice().reverse())n.push(...o);return[a[0]].concat(n)})}build(e){Gv(e)&&(e=e[0]),e=e;let t;this.cells.forEach((n,r)=>{qi(`RNNCell_${r}`,()=>{n.build(e),Array.isArray(n.stateSize)?t=n.stateSize[0]:t=n.stateSize,e=[e[0],t]})}),this.built=!0}getConfig(){let e=super.getConfig(),t=s=>({className:s.getClassName(),config:s.getConfig()}),r={cells:this.cells.map(t)};return{...e,...r}}static fromConfig(e,t,n={}){let r=[];for(let s of t.cells)r.push(Jr(s,n));return new e({cells:r})}get trainableWeights(){if(!this.trainable)return[];let e=[];for(let t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){let e=[];for(let t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){let t=[];for(let n of this.cells)t.push(...n.trainableWeights);return t.concat(e)}return e}getWeights(){let e=[];for(let t of this.cells)e.push(...t.weights);return Hv(e)}setWeights(e){let t=[];for(let n of this.cells){let r=n.weights.length,s=e.splice(r);for(let a=0;a<n.weights.length;++a)t.push([n.weights[a],s[a]])}jv(t)}};rm.className="StackedRNNCells";oe.registerClass(rm);function Io(e){let{ones:t,rate:n,training:r=!1,count:s=1,dropoutFunc:a}=e,o=()=>a!=null?a(t(),n):D0(t(),n),i=()=>Ld(o,t,r);return!s||s<=1?nn(i().clone()):Array(s).fill(void 0).map(i).map(l=>nn(l.clone()))}var W2=class extends zs{constructor(e){if(e.unroll)throw new De("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new De("It is not possible at the moment to stack convolutional cells.");super(e);this.inputSpec=[new Gt({ndim:5})]}call(e,t){return M(()=>{if(this.cell.dropoutMask!=null&&(Fe(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Fe(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new H("ConvRNN2D cell does not support constants");let n=t==null?null:t.mask,r=t==null?null:t.training,s=t==null?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:s})})}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return M(()=>{let{stateSize:t}=this.cell,n=e.shape,r=this.computeSingleOutputShape(n),s=[r[0],...r.slice(2)],a=kt(s);return Array.isArray(t)?Array(t.length).fill(a):[a]})}resetStates(e,t=!1){M(()=>{if(!this.stateful)throw new Ms("Cannot call resetStates() on an RNN Layer that is not stateful.");let n=this.inputSpec[0].shape,r=this.computeSingleOutputShape(n),s=[r[0],...r.slice(2)];if(n[0]==null)throw new H("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>kt(s)):this.states_=[kt(s)];else if(e==null)Fe(this.states_),this.keptStates!=null&&(Fe(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>kt(s)):this.states_[0]=kt(s);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new H(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):Fe(this.states_);for(let o=0;o<this.states_.length;++o){let i=e[o],u=s;if(!w.arraysEqual(i.shape,u))throw new H(`State ${o} is incompatible with layer ${this.name}: expected shape=${u}, received shape=${i.shape}`);this.states_[o]=i}}this.states_=this.states_.map(o=>nn(o.clone()))})}computeSingleOutputShape(e){let{dataFormat:t,filters:n,kernelSize:r,padding:s,strides:a,dilationRate:o}=this.cell,i=t==="channelsFirst",u=e[i?3:2],l=e[i?4:3],c=es(u,r[0],s,a[0],o[0]),d=es(l,r[1],s,a[1],o[1]);return[...e.slice(0,2),...i?[n,c,d]:[c,d,n]]}};W2.className="ConvRNN2D";var sm=class extends jd{constructor(e){let{filters:t,kernelSize:n,strides:r,padding:s,dataFormat:a,dilationRate:o}=e;super({...e,units:t});this.filters=t,rn(this.filters,"filters"),this.kernelSize=Oc(n,2,"kernelSize"),this.kernelSize.forEach(i=>rn(i,"kernelSize")),this.strides=Oc(r||1,2,"strides"),this.strides.forEach(i=>rn(i,"strides")),this.padding=s||"valid",vr(this.padding),this.dataFormat=a||"channelsLast",Bt(this.dataFormat),this.dilationRate=Oc(o||1,2,"dilationRate"),this.dilationRate.forEach(i=>rn(i,"dilationRate"))}build(e){var t;e=ut(e);let n=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[n]==null)throw new H(`The channel dimension of the input should be defined. Found ${e[n]}`);let r=e[n],s=4,a=this.kernelSize.concat([r,this.filters*s]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);let o=this.kernelSize.concat([this.filters,this.filters*s]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",o,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let i;if(this.unitForgetBias){let u=this.biasInitializer,l=this.filters;i=new(t=class extends Pr{apply(c,d){let p=u.apply([l]),h=rr([l]),f=u.apply([l*2]);return Rv([p,h,f])}},t.className="CustomInit",t)}else i=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*s],null,i,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return M(()=>{if(e.length!==3)throw new H(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let n=t.training||!1,r=e[0],s=e[1],a=e[2],o=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Io({ones:()=>br(r),rate:this.dropout,training:n,count:o,dropoutFunc:this.dropoutFunc}));let i=this.dropoutMask,u=(Q,ee,re)=>!ee||!ee[re]?Q:V(ee[re],Q),l=u(r,i,0),c=u(r,i,1),d=u(r,i,2),p=u(r,i,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Io({ones:()=>br(s),rate:this.recurrentDropout,training:n,count:o,dropoutFunc:this.dropoutFunc}));let h=this.recurrentDropoutMask,f=u(s,h,0),m=u(s,h,1),g=u(s,h,2),b=u(s,h,3),y=3,[v,x,k,T]=sr(this.kernel.read(),o,y),[C,E,F,O]=this.useBias?sr(this.bias.read(),o):[null,null,null,null];l=this.inputConv(l,v,C,this.padding),c=this.inputConv(c,x,E,this.padding),d=this.inputConv(d,k,F,this.padding),p=this.inputConv(p,T,O,this.padding);let[D,R,_,L]=sr(this.recurrentKernel.read(),o,y);f=this.recurrentConv(f,D),m=this.recurrentConv(m,R),g=this.recurrentConv(g,_),b=this.recurrentConv(b,L);let U=this.recurrentActivation.apply(Z(l,f)),j=this.recurrentActivation.apply(Z(c,m)),K=Z(V(j,a),V(U,this.activation.apply(Z(d,g)))),q=V(this.recurrentActivation.apply(Z(p,b)),this.activation.apply(K));return[q,q,K]})}getConfig(){let{units:e,...t}=super.getConfig(),n={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return{...t,...n}}inputConv(e,t,n,r){let s=Wt(e,t,this.strides,r||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return n?Qr(s,n,this.dataFormat):s}recurrentConv(e,t){return Wt(e,t,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}};sm.className="ConvLSTM2DCell";oe.registerClass(sm);var Ex=class extends W2{constructor(e){let t=new sm(e);super({...e,cell:t})}static fromConfig(e,t){return new e(t)}};Ex.className="ConvLSTM2D";oe.registerClass(Ex);var am=class extends Ye{constructor(e){super(e);this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(this.noiseShape==null)return this.noiseShape;let t=e.shape,n=[];for(let r=0;r<this.noiseShape.length;++r)n.push(this.noiseShape[r]==null?t[r]:this.noiseShape[r]);return n}call(e,t){return M(()=>{this.invokeCallHook(e,t);let n=Me(e);if(0<this.rate&&this.rate<1){let r=t.training==null?!1:t.training,s=this.getNoiseShape(n);return Ld(()=>D0(n,this.rate,s,this.seed),()=>n,r)}return e})}getConfig(){let e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}};am.className="Dropout";oe.registerClass(am);var Ax=class extends am{constructor(e){super(e);this.inputSpec=[{ndim:3}]}getNoiseShape(e){let t=e.shape;return[t[0],1,t[2]]}};Ax.className="SpatialDropout1D";oe.registerClass(Ax);var $x=class extends Ye{constructor(e){super(e);if(this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.batchInputShape==null&&e.inputShape==null&&e.inputDim!=null){let t=null;e.batchSize!=null&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,rn(this.units,"units"),this.activation=ko(e.activation),e.useBias!=null&&(this.useBias=e.useBias),this.kernelInitializer=Nt(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=Nt(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=Zt(e.kernelConstraint),this.biasConstraint=Zt(e.biasConstraint),this.kernelRegularizer=_t(e.kernelRegularizer),this.biasRegularizer=_t(e.biasRegularizer),this.activityRegularizer=_t(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){e=ut(e);let t=e[e.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){e=ut(e);let t=e.slice();return t[t.length-1]=this.units,t}call(e,t){return M(()=>{this.invokeCallHook(e,t);let n=Me(e),r=k0(this.activation.getClassName()),s;return r!=null?s=ps(n,this.kernel.read(),r,this.bias?this.bias.read():null):(s=ps(n,this.kernel.read()),this.bias!=null&&(s=Qr(s,this.bias.read())),this.activation!=null&&(s=this.activation.apply(s))),s})}getConfig(){let e={units:this.units,activation:wo(this.activation),useBias:this.useBias,kernelInitializer:Dt(this.kernelInitializer),biasInitializer:Dt(this.biasInitializer),kernelRegularizer:mt(this.kernelRegularizer),biasRegularizer:mt(this.biasRegularizer),activityRegularizer:mt(this.activityRegularizer),kernelConstraint:Qt(this.kernelConstraint),biasConstraint:Qt(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}};$x.className="Dense";oe.registerClass($x);var Fx=class extends Ye{constructor(e){e=e||{};super(e);this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=ut(e);for(let t of e.slice(1))if(t==null)throw new H(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],yo(e,1)]}call(e,t){return M(()=>{this.invokeCallHook(e,t);let n=Me(e);if(this.dataFormat==="channelsFirst"&&n.rank>1){let r=[0];for(let s=2;s<n.rank;++s)r.push(s);r.push(1),n=Oe(n,r)}return KV(n)})}getConfig(){let e={};this.dataFormat!=null&&(e.dataFormat=this.dataFormat);let t=super.getConfig();return Object.assign(e,t),e}};Fx.className="Flatten";oe.registerClass(Fx);var Dx=class extends Ye{constructor(e){super(e);this.supportsMasking=!0,this.activation=ko(e.activation)}call(e,t){return M(()=>{this.invokeCallHook(e,t);let n=Me(e);return this.activation.apply(n)})}getConfig(){let e={activation:wo(this.activation)},t=super.getConfig();return Object.assign(e,t),e}};Dx.className="Activation";oe.registerClass(Dx);var Rx=class extends Ye{constructor(e){super(e);this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return M(()=>(e=Me(e),jV(e,this.n)))}getConfig(){let e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}};Rx.className="RepeatVector";oe.registerClass(Rx);var Px=class extends Ye{constructor(e){super(e);this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||e==null}fixUnknownDimension(e,t){let n="Total size of new array must be unchanged.",r=t.slice(),s=1,a=null;for(let i=0;i<r.length;++i){let u=r[i];if(this.isUnknown(u))if(a===null)a=i;else throw new H("Can only specifiy one unknown dimension.");else s*=u}let o=yo(e);if(a!==null){if(s===0||o%s!=0)throw new H(n);r[a]=o/s}else if(o!==s)throw new H(n);return r}computeOutputShape(e){let t=!1;for(let n=0;n<e.length;++n)if(this.isUnknown(e[n])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return M(()=>{this.invokeCallHook(e,t);let n=Me(e),r=n.shape,s=r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape));return G(n,s)})}getConfig(){let e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}};Px.className="Reshape";oe.registerClass(Px);var Ox=class extends Ye{constructor(e){super(e);if(e.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);let t=Yr(1,e.dims.length+1);if(!w.arraysEqual(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new Gt({ndim:this.dims.length+1})]}computeOutputShape(e){e=ut(e);let t=e.slice();return this.dims.forEach((n,r)=>{t[r+1]=e[n]}),t}call(e,t){return Oe(Me(e),this.dimsIncludingBatch)}getConfig(){let e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}};Ox.className="Permute";oe.registerClass(Ox);var Mx=class extends Ye{constructor(e){super(e==null?{}:e);this.supportsMasking=!0,e!=null?this.maskValue=e.maskValue==null?0:e.maskValue:this.maskValue=0}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){let n=Me(e),r=-1;return Jh(Cc(n,this.maskValue),r)}call(e,t){return M(()=>{this.invokeCallHook(e,t);let n=Me(e),r=-1,s=!0,a=Jh(Cc(n,this.maskValue),r,s);return V(n,ue(a,n.dtype))})}};Mx.className="Masking";oe.registerClass(Mx);var Lx=class extends Ye{constructor(e){super(e);if(this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",e.batchInputShape==null&&e.inputShape==null){let t=null;e.batchSize!=null&&(t=e.batchSize),e.inputLength==null?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(It(e.inputLength))}this.inputDim=e.inputDim,rn(this.inputDim,"inputDim"),this.outputDim=e.outputDim,rn(this.outputDim,"outputDim"),this.embeddingsInitializer=Nt(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=_t(e.embeddingsRegularizer),this.activityRegularizer=_t(e.activityRegularizer),this.embeddingsConstraint=Zt(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return M(()=>this.maskZero?(e=Me(e),Cc(e,Xe(e))):null)}computeOutputShape(e){if(e=ut(e),this.inputLength==null)return[...e,this.outputDim];let t=It(this.inputLength);if(t.length!==e.length-1)throw new H(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let n=0;for(let r=0;r<t.length;++r){let s=t[r],a=e[r+1];if(s!=null&&a!=null&&s!==a)throw new H(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);s==null&&(t[n]=a),n++}}return[e[0],...t,this.outputDim]}call(e,t){return M(()=>{this.invokeCallHook(e,t);let n=Me(e);n.dtype!=="int32"&&(n=Ef(n,"int32"));let r=F0(this.embeddings.read(),G(n,[n.size]));return G(r,ut(this.computeOutputShape(n.shape)))})}getConfig(){let e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:Dt(this.embeddingsInitializer),embeddingsRegularizer:mt(this.embeddingsRegularizer),activityRegularizer:mt(this.activityRegularizer),embeddingsConstraint:Qt(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}};Lx.className="Embedding";oe.registerClass(Lx);var Zi=class extends Ye{constructor(e){super(e||{});this.supportsMasking=!0}mergeFunction(e){throw new De}computeElementwiseOpOutputShape(e,t){if(e==null||t==null)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(t.length===0)return e;let n=e.slice(0,e.length-t.length);for(let r=0;r<t.length;++r){let s=e[e.length-t.length+r],a=t[r];if(s==null||a==null||s<0||a<0)n.push(null);else if(s===1)n.push(a);else if(a===1)n.push(s);else{if(s!==a)throw new H("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));n.push(s)}}return n}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[ut(e)]),e=e,e.length<2)throw new H(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(let s of e)s!=null&&s[0]!==null&&t.push(s[0]);if(t=bo(t),t.length>1)throw new H(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let n=e[0]==null?null:e[0].slice(1);for(let s=1;s<e.length;++s){let a=e[s]==null?null:e[s].slice(1);n=this.computeElementwiseOpOutputShape(n,a)}let r=e.map(s=>s.length);e.indexOf(null)===-1&&bo(r).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return M(()=>{if(e=e,this.reshapeRequired){let n=[],r=e.map(s=>s.rank);if(r.indexOf(null)===-1){let s=vo(r);for(let a of e){let o=a.rank;for(let i=0;i<s-o;++i)a=Od(a,1);n.push(a)}return this.mergeFunction(n)}else{let s=!1;for(let i of e){let u=i.rank;if(u==null){let l=i.shape,c=l[0],d=l.slice(1).concat([c]),p=G(i,[c].concat(yo(l.slice(1))));p=Oe(p,[1,0]),p=G(p,d),n.push(p),s=!0}else if(u>1){let l=Yr(1,u).concat([0]);n.push(Oe(i,l)),s=!0}else n.push(i)}let a=this.mergeFunction(n),o=a.rank;if(s){if(o==null){let i=a.shape,u=i.length,l=i[u-1],c=[l].concat(i.slice(0,i.length-1));a=G(Oe(G(a,[-1,l]),[1,0]),c)}else if(o>1){let i=[o-1].concat(Yr(0,o-1));a=Oe(a,i)}}return a}}else return this.mergeFunction(e)})}computeOutputShape(e){e=e;let t;e[0]==null?t=null:t=e[0].slice(1);for(let r=1;r<e.length;++r){let s=e[r]==null?null:e[r].slice(1);t=this.computeElementwiseOpOutputShape(t,s)}let n=[];for(let r of e)r!=null&&r[0]!==null&&n.push(r[0]);return n=bo(n),n.length===1?t=n.concat(t):t=[null].concat(t),t}computeMask(e,t){return M(()=>{if(t==null)return null;if(!Array.isArray(t))throw new H("`mask` should be an Array");if(!Array.isArray(e))throw new H("`inputs` should be an Array");if(t.length!==e.length)throw new H(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every(r=>r==null))return null;t=t.map(r=>r==null?r:Nn(r,0));let n=t[0];for(let r=1;r<t.length-1;++r)n=Hr(n,t[r]);return n})}},Bx=class extends Zi{constructor(e){super(e)}mergeFunction(e){return M(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=Z(t,e[n]);return t})}};Bx.className="Add";oe.registerClass(Bx);var zx=class extends Zi{constructor(e){super(e)}mergeFunction(e){return M(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=V(t,e[n]);return t})}};zx.className="Multiply";oe.registerClass(zx);var Wx=class extends Zi{constructor(e){super(e)}mergeFunction(e){return M(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=Z(t,e[n]);return V(1/e.length,t)})}};Wx.className="Average";oe.registerClass(Wx);var Vx=class extends Zi{constructor(e){super(e)}mergeFunction(e){return M(()=>{let t=e[0];for(let n=1;n<e.length;++n)t=Ds(t,e[n]);return t})}};Vx.className="Maximum";oe.registerClass(Vx);var Ux=class extends Zi{constructor(e){super(e)}mergeFunction(e){return M(()=>{let t=e[0];for(let n=1;n<e.length;++n)t=Td(t,e[n]);return t})}};Ux.className="Minimum";oe.registerClass(Ux);var Gx=class extends Zi{constructor(e){super(e);this.DEFAULT_AXIS=-1,e==null&&(e={}),this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!(Array.isArray(e)&&Array.isArray(e[0]))||e.length===1)throw new H("A `Concatenate` layer should be called on a list of at least 2 inputs");e=e;let t=!0;for(let r of e)if(r!=null){t=!1;break}if(t)return;let n=[];for(let r=0;r<e.length;++r){let s=e[r].slice();s.splice(this.axis,1);let a=!1;for(let o of n)if(w.arraysEqual(o,s)){a=!0;break}a||n.push(s)}if(n.length>1)throw new H("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return M(()=>Rv(e,this.axis))}computeOutputShape(e){if(!(Array.isArray(e)&&Array.isArray(e[0])))throw new H("A `Concatenate` layer should be called on a list of inputs.");let t=e,n=t[0].slice(),r=this.axis<0?n.length+this.axis:this.axis;for(let s of t.slice(1)){if(n[r]==null||s[r]==null){n[r]=null;break}n[r]+=s[r]}return n}computeMask(e,t){if(t==null)return null;if(!Array.isArray(t))throw new H("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new H("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new H(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return M(()=>{let n=!0;if(t.forEach(a=>{if(a!=null){n=!1;return}}),n)return null;let r=[];for(let a=0;a<e.length;++a)t[a]==null?r.push(ue(br(e[a]),"bool")):t[a].rank<e[a].rank?r.push(Nn(t[a],-1)):r.push(t[a]);let s=ot(r,this.axis);return By(s,-1,!1)})}getConfig(){let e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}};Gx.className="Concatenate";oe.registerClass(Gx);function qd(e,t){for(;e<0;)e+=t;return e}function EG(e,t,n){if(e.shape.length>3||t.shape.length>3)throw new De("batchDot is not implemented for tensors of 4D or higher rank yet");if(w.assert(e.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${e.shape.length}`),w.assert(e.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`),typeof n=="number"&&(n=[n,n]),e.dtype==="complex64"||t.dtype==="complex64")throw new De("batchDot is not implemented for complex64-type Tensors yet.");let r=e.shape.length,s=t.shape.length;n==null&&(n=[r-1,s-2]);let a=n;return M(()=>{let o;if(r>s){o=r-s;let u=[];for(let l=0;l<o;++l)u.push(1);t=G(t,t.shape.concat(u))}else if(s>r){o=s-r;let u=[];for(let l=0;l<o;++l)u.push(1);e=G(e,e.shape.concat(u))}else o=0;let i;if(e.shape.length===2&&t.shape.length===2)a[0]===a[1]?i=ve(V(e,t),a[0]):i=ve(V(Oe(e,[1,0]),t),a[1]);else{let u=a[0]!==e.shape.length-1,l=a[1]===t.shape.length-1;i=Re(e,t,u,l)}if(o>0){let u;r>s?u=r+s-3:u=r-1;let l=[];for(let c=u;c<u+o;++c)l.push(c);i=Rs(i,l)}return i.shape.length===1&&(i=Nn(i,1)),i})}var Hx=class extends Zi{constructor(e){super(e);this.axes=e.axes,this.normalize=e.normalize==null?!1:e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){w.assert(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let t=e[0],n=e[1];if(t.length>3||n.length>3)throw new De("Dot layer does not support tensors of 4D or higher rank yet.");let r=this.interpretAxes(t,n);if(t[r[0]]!==n[r[1]])throw new H(`Dimension incompatibility: ${t[r[0]]} !== ${n[r[1]]}`)}mergeFunction(e){if(e.length!==2)throw new H(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t=e[0],n=e[1],r;return Array.isArray(this.axes)?r=this.axes.map((s,a)=>qd(s,e[a].shape.length)):r=[qd(this.axes,t.shape.length),qd(this.axes,n.shape.length)],this.normalize&&(t=Gf(t,r[0]),n=Gf(n,r[1])),EG(t,n,r)}interpretAxes(e,t){let n;return Array.isArray(this.axes)?n=this.axes:n=[qd(this.axes,e.length),qd(this.axes,t.length)],n}computeOutputShape(e){w.assert(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let t=e[0].slice(),n=e[1].slice();if(t.length>3||n.length>3)throw new De("Dot layer does not support tensors of 4D or higher rank yet.");let r=this.interpretAxes(t,n);t.splice(r[0],1),n.splice(r[1],1),n.splice(0,1);let s=t.concat(n);return s.length===1&&s.push(1),s}computeMask(e,t){return null}getConfig(){let e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}};Hx.className="Dot";oe.registerClass(Hx);var jx=class extends Ye{constructor(e){super(e);this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return M(()=>{this.invokeCallHook(e,t);let n=Me(e);return Ld(()=>Z($f(n.shape,0,this.stddev),n),()=>n,t.training||!1)})}};jx.className="GaussianNoise";oe.registerClass(jx);var qx=class extends Ye{constructor(e){super(e);this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return M(()=>{this.invokeCallHook(e,t);let n=Me(e);return this.rate>0&&this.rate<1?Ld(()=>{let s=Math.sqrt(this.rate/(1-this.rate));return V(n,$f(n.shape,1,s))},()=>n,t.training||!1):n})}};qx.className="GaussianDropout";oe.registerClass(qx);var Kx=class extends Ye{constructor(e){super(e);this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||Me(e).shape}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return M(()=>{if(this.rate<1&&this.rate>0){let n=this._getNoiseShape(e);return Ld(()=>{let s=Me(e),a=1.6732632423543772,o=1.0507009873554805,i=-a*o,u=zi(Tc(n),this.rate);u=Ef(u,"float32");let l=((1-this.rate)*(1+this.rate*i**2))**-.5,c=-l*i*this.rate,d=Z(V(s,u),V(Z(u,-1),i));return Z(V(d,l),c)},()=>Me(e),t.training||!1)}return e})}};Kx.className="AlphaDropout";oe.registerClass(Kx);function Kd(e,t,n,r,s,a=.001){let o;if(e.rank===2)o=rS(e,t,n,r,s,a);else if(e.rank===3)o=sS(e,t,n,r,s,a);else if(e.rank===4)o=aS(e,t,n,r,s,a);else throw new De(`batchNormalization is not implemented for array of rank ${e.rank} yet`);return o}function AG(e,t,n,r,s=.001){return M(()=>{let a=lf(e,r),o=a.mean,i=a.variance;return[Kd(e,o,i,n,t,s),o,i]})}function $G(e,t,n,r,s=.001){return M(()=>{let a=lf(e,r),o=a.mean,i=a.variance,u=[];for(let f of Yr(0,e.rank))r.indexOf(f)!==-1?u.push(1):u.push(e.shape[f]);let l=G(o,u),c=G(i,u),d=t==null?null:G(t,u),p=n==null?null:G(n,u);return[Kd(e,l,c,p,d,s),o,i]})}function FG(e,t,n,r,s=.001){return w.arraysEqual(r.slice().sort(),Yr(0,e.rank-1))?AG(e,t,n,r,s):$G(e,t,n,r,s)}var Xx=class extends Ye{constructor(e){e==null&&(e={});super(e);this.supportsMasking=!0,this.axis=e.axis==null?-1:e.axis,this.momentum=e.momentum==null?.99:e.momentum,this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=Nt(e.betaInitializer||"zeros"),this.gammaInitializer=Nt(e.gammaInitializer||"ones"),this.movingMeanInitializer=Nt(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=Nt(e.movingVarianceInitializer||"ones"),this.betaConstraint=Zt(e.betaConstraint),this.gammaConstraint=Zt(e.gammaConstraint),this.betaRegularizer=_t(e.betaRegularizer),this.gammaRegularizer=_t(e.gammaRegularizer)}build(e){e=ut(e);let t=this.axis>=0?this.axis:this.axis+e.length,n=e[t];if(n==null)throw new H(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new Gt({ndim:e.length,axes:{[t]:n}})];let r=[n];this.scale&&(this.gamma=this.addWeight("gamma",r,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",r,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",r,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",r,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return M(()=>{let n=t.training==null?!1:t.training,r=Me(e),s=r.shape,a=s.length,o=Yr(0,a),i=this.axis>=0?this.axis:this.axis+a;o.splice(i,1);let u=Gi(1,a);u[i]=s[i];let l=o.slice();l.sort();let c=!w.arraysEqual(l,Yr(0,a).slice(0,a-1)),d=()=>{if(c){let b=G(this.movingMean.read(),u),y=G(this.movingVariance.read(),u),v=this.center?G(this.beta.read(),u):null,x=this.scale?G(this.gamma.read(),u):null;return Kd(r,b,y,v,x,this.epsilon)}else return Kd(r,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!n)return d();let[p,h,f]=FG(r,this.gamma.read(),this.beta.read(),o,this.epsilon),m=(b,y,v)=>{M(()=>{let x=1-v,k=b.read(),T=V(he(k,y),x);b.write(he(k,T))})};return(()=>{m(this.movingMean,h,this.momentum),m(this.movingVariance,f,this.momentum)})(),p})}getConfig(){let e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Dt(this.betaInitializer),gammaInitializer:Dt(this.gammaInitializer),movingMeanInitializer:Dt(this.movingMeanInitializer),movingVarianceInitializer:Dt(this.movingVarianceInitializer),betaRegularizer:mt(this.betaRegularizer),gammaRegularizer:mt(this.gammaRegularizer),betaConstraint:Qt(this.betaConstraint),gammaConstraint:Qt(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}};Xx.className="BatchNormalization";oe.registerClass(Xx);var Yx=class extends Ye{constructor(e){e==null&&(e={});super(e);if(this.axis=e.axis==null?-1:e.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(let t of this.axis)if(!Number.isInteger(t))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=Nt(e.betaInitializer||"zeros"),this.gammaInitializer=Nt(e.gammaInitializer||"ones"),this.betaRegularizer=_t(e.betaRegularizer),this.gammaRegularizer=_t(e.gammaRegularizer),this.supportsMasking=!0}build(e){e=ut(e);let t=e.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let s=0;s<this.axis.length;++s)this.axis[s]<0&&(this.axis[s]+=t);for(let s of this.axis)if(s<0||s>=t)throw new Error(`Invalid axis: ${s}`);if(this.axis.length!==bo(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);let n=this.axis.map(s=>e[s]),r=!0;this.scale?this.gamma=this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,r):this.gamma=null,this.center?this.beta=this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,r):this.beta=null,this.built=!0}call(e,t){let n=Me(e),r=n.shape,s=r.length;return M(()=>{let a=!0,{mean:o,variance:i}=lf(n,this.axis,a),u=Gi(1,s);for(let f of this.axis)u[f]=r[f];let l=f=>f!=null&&f.shape.length!==s?G(f,u):f,c=l(this.gamma.read()),d=l(this.beta.read()),p=[],h=[];for(let f=0;f<s;++f)this.axis.indexOf(f)!==-1?(p.push(r[f]),h.push(1)):(p.push(1),h.push(r[f]));return o=tr(o,p),i=tr(i,p),c=tr(c,h),d=tr(d,h),Kd(n,o,i,d,c,this.epsilon)})}getConfig(){let e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Dt(this.betaInitializer),gammaInitializer:Dt(this.gammaInitializer),betaRegularizer:mt(this.betaRegularizer),gammaRegularizer:mt(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}};Yx.className="LayerNormalization";oe.registerClass(Yx);function DG(e,t,n){return M(()=>{if(e.rank!==4)throw new H(`temporalPadding expects input tensor to be 4-D, but received a ${e.rank}-D tensor.`);if(t==null&&(t=[[1,1],[1,1]]),t.length!==2||t[0].length!==2||t[1].length!==2)throw new H("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(n==null&&(n=Kr()),n!=="channelsLast"&&n!=="channelsFirst")throw new H(`Unknown data format: ${n}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let r;return n==="channelsFirst"?r=[[0,0],[0,0],t[0],t[1]]:r=[[0,0],t[0],t[1],[0,0]],Fr(e,r)})}var Qx=class extends Ye{constructor(e){e==null&&(e={});super(e);if(this.dataFormat=e.dataFormat==null?Kr():e.dataFormat,e.padding==null)this.padding=[[1,1],[1,1]];else if(typeof e.padding=="number")this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,e.padding.length!==2)throw new H(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,n;if(typeof e.padding[0]=="number")t=[e.padding[0],e.padding[0]],n=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,e.padding[0].length!==2)throw new H(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],e.padding[1].length!==2)throw new H(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);n=e.padding[1]}this.padding=[t,n]}this.inputSpec=[new Gt({ndim:4})]}computeOutputShape(e){e=ut(e);let t,n;return this.dataFormat==="channelsFirst"?(e[2]!=null&&e[2]>=0?t=e[2]+this.padding[0][0]+this.padding[0][1]:t=null,e[3]!=null&&e[3]>=0?n=e[3]+this.padding[1][0]+this.padding[1][1]:n=null,[e[0],e[1],t,n]):(e[1]!=null&&e[1]>=0?t=e[1]+this.padding[0][0]+this.padding[0][1]:t=null,e[2]!=null&&e[2]>=0?n=e[2]+this.padding[1][0]+this.padding[1][1]:n=null,[e[0],t,n,e[3]])}call(e,t){return M(()=>DG(Me(e),this.padding,this.dataFormat))}getConfig(){let e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}};Qx.className="ZeroPadding2D";oe.registerClass(Qx);function om(e,t,n,r,s,a){return M(()=>{Bt(s),T0(a),vr(r),n==null&&(n=[1,1]),r==null&&(r="valid"),s==null&&(s=Kr()),a==null&&(a="max"),e=bx(e,s);let o,i=r==="same"?"same":"valid";return a==="max"?o=Vt(e,t,n,i):o=Ar(e,t,n,i),s==="channelsFirst"&&(o=Oe(o,[0,3,1,2])),o})}function V2(e,t,n,r,s,a){return M(()=>{Bt(s),T0(a),vr(r),n==null&&(n=[1,1,1]),r==null&&(r="valid"),s==null&&(s=Kr()),a==null&&(a="max"),e=F2(e,s);let o,i=r==="same"?"same":"valid";return a==="max"?o=nv(e,t,n,i):o=Vy(e,t,n,i),s==="channelsFirst"&&(o=Oe(o,[0,4,1,2,3])),o})}var U2=class extends Ye{constructor(e){e.poolSize==null&&(e.poolSize=2);super(e);if(typeof e.poolSize=="number")this.poolSize=[e.poolSize];else if(Array.isArray(e.poolSize)&&e.poolSize.length===1&&typeof e.poolSize[0]=="number")this.poolSize=e.poolSize;else throw new H(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);if(rn(this.poolSize,"poolSize"),e.strides==null)this.strides=this.poolSize;else if(typeof e.strides=="number")this.strides=[e.strides];else if(Array.isArray(e.strides)&&e.strides.length===1&&typeof e.strides[0]=="number")this.strides=e.strides;else throw new H(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);rn(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,vr(this.padding),this.inputSpec=[new Gt({ndim:3})]}computeOutputShape(e){e=ut(e);let t=es(e[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return M(()=>{this.invokeCallHook(e,t),e=Od(Me(e),2);let n=this.poolingFunction(Me(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return Rs(n,[2])})}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}},Zx=class extends U2{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return Bt(s),vr(r),om(e,t,n,r,s,"max")}};Zx.className="MaxPooling1D";oe.registerClass(Zx);var Jx=class extends U2{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return Bt(s),vr(r),om(e,t,n,r,s,"avg")}};Jx.className="AveragePooling1D";oe.registerClass(Jx);var G2=class extends Ye{constructor(e){e.poolSize==null&&(e.poolSize=[2,2]);super(e);if(this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==2)throw new H(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];rn(this.poolSize,"poolSize"),rn(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Bt(this.dataFormat),vr(this.padding),this.inputSpec=[new Gt({ndim:4})]}computeOutputShape(e){e=ut(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],n=this.dataFormat==="channelsFirst"?e[3]:e[2];return t=es(t,this.poolSize[0],this.padding,this.strides[0]),n=es(n,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,n]:[e[0],t,n,e[3]]}call(e,t){return M(()=>(this.invokeCallHook(e,t),this.poolingFunction(Me(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},ew=class extends G2{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return Bt(s),vr(r),om(e,t,n,r,s,"max")}};ew.className="MaxPooling2D";oe.registerClass(ew);var tw=class extends G2{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return Bt(s),vr(r),om(e,t,n,r,s,"avg")}};tw.className="AveragePooling2D";oe.registerClass(tw);var H2=class extends Ye{constructor(e){e.poolSize==null&&(e.poolSize=[2,2,2]);super(e);if(this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==3)throw new H(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];rn(this.poolSize,"poolSize"),rn(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Bt(this.dataFormat),vr(this.padding),this.inputSpec=[new Gt({ndim:5})]}computeOutputShape(e){e=ut(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],n=this.dataFormat==="channelsFirst"?e[3]:e[2],r=this.dataFormat==="channelsFirst"?e[4]:e[3];return t=es(t,this.poolSize[0],this.padding,this.strides[0]),n=es(n,this.poolSize[1],this.padding,this.strides[1]),r=es(r,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,n,r]:[e[0],t,n,r,e[4]]}call(e,t){return M(()=>(this.invokeCallHook(e,t),this.poolingFunction(Me(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},nw=class extends H2{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return Bt(s),vr(r),V2(e,t,n,r,s,"max")}};nw.className="MaxPooling3D";oe.registerClass(nw);var rw=class extends H2{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return Bt(s),vr(r),V2(e,t,n,r,s,"avg")}};rw.className="AveragePooling3D";oe.registerClass(rw);var j2=class extends Ye{constructor(e){super(e);this.inputSpec=[new Gt({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new De}},sw=class extends j2{constructor(e){super(e||{})}call(e,t){return M(()=>{let n=Me(e);return Ot(n,1)})}};sw.className="GlobalAveragePooling1D";oe.registerClass(sw);var aw=class extends j2{constructor(e){super(e||{})}call(e,t){return M(()=>{let n=Me(e);return Gr(n,1)})}};aw.className="GlobalMaxPooling1D";oe.registerClass(aw);var q2=class extends Ye{constructor(e){super(e);this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Bt(this.dataFormat),this.inputSpec=[new Gt({ndim:4})]}computeOutputShape(e){return e=e,this.dataFormat==="channelsLast"?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new De}getConfig(){let e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},ow=class extends q2{call(e,t){return M(()=>{let n=Me(e);return this.dataFormat==="channelsLast"?Ot(n,[1,2]):Ot(n,[2,3])})}};ow.className="GlobalAveragePooling2D";oe.registerClass(ow);var iw=class extends q2{call(e,t){return M(()=>{let n=Me(e);return this.dataFormat==="channelsLast"?Gr(n,[1,2]):Gr(n,[2,3])})}};iw.className="GlobalMaxPooling2D";oe.registerClass(iw);var K2=class extends Ye{constructor(e){super(e);this.layer=e.layer}build(e){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(e){this.layer!=null&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){let e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t,n={}){let r=t.layer,s=Jr(r,n);delete t.layer;let a={layer:s};return Object.assign(a,t),new e(a)}},uw=class extends K2{constructor(e){super(e);this.supportsMasking=!0}build(e){if(e=ut(e),e.length<3)throw new H(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];let t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){e=ut(e);let t=[e[0]].concat(e.slice(2)),n=this.layer.computeOutputShape(t),r=e[1];return[n[0],r].concat(n.slice(1))}call(e,t){return M(()=>(e=Me(e),B2((a,o)=>[Me(this.layer.call(a,t)),[]],e,[],!1,null,null,!1,!0)[1]))}};uw.className="TimeDistributed";oe.registerClass(uw);function RG(e){ji(WV,"BidirectionalMergeMode",e)}var PG="concat",cw=class extends K2{constructor(e){super(e);let t=e.layer.getConfig(),n={};n.className=e.layer.getClassName(),n.config=t,this.forwardLayer=Jr(n),t.goBackwards=t.goBackwards!==!0;let r={};if(r.className=e.layer.getClassName(),r.config=t,this.backwardLayer=Jr(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=e.mergeMode===void 0?PG:e.mergeMode,RG(this.mergeMode),e.weights)throw new De("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,this.forwardLayer!=null&&(this.forwardLayer.trainable=e),this.backwardLayer!=null&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){let t=e.length,n=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,n)),this.backwardLayer.setWeights(e.slice(n))}computeOutputShape(e){let t=this.forwardLayer.computeOutputShape(e);Array.isArray(t)&&Array.isArray(t[0])||(t=[t]),t=t;let n,r,s;return this.returnState&&(s=t.slice(1)),n=t[0],n=n,this.mergeMode==="concat"?(n[n.length-1]*=2,r=[n]):this.mergeMode==null?r=[n,n.slice()]:r=[n],this.returnState?this.mergeMode==null?r.concat(s).concat(s.slice()):[n].concat(s).concat(s.slice()):Gn(r)}apply(e,t){let n=t==null?null:t.initialState,r=t==null?null:t.constants;t==null&&(t={});let s=L2(e,n,r,this.numConstants);if(e=s.inputs,n=s.initialState,r=s.constants,Array.isArray(e)&&(n=e.slice(1),e=e[0]),(n==null||n.length===0)&&r==null)return super.apply(e,t);let a=[],o=[];if(n!=null){let u=n.length;if(u%2>0)throw new H("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=n,a.push(...n);let l=n.map(c=>new Gt({shape:c.shape}));this.forwardLayer.stateSpec=l.slice(0,u/2),this.backwardLayer.stateSpec=l.slice(u/2),o.push(...l)}if(r!=null)throw new De("Support for constants in Bidirectional layers is not implemented yet.");let i=a[0]instanceof Zr;for(let u of a)if(u instanceof Zr!==i)throw new H("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(i){let u=[e].concat(a),l=this.inputSpec.concat(o),c=this.inputSpec;this.inputSpec=l;let d=super.apply(u,t);return this.inputSpec=c,d}else return super.apply(e,t)}call(e,t){return M(()=>{let n=t.initialState,r,s;if(n==null)r=this.forwardLayer.call(e,t),s=this.backwardLayer.call(e,t);else{let i=n.slice(0,n.length/2),u=n.slice(n.length/2);r=this.forwardLayer.call(e,Object.assign(t,{initialState:i})),s=this.backwardLayer.call(e,Object.assign(t,{initialState:u}))}let a;this.returnState&&(Array.isArray(r)&&(a=r.slice(1).concat(s.slice(1))),r=r[0],s=s[0]),this.returnSequences&&(s=yr(s,1));let o;return this.mergeMode==="concat"?o=Rv([r,s]):this.mergeMode==="sum"?o=Z(r,s):this.mergeMode==="ave"?o=V(.5,Z(r,s)):this.mergeMode==="mul"?o=V(r,s):this.mergeMode==null&&(o=[r,s]),this.returnState?this.mergeMode==null?o.concat(a):[o].concat(a):o})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){qi(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),qi(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,t){Array.isArray(t)&&(t=t[0]);let n;if(this.returnSequences?this.mergeMode==null?n=[t,t]:n=t:this.mergeMode==null?n=[null,null]:n=null,this.returnState){let s=this.forwardLayer.states.map(a=>null);return Array.isArray(n)?n.concat(s).concat(s):[n].concat(s).concat(s)}else return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(e),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){let e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){let n=Jr(t.layer);if(delete t.layer,t.numConstants!=null)throw new De("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");let r=t;return r.layer=n,new e(r)}};cw.className="Bidirectional";oe.registerClass(cw);function OG(e){return new Dc(e)}function MG(e){return new fx(e)}function LG(e){return new dx(e)}function BG(e){return new px(e)}function zG(e){return new hx(e)}function WG(e){return new gx(e)}function VG(e){return new mx(e)}function UG(e){return new kx(e)}function GG(e){return new Jf(e)}function HG(e){return new vx(e)}function jG(e){return new em(e)}function qG(e){return new xx(e)}function KG(e){return new wx(e)}function XG(e){return new Ix(e)}function YG(e){return new Sx(e)}function QG(e){return new Cx(e)}function ZG(e){return new Dx(e)}function JG(e){return new $x(e)}function eH(e){return new am(e)}function tH(e){return new Ax(e)}function nH(e){return new Fx(e)}function rH(e){return new Rx(e)}function sH(e){return new Px(e)}function aH(e){return new Ox(e)}function oH(e){return new Lx(e)}function iH(e){return new Bx(e)}function uH(e){return new Wx(e)}function cH(e){return new Gx(e)}function lH(e){return new Vx(e)}function dH(e){return new Ux(e)}function pH(e){return new zx(e)}function hH(e){return new Hx(e)}function fH(e){return new Xx(e)}function mH(e){return new Yx(e)}function gH(e){return new Qx(e)}function lw(e){return new Jx(e)}function bH(e){return lw(e)}function yH(e){return lw(e)}function dw(e){return new tw(e)}function vH(e){return dw(e)}function xH(e){return dw(e)}function pw(e){return new rw(e)}function wH(e){return pw(e)}function kH(e){return pw(e)}function IH(e){return new sw(e)}function SH(e){return new ow(e)}function X2(e){return new aw(e)}function Y2(e){return new iw(e)}function Q2(e){return new Zx(e)}function Z2(e){return new ew(e)}function CH(e){return new nw(e)}function TH(e){return new Nx(e)}function NH(e){return new nm(e)}function _H(e){return new _x(e)}function EH(e){return new jd(e)}function AH(e){return new Tx(e)}function $H(e){return new tm(e)}function FH(e){return new Ex(e)}function DH(e){return new sm(e)}function RH(e){return new zs(e)}function PH(e){return new rm(e)}function OH(e){return new cw(e)}function MH(e){return new uw(e)}var LH=X2,BH=Y2,zH=Q2,WH=Z2;function VH(e){return new jx(e)}function UH(e){return new qx(e)}function GH(e){return new Kx(e)}function HH(e){return new Mx(e)}var J2={};Ee(J2,{MAPE:()=>n6,MSE:()=>a6,binaryAccuracy:()=>jH,binaryCrossentropy:()=>qH,categoricalAccuracy:()=>XH,categoricalCrossentropy:()=>YH,cosineProximity:()=>JH,mape:()=>r6,meanAbsoluteError:()=>e6,meanAbsolutePercentageError:()=>t6,meanSquaredError:()=>s6,mse:()=>o6,precision:()=>QH,recall:()=>ZH,sparseCategoricalAccuracy:()=>KH});function jH(e,t){return Yv(e,t)}function qH(e,t){return Q0(e,t)}function KH(e,t){return Z0(e,t)}function XH(e,t){return Qv(e,t)}function YH(e,t){return Zv(e,t)}function QH(e,t){return Y0(e,t)}function ZH(e,t){return OU(e,t)}function JH(e,t){return Kv(e,t)}function e6(e,t){return Hf(e,t)}function t6(e,t){return Pc(e,t)}function n6(e,t){return Pc(e,t)}function r6(e,t){return Pc(e,t)}function s6(e,t){return Xi(e,t)}function a6(e,t){return Xi(e,t)}function o6(e,t){return Xi(e,t)}var eC={};Ee(eC,{modelFromJSON:()=>gG});var tC={};Ee(tC,{l1:()=>u6,l1l2:()=>i6,l2:()=>c6});function i6(e){return new Ud(e)}function u6(e){return SG(e)}function c6(e){return CG(e)}var nC=class extends Rc{constructor(){super(...arguments);this.model=null}setModel(e){if(!(e instanceof Bs))throw new Error("model must be a LayersModel, not some other Container");this.model=e}};function im(e,t){return e<t}function rC(e,t){return e>t}var sC=class extends nC{constructor(e){super();if(e==null&&(e={}),e.restoreBestWeights)throw new De("restoreBestWeights = True is not implemented in EarlyStopping yet.");this.monitor=e.monitor||"val_loss",this.minDelta=Math.abs(e.minDelta||0),this.patience=e.patience||0,this.verbose=e.verbose||0,this.mode=e.mode||"auto",this.baseline=e.baseline,["auto","min","max"].indexOf(this.mode)===-1&&(console.warn(`EarlyStopping mode '${this.mode}' is invalid. Falling back to mode 'auto'.`),this.mode="auto"),this.mode==="min"?this.monitorFunc=im:this.mode==="max"?this.monitorFunc=rC:this.monitor.indexOf("acc")!==-1?this.monitorFunc=rC:this.monitorFunc=im,this.monitorFunc===im&&(this.minDelta*=-1)}async onTrainBegin(e){this.wait=0,this.stoppedEpoch=0,this.baseline!=null?this.best=this.baseline:this.best=this.monitorFunc===im?1/0:-1/0}async onEpochEnd(e,t){await xo(t);let n=this.getMonitorValue(t);n!=null&&(this.monitorFunc(n-this.minDelta,this.best)?(this.best=n,this.wait=0):(this.wait++,this.wait>=this.patience&&(this.stoppedEpoch=e,this.model.stopTraining=!0)))}async onTrainEnd(e){this.stoppedEpoch>0&&this.verbose&&console.log(`Epoch ${this.stoppedEpoch}: early stopping.`)}getMonitorValue(e){e==null&&(e={});let t=e[this.monitor];return t==null&&console.warn(`Metric for EarlyStopping ${this.monitor} is not available. Available metrics are: ${Object.keys(e)}`),t}};function l6(e){return new sC(e)}var d6={earlyStopping:l6},p6=X();p6.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,e=>{e&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var Or;(function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_QINT16=15]="DT_QINT16",e[e.DT_QUINT16=16]="DT_QUINT16",e[e.DT_UINT16=17]="DT_UINT16",e[e.DT_COMPLEX128=18]="DT_COMPLEX128",e[e.DT_HALF=19]="DT_HALF",e[e.DT_RESOURCE=20]="DT_RESOURCE",e[e.DT_VARIANT=21]="DT_VARIANT",e[e.DT_UINT32=22]="DT_UINT32",e[e.DT_UINT64=23]="DT_UINT64",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",e[e.DT_QINT16_REF=115]="DT_QINT16_REF",e[e.DT_QUINT16_REF=116]="DT_QUINT16_REF",e[e.DT_UINT16_REF=117]="DT_UINT16_REF",e[e.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",e[e.DT_HALF_REF=119]="DT_HALF_REF",e[e.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",e[e.DT_VARIANT_REF=121]="DT_VARIANT_REF",e[e.DT_UINT32_REF=122]="DT_UINT32_REF",e[e.DT_UINT64_REF=123]="DT_UINT64_REF"})(Or||(Or={}));var aC;(function(e){let t;(function(n){n[n.LEGACY=0]="LEGACY",n[n.V1=1]="V1",n[n.V2=2]="V2"})(t=e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))})(aC||(aC={}));var hw={};function h6(e,t){let n={tfOpName:e,category:"custom",inputs:[],attrs:[],customExecutor:t};hw[e]=n}function oC(e){return hw[e]}function f6(e){delete hw[e]}function I(e,t,n,r,s){let a=t.inputParams[e];if(a&&a.inputIndexStart!==void 0){let i=a.inputIndexStart,u=a.inputIndexEnd===0?void 0:a.inputIndexEnd===void 0?i+1:a.inputIndexEnd;if(a.type==="tensor")return An(t.inputNames[a.inputIndexStart],n,r,s);if(a.type==="tensors")return t.inputNames.slice(i,u).map(p=>An(p,n,r,s));let l=An(t.inputNames.slice(i)[0],n,r,s),c=l.dataSync();return a.type==="number"?c[0]:w.toNestedArray(l.shape,c)}let o=t.attrParams[e];return o&&o.value}function An(e,t,n,r){let[s,a]=or(e);if(r!=null){let i=r.getHashTableHandleByName(s);if(i!=null)return i}let o=n.currentContextIds.find(i=>!!t[um(s,i)]);return o!==void 0?t[um(s,o)][a]:void 0}function m6(e,t,n){return t[um(e,n.currentContextId)]}function gs(e,t){let[n,r,s]=or(e);return[um(n,t&&t.currentContextId),r,s]}function um(e,t){return t?`${e}-${t}`:e}function or(e){let t=e.split(":");if(t.length===1)return[e,0,void 0];let n=t[0],r=t.length===3?t[1]:void 0,s=Number(t[t.length-1]);return[n,s,r]}function cm(e,t,n){let r=I("pad",e,t,n);if(r==="explicit"){r=I("explicitPaddings",e,t,n);let s=[[0,0],[0,0],[0,0],[0,0]];for(let a=0;a<4;a++)s[a][0]=r[a*2],s[a][1]=r[a*2+1];return s}return r}function Ws(e){return e.kept?e:Fs(e)}var iC={};Ee(iC,{json:()=>g6});var g6=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],uC={};Ee(uC,{json:()=>b6});var b6=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],cC={};Ee(cC,{json:()=>y6});var y6=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]}],lC={};Ee(lC,{json:()=>v6});var v6=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number"}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],dC={};Ee(dC,{json:()=>x6});var x6=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],pC={};Ee(pC,{json:()=>w6});var w6=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],hC={};Ee(hC,{json:()=>k6});var k6=[{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],fC={};Ee(fC,{json:()=>I6});var I6=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],mC={};Ee(mC,{json:()=>S6});var S6=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]}],gC={};Ee(gC,{json:()=>C6});var C6=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]}],bC={};Ee(bC,{json:()=>T6});var T6=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],yC={};Ee(yC,{json:()=>N6});var N6=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]}],vC={};Ee(vC,{json:()=>_6});var _6=[{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}],xC={};Ee(xC,{json:()=>E6});var E6=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],wC={};Ee(wC,{json:()=>A6});var A6=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}],kC={};Ee(kC,{json:()=>$6});var $6=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],IC={};Ee(IC,{json:()=>F6});var F6=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],SC={};Ee(SC,{json:()=>D6});var D6=[{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],CC={};Ee(CC,{json:()=>R6});var R6=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],TC=class{static get Instance(){return this._instance||(this._instance=new this)}constructor(){let e=[iC,uC,cC,lC,dC,pC,hC,fC,mC,gC,bC,yC,vC,xC,wC,kC,IC,SC,CC],t=[].concat(...e.map(n=>n.json));this.opMappers=t.reduce((n,r)=>(n[r.tfOpName]=r,n),{})}transformGraph(e,t={}){let n=e.node,r=[],s=[],a=[],o=n.reduce((f,m)=>(f[m.name]=this.mapNode(m),m.op.startsWith("Placeholder")?r.push(f[m.name]):m.op==="Const"?s.push(f[m.name]):(m.input==null||m.input.length===0)&&a.push(f[m.name]),f),{}),i=[],u=[],l={},c={};t!=null&&(l=this.mapSignatureEntries(t.inputs),c=this.mapSignatureEntries(t.outputs));let d=Object.keys(o);d.forEach(f=>{let m=o[f];m.inputNames.forEach((g,b)=>{let[y,,v]=gs(g),x=o[y];if(x.outputs!=null){let k=x.outputs.indexOf(v);if(k!==-1){let T=`${y}:${k}`;m.inputNames[b]=T}}m.inputs.push(x),x.children.push(m)})}),Object.keys(c).length===0?d.forEach(f=>{let m=o[f];m.children.length===0&&u.push(m)}):Object.keys(c).forEach(f=>{let[m]=gs(f),g=o[m];g!=null&&(g.signatureKey=c[f],u.push(g))}),Object.keys(l).length>0?Object.keys(l).forEach(f=>{let[m]=gs(f),g=o[m];g&&(g.signatureKey=l[f],i.push(g))}):i=r;let p={};e.library!=null&&e.library.function!=null&&(p=e.library.function.reduce((f,m)=>(f[m.signature.name]=this.mapFunction(m),f),{}));let h={nodes:o,inputs:i,outputs:u,weights:s,placeholders:r,signature:t,functions:p};return a.length>0&&(h.initNodes=a),h}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,n)=>(t[e[n].name]=n,t),{})}mapNode(e){let t=oC(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});let n={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(r=>r.startsWith("^")?r.substr(1):r),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return t.inputs!=null&&(n.inputParams=t.inputs.reduce((r,s)=>(r[s.name]={type:s.type,inputIndexStart:s.start,inputIndexEnd:s.end},r),{})),t.attrs!=null&&(n.attrParams=t.attrs.reduce((r,s)=>{let a=s.type,o;switch(s.type){case"string":o=fw(e.attr,s.tfName,s.defaultValue),o===void 0&&!!s.tfDeprecatedName&&(o=fw(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"string[]":o=kw(e.attr,s.tfName,s.defaultValue),o===void 0&&!!s.tfDeprecatedName&&(o=kw(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"number":o=gw(e.attr,s.tfName,s.defaultValue||0),o===void 0&&!!s.tfDeprecatedName&&(o=gw(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"number[]":o=ww(e.attr,s.tfName,s.defaultValue),o===void 0&&!!s.tfDeprecatedName&&(o=ww(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"bool":o=mw(e.attr,s.tfName,s.defaultValue),o===void 0&&!!s.tfDeprecatedName&&(o=mw(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"bool[]":o=Sw(e.attr,s.tfName,s.defaultValue),o===void 0&&!!s.tfDeprecatedName&&(o=Sw(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"shape":o=xw(e.attr,s.tfName,s.defaultValue),o===void 0&&!!s.tfDeprecatedName&&(o=xw(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"shape[]":o=Iw(e.attr,s.tfName,s.defaultValue),o===void 0&&!!s.tfDeprecatedName&&(o=Iw(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"dtype":o=yw(e.attr,s.tfName,s.defaultValue),o===void 0&&!!s.tfDeprecatedName&&(o=yw(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"dtype[]":o=vw(e.attr,s.tfName,s.defaultValue),o===void 0&&!!s.tfDeprecatedName&&(o=vw(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"func":o=_C(e.attr,s.tfName,s.defaultValue),o===void 0&&!!s.tfDeprecatedName&&(o=_C(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${s.type} for op: ${e.op}`)}return r[s.name]={value:o,type:a},r},{})),n}mapFunction(e){let t=e.nodeDef,n=[],r=[],s={};t!=null&&(s=t.reduce((c,d)=>(c[d.name]=this.mapNode(d),d.op==="Const"&&r.push(c[d.name]),c),{}));let a=[],o=[];e.signature.inputArg.forEach(c=>{let[d]=gs(c.name),p={name:d,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:bw(c.type),type:"dtype"}},children:[]};p.signatureKey=c.name,a.push(p),s[d]=p}),Object.keys(s).forEach(c=>{let d=s[c];d.inputNames.forEach((p,h)=>{let[f,,m]=gs(p),g=s[f];if(g.outputs!=null){let b=g.outputs.indexOf(m);if(b!==-1){let y=`${f}:${b}`;d.inputNames[h]=y}}d.inputs.push(g),g.children.push(d)})});let u=e.ret;e.signature.outputArg.forEach(c=>{let[d,p]=gs(u[c.name]),h=s[d];h!=null&&(h.defaultOutput=p,o.push(h))});let l=this.mapArgsToSignature(e);return{nodes:s,inputs:a,outputs:o,weights:r,placeholders:n,signature:l}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n),t),{}),outputs:e.signature.outputArg.reduce((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n,e.ret),t),{})}}mapArgToTensorInfo(e,t){let n=e.name;return t!=null&&(n=t[n]),{name:n,dtype:e.type}}};function P6(e){let t=X().global;if(typeof t.atob!="undefined")return t.atob(e);if(typeof Buffer!="undefined")return new Buffer(e,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function NC(e,t){let n=Array.isArray(e)?String.fromCharCode.apply(null,e):P6(e);return t?n:n.toLowerCase()}function fw(e,t,n,r=!1){let s=e[t];return s!=null?NC(s.s,r):n}function mw(e,t,n){let r=e[t];return r?r.b:n}function gw(e,t,n){let r=e[t]||{},s=r.i!=null?r.i:r.f!=null?r.f:n;return typeof s=="number"?s:parseInt(s,10)}function bw(e){switch(typeof e=="string"&&(e=Or[e]),e){case Or.DT_FLOAT:case Or.DT_HALF:return"float32";case Or.DT_INT32:case Or.DT_INT64:case Or.DT_INT8:case Or.DT_UINT8:return"int32";case Or.DT_BOOL:return"bool";case Or.DT_DOUBLE:return"float32";case Or.DT_STRING:return"string";default:return null}}function _C(e,t,n){let r=e[t];return r&&r.func?r.func.name:n}function yw(e,t,n){let r=e[t];return r&&r.type?bw(r.type):n}function vw(e,t,n){let r=e[t];return r&&r.list&&r.list.type?r.list.type.map(s=>bw(s)):n}function EC(e){if(!e.unknownRank)return e.dim!=null?e.dim.map(t=>typeof t.size=="number"?t.size:parseInt(t.size,10)):[]}function xw(e,t,n){let r=e[t];return r&&r.shape?EC(r.shape):n}function ww(e,t,n){let r=e[t];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map(s=>typeof s=="number"?s:parseInt(s,10)):n}function kw(e,t,n,r=!1){let s=e[t];return s&&s.list&&s.list.s?s.list.s.map(a=>NC(a,r)):n}function Iw(e,t,n){let r=e[t];return r&&r.list&&r.list.shape?r.list.shape.map(s=>EC(s)):n}function Sw(e,t,n){let r=e[t];return r&&r.list&&r.list.b?r.list.b:n}var O6=class{constructor(e,t,n){this.node=e,this.tensorMap=t,this.context=n,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(r=>this.getInput(r)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((r,s)=>(r[s]=this.getAttr(s),r),{}))}getInput(e){return An(e,this.tensorMap,this.context)}getAttr(e,t){let n=this.node.rawAttrs[e];if(n.tensor!=null)return An(e,this.tensorMap,this.context);if(n.i!=null||n.f!=null)return gw(this.node.rawAttrs,e,t);if(n.s!=null)return fw(this.node.rawAttrs,e,t);if(n.b!=null)return mw(this.node.rawAttrs,e,t);if(n.shape!=null)return xw(this.node.rawAttrs,e,t);if(n.type!=null)return yw(this.node.rawAttrs,e,t);if(n.list!=null){if(n.list.i!=null||n.list.f!=null)return ww(this.node.rawAttrs,e,t);if(n.list.s!=null)return kw(this.node.rawAttrs,e,t);if(n.list.shape!=null)return Iw(this.node.rawAttrs,e,t);if(n.list.b!=null)return Sw(this.node.rawAttrs,e,t);if(n.list.type!=null)return vw(this.node.rawAttrs,e,t)}return t}},M6=(e,t,n)=>{switch(e.op){case"BiasAdd":case"AddV2":case"Add":return[Z(I("a",e,t,n),I("b",e,t,n))];case"AddN":return[q1(I("tensors",e,t,n))];case"FloorMod":case"Mod":return[$S(I("a",e,t,n),I("b",e,t,n))];case"Mul":return[V(I("a",e,t,n),I("b",e,t,n))];case"RealDiv":case"Div":return[me(I("a",e,t,n),I("b",e,t,n))];case"DivNoNan":return[bS(I("a",e,t,n),I("b",e,t,n))];case"FloorDiv":return[Ly(I("a",e,t,n),I("b",e,t,n))];case"Sub":return[he(I("a",e,t,n),I("b",e,t,n))];case"Minimum":return[Td(I("a",e,t,n),I("b",e,t,n))];case"Maximum":return[Ds(I("a",e,t,n),I("b",e,t,n))];case"Pow":return[fo(I("a",e,t,n),I("b",e,t,n))];case"SquaredDifference":return[fv(I("a",e,t,n),I("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},L6=(e,t,n)=>{switch(e.op){case"Abs":case"ComplexAbs":return[Xt(I("x",e,t,n))];case"Acos":return[H1(I("x",e,t,n))];case"Acosh":return[j1(I("x",e,t,n))];case"Asin":return[X1(I("x",e,t,n))];case"Asinh":return[Y1(I("x",e,t,n))];case"Atan":return[Q1(I("x",e,t,n))];case"Atan2":return[Z1(I("x",e,t,n),I("y",e,t,n))];case"Atanh":return[J1(I("x",e,t,n))];case"Ceil":return[iS(I("x",e,t,n))];case"Complex":return[io(I("real",e,t,n),I("imag",e,t,n))];case"Cos":return[nf(I("x",e,t,n))];case"Cosh":return[Ky(I("x",e,t,n))];case"Elu":return[Sd(I("x",e,t,n))];case"Erf":return[vS(I("x",e,t,n))];case"Exp":return[Tn(I("x",e,t,n))];case"Expm1":return[xS(I("x",e,t,n))];case"Floor":return[Cd(I("x",e,t,n))];case"Log":return[gr(I("x",e,t,n))];case"Log1p":return[af(I("x",e,t,n))];case"Imag":return[rf(I("x",e,t,n))];case"Neg":return[Ft(I("x",e,t,n))];case"Reciprocal":return[RS(I("x",e,t,n))];case"Real":return[Nd(I("x",e,t,n))];case"Relu":return[Qe(I("x",e,t,n))];case"Round":return[iv(I("x",e,t,n))];case"Selu":return[cv(I("x",e,t,n))];case"Sigmoid":return[$r(I("x",e,t,n))];case"Sin":return[lv(I("x",e,t,n))];case"Sign":return[OS(I("x",e,t,n))];case"Sinh":return[dv(I("x",e,t,n))];case"Softplus":return[Sc(I("x",e,t,n))];case"Sqrt":return[vn(I("x",e,t,n))];case"Square":return[ft(I("x",e,t,n))];case"Tanh":return[kc(I("x",e,t,n))];case"Tan":return[LS(I("x",e,t,n))];case"ClipByValue":return[dn(I("x",e,t,n),I("clipValueMin",e,t,n),I("clipValueMax",e,t,n))];case"Relu6":return[ov(I("x",e,t,n))];case"Rsqrt":return[uv(An(e.inputNames[0],t,n))];case"Prod":return[rv(I("x",e,t,n),I("axes",e,t,n))];case"LeakyRelu":return[sf(I("x",e,t,n),I("alpha",e,t,n))];case"Prelu":return[pf(I("x",e,t,n),I("alpha",e,t,n))];case"IsNan":return[wS(An(e.inputNames[0],t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};function Mr(e,t,n=""){if(!(typeof e=="number"||typeof t=="number")){w.assert(e.length===t.length,()=>n+` Shapes ${e} and ${t} must match`);for(let r=0;r<e.length;r++){let s=e[r],a=t[r];w.assert(s<0||a<0||s===a,()=>n+` Shapes ${e} and ${t} must match`)}}}function AC(e){return!(typeof e=="number"||e.some(t=>t<0))}function Xd(e,t,n){let r=Cw(e,n),s=!AC(r);if(s&&t.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(s&&t.forEach(a=>{r=Cw(a.shape,r)}),!AC(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function Cw(e,t){if(typeof e=="number")return t;if(typeof t=="number")return e;if(e.length!==t.length)throw new Error(`Incompatible ranks during merge: ${e} vs. ${t}`);let n=[];for(let r=0;r<e.length;++r){let s=e[r],a=t[r];if(s>=0&&a>=0&&s!==a)throw new Error(`Incompatible shape during merge: ${e} vs. ${t}`);n[r]=s>=0?s:a}return n}var B6=class{constructor(e,t,n,r,s,a,o){this.name=e,this.dtype=t,this.maxSize=n,this.elementShape=r,this.identicalElementShapes=s,this.dynamicSize=a,this.clearAfterRead=o,this.tensors=[],this.closed_=!1,this.idTensor=ke(0),nn(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.tensor.id))&&t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);let t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(t=>this.read(t))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);let n=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=t.shape),Mr(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),n.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(n.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);n.tensor=t,nn(t),n.written=!0,this.tensors[e]=n}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((n,r)=>this.write(n,t[r]))}gather(e,t){if(!!t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let r=0;r<this.size();r++)e.push(r)}if(e.length===0)return er([],[0].concat(this.elementShape));let n=this.readMany(e);return Mr(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),Ut(n,0)}concat(e){if(!!e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return er([],[0].concat(this.elementShape));let t=[];for(let r=0;r<this.size();r++)t.push(r);let n=this.readMany(t);return Mr(this.elementShape,n[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n[0].shape})`),ot(n,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);let n=Math.max(...e);if(!this.dynamicSize&&n>=this.maxSize)throw new Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`);this.writeMany(e,vt(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let n=0,r=e.map(i=>(n+=i,n));if(n!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${n}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);let s=n===0?0:t.size/n,a=[];M(()=>{t=G(t,[1,n,s]);for(let i=0;i<e.length;++i){let u=i===0?0:r[i-1],l=[0,u,0],c=[1,e[i],s];a[i]=G(Ve(t,l,c),this.elementShape)}return a});let o=[];for(let i=0;i<e.length;i++)o[i]=i;this.writeMany(o,a)}},Yd=class{constructor(e,t,n,r=-1){this.tensors=e,this.elementShape=t,this.elementDtype=n,e!=null&&e.forEach(s=>{if(n!==s.dtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${s.dtype}`);Mr(t,s.shape,"TensorList shape mismatch: "),nn(s)}),this.idTensor=ke(0),this.maxNumElements=r,nn(this.idTensor)}get id(){return this.idTensor.id}copy(){return new Yd([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.id))&&t.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,n=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(n!==-1&&this.tensors.length!==n)throw new Error(`Operation expected a list with ${n} elements but got a list with ${this.tensors.length} elements.`);Mr(e,this.elementShape,"TensorList shape mismatch: ");let r=Xd(this.elementShape,this.tensors,e);return M(()=>{let s=this.tensors.map(a=>G(a,r));return Ut(s,0)})}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");let n=Xd(this.elementShape,this.tensors,e),r=this.tensors.pop();return Mr(r.shape,e,"TensorList shape mismatch: "),G(r,n)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(Mr(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");nn(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(this.maxNumElements!==-1&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);this.tensors.length=e}getItem(e,t,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(this.tensors[e]==null)throw new Error(`element at index ${e} is null.`);Mr(this.tensors[e].shape,t,"TensorList shape mismatch: ");let r=Xd(this.elementShape,this.tensors,t);return G(this.tensors[e],r)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||this.maxNumElements!==-1&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);Mr(this.elementShape,t.shape,"TensorList shape mismatch: "),nn(t),this.tensors[e]=t}gather(e,t,n){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);Mr(this.elementShape,n,"TensorList shape mismatch: "),e=e.slice(0,this.size());let r=Xd(this.elementShape,this.tensors,n);return e.length===0?er([],[0].concat(r)):M(()=>{let s=e.map(a=>G(this.tensors[a],r));return Ut(s,0)})}concat(e,t){if(!!e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);Mr(this.elementShape,t,"TensorList shape mismatch: ");let n=Xd(this.elementShape,this.tensors,t);return this.size()===0?er([],[0].concat(n)):M(()=>{let r=this.tensors.map(s=>G(s,n));return ot(r,0)})}};function z6(e,t,n){let r=e.dtype;if(e.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${e.shape}`);if(e.dtype!==n)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${n}`);let s=e.shape.slice(1);Mr(s,t,"TensorList shape mismatch: ");let a=vt(e);return new Yd(a,t,r)}function W6(e,t,n){return new Yd([],e,t,n)}function V6(e,t,n,r){if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);let s=Math.max(...t);if(r!=null&&r!==-1&&s>=r)throw new Error(`Max index must be < array size (${s}  vs. ${r})`);let a=new Yd([],n,e.dtype,r),o=vt(e,0);return t.forEach((i,u)=>{a.setItem(i,o[u])}),a}function U6(e,t,n){let r=0,s=t.map(c=>(r+=c,r));if(r!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${r}, and tensor's shape is: ${e.shape}`);let a=e.shape.slice(1),o=Cw(a,n),i=r===0?0:e.size/r,u=M(()=>{let c=[];e=G(e,[1,r,i]);for(let d=0;d<t.length;++d){let p=d===0?0:s[d-1],h=[0,p,0],f=[1,t[d],i];c[d]=G(Ve(e,h,f),o)}return e.dispose(),c}),l=new Yd([],n,e.dtype,t.length);for(let c=0;c<u.length;c++)l.setItem(c,u[c]);return l}var G6=async(e,t,n)=>{switch(e.op){case"If":case"StatelessIf":{let r=I("thenBranch",e,t,n),s=I("elseBranch",e,t,n),a=I("cond",e,t,n),o=I("args",e,t,n);return(await a.data())[0]?n.functionMap[r].executeFunctionAsync(o,n.tensorArrayMap,n.tensorListMap):n.functionMap[s].executeFunctionAsync(o,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{let r=I("body",e,t,n),s=I("cond",e,t,n),a=I("args",e,t,n),o=await n.functionMap[s].executeFunctionAsync(a,n.tensorArrayMap,n.tensorListMap),i=a.map(c=>c.id),u=await o[0].data();o.forEach(c=>{!c.kept&&i.indexOf(c.id)===-1&&c.dispose()});let l=a;for(;u[0];){let c=l;l=await n.functionMap[r].executeFunctionAsync(l,n.tensorArrayMap,n.tensorListMap);let d=l.map(h=>h.id);c.forEach(h=>{!h.kept&&i.indexOf(h.id)===-1&&d.indexOf(h.id)===-1&&h.dispose()});let p=await n.functionMap[s].executeFunctionAsync(l,n.tensorArrayMap,n.tensorListMap);u=await p[0].data(),p.forEach(h=>{!h.kept&&i.indexOf(h.id)===-1&&d.indexOf(h.id)===-1&&h.dispose()})}return l}case"LoopCond":{let r=I("pred",e,t,n);return[Ws(r)]}case"Switch":{let r=I("pred",e,t,n),s=I("data",e,t,n);return s.kept||(s=Ws(s)),(await r.data())[0]?[void 0,s]:[s,void 0]}case"Merge":{let r=e.inputNames.find(s=>An(s,t,n)!==void 0);if(r){let s=An(r,t,n);return[Ws(s)]}return}case"Enter":{let r=I("frameName",e,t,n),s=I("tensor",e,t,n);return n.enterFrame(r),[Ws(s)]}case"Exit":{let r=I("tensor",e,t,n);return n.exitFrame(),[Ws(r)]}case"NextIteration":{let r=I("tensor",e,t,n);return n.nextIteration(),[Ws(r)]}case"TensorArrayV3":{let r=I("size",e,t,n),s=I("dtype",e,t,n),a=I("elementShape",e,t,n),o=I("dynamicSize",e,t,n),i=I("clearAfterRead",e,t,n),u=I("identicalElementShapes",e,t,n),l=I("name",e,t,n),c=new B6(l,s,r,a,u,o,i);return n.addTensorArray(c),[c.idTensor,ke(1)]}case"TensorArrayWriteV3":{let r=I("tensorArrayId",e,t,n),s=I("index",e,t,n),a=I("tensor",e,t,n),o=n.getTensorArray(r.id);return o.write(s,a),[o.idTensor]}case"TensorArrayReadV3":{let r=I("tensorArrayId",e,t,n),s=I("index",e,t,n);return[n.getTensorArray(r.id).read(s)]}case"TensorArrayGatherV3":{let r=I("tensorArrayId",e,t,n),s=I("indices",e,t,n),a=I("dtype",e,t,n);return[n.getTensorArray(r.id).gather(s,a)]}case"TensorArrayScatterV3":{let r=I("tensorArrayId",e,t,n),s=I("indices",e,t,n),a=I("tensor",e,t,n),o=n.getTensorArray(r.id);return o.scatter(s,a),[o.idTensor]}case"TensorArrayConcatV3":{let r=I("tensorArrayId",e,t,n),s=n.getTensorArray(r.id),a=I("dtype",e,t,n);return[s.concat(a)]}case"TensorArraySplitV3":{let r=I("tensorArrayId",e,t,n),s=I("tensor",e,t,n),a=I("lengths",e,t,n),o=n.getTensorArray(r.id);return o.split(a,s),[o.idTensor]}case"TensorArraySizeV3":{let r=I("tensorArrayId",e,t,n),s=n.getTensorArray(r.id);return[ke(s.size(),"int32")]}case"TensorArrayCloseV3":{let r=I("tensorArrayId",e,t,n),s=n.getTensorArray(r.id);return s.clearAndClose(),[s.idTensor]}case"TensorListSetItem":{let r=I("tensorListId",e,t,n),s=I("index",e,t,n),a=I("tensor",e,t,n),o=n.getTensorList(r.id);return o.setItem(s,a),[o.idTensor]}case"TensorListGetItem":{let r=I("tensorListId",e,t,n),s=I("index",e,t,n),a=I("elementShape",e,t,n),o=I("elementDType",e,t,n);return[n.getTensorList(r.id).getItem(s,a,o)]}case"TensorListScatterV2":case"TensorListScatter":{let r=I("indices",e,t,n),s=I("tensor",e,t,n),a=I("elementShape",e,t,n),o=I("numElements",e,t,n),i=V6(s,r,a,o);return n.addTensorList(i),[i.idTensor]}case"TensorListReserve":case"EmptyTensorList":{let r=I("elementShape",e,t,n),s=I("elementDType",e,t,n),a;e.op==="TensorListReserve"?a="numElements":a="maxNumElements";let o=I(a,e,t,n),i=W6(r,s,o);return n.addTensorList(i),[i.idTensor]}case"TensorListGather":{let r=I("tensorListId",e,t,n),s=I("indices",e,t,n),a=I("elementShape",e,t,n),o=I("elementDType",e,t,n);return[n.getTensorList(r.id).gather(s,o,a)]}case"TensorListStack":{let r=I("tensorListId",e,t,n),s=I("elementShape",e,t,n),a=I("elementDType",e,t,n),o=I("numElements",e,t,n);return[n.getTensorList(r.id).stack(s,a,o)]}case"TensorListFromTensor":{let r=I("tensor",e,t,n),s=I("elementShape",e,t,n),a=I("elementDType",e,t,n),o=z6(r,s,a);return n.addTensorList(o),[o.idTensor]}case"TensorListConcat":{let r=I("tensorListId",e,t,n),s=n.getTensorList(r.id),a=I("dtype",e,t,n),o=I("elementShape",e,t,n);return[s.concat(a,o)]}case"TensorListPushBack":{let r=I("tensorListId",e,t,n),s=I("tensor",e,t,n),a=n.getTensorList(r.id);return a.pushBack(s),[a.idTensor]}case"TensorListPopBack":{let r=I("tensorListId",e,t,n),s=I("elementShape",e,t,n),a=I("elementDType",e,t,n);return[n.getTensorList(r.id).popBack(s,a)]}case"TensorListSplit":{let r=I("tensor",e,t,n),s=I("elementShape",e,t,n),a=I("lengths",e,t,n),o=U6(r,a,s);return n.addTensorList(o),[o.idTensor]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};function $C(e,t,n){let[r,s]=I("fusedOps",e,t,n),a=r==="biasadd",o=!a,i=s==="prelu",u=r==="fusedbatchnorm",l=I("numArgs",e,t,n);if(a){if(i&&l!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!i&&a&&l!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(u)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");let c=I("strides",e,t,n),d=cm(e,t,n),p=I("dataFormat",e,t,n).toUpperCase(),h=I("dilations",e,t,n),[f,m]=I("args",e,t,n);o&&(m=f,f=void 0);let g=I("leakyreluAlpha",e,t,n);return{stride:c,pad:d,dataFormat:p,dilations:h,biasArg:f,preluArg:m,activationFunc:s,leakyreluAlpha:g}}var H6=(e,t,n)=>{switch(e.op){case"Conv1D":{let r=I("stride",e,t,n),s=I("pad",e,t,n),a=I("dataFormat",e,t,n).toUpperCase(),o=I("dilation",e,t,n);return[Gy(I("x",e,t,n),I("filter",e,t,n),r,s,a,o)]}case"Conv2D":{let r=I("strides",e,t,n),s=cm(e,t,n),a=I("dataFormat",e,t,n).toUpperCase(),o=I("dilations",e,t,n);return[Wt(I("x",e,t,n),I("filter",e,t,n),[r[1],r[2]],s,a,[o[1],o[2]])]}case"_FusedConv2D":{let{stride:r,pad:s,dataFormat:a,dilations:o,biasArg:i,preluArg:u,activationFunc:l,leakyreluAlpha:c}=$C(e,t,n);return[mo.conv2d({x:I("x",e,t,n),filter:I("filter",e,t,n),strides:[r[1],r[2]],pad:s,dataFormat:a,dilations:[o[1],o[2]],bias:i,activation:l,preluActivationWeights:u,leakyreluAlpha:c})]}case"FusedDepthwiseConv2dNative":{let{stride:r,pad:s,dataFormat:a,dilations:o,biasArg:i,preluArg:u,activationFunc:l,leakyreluAlpha:c}=$C(e,t,n);return[mo.depthwiseConv2d({x:I("x",e,t,n),filter:I("filter",e,t,n),strides:[r[1],r[2]],pad:s,dataFormat:a,dilations:[o[1],o[2]],bias:i,activation:l,preluActivationWeights:u,leakyreluAlpha:c})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{let r=I("outputShape",e,t,n),s=I("strides",e,t,n),a=cm(e,t,n);return[jy(I("x",e,t,n),I("filter",e,t,n),r,[s[1],s[2]],a)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{let r=I("strides",e,t,n),s=cm(e,t,n),a=I("dilations",e,t,n),o=I("dataFormat",e,t,n).toUpperCase();return[Bi(I("input",e,t,n),I("filter",e,t,n),[r[1],r[2]],s,o,[a[1],a[2]])]}case"Conv3D":{let r=I("strides",e,t,n),s=I("pad",e,t,n),a=I("dataFormat",e,t,n).toUpperCase(),o=I("dilations",e,t,n);return[qy(I("x",e,t,n),I("filter",e,t,n),[r[1],r[2],r[3]],s,a,[o[1],o[2],o[3]])]}case"AvgPool":{let r=I("strides",e,t,n),s=I("pad",e,t,n),a=I("kernelSize",e,t,n);return[Ar(I("x",e,t,n),[a[1],a[2]],[r[1],r[2]],s)]}case"MaxPool":{let r=I("strides",e,t,n),s=I("pad",e,t,n),a=I("kernelSize",e,t,n);return[Vt(I("x",e,t,n),[a[1],a[2]],[r[1],r[2]],s)]}case"MaxPoolWithArgmax":{let r=I("strides",e,t,n),s=I("pad",e,t,n),a=I("kernelSize",e,t,n),o=I("includeBatchInIndex",e,t,n),{result:i,indexes:u}=ES(I("x",e,t,n),[a[1],a[2]],[r[1],r[2]],s,o);return[i,u]}case"AvgPool3D":{let r=I("strides",e,t,n),s=I("pad",e,t,n),a=I("kernelSize",e,t,n);return[Vy(I("x",e,t,n),[a[1],a[2],a[3]],[r[1],r[2],r[3]],s)]}case"MaxPool3D":{let r=I("strides",e,t,n),s=I("pad",e,t,n),a=I("kernelSize",e,t,n);return[nv(I("x",e,t,n),[a[1],a[2],a[3]],[r[1],r[2],r[3]],s)]}case"Dilation2D":{let r=I("strides",e,t,n),s=I("pad",e,t,n),a=I("dilations",e,t,n),o=r[1],i=r[2],u=a[1],l=a[2];return[gS(I("x",e,t,n),I("filter",e,t,n),[o,i],s,[u,l],"NHWC")]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},j6=(e,t,n)=>{switch(e.op){case"Fill":{let r=I("shape",e,t,n),s=I("dtype",e,t,n),a=I("value",e,t,n);return[_n(r,a,s)]}case"LinSpace":{let r=I("start",e,t,n),s=I("stop",e,t,n),a=I("num",e,t,n);return[kS(r,s,a)]}case"Multinomial":{let r=I("logits",e,t,n),s=I("numSamples",e,t,n),a=I("seed",e,t,n);return[FS(r,s,a)]}case"OneHot":{let r=I("indices",e,t,n),s=I("depth",e,t,n),a=I("onValue",e,t,n),o=I("offValue",e,t,n);return[xd(r,s,a,o)]}case"Ones":return[rr(I("shape",e,t,n),I("dtype",e,t,n))];case"OnesLike":return[br(I("x",e,t,n))];case"RandomUniform":return[Tc(I("shape",e,t,n),I("minval",e,t,n),I("maxval",e,t,n),I("dtype",e,t,n))];case"Range":{let r=I("start",e,t,n),s=I("stop",e,t,n),a=I("step",e,t,n);return[Nc(r,s,a,I("dtype",e,t,n))]}case"TruncatedNormal":{let r=I("shape",e,t,n),s=I("mean",e,t,n),a=I("stdDev",e,t,n),o=I("seed",e,t,n);return[gf(r,s,a,I("dtype",e,t,n),o)]}case"Zeros":return[kt(I("shape",e,t,n),I("dtype",e,t,n))];case"ZerosLike":return[Xe(I("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};function Tw(e,t,n){let r=I("boxes",e,t,n),s=I("scores",e,t,n),a=I("maxOutputSize",e,t,n),o=I("iouThreshold",e,t,n),i=I("scoreThreshold",e,t,n),u=I("softNmsSigma",e,t,n);return{boxes:r,scores:s,maxOutputSize:a,iouThreshold:o,scoreThreshold:i,softNmsSigma:u}}var q6=async(e,t,n)=>{switch(e.op){case"NonMaxSuppressionV5":{let{boxes:r,scores:s,maxOutputSize:a,iouThreshold:o,scoreThreshold:i,softNmsSigma:u}=Tw(e,t,n),l=await ar.nonMaxSuppressionWithScoreAsync(r,s,a,o,i,u);return[l.selectedIndices,l.selectedScores]}case"NonMaxSuppressionV4":{let{boxes:r,scores:s,maxOutputSize:a,iouThreshold:o,scoreThreshold:i}=Tw(e,t,n),u=I("padToMaxOutputSize",e,t,n),l=await ar.nonMaxSuppressionPaddedAsync(r,s,a,o,i,u);return[l.selectedIndices,l.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{let{boxes:r,scores:s,maxOutputSize:a,iouThreshold:o,scoreThreshold:i}=Tw(e,t,n);return[await ar.nonMaxSuppressionAsync(r,s,a,o,i)]}case"Where":{let r=ue(I("condition",e,t,n),"bool"),s=[await gv(r)];return r.dispose(),s}case"ListDiff":return PS(I("x",e,t,n),I("y",e,t,n));default:throw TypeError(`Node type ${e.op} is not implemented`)}},K6=(e,t,n)=>{switch(e.op){case"TopKV2":{let r=I("x",e,t,n),s=I("k",e,t,n),a=I("sorted",e,t,n),o=BS(r,s,a);return[o.values,o.indices]}case"Unique":{let r=I("x",e,t,n),s=mv(r);return[s.values,s.indices]}case"UniqueV2":{let r=I("x",e,t,n),s=I("axis",e,t,n),a=mv(r,s);return[a.values,a.indices]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},X6=(e,t,n)=>{switch(e.op){case"Const":return t[e.name];case"PlaceholderWithDefault":let r=I("default",e,t,n);return[An(e.name,t,n)||r];case"Placeholder":return[An(e.name,t,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{let l=I("x",e,t,n);return[Ws(l)]}case"IdentityN":return I("x",e,t,n).map(l=>Ws(l));case"Snapshot":let s=I("x",e,t,n);return[Ws(s)];case"Shape":return[je(I("x",e,t,n).shape,"int32")];case"ShapeN":return I("x",e,t,n).map(l=>je(l.shape));case"Size":return[ke(I("x",e,t,n).size,"int32")];case"Rank":return[ke(I("x",e,t,n).rank,"int32")];case"NoOp":return[ke(1)];case"Print":let a=I("x",e,t,n),o=I("data",e,t,n),i=I("message",e,t,n),u=I("summarize",e,t,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(i);for(let l=0;l<o.length;l++)console.log(Array.prototype.slice.call(o[l].dataSync()).slice(0,u));return[a];default:throw TypeError(`Node type ${e.op} is not implemented`)}},Y6=class{constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=ke(0),this.tensorMap=new Map,nn(this.handle)}get id(){return this.handle.id}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return ke(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);let n=await e.data();return this.tensorMap.forEach(r=>r.dispose()),this.tensorMap.clear(),M(()=>{let r=vt(t),s=n.length,a=r.length;w.assert(s===a,()=>`The number of elements doesn't match, keys has ${s} elements, the values has ${a} elements.`);for(let o=0;o<s;o++){let i=n[o],u=r[o];nn(u),this.tensorMap.set(i,u)}return this.handle})}async find(e,t){this.checkKeyAndValueTensor(e,t);let n=await e.data();return M(()=>{let r=[];for(let s=0;s<n.length;s++){let a=n[s],o=this.findWithDefault(a,t);r.push(o)}return Ut(r)})}findWithDefault(e,t){let n=this.tensorMap.get(e);return n!=null?n:t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}},Q6=async(e,t,n,r)=>{switch(e.op){case"HashTable":case"HashTableV2":{let s=I("keyDType",e,t,n),a=I("valueDType",e,t,n),o=new Y6(s,a);return r.addHashTable(e.name,o),[o.handle]}case"LookupTableImport":case"LookupTableImportV2":{let s=I("tableHandle",e,t,n,r),a=I("keys",e,t,n),o=I("values",e,t,n);return[await r.getHashTableById(s.id).import(a,o)]}case"LookupTableFind":case"LookupTableFindV2":{let s=I("tableHandle",e,t,n,r),a=I("keys",e,t,n),o=I("defaultValue",e,t,n);return[await r.getHashTableById(s.id).find(a,o)]}case"LookupTableSize":case"LookupTableSizeV2":{let s=I("tableHandle",e,t,n,r);return[r.getHashTableById(s.id).tensorSize()]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},Z6=(e,t,n)=>{switch(e.op){case"ResizeBilinear":{let r=I("images",e,t,n),s=I("size",e,t,n),a=I("alignCorners",e,t,n),o=I("halfPixelCenters",e,t,n);return[ar.resizeBilinear(r,[s[0],s[1]],a,o)]}case"ResizeNearestNeighbor":{let r=I("images",e,t,n),s=I("size",e,t,n),a=I("alignCorners",e,t,n),o=I("halfPixelCenters",e,t,n);return[ar.resizeNearestNeighbor(r,[s[0],s[1]],a,o)]}case"CropAndResize":{let r=I("image",e,t,n),s=I("boxes",e,t,n),a=I("boxInd",e,t,n),o=I("cropSize",e,t,n),i=I("method",e,t,n),u=I("extrapolationValue",e,t,n);return[ar.cropAndResize(r,s,a,o,i,u)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},J6=(e,t,n)=>{switch(e.op){case"Equal":return[mr(I("a",e,t,n),I("b",e,t,n))];case"NotEqual":return[Cc(I("a",e,t,n),I("b",e,t,n))];case"Greater":return[nr(I("a",e,t,n),I("b",e,t,n))];case"GreaterEqual":return[zi(I("a",e,t,n),I("b",e,t,n))];case"Less":return[Qy(I("a",e,t,n),I("b",e,t,n))];case"LessEqual":return[Wi(I("a",e,t,n),I("b",e,t,n))];case"LogicalAnd":return[Hr(I("a",e,t,n),I("b",e,t,n))];case"LogicalNot":return[uf(I("a",e,t,n))];case"LogicalOr":return[tv(I("a",e,t,n),I("b",e,t,n))];case"Select":case"SelectV2":return[Cn(I("condition",e,t,n),I("a",e,t,n),I("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},e5=(e,t,n)=>{switch(e.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[Re(I("a",e,t,n),I("b",e,t,n),I("transposeA",e,t,n),I("transposeB",e,t,n))];case"Einsum":return[yS(I("equation",e,t,n),...I("tensors",e,t,n))];case"Transpose":return[Oe(I("x",e,t,n),I("perm",e,t,n))];case"_FusedMatMul":let[r,s]=I("fusedOps",e,t,n),a=r==="biasadd",o=s==="prelu",i=I("numArgs",e,t,n),u=I("leakyreluAlpha",e,t,n);if(a){if(o&&i!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&i!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}let[l,c]=I("args",e,t,n);return[mo.matMul({a:I("a",e,t,n),b:I("b",e,t,n),transposeA:I("transposeA",e,t,n),transposeB:I("transposeB",e,t,n),bias:l,activation:s,preluActivationWeights:c,leakyreluAlpha:u})];default:throw TypeError(`Node type ${e.op} is not implemented`)}},t5=(e,t,n)=>{switch(e.op){case"FusedBatchNorm":case"FusedBatchNormV2":return[ho(I("x",e,t,n),I("mean",e,t,n),I("variance",e,t,n),I("offset",e,t,n),I("scale",e,t,n),I("epsilon",e,t,n))];case"FusedBatchNormV3":return[ho(I("x",e,t,n),I("mean",e,t,n),I("variance",e,t,n),I("offset",e,t,n),I("scale",e,t,n),I("epsilon",e,t,n))];case"LRN":return[IS(I("x",e,t,n),I("radius",e,t,n),I("bias",e,t,n),I("alpha",e,t,n),I("beta",e,t,n))];case"Softmax":return[ls(I("x",e,t,n))];case"LogSoftmax":return[Zy(I("x",e,t,n))];case"SparseToDense":return[yv(I("sparseIndices",e,t,n),I("outputShape",e,t,n),I("sparseValues",e,t,n),I("defaultValue",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},n5=(e,t,n)=>{switch(e.op){case"Max":{let o=I("axis",e,t,n),i=I("keepDims",e,t,n);return[Gr(I("x",e,t,n),o,i)]}case"Mean":{let o=I("axis",e,t,n),i=I("keepDims",e,t,n);return[Ot(I("x",e,t,n),o,i)]}case"Min":{let o=I("axis",e,t,n),i=I("keepDims",e,t,n);return[cf(I("x",e,t,n),o,i)]}case"Sum":{let o=I("axis",e,t,n),i=I("keepDims",e,t,n);return[ve(I("x",e,t,n),o,i)]}case"All":{let o=I("axis",e,t,n),i=I("keepDims",e,t,n);return[By(I("x",e,t,n),o,i)]}case"Any":{let o=I("axis",e,t,n),i=I("keepDims",e,t,n);return[Jh(I("x",e,t,n),o,i)]}case"ArgMax":{let o=I("axis",e,t,n);return[xc(I("x",e,t,n),o)]}case"ArgMin":{let o=I("axis",e,t,n);return[K1(I("x",e,t,n),o)]}case"Prod":{let o=I("axis",e,t,n),i=I("keepDims",e,t,n);return[rv(I("x",e,t,n),o,i)]}case"Cumsum":{let o=I("axis",e,t,n),i=I("exclusive",e,t,n),u=I("reverse",e,t,n);return[Xy(I("x",e,t,n),o,i,u)]}case"Bincount":let r=I("x",e,t,n),s=I("weights",e,t,n),a=I("size",e,t,n);return[Uy(r,s,a)];case"DenseBincount":{let o=I("x",e,t,n),i=I("weights",e,t,n),u=I("size",e,t,n),l=I("binaryOutput",e,t,n);return[fS(o,i,u,l)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},r5=(e,t,n)=>{switch(e.op){case"ConcatV2":case"Concat":{let r=I("n",e,t,n),s=I("axis",e,t,n),a=I("tensors",e,t,n);return a=a.slice(0,r),[ot(a,s)]}case"Gather":{let r=I("x",e,t,n),s=I("indices",e,t,n);return[Ic(r,ue(s,"int32"),0)]}case"GatherV2":{let r=I("axis",e,t,n),s=I("batchDims",e,t,n),a=I("x",e,t,n),o=I("indices",e,t,n);return[Ic(a,ue(o,"int32"),r,s)]}case"Reverse":{let r=I("dims",e,t,n),s=[];for(let o=0;o<r.length;o++)r[o]&&s.push(o);let a=I("x",e,t,n);return[yr(a,s)]}case"ReverseV2":{let r=I("axis",e,t,n),s=I("x",e,t,n);return[yr(s,r)]}case"Slice":{let r=I("begin",e,t,n),s=I("size",e,t,n);return[Ve(I("x",e,t,n),r,s)]}case"StridedSlice":{let r=I("begin",e,t,n),s=I("end",e,t,n),a=I("strides",e,t,n),o=I("beginMask",e,t,n),i=I("endMask",e,t,n),u=I("ellipsisMask",e,t,n),l=I("newAxisMask",e,t,n),c=I("shrinkAxisMask",e,t,n),d=I("x",e,t,n);return[MS(d,r,s,a,o,i,u,l,c)]}case"Pack":return M(()=>{let r=I("axis",e,t,n),s=I("tensors",e,t,n),a=s[0].shape,o=Rs(s[0]).shape,i=s.map(u=>{let l=w.arraysEqual(u.shape,a);if(!l&&!w.arraysEqual(Rs(u).shape,o))throw new Error("the input tensors shape does not match");return l?u:G(u,a)});return[Ut(i,r)]});case"Unpack":{let r=I("axis",e,t,n),s=I("tensor",e,t,n);return vt(s,r)}case"Tile":{let r=I("reps",e,t,n);return[tr(I("x",e,t,n),r)]}case"Split":case"SplitV":{let r=I("axis",e,t,n),s=I("numOrSizeSplits",e,t,n),a=I("x",e,t,n);return sr(a,s,r)}case"ScatterNd":{let r=I("indices",e,t,n),s=I("values",e,t,n),a=I("shape",e,t,n);return[GS(r,s,a)]}case"GatherNd":{let r=I("x",e,t,n),s=I("indices",e,t,n);return[HS(r,s)]}case"SparseToDense":{let r=I("sparseIndices",e,t,n),s=I("outputShape",e,t,n),a=I("sparseValues",e,t,n),o=I("defaultValue",e,t,n);return[yv(r,a,s,a.dtype===o.dtype?o:ue(o,a.dtype))]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},s5=(e,t,n)=>{switch(e.op){case"SparseFillEmptyRows":{let{outputIndices:r,outputValues:s,emptyRowIndicator:a,reverseIndexMap:o}=$d.sparseFillEmptyRows(I("indices",e,t,n),I("values",e,t,n),I("denseShape",e,t,n),I("defaultValue",e,t,n));return[r,s,a,o]}case"SparseReshape":{let{outputIndices:r,outputShape:s}=$d.sparseReshape(I("inputIndices",e,t,n),I("inputShape",e,t,n),I("newShape",e,t,n));return[r,s]}case"SparseSegmentMean":return[$d.sparseSegmentMean(I("data",e,t,n),I("indices",e,t,n),I("segmentIds",e,t,n))];case"SparseSegmentSum":return[$d.sparseSegmentSum(I("data",e,t,n),I("indices",e,t,n),I("segmentIds",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},a5=(e,t,n)=>{switch(e.op){case"FFT":return[ff(I("x",e,t,n))];case"IFFT":return[Ed(I("x",e,t,n))];case"RFFT":return[mf(I("x",e,t,n))];case"IRFFT":return[hv(I("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},o5=(e,t,n)=>{switch(e.op){case"StringNGrams":{let{nGrams:r,nGramsSplits:s}=wf.stringNGrams(I("data",e,t,n),I("dataSplits",e,t,n),I("separator",e,t,n),I("nGramWidths",e,t,n),I("leftPad",e,t,n),I("rightPad",e,t,n),I("padWidth",e,t,n),I("preserveShortSequences",e,t,n));return[r,s]}case"StringSplit":{let{indices:r,values:s,shape:a}=wf.stringSplit(I("input",e,t,n),I("delimiter",e,t,n),I("skipEmpty",e,t,n));return[r,s,a]}case"StringToHashBucketFast":return[wf.stringToHashBucketFast(I("input",e,t,n),I("numBuckets",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},i5=(e,t,n)=>{switch(e.op){case"Cast":return[ue(I("x",e,t,n),I("dtype",e,t,n))];case"ExpandDims":{let r=I("axis",e,t,n);return[Nn(I("x",e,t,n),r)]}case"Squeeze":{let r=I("axis",e,t,n);return[Rs(I("x",e,t,n),r)]}case"Reshape":return[G(I("x",e,t,n),I("shape",e,t,n))];case"MirrorPad":return[AS(I("x",e,t,n),I("padding",e,t,n),I("mode",e,t,n))];case"PadV2":case"Pad":return[Fr(I("x",e,t,n),I("padding",e,t,n),I("constantValue",e,t,n))];case"SpaceToBatchND":{let r=I("blockShape",e,t,n),s=I("paddings",e,t,n);return[df(I("x",e,t,n),r,s)]}case"BatchToSpaceND":{let r=I("blockShape",e,t,n),s=I("crops",e,t,n);return[tf(I("x",e,t,n),r,s)]}case"DepthToSpace":{let r=I("blockSize",e,t,n),s=I("dataFormat",e,t,n).toUpperCase();return[mS(I("x",e,t,n),r,s)]}case"BroadcastTo":return[Id(I("x",e,t,n),I("shape",e,t,n))];case"BroadcastArgs":return[oS(I("s0",e,t,n),I("s1",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};function FC(e,t,n,r){let s=((a,o,i)=>{switch(a.category){case"arithmetic":return M(()=>M6(a,o,i));case"basic_math":return M(()=>L6(a,o,i));case"control":return G6(a,o,i);case"convolution":return M(()=>H6(a,o,i));case"creation":return M(()=>j6(a,o,i));case"dynamic":return q6(a,o,i);case"evaluation":return M(()=>K6(a,o,i));case"image":return M(()=>Z6(a,o,i));case"graph":return M(()=>X6(a,o,i));case"logical":return M(()=>J6(a,o,i));case"matrices":return M(()=>e5(a,o,i));case"normalization":return M(()=>t5(a,o,i));case"reduction":return M(()=>n5(a,o,i));case"slice_join":return M(()=>r5(a,o,i));case"sparse":return M(()=>s5(a,o,i));case"spectral":return M(()=>a5(a,o,i));case"string":return M(()=>o5(a,o,i));case"transformation":return M(()=>i5(a,o,i));case"hash_table":return Q6(a,o,i,r);case"custom":let u=oC(a.op);if(u&&u.customExecutor)return u.customExecutor(new O6(a,o,i));throw TypeError(`Custom op ${a.op} is not registered.`);default:throw TypeError(`Unknown op '${a.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(e,t,n);return w.isPromise(s)?s.then(a=>[].concat(a)):[].concat(s)}var DC=class{constructor(e={},t={},n={},r={}){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=n,this.functionMap=r,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){let e=[];for(let t=0;t<this.contexts.length-1;t++){let n=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(n))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(t=>t.id===0&&t.iterationId===0?"":`${t.frameName}-${t.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;let e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(let t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(let t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}};function RC(e,t,n,r){let s=new Set,a=[],o=null,i=null,u=new Set,l=Object.keys(e).map(p=>or(p)[0]),c=[];r!=null&&(c=r.map(p=>or(p.name)[0]));let d=[...t];for(;d.length>0;){let p=d.pop();if((PC(p)||p5(p)||h5(p))&&o==null&&(o=p,i=o.children.map(h=>h.name).filter(h=>s.has(h))),s.add(p.name),n[p.name]==null&&l.indexOf(p.name)===-1&&c.indexOf(p.name)===-1){if(p.inputs.length===0){a.push(p.name);continue}p.inputs.forEach(h=>{u.has(h.name)||(u.add(h.name),d.push(h))})}}return{inputs:e,outputs:t,usedNodes:s,missingInputs:a,dynamicNode:o,syncInputs:i}}function u5(e,t,n){let{usedNodes:r,inputs:s}=n,a=[],o=Object.keys(s).map(c=>or(c)[0]).map(c=>e.nodes[c]),i=e.initNodes;o.forEach(c=>{r.has(c.name)&&a.push(c)}),e.weights.forEach(c=>{r.has(c.name)&&a.push(c)}),i!=null&&i.forEach(c=>{r.has(c.name)&&a.push(c)});let u=new Set,l=[];for(;a.length>0;){let c=a.pop();u.add(c.name),t[c.name]||l.push(c),c.children.forEach(d=>{!u.has(d.name)&&r.has(d.name)&&d.inputs.every(p=>u.has(p.name))&&a.push(d)})}return l}var c5=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"],l5=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"],d5=["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"];function PC(e){return c5.indexOf(e.op)>=0}function p5(e){return l5.indexOf(e.op)>=0}function h5(e){return d5.indexOf(e.op)>=0}var Nw=class{constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this._weightMap={},this.SEPERATOR=",",this._functions={},this._functionExecutorMap={},this.intermediateTensors={},this.keepTensorForDebug=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,e.functions!=null&&Object.keys(e.functions).forEach(n=>{this._functionExecutorMap[n]=new Nw(e.functions[n],this)})}get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){let t=Object.keys(e).map(n=>e[n].map(r=>r.id));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{let t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t})}get functions(){return Object.keys(this._functions).reduce((e,t)=>(e[t]=this._functions[t].signature,e),{})}getCompilationKey(e,t){let n=e.map(s=>s.name).sort(),r=t.map(s=>s.name).sort();return n.join(this.SEPERATOR)+"--"+r.join(this.SEPERATOR)}compile(e,t){let n=RC(e,t,this.weightMap,this._initNodes),{missingInputs:r,dynamicNode:s,syncInputs:a}=n;if(s!=null)throw new Error(`This execution contains the node '${s.name}', which has the dynamic op '${s.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${a}]`);if(r.length>0){let o=t.map(u=>u.name),i=Object.keys(e);throw new Error(`Cannot compute the outputs [${o}] from the provided inputs [${i}]. Missing the following inputs: [${r}]`)}return u5(this.graph,this.weightMap,n)}execute(e,t){e=this.mapInputs(e);let n=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);let r=n.map(c=>this.graph.nodes[or(c)[0]]),s=t.map(c=>or(c)[0]),a=s.map(c=>this.graph.nodes[c]);this.resetIntermediateTensors(),a.length===0&&(a=this._outputs);let o=this.getCompilationKey(r,a),i=this.compiledMap.get(o);i==null&&(i=this.compile(e,a),this.compiledMap.set(o,i));let u={},l={};return M(()=>{let c=new DC(this.weightMap,u,l,this.functionExecutorMap),d={...this.weightMap};Object.keys(e).forEach(f=>{let[m,g]=or(f),b=[];b[g]=e[f],d[m]=b});let p=this.getFrozenTensorIds(d),h={};for(let f=0;f<i.length;f++){let m=i[f];if(!d[m.name]){let g=FC(m,d,c,this._resourceManager);if(w.isPromise(g))throw new Error(`The execution of the op '${m.op}' returned a promise. Please use model.executeAsync() instead.`);d[m.name]=g,this.checkTensorForDisposal(m.name,m,d,c,p,s,h)}}return this.parent==null&&c.dispose(p),t.map(f=>An(f,d,c))})}getFrozenTensorIds(e){let t=[].concat.apply([],Object.keys(e).map(n=>e[n]).map(n=>n.map(r=>r.id)));return new Set(t)}checkTensorForDisposal(e,t,n,r,s,a,o){t.category==="control"||a.indexOf(e)!==-1||(n[e].forEach(i=>{i!=null&&(o[i.id]=(o[i.id]||0)+t.children.length)}),t.inputs.forEach(i=>{if(i.category!=="control"){let u=m6(i.name,n,r);u!=null&&u.forEach(l=>{if(l&&!l.kept&&!s.has(l.id)){let c=o[l.id];if(c===1){if(!this.keepTensorForDebug)l.dispose();else{let[d,p]=gs(t.name,r);this.intermediateTensors[d]?this.intermediateTensors[d][p]=l:(this.intermediateTensors[d]=[],this.intermediateTensors[d][p]=l)}delete o[l.id]}else c!=null&&o[l.id]--}})}}))}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){!this.intermediateTensors||(Object.keys(this.intermediateTensors).forEach(e=>this.intermediateTensors[e].forEach(t=>t.dispose())),this.disposeTensorsMap())}disposeTensorsMap(){!this.tensorsMap||Object.keys(this.tensorsMap).forEach(e=>{this.tensorsMap[e].forEach(n=>{n&&!n.kept&&!n.isDisposed&&!this.keepIds.has(n.id)&&n.dispose()})})}getIntermediateTensors(){return this.tensorsMap}resetIntermediateTensors(){for(let e in this.intermediateTensors)this.intermediateTensors[e].forEach(t=>t.dispose()),delete this.intermediateTensors[e]}async _executeAsync(e,t,n=!1,r={},s={}){n||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepTensorForDebug=X().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(l){console.warn(l.message)}this.resetIntermediateTensors();let a=new DC(this.weightMap,r,s,this.functionExecutorMap);this.tensorsMap=await this.executeWithControlFlow(e,a,t,n);let o=t.map(l=>An(l,this.tensorsMap,a)),i=o.map(l=>l.id),u=Object.keys(e).map(l=>e[l].id);return this.keepIds=new Set([...i,...u,...this.weightIds]),this.keepTensorForDebug||this.disposeTensorsMap(),this.parent==null&&a.dispose(this.keepIds),o}async executeFunctionAsync(e,t,n){let r=e.reduce((s,a,o)=>(s[this.inputs[o].name]=a,s),{});return this._executeAsync(r,this.outputNodes,!0,t,n)}async executeWithControlFlow(e,t,n,r){let s=Object.keys(e),a=s.map(y=>this.graph.nodes[or(y)[0]]),o=n.map(y=>or(y)[0]),i=o.map(y=>this.graph.nodes[y]);i.length===0&&(i=this._outputs);let{usedNodes:u,missingInputs:l,dynamicNode:c,syncInputs:d}=RC(e,i,this.weightMap,this._initNodes),p=[...a,...this.graph.weights,...this._initNodes||[]].map(y=>({node:y,contexts:t.currentContext})),h={...this.weightMap};Object.keys(e).forEach(y=>{let[v,x]=or(y),k=[];k[x]=e[y],h[v]=k});let f={},m=this.getFrozenTensorIds(h),g={};for(;p.length>0;){let y=this.processStack(a,p,t,h,g,m,o,f,u);await Promise.all(y)}c==null&&!r&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");let b=i.filter(y=>!PC(y)&&!An(y.name,h,t)).map(y=>y.name);if(b.length>0){let y="";throw c!=null&&(y=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${d}]`),new Error(`Cannot compute the outputs [${b}] from the provided inputs [${s}]. Consider providing the following inputs: [${l}]. ${y}`)}return h}processStack(e,t,n,r,s,a,o,i,u){let l=[];for(;t.length>0;){let c=t.pop();n.currentContext=c.contexts;let d="";if(c.node.op==="Enter"&&I("isConstant",c.node,r,n)&&([d]=gs(c.node.name,n)),r[c.node.name]==null){let p=FC(c.node,r,n,this._resourceManager);d||([d]=gs(c.node.name,n));let h=n.currentContext;w.isPromise(p)?l.push(p.then(f=>(r[d]=f,n.currentContext=h,this.checkTensorForDisposal(d,c.node,r,n,a,o,i),this.processChildNodes(c.node,t,n,r,s,u),f))):(r[d]=p,this.checkTensorForDisposal(d,c.node,r,n,a,o,i),this.processChildNodes(c.node,t,n,r,s,u))}else this.processChildNodes(c.node,t,n,r,s,u)}return l}processChildNodes(e,t,n,r,s,a){e.children.forEach(o=>{let[i]=gs(o.name,n);s[i]||!a.has(o.name)||(o.op==="Merge"?o.inputNames.some(u=>!!An(u,r,n))&&(s[i]=!0,t.push({contexts:n.currentContext,node:o})):o.inputNames.every(u=>!!An(u,r,n))&&(s[i]=!0,t.push({contexts:n.currentContext,node:o})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(t=>t.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(t=>{let n=e[t],[r]=or(t),s=this.graph.nodes[r];if(s.attrParams.shape&&s.attrParams.shape.value){let a=s.attrParams.shape.value,o=a.length===n.shape.length&&n.shape.every((i,u)=>a[u]===-1||a[u]===i);w.assert(o,()=>`The shape of dict['${s.name}'] provided in model.execute(dict) must be [${a}], but was [${n.shape}]`)}s.attrParams.dtype&&s.attrParams.dtype.value&&w.assert(n.dtype===s.attrParams.dtype.value,()=>`The dtype of dict['${s.name}'] provided in model.execute(dict) must be ${s.attrParams.dtype.value}, but was ${n.dtype}`)})}mapInputs(e){let t={};for(let n in e)if(this._signature!=null&&this._signature.inputs!=null&&this._signature.inputs[n]!=null){let r=this._signature.inputs[n];t[r.name]=e[n]}else t[n]=e[n];return t}checkInputs(e){let t=Object.keys(e).filter(n=>{let[r]=or(n);return this.graph.nodes[r]==null});if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map(t=>this._signature!=null&&this._signature.outputs!=null&&this._signature.outputs[t]!=null?this._signature.outputs[t].name:t,{})}checkOutputs(e){e.forEach(t=>{let[n]=or(t);if(!this.graph.nodes[n])throw new Error(`The output '${t}' is not found in the graph`)})}},f5=class{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(let e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(let e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}},m5="?tfjs-format=file",g5="model.json",OC=class{constructor(e,t={}){this.modelUrl=e,this.loadOptions=t,this.version="n/a",t==null&&(this.loadOptions={}),this.resourceManager=new f5}get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}findIOHandler(){let e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=tn.browserHTTPRequest(e,this.loadOptions);else{let t=tn.getLoadHandlers(e,this.loadOptions);if(t.length===0)t.push(tn.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}async load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let e=await this.handler.load();return this.loadSync(e)}loadSync(e){this.artifacts=e;let t=this.artifacts.modelTopology,n;this.artifacts.userDefinedMetadata!=null&&this.artifacts.userDefinedMetadata.signature!=null?n=this.artifacts.userDefinedMetadata.signature:n=this.artifacts.signature,this.signature=n,this.version=`${t.versions.producer}.${t.versions.minConsumer}`;let r=tn.decodeWeights(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new Nw(TC.Instance.transformGraph(t,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(r),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){let s=TC.Instance.transformGraph(e.modelInitializer);this.initializer=new Nw(s),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializer.executeAsync({},[])}return!0}async save(e,t){if(typeof e=="string"){let n=tn.getSaveHandlers(e);if(n.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(n.length>1)throw new Error(`Found more than one (${n.length}) save handlers for URL '${e}'`);e=n[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}predict(e,t){return this.execute(e,this.outputNodes)}normalizeInputs(e){if(!(e instanceof Ae)&&!Array.isArray(e))return e;if(e=Array.isArray(e)?e:[e],e.length!==this.inputNodes.length)throw new Error(`Input tensor count mismatch,the graph model has ${this.inputNodes.length} placeholders, while there are ${e.length} input tensors.`);return this.inputNodes.reduce((t,n,r)=>(t[n]=e[r],t),{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}execute(e,t){e=this.normalizeInputs(e),t=this.normalizeOutputs(t);let n=this.executor.execute(e,t);return n.length>1?n:n[0]}async executeAsync(e,t){e=this.normalizeInputs(e),t=this.normalizeOutputs(t);let n=await this.executor.executeAsync(e,t);return n.length>1?n:n[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,n)=>(t[n]=[e[n]],t),{})}dispose(){this.executor.dispose(),this.initializer&&this.initializer.dispose(),this.resourceManager.dispose()}};async function b5(e,t={}){if(e==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");t==null&&(t={}),t.fromTFHub&&e.load==null&&(e.endsWith("/")||(e=e+"/"),e=`${e}${g5}${m5}`);let n=new OC(e,t);return await n.load(),n}var y5="0.0.0",MC={};Ee(MC,{CSVDataset:()=>QC,Dataset:()=>Lc,FileDataSource:()=>sT,TextLineDataset:()=>KC,URLDataSource:()=>aT,array:()=>W5,csv:()=>Z5,func:()=>J5,generator:()=>ej,microphone:()=>nj,version_data:()=>rj,webcam:()=>tj,zip:()=>V5});var v5=Bo(ch()),x5=Bo(ch());function w5(e,t){return lm(e,t)}function lm(e,t,n=new Map,r=new Set){if(e==null)return null;if(typeof Blob=="function"&&e instanceof Blob)return e.slice();if(r.has(e))throw new Error("Circular references are not supported.");if(n.has(e))return n.get(e);let s=t(e);if(s.recurse&&s.value!==null)throw new Error("A deep map function may not return both a value and recurse=true.");if(s.recurse)if(Mc(e)){let a=Array.isArray(e)?[]:{};r.add(e);for(let o in e){let i=e[o],u=lm(i,t,n,r);a[o]=u}return r.delete(e),e.__proto__&&(a.__proto__=e.__proto__),a}else throw new Error(`Can't recurse into non-iterable type: ${e}`);else return n.set(e,s.value),s.value}function k5(e,t=BC){return LC(e,t)}function LC(e,t,n=new Set){let r=e[0];if(n.has(r))throw new Error("Circular references are not supported.");let s=t(e);if(s.recurse&&s.value!==null)throw new Error("A deep zip function may not return both a value and recurse=true.");if(s.recurse)if(Mc(r)){let a=Array.isArray(r)?[]:{};n.add(r);for(let o in r){let i=e.map(l=>l[o]),u=LC(i,t,n);a[o]=u}return n.delete(r),a}else throw new Error(`Can't recurse into non-iterable type: ${r}`);else return s.value}function BC(e){return e===null?null:Mc(e[0])?{value:null,recurse:!0}:{value:e,recurse:!1}}async function zC(e,t){let n=new Map;lm(e,t,n);for(let s of Array.from(n.keys())){let a=n.get(s);if(w.isPromise(a)){let o=await a;n.set(s,o)}}return lm(e,t,n)}function Mc(e){let t=!1;if(X().get("IS_BROWSER"))t=e instanceof TextDecoder;else{let{StringDecoder:n}=$I();t=e instanceof n}return e!=null&&!ArrayBuffer.isView(e)&&(Array.isArray(e)||typeof e=="object"&&!(e instanceof Ae)&&!(e instanceof Promise)&&!t)}function I5(e){return e==null||S5(e)||Array.isArray(e)||typeof e=="object"&&e instanceof Ae||w.isTypedArray(e)}function S5(e){return e===null||typeof e!="object"&&typeof e!="function"}function C5(e){return w5(e,T5)}function T5(e){return e instanceof Ae?{value:e.clone(),recurse:!1}:Mc(e)?{value:null,recurse:!0}:{value:e,recurse:!1}}var WC=class{constructor(e){if(this.capacity=e,this.begin=0,this.end=0,e==null)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(e<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(e),this.doubledCapacity=2*e}wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw new RangeError("Can't get item at a negative index.");return this.data[e%this.capacity]}set(e,t){if(e<0)throw new RangeError("Can't set item at a negative index.");this.data[e%this.capacity]=t}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return this.length()===0}push(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(let t of e)this.push(t)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);let e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let t=this.wrap(this.begin+e),n=this.get(t);return this.set(t,this.pop()),n}},VC=class extends WC{constructor(){super(VC.INITIAL_CAPACITY)}isFull(){return!1}push(e){super.isFull()&&this.expand(),super.push(e)}unshift(e){super.isFull()&&this.expand(),super.unshift(e)}expand(){let e=this.capacity*2,t=new Array(e),n=this.length();for(let r=0;r<n;r++)t[r]=this.get(this.wrap(this.begin+r));this.data=t,this.capacity=e,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=n}},UC=VC;UC.INITIAL_CAPACITY=32;function GC(e){return new E5(e)}function _w(e){return new A5(e)}function N5(e,t){return new jC(e,t)}function _5(e,t=dm.FAIL){return new B5(e,t)}var sn=class{async toArray(){let e=[],t=await this.next();for(;!t.done;)e.push(t.value),t=await this.next();return e}async toArrayForTest(){let e=this.prefetch(100),t=[],n=await e.next();for(;!n.done;)t.push(n.value),n=await e.next();return t}async resolveFully(){let e=await this.next();for(;!e.done;)e=await this.next()}async resolveWhile(e){let t=await this.next(),n=e(t.value);for(;!t.done&&n;)t=await this.next(),n=e(t.value)}handleErrors(e){return new M5(this,e)}filter(e){return new P5(this,e)}map(e){return new O5(this,e)}mapAsync(e){return new HC(this,e)}serialMapAsync(e){return new HC(this,e).serial()}flatmap(e){return new L5(this,e)}async forEachAsync(e){return this.map(e).resolveFully()}async serialForEach(e){return this.serialMapAsync(e).resolveWhile(t=>t===!0)}rowMajorBatch(e,t=!0){return new R5(this,e,t)}columnMajorBatch(e,t=!0,n=BC){return this.rowMajorBatch(e,t).map(s=>k5(s,n))}concatenate(e,t){return new jC(GC([this,e]),t)}take(e){return e<0||e==null?this:new D5(this,e)}skip(e){return e<0||e==null?this:new F5(this,e)}prefetch(e){return new qC(this,e)}shuffle(e,t){return new z5(this,e,t)}serial(){return new $5(this)}},E5=class extends sn{constructor(e){super();this.items=e,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};let e=this.items[this.trav];return this.trav++,{value:C5(e),done:!1}}},A5=class extends sn{constructor(e){super();this.nextFn=e}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(e){throw e.message=`Error thrown while iterating through a dataset: ${e.message}`,e}}},$5=class extends sn{constructor(e){super();this.upstream=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){return this.upstream.next()}},F5=class extends sn{constructor(e,t){super();this.upstream=e,this.maxCount=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){let e=await this.upstream.next();if(e.done)return e;Fe(e.value)}return this.upstream.next()}},D5=class extends sn{constructor(e,t){super();this.upstream=e,this.maxCount=t,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}},R5=class extends sn{constructor(e,t,n=!0){super();this.upstream=e,this.batchSize=t,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){let e=[];for(;e.length<this.batchSize;){let t=await this.upstream.next();if(t.done)return this.enableSmallLastBatch&&e.length>0?{value:e,done:!1}:{value:null,done:!0};e.push(t.value)}return{value:e,done:!1}}},P5=class extends sn{constructor(e,t){super();this.upstream=e,this.predicate=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;){let e=await this.upstream.next();if(e.done||this.predicate(e.value))return e;Fe(e.value)}}},O5=class extends sn{constructor(e,t){super();this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Map`}async next(){let e=await this.upstream.next();if(e.done)return{value:null,done:!0};let t=Vr.getTensorsInContainer(e.value),n=this.transform(e.value),r=Vr.getTensorsInContainer(n);for(let s of t)Vr.isTensorInList(s,r)||s.dispose();return{value:n,done:!1}}},M5=class extends sn{constructor(e,t){super();this.upstream=e,this.handler=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(e){if(!this.handler(e))return{value:null,done:!0}}}},HC=class extends sn{constructor(e,t){super();this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){let e=await this.upstream.next();if(e.done)return{value:null,done:!0};let t=Vr.getTensorsInContainer(e.value),n=await this.transform(e.value),r=Vr.getTensorsInContainer(n);for(let s of t)Vr.isTensorInList(s,r)||s.dispose();return{value:n,done:!1}}},Ew=class extends sn{constructor(){super();this.outputQueue=new UC,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.outputQueue.length()===0;)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}},L5=class extends Ew{constructor(e,t){super();this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){let e=await this.upstream.next();if(e.done)return!1;let t=Vr.getTensorsInContainer(e.value),n=this.transform(e.value),r=Vr.getTensorsInContainer(n);this.outputQueue.pushAll(n);for(let s of t)Vr.isTensorInList(s,r)||s.dispose();return!0}},jC=class extends sn{constructor(e,t){super();this.baseErrorHandler=t,this.lastRead=null,this.iterator=null,this.moreIterators=e}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(e){if(await e,this.iterator==null){let n=await this.moreIterators.next();if(n.done)return{value:null,done:!0};this.iterator=n.value,this.baseErrorHandler!=null&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}let t=await this.iterator.next();return t.done?(this.iterator=null,this.readFromChain(e)):t}},dm;(function(e){e[e.FAIL=0]="FAIL",e[e.SHORTEST=1]="SHORTEST",e[e.LONGEST=2]="LONGEST"})(dm||(dm={}));var B5=class extends sn{constructor(e,t=0){super();this.iterators=e,this.mismatchMode=t,this.count=0,this.currentPromise=null}summary(){return"{TODO: fill in upstream of zip summaries} -> Zip"}async nextState(e){await e;let t=0,n=0;function r(a){return a instanceof sn?{value:a.next().then(i=>(t++,i.done&&n++,i.value)),recurse:!1}:{value:null,recurse:!0}}let s=await zC(this.iterators,r);if(t===n)return{value:null,done:!0};if(n>0)switch(this.mismatchMode){case 0:throw new Error(`Zipped streams should have the same length. Mismatched at element ${this.count}.`);case 1:return{value:null,done:!0};case 2:default:}return this.count++,{value:s,done:!1}}async next(){return this.currentPromise=this.nextState(this.currentPromise),this.currentPromise}},qC=class extends sn{constructor(e,t){super();this.upstream=e,this.bufferSize=t,this.buffer=new WC(t)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){let e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}},z5=class extends qC{constructor(e,t,n){super(e,t);this.upstream=e,this.windowSize=t,this.upstreamExhausted=!1,this.random=x5.alea(n||w.now().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){let e=this.chooseIndex(),t=await this.buffer.shuffleExcise(e);if(t.done)this.upstreamExhausted=!0;else return this.refill(),t}return{value:null,done:!0}}},Lc=class{constructor(){this.size=null}batch(e,t=!0){let n=this;w.assert(e>0,()=>`batchSize needs to be positive, but it is
      ${e}`);let r;return this.size===1/0||this.size==null?r=this.size:t?r=Math.ceil(this.size/e):r=Math.floor(this.size/e),ir(async()=>(await n.iterator()).columnMajorBatch(e,t,U5),r)}concatenate(e){let t=this,n;return this.size===1/0||e.size===1/0?n=1/0:this.size!=null&&e.size!=null?n=this.size+e.size:n=null,ir(async()=>(await t.iterator()).concatenate(await e.iterator()),n)}filter(e){let t=this,n;return this.size===1/0?n=1/0:n=null,ir(async()=>(await t.iterator()).filter(r=>M(()=>e(r))),n)}async forEachAsync(e){return(await this.iterator()).forEachAsync(e)}map(e){let t=this;return ir(async()=>(await t.iterator()).map(n=>M(()=>e(n))),this.size)}mapAsync(e){let t=this;return ir(async()=>(await t.iterator()).mapAsync(e),this.size)}prefetch(e){if(e==null)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");let t=this;return ir(async()=>(await t.iterator()).prefetch(e),this.size)}repeat(e){let t=this,n;return this.size!=null&&e>0?n=this.size*e:e===0?n=0:this.size!=null&&(e===void 0||e<0)?n=1/0:n=null,ir(async()=>{let r=_w(async()=>({value:await t.iterator(),done:!1}));return N5(r.take(e))},n)}skip(e){let t=this,n;return this.size!=null&&e>=0&&this.size>=e?n=this.size-e:this.size!=null&&(this.size<e||e===void 0||e<0)?n=0:n=null,ir(async()=>(await t.iterator()).skip(e),n)}shuffle(e,t,n=!0){if(e==null||e<0)throw this.size==null?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);let r=this,s=v5.alea(t||w.now().toString());return ir(async()=>{let a=s.int32();return n&&(a+=s.int32()),(await r.iterator()).shuffle(e,a.toString())},this.size)}take(e){let t=this,n;return this.size!=null&&this.size>e?n=e:this.size!=null&&this.size<=e?n=this.size:n=null,ir(async()=>(await t.iterator()).take(e),n)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}};Lc.MAX_BUFFER_SIZE=1e4;function ir(e,t=null){return new class extends Lc{constructor(){super(...arguments);this.size=t}async iterator(){return e()}}}function W5(e){return ir(async()=>GC(e),e.length)}function V5(e){if(!Mc(e))throw new Error("The argument to zip() must be an object or array.");let t;if(Array.isArray(e))for(let n=0;n<e.length;n++)t=t==null?e[n].size:Math.min(t,e[n].size);else if(e instanceof Object)for(let n in e)t=t==null?e[n].size:Math.min(t,e[n].size);return ir(async()=>{let n=await zC(e,r=>{if(r instanceof Lc)return{value:r.iterator(),recurse:!1};if(Mc(r))return{value:null,recurse:!0};throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.")});return _5(n,dm.SHORTEST)},t)}function U5(e){if(e===null)return null;let t=e[0];return I5(t)?{value:G5(e),recurse:!1}:{value:null,recurse:!0}}function G5(e){if(e.length===0)throw new Error("Can't make a batch of zero elements.");return e[0]instanceof Ae?Ut(e):er(e)}var KC=class extends Lc{constructor(e){super();this.input=e}async iterator(){return(await this.input.iterator()).decodeUTF8().split(`
`).map(r=>(r.endsWith("\r")&&(r=r.slice(0,-1)),r))}},pm='"',Qd=Symbol("out"),XC=Symbol("field"),hm=Symbol("quote"),Aw=Symbol("quoteafterquote"),YC=Symbol("quoteinquote"),QC=class extends Lc{constructor(e,t){super();this.input=e,this.hasHeader=!0,this.fullColumnNames=null,this.columnNamesValidated=!1,this.columnConfigs=null,this.configuredColumnsOnly=!1,this.delimiter=",",this.delimWhitespace=!1,this.base=new KC(e),t||(t={}),this.hasHeader=t.hasHeader!==!1,this.fullColumnNames=t.columnNames,this.columnConfigs=t.columnConfigs,this.configuredColumnsOnly=t.configuredColumnsOnly,t.delimWhitespace?(w.assert(t.delimiter==null,()=>"Delimiter should not be provided when delimWhitespace is true."),this.delimWhitespace=!0,this.delimiter=" "):this.delimiter=t.delimiter?t.delimiter:","}async columnNames(){return this.columnNamesValidated||await this.setColumnNames(),this.configuredColumnsOnly?Object.keys(this.columnConfigs):this.fullColumnNames}async setColumnNames(){let e=await this.maybeReadHeaderLine();if(!this.fullColumnNames&&!e)throw new Error("Column names must be provided if there is no header line.");this.fullColumnNames&&e&&w.assert(e.length===this.fullColumnNames.length,()=>"The length of provided columnNames ("+this.fullColumnNames.length.toString()+") does not match the length of the header line read from file ("+e.length.toString()+")."),this.fullColumnNames||(this.fullColumnNames=e);let t=this.fullColumnNames.reduce((r,s)=>(r[s]=r[s]+1||1,r),{}),n=Object.keys(t).filter(r=>t[r]>1);if(w.assert(n.length===0,()=>"Duplicate column names found: "+n.toString()),this.columnConfigs){for(let r of Object.keys(this.columnConfigs))if(this.fullColumnNames.indexOf(r)===-1)throw new Error('The key "'+r+'" provided in columnConfigs does not match any of the column names ('+this.fullColumnNames.toString()+").")}this.columnNamesValidated=!0}async maybeReadHeaderLine(){if(this.hasHeader){let t=await(await this.base.iterator()).next();if(t.done)throw new Error("No data was found for CSV parsing.");let n=t.value;return this.parseRow(n,!1)}else return null}async iterator(){this.columnNamesValidated||await this.setColumnNames();let e=await this.base.iterator();return this.hasHeader&&(e=e.skip(1)),e.map(t=>this.makeDataElement(t))}makeDataElement(e){let t=this.parseRow(e),n={},r={};for(let s=0;s<this.fullColumnNames.length;s++){let a=this.fullColumnNames[s],o=this.columnConfigs?this.columnConfigs[a]:null;if(!(this.configuredColumnsOnly&&!o)){let i=t[s],u=null;if(i==="")if(o&&o.default!==void 0)u=o.default;else{if(o&&(o.required||o.isLabel))throw new Error(`Required column ${a} is empty in this line: ${e}`);u=void 0}else{let l=Number(i);if(isNaN(l))o&&o.dtype==="bool"?u=this.getBoolean(i):u=i;else if(!o||!o.dtype)u=l;else switch(o.dtype){case"float32":u=l;break;case"int32":u=Math.floor(l);break;case"bool":u=this.getBoolean(i);break;default:u=l}}o&&o.isLabel?r[a]=u:n[a]=u}}return Object.keys(r).length===0?n:{xs:n,ys:r}}getBoolean(e){return e==="1"||e.toLowerCase()==="true"?1:0}parseRow(e,t=!0){let n=[],r=0,s=e.length,a=Qd;for(let o=0;o<s;o++)switch(a){case Qd:switch(e.charAt(o)){case pm:r=o+1,a=hm;break;case this.delimiter:if(r=o+1,this.delimiter===" "&&this.delimWhitespace)break;n.push(""),a=Qd;break;default:a=XC,r=o;break}break;case XC:switch(e.charAt(o)){case this.delimiter:n.push(e.substring(r,o)),a=Qd,r=o+1;break;default:}break;case hm:switch(e.charAt(o)){case pm:a=Aw;break;default:}break;case Aw:switch(e.charAt(o)){case this.delimiter:n.push(e.substring(r,o-1)),a=Qd,r=o+1;break;case pm:a=hm;break;default:a=YC;break}break;case YC:switch(e.charAt(o)){case pm:a=hm;break;default:}break;default:}if(a===Aw?n.push(e.substring(r,s-1)):n.push(e.substring(r)),t&&n.length!==this.fullColumnNames.length)throw new Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${n}`);return n}},ZC=class extends sn{constructor(e){super();this.microphoneConfig=e,this.isClosed=!1,this.fftSize=e.fftSize||1024;let t=Math.log2(this.fftSize);if(this.fftSize<0||t<4||t>14||!Number.isInteger(t))throw new Error(`Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got ${this.fftSize}`);if(this.numFrames=e.numFramesPerSpectrogram||43,this.sampleRateHz=e.sampleRateHz,this.columnTruncateLength=e.columnTruncateLength||this.fftSize,this.audioTrackConstraints=e.audioTrackConstraints,this.smoothingTimeConstant=e.smoothingTimeConstant||0,this.includeSpectrogram=e.includeSpectrogram!==!1,this.includeWaveform=e.includeWaveform===!0,!this.includeSpectrogram&&!this.includeWaveform)throw new Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.")}summary(){return"microphone"}static async create(e={}){if(X().get("IS_NODE"))throw new Error("microphone API is only supported in browser environment.");let t=new ZC(e);return await t.start(),t}async start(){try{this.stream=await navigator.mediaDevices.getUserMedia({audio:this.audioTrackConstraints==null?!0:this.audioTrackConstraints,video:!1})}catch(n){throw new Error(`Error thrown while initializing video stream: ${n.message}`)}if(!this.stream)throw new Error("Could not obtain audio from microphone.");let e=window.AudioContext||window.webkitAudioContext;if(this.audioContext=new e,!this.sampleRateHz)this.sampleRateHz=this.audioContext.sampleRate;else if(this.audioContext.sampleRate!==this.sampleRateHz)throw new Error(`Mismatch in sampling rate: Expected: ${this.sampleRateHz}; Actual: ${this.audioContext.sampleRate}`);let t=this.audioContext.createMediaStreamSource(this.stream);this.analyser=this.audioContext.createAnalyser(),this.analyser.fftSize=this.fftSize*2,this.analyser.smoothingTimeConstant=this.smoothingTimeConstant,t.connect(this.analyser),this.freqData=new Float32Array(this.fftSize),this.timeData=new Float32Array(this.fftSize)}async next(){if(this.isClosed)return{value:null,done:!0};let e,t,n=await this.getAudioData();if(this.includeSpectrogram){let r=this.flattenQueue(n.freqDataQueue);e=this.getTensorFromAudioDataArray(r,[this.numFrames,this.columnTruncateLength,1])}if(this.includeWaveform){let r=this.flattenQueue(n.timeDataQueue);t=this.getTensorFromAudioDataArray(r,[this.numFrames*this.fftSize,1])}return{value:{spectrogram:e,waveform:t},done:!1}}async capture(){return(await this.next()).value}async getAudioData(){let e=[],t=[],n=0;return new Promise(r=>{let s=setInterval(()=>{this.includeSpectrogram&&(this.analyser.getFloatFrequencyData(this.freqData),this.freqData[0]===-1/0&&r({freqDataQueue:e,timeDataQueue:t}),e.push(this.freqData.slice(0,this.columnTruncateLength))),this.includeWaveform&&(this.analyser.getFloatTimeDomainData(this.timeData),t.push(this.timeData.slice())),++n===this.numFrames&&(clearInterval(s),r({freqDataQueue:e,timeDataQueue:t}))},this.fftSize/this.sampleRateHz*1e3)})}stop(){this.isClosed||(this.isClosed=!0,this.analyser.disconnect(),this.audioContext.close(),this.stream!=null&&this.stream.getTracks().length>0&&this.stream.getTracks()[0].stop())}toArray(){throw new Error("Can not convert infinite audio stream to array.")}getSampleRate(){return this.sampleRateHz}flattenQueue(e){let t=e[0].length,n=new Float32Array(e.length*t);return e.forEach((r,s)=>n.set(r,s*t)),n}getTensorFromAudioDataArray(e,t){let n=new Float32Array(w.sizeFromShape(t));return n.set(e,n.length-e.length),er(n,t)}},JC=class extends sn{constructor(e,t){super();if(this.webcamVideoElement=e,this.webcamConfig=t,this.isClosed=!0,this.resize=!1,this.needToResize())if(this.resize=!0,this.cropSize=[this.webcamConfig.resizeHeight,this.webcamConfig.resizeWidth],this.cropBoxInd=je([0],"int32"),this.webcamConfig.centerCrop){let n=this.webcamConfig.resizeWidth*1/this.webcamVideoElement.width,r=this.webcamConfig.resizeHeight*1/this.webcamVideoElement.height,s=(1-n)/2,a=(1-r)/2,o=s+n,i=r+a;this.cropBox=jr([a,s,i,o],[1,4])}else this.cropBox=jr([0,0,1,1],[1,4])}summary(){return"webcam"}static async create(e,t={}){if(X().get("IS_NODE"))throw new Error("tf.data.webcam is only supported in browser environment.");if(!e){if(e=document.createElement("video"),!t.resizeWidth||!t.resizeHeight)throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");e.width=t.resizeWidth,e.height=t.resizeHeight}let n=new JC(e,t);return await n.start(),n}async start(){this.webcamConfig.facingMode&&w.assert(this.webcamConfig.facingMode==="user"||this.webcamConfig.facingMode==="environment",()=>`Invalid webcam facing mode: ${this.webcamConfig.facingMode}. Please provide 'user' or 'environment'`);try{this.stream=await navigator.mediaDevices.getUserMedia({video:{deviceId:this.webcamConfig.deviceId,facingMode:this.webcamConfig.facingMode?this.webcamConfig.facingMode:"user",width:this.webcamVideoElement.width,height:this.webcamVideoElement.height}})}catch(e){throw e.message=`Error thrown while initializing video stream: ${e.message}`,e}if(!this.stream)throw new Error("Could not obtain video from webcam.");try{this.webcamVideoElement.srcObject=this.stream}catch(e){console.log(e),this.webcamVideoElement.src=window.URL.createObjectURL(this.stream)}return this.webcamVideoElement.play(),this.isClosed=!1,new Promise(e=>{this.webcamVideoElement.onloadedmetadata=()=>{e()}})}async next(){if(this.isClosed)return{value:null,done:!0};let e;try{e=Pi.fromPixels(this.webcamVideoElement)}catch(t){throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(t)}`)}if(this.resize)try{return{value:this.cropAndResizeFrame(e),done:!1}}catch(t){throw new Error(`Error thrown cropping the video: ${t.message}`)}finally{e.dispose()}else return{value:e,done:!1}}needToResize(){return!!(this.webcamConfig.resizeWidth&&this.webcamConfig.resizeHeight&&(this.webcamVideoElement.width!==this.webcamConfig.resizeWidth||this.webcamVideoElement.height!==this.webcamConfig.resizeHeight))}cropAndResizeFrame(e){return M(()=>{let t=Nn(ue(e,"float32"),0),n;n=ar.cropAndResize(t,this.cropBox,this.cropBoxInd,this.cropSize,"bilinear");let r=n.shape;return G(n,r.slice(1))})}async capture(){return(await this.next()).value}stop(){this.stream.getTracks().forEach(t=>t.stop());try{this.webcamVideoElement.srcObject=null}catch(t){console.log(t),this.webcamVideoElement.src=null}this.isClosed=!0}toArray(){throw new Error("Can not convert infinite video stream to array.")}},eT=class{},tT=class extends sn{split(e){return new H5(this,e)}},H5=class extends tT{constructor(e,t){super();this.upstream=e,this.impl=new j5(e,t)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},j5=class extends Ew{constructor(e,t){super();this.upstream=e,this.separator=t,this.carryover=""}summary(){return`${this.upstream.summary()} -> Split('${this.separator}')`}async pump(){let e=await this.upstream.next();if(e.done)return this.carryover===""?!1:(this.outputQueue.push(this.carryover),this.carryover="",!0);let t=e.value.split(this.separator);t[0]=this.carryover+t[0];for(let n of t.slice(0,-1))this.outputQueue.push(n);return this.carryover=t[t.length-1],!0}},q5=class extends sn{decodeUTF8(){return new K5(this)}},K5=class extends tT{constructor(e){super();this.upstream=e,this.impl=new X5(e)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},X5=class extends Ew{constructor(e){super();if(this.upstream=e,X().get("IS_BROWSER"))this.decoder=new TextDecoder("utf-8");else{let{StringDecoder:t}=$I();this.decoder=new t("utf8")}}summary(){return`${this.upstream.summary()} -> Utf8`}async pump(){let e=await this.upstream.next(),t;if(e.done)return!1;t=e.value;let n;return X().get("IS_BROWSER")?n=this.decoder.decode(t,{stream:!0}):n=this.decoder.write(Buffer.from(t.buffer)),this.outputQueue.push(n),!0}},nT=class extends q5{constructor(e,t={}){super();this.file=e,this.options=t,w.assert(e instanceof Uint8Array||(X().get("IS_BROWSER")?e instanceof File||e instanceof Blob:!1),()=>"FileChunkIterator only supports File, Blob and Uint8Array right now."),this.offset=t.offset||0,this.chunkSize=t.chunkSize||1024*1024}summary(){return`FileChunks ${this.file}`}async next(){return this.offset>=(this.file instanceof Uint8Array?this.file.byteLength:this.file.size)?{value:null,done:!0}:{value:await new Promise((t,n)=>{let r=this.offset+this.chunkSize;if(this.file instanceof Uint8Array)t(new Uint8Array(this.file.slice(this.offset,r)));else{let s=new FileReader;s.onload=o=>{let i=s.result;if(i instanceof ArrayBuffer&&(i=new Uint8Array(i)),!(i instanceof Uint8Array))return n(new TypeError("FileReader returned unknown type."));t(i)},s.onabort=o=>n(new Error("Aborted")),s.onerror=o=>n(new Error(o.type));let a=this.file.slice(this.offset,r);s.readAsArrayBuffer(a)}this.offset=r}),done:!1}}};async function Y5(e,t={},n){let r,s;typeof e=="string"?r=e:(r=e.url,s=Q5(e));let a=await(n||w.fetch)(r,s);if(a.ok){let o=new Uint8Array(await a.arrayBuffer());return new nT(o,t)}else throw new Error(a.statusText)}var Q5=e=>({method:e.method,headers:e.headers,body:e.body,mode:e.mode,credentials:e.credentials,cache:e.cache,redirect:e.redirect,referrer:e.referrer,integrity:e.integrity});function rT(e){return typeof e=="string"&&e.substr(0,7)==="file://"}var sT=class extends eT{constructor(e,t={}){super();this.input=e,this.options=t}async iterator(){if(rT(this.input)&&X().get("IS_NODE")){let e=lh();this.input=e.readFileSync(this.input.substr(7))}return new nT(this.input,this.options)}},aT=class extends eT{constructor(e,t={}){super();this.url=e,this.fileOptions=t}async iterator(){return rT(this.url)?new sT(this.url,this.fileOptions).iterator():Y5(this.url,this.fileOptions)}};function Z5(e,t={}){return new QC(new aT(e),t)}function J5(e){let t=_w(e);return ir(async()=>t)}function ej(e){return ir(async()=>{let t=await e();return _w(()=>t.next())})}async function tj(e,t){return JC.create(e,t)}async function nj(e){return ZC.create(e)}var rj="0.0.0";function we(e,t){Array.isArray(e)||(e=[e]),e.forEach(n=>{n!=null&&w.assert(n.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the CPU backend.`)})}var sj=Dr.whereImpl,oT=class extends Mu{constructor(){super();this.blockSize=48,this.firstUse=!0,this.data=new Ul(this,is())}nextDataId(){return oT.nextDataId++}write(e,t,n){this.firstUse&&(this.firstUse=!1,X().get("IS_NODE")&&N.warn(`
============================
Hi there \u{1F44B}. Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.
============================`));let r={id:this.nextDataId()};return this.data.set(r,{values:e,dtype:n,refCount:1}),r}makeTensorInfo(e,t,n){let r;if(t==="string"&&n!=null&&n.length>0&&w.isString(n[0])){let s=n.map(a=>w.encodeString(a));r=this.write(s,e,t)}else r=this.write(n,e,t);return{dataId:r,shape:e,dtype:t}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){let t=this.data.get(e);t.refCount++}decRef(e){if(this.data.has(e)){let t=this.data.get(e);t.refCount--}}move(e,t,n,r,s){this.data.set(e,{values:t,dtype:r,refCount:s})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){let{dtype:t,complexTensorInfos:n}=this.data.get(e);if(t==="complex64"){let r=this.readSync(n.real.dataId),s=this.readSync(n.imag.dataId);return N.mergeRealAndImagArrays(r,s)}return this.data.get(e).values}bufferSync(e){let t=this.readSync(e.dataId),n=t;if(e.dtype==="string")try{n=t.map(r=>w.decodeString(r))}catch(r){throw new Error("Failed to decode encoded string bytes into utf-8")}return $e(e.shape,e.dtype,n)}makeOutput(e,t,n){let r=this.write(e,t,n);return is().makeTensorFromDataId(r,t,n,this)}disposeData(e,t=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;let{complexTensorInfos:n}=this.data.get(e);n!=null&&(this.disposeData(n.real.dataId,!0),this.disposeData(n.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){let t=w.now();return e(),{kernelMs:w.now()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){we([e],"where");let t=this.readSync(e.dataId);return sj(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}},$w=oT;$w.nextDataId=0;var fm={};Ee(fm,{addImpl:()=>uT,bincountImpl:()=>Dw,bincountReduceImpl:()=>cT,ceilImpl:()=>lT,concatImpl:()=>Rw,equalImpl:()=>dT,expImpl:()=>hT,expm1Impl:()=>mT,floorImpl:()=>gT,gatherNdImpl:()=>bT,gatherV2Impl:()=>yT,greaterEqualImpl:()=>xT,greaterImpl:()=>vT,lessEqualImpl:()=>kT,lessImpl:()=>wT,linSpaceImpl:()=>IT,logImpl:()=>ST,maxImpl:()=>CT,maximumImpl:()=>TT,minimumImpl:()=>NT,multiplyImpl:()=>Pw,negImpl:()=>_T,notEqualImpl:()=>ET,prodImpl:()=>AT,rangeImpl:()=>Mw,rsqrtImpl:()=>$T,sigmoidImpl:()=>jj,simpleAbsImpl:()=>iT,sliceImpl:()=>bm,sparseFillEmptyRowsImpl:()=>DT,sparseReshapeImpl:()=>RT,sparseSegmentReductionImpl:()=>Lw,sqrtImpl:()=>Xj,squaredDifferenceImpl:()=>PT,stridedSliceImpl:()=>OT,stringNGramsImpl:()=>MT,stringSplitImpl:()=>LT,stringToHashBucketFastImpl:()=>BT,subImpl:()=>zT,tileImpl:()=>WT,topKImpl:()=>UT,transposeImpl:()=>Ow,uniqueImpl:()=>GT});function iT(e){let t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}var aj=e=>{let{x:t}=e.inputs,n=e.backend;we(t,"abs");let r=new Float32Array(w.sizeFromShape(t.shape)),s=n.data.get(t.dataId).values;return r=iT(s),n.makeOutput(r,t.shape,t.dtype)},oj={kernelName:Vo,backendName:"cpu",kernelFunc:aj};function Ht(e){return(t,n,r,s,a)=>{let o=N.assertAndGetBroadcastShape(t,n),i=o.length,u=w.computeStrides(o),l=w.sizeFromShape(o),c=w.getTypedArrayFromDType(a,l),d=t.length,p=n.length,h=w.computeStrides(t),f=w.computeStrides(n),m=N.getBroadcastDims(t,o),g=N.getBroadcastDims(n,o);if(m.length+g.length===0)for(let b=0;b<c.length;++b)c[b]=e(r[b%r.length],s[b%s.length]);else for(let b=0;b<c.length;++b){let y=w.indexToLoc(b,i,u),v=y.slice(-d);m.forEach(C=>v[C]=0);let x=w.locToIndex(v,d,h),k=y.slice(-p);g.forEach(C=>k[C]=0);let T=w.locToIndex(k,p,f);c[b]=e(r[x],s[T])}return[c,o]}}function ur(e){let{inputs:t,backend:n}=e,{real:r,imag:s}=t,a=n.data.get(r.dataId).values,o=n.data.get(s.dataId).values,i=n.makeTensorInfo(r.shape,"complex64"),u=n.data.get(i.dataId);return u.complexTensorInfos={real:n.makeTensorInfo(r.shape,"float32",a),imag:n.makeTensorInfo(s.shape,"float32",o)},i}var ij={kernelName:ql,backendName:"cpu",kernelFunc:ur};function mm(e,t,n="float32"){if(n==="complex64"){let s=mm(e,t,"float32"),a=mm(e,t,"float32");return ur({inputs:{real:s,imag:a},backend:e})}let r=w.makeZerosTypedArray(w.sizeFromShape(t),n);return e.makeTensorInfo(t,n,r)}function bs(e){let{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}var uj={kernelName:_a,backendName:"cpu",kernelFunc:bs};function Ji(e){let{inputs:t,backend:n}=e,{input:r}=t,s=n.data.get(r.dataId).complexTensorInfos.real,a=n.data.get(s.dataId).values;return n.makeTensorInfo(s.shape,s.dtype,a)}var cj={kernelName:nd,backendName:"cpu",kernelFunc:Ji};function So(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dtype:a}=r;if(a==="complex64"){if(s.dtype==="complex64")return bs({inputs:{x:s},backend:n});let o=mm(n,s.shape,s.dtype),i=So({inputs:{x:s},backend:n,attrs:{dtype:"float32"}}),u=ur({inputs:{real:i,imag:o},backend:n});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(i),u}if(s.dtype==="complex64"){let o=Ji({inputs:{input:s},backend:n}),i=So({inputs:{x:o},backend:n,attrs:{dtype:a}});return n.disposeIntermediateTensorInfo(o),i}if(!w.hasEncodingLoss(s.dtype,a)){let o=bs({inputs:{x:s},backend:n});return{dataId:o.dataId,shape:o.shape,dtype:a}}if(a==="int32"){let o=n.data.get(s.dataId).values,i=Int32Array.from(o);return n.makeTensorInfo(s.shape,"int32",i)}if(a==="bool"){let o=n.data.get(s.dataId).values,i=w.toTypedArray([0],s.dtype),[u,l]=Ht((c,d)=>c!==d?1:0)(s.shape,[],o,i,"bool");return n.makeTensorInfo(l,"bool",u)}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${a}`)}var lj={kernelName:fa,backendName:"cpu",kernelFunc:So};function an(e,t,n,r){return n==null?({inputs:s,backend:a})=>{let{a:o,b:i}=s,u=a;we([o,i],e);let l=u.data.get(o.dataId).values,c=u.data.get(i.dataId).values,d=o.dtype==="string"?N.fromUint8ToStringArray(l):l,p=o.dtype==="string"?N.fromUint8ToStringArray(c):c,h=r||o.dtype,[f,m]=t(o.shape,i.shape,d,p,h);return u.makeTensorInfo(m,h,f)}:({inputs:s,backend:a})=>{let{a:o,b:i}=s,u=a;if(o.dtype==="complex64"||i.dtype==="complex64"){let l=So({inputs:{x:o},backend:u,attrs:{dtype:"complex64"}}),c=u.data.get(l.dataId),d=c.complexTensorInfos.real,p=c.complexTensorInfos.imag,h=u.data.get(d.dataId).values,f=u.data.get(p.dataId).values,m=So({inputs:{x:i},backend:u,attrs:{dtype:"complex64"}}),g=u.data.get(m.dataId),b=g.complexTensorInfos.real,y=g.complexTensorInfos.imag,v=u.data.get(b.dataId).values,x=u.data.get(y.dataId).values,[k,T,C]=n(o.shape,i.shape,h,f,v,x),E=u.makeTensorInfo(C,"float32",k),F=u.makeTensorInfo(C,"float32",T),O=ur({inputs:{real:E,imag:F},backend:u});return u.disposeIntermediateTensorInfo(l),u.disposeIntermediateTensorInfo(m),u.disposeIntermediateTensorInfo(E),u.disposeIntermediateTensorInfo(F),O}else{let l=u.data.get(o.dataId).values,c=u.data.get(i.dataId).values,d=r||o.dtype,[p,h]=t(o.shape,i.shape,l,c,d);return u.makeTensorInfo(h,d,p)}}}function Fw(e){return(t,n,r,s,a,o)=>{let i=N.assertAndGetBroadcastShape(t,n),u=w.sizeFromShape(i),l=i.length,c=w.computeStrides(i),d=w.getTypedArrayFromDType("float32",u),p=w.getTypedArrayFromDType("float32",u),h=N.getBroadcastDims(t,i),f=N.getBroadcastDims(n,i),m=N.mergeRealAndImagArrays(r,s),g=N.mergeRealAndImagArrays(a,o),b=t.length,y=w.computeStrides(t),v=n.length,x=w.computeStrides(n);if(h.length+f.length===0)for(let k=0;k<d.length;k++){let T=k%m.length,C=k%g.length,E=e(m[T*2],m[T*2+1],g[C*2],g[C*2+1]);d[k]=E.real,p[k]=E.imag}else for(let k=0;k<d.length;k++){let T=w.indexToLoc(k,l,c),C=T.slice(-b);h.forEach(R=>C[R]=0);let E=w.locToIndex(C,b,y),F=T.slice(-v);f.forEach(R=>F[R]=0);let O=w.locToIndex(F,v,x),D=e(m[E*2],m[E*2+1],g[O*2],g[O*2+1]);d[k]=D.real,p[k]=D.imag}return[d,p,i]}}var uT=Ht((e,t)=>e+t),dj=Fw((e,t,n,r)=>({real:e+n,imag:t+r})),Zd=an(_s,uT,dj),pj={kernelName:_s,backendName:"cpu",kernelFunc:Zd};function Dw(e,t,n,r,s){let a=w.sizeFromShape(r),o=w.makeZerosTypedArray(s,n);for(let i=0;i<e.length;i++){let u=e[i];if(u<0)throw new Error("Input x must be non-negative!");u>=s||(a>0?o[u]+=t[i]:o[u]+=1)}return o}function cT(e,t,n,r=!1){let s=e.shape[0],a=e.shape[1],o=$e([s,n],t.dtype);for(let i=0;i<s;i++)for(let u=0;u<a;u++){let l=e.get(i,u);if(l<0)throw new Error("Input x must be non-negative!");l>=n||(r?o.set(1,i,l):t.size>0?o.set(o.get(i,l)+t.get(i,u),i,l):o.set(o.get(i,l)+1,i,l))}return o}function Co(e){return(t,n,r)=>{let s=w.getTypedArrayFromDType(n,t.length);for(let a=0;a<t.length;++a)s[a]=e(t[a],r);return s}}function ct(e,t,n){return({inputs:r,attrs:s,backend:a})=>{let{x:o}=r;if(we(o,e),o.dtype==="string"||n==="string")throw new Error("unaryKernelFunc does not support string input/output");let i=a,u=i.data.get(o.dataId).values,l=w.sizeFromShape(o.shape),c=n||o.dtype,d=w.getArrayFromDType(c,l);for(let p=0;p<l;++p)d[p]=t(u[p],s);return i.makeTensorInfo(o.shape,c,d)}}function Bc(e,t,n){return({inputs:r,attrs:s,backend:a})=>{let{x:o}=r;if(we(o,e),o.dtype==="string"||n==="string")throw new Error("unaryKernelFunc does not support string input/output");let i=a,u=i.data.get(o.dataId).values,l=n||o.dtype,c=t(u,l,s);return i.makeTensorInfo(o.shape,l,c)}}var lT=Co(e=>Math.ceil(e)),hj=Bc(ma,lT),fj={kernelName:ma,backendName:"cpu",kernelFunc:hj};function Rw(e,t,n,r){let s=w.getArrayFromDType(n,w.sizeFromShape(t));if(r&&n!=="string"){let a=0;e.forEach(o=>{let i=w.sizeFromShape(o.shape);s.set(o.vals,a),a+=i})}else{let a=0;e.forEach(o=>{let i=n==="string"?N.fromUint8ToStringArray(o.vals):o.vals,u=0;for(let l=0;l<o.shape[0];++l){let c=l*t[1]+a;for(let d=0;d<o.shape[1];++d)s[c+d]=i[u++]}a+=o.shape[1]})}return s}var dT=Ht((e,t)=>e===t?1:0),pT=an(Ko,dT,null,"bool"),mj={kernelName:Ko,backendName:"cpu",kernelFunc:pT},hT=Co(e=>Math.exp(e)),fT=Bc(Ia,hT,"float32"),gj={kernelName:Ia,backendName:"cpu",kernelFunc:fT},mT=Co(e=>Math.expm1(e)),bj=Bc(Yo,mT),yj={kernelName:Yo,backendName:"cpu",kernelFunc:bj},gT=Co(e=>Math.floor(e)),vj=Bc(Sa,gT),xj={kernelName:Sa,backendName:"cpu",kernelFunc:vj};function bT(e,t,n,r,s,a,o,i,u){let l=$e([r,a],n);for(let c=0;c<r;c++){let d=[],p=0;for(let h=0;h<s;h++){let f=e[c*s+h];p+=f*o[h],d.push(f)}if(p<0||p>=u/a)throw new Error(`Invalid indices: ${d} does not index into ${i}`);for(let h=0;h<a;h++)l.values[c*a+h]=t.get(...t.indexToLoc(p*a+h))}return l}function yT(e,t,n){let r=$e(n,e.dtype);for(let s=0;s<r.size;++s){let o=r.indexToLoc(s).slice(),i=o[0],u=o[2],l=t.locToIndex([i,u]);o[2]=t.values[l];let c=e.locToIndex(o);r.values[s]=e.values[c]}return r}var vT=Ht((e,t)=>e>t?1:0),wj=an(ei,vT,null,"bool"),kj={kernelName:ei,backendName:"cpu",kernelFunc:wj},xT=Ht((e,t)=>e>=t?1:0),Ij=an(Na,xT,null,"bool"),Sj={kernelName:Na,backendName:"cpu",kernelFunc:Ij},wT=Ht((e,t)=>e<t?1:0),Cj=an(ni,wT,null,"bool"),Tj={kernelName:ni,backendName:"cpu",kernelFunc:Cj},kT=Ht((e,t)=>e<=t?1:0),Nj=an(ri,kT,null,"bool"),_j={kernelName:ri,backendName:"cpu",kernelFunc:Nj};function IT(e,t,n){let r=(t-e)/(n-1),s=w.makeZerosTypedArray(n,"float32");s[0]=e;for(let a=1;a<s.length;a++)s[a]=s[a-1]+r;return s}var ST=Co(e=>Math.log(e)),Ej=Bc(Ea,ST),Aj={kernelName:Ea,backendName:"cpu",kernelFunc:Ej};function CT(e,t,n,r){let s=w.getTypedArrayFromDType(r,w.sizeFromShape(n));for(let a=0;a<s.length;++a){let o=a*t,i=e[o];for(let u=0;u<t;++u){let l=e[o+u];(Number.isNaN(l)||l>i)&&(i=l)}s[a]=i}return s}var TT=Ht((e,t)=>Math.max(e,t)),$j=an($a,TT),Fj={kernelName:$a,backendName:"cpu",kernelFunc:$j},NT=Ht((e,t)=>Math.min(e,t)),Dj=an(Pa,NT),Rj={kernelName:Pa,backendName:"cpu",kernelFunc:Dj},Pw=Ht((e,t)=>e*t),Pj=Fw((e,t,n,r)=>({real:e*n-t*r,imag:e*r+t*n})),gm=an(Ma,Pw,Pj),Oj={kernelName:Ma,backendName:"cpu",kernelFunc:gm};function _T(e,t,n){let r=w.createScalarValue(-1,n);return Pw([],t,r,e,n)}function Mj(e){let{inputs:t,backend:n}=e,{x:r}=t;we(r,"neg");let s=n.data.get(r.dataId).values,[a,o]=_T(s,r.shape,r.dtype);return n.makeTensorInfo(o,r.dtype,a)}var Lj={kernelName:ai,backendName:"cpu",kernelFunc:Mj},ET=Ht((e,t)=>e!==t?1:0),Bj=an(oi,ET,null,"bool"),zj={kernelName:oi,backendName:"cpu",kernelFunc:Bj};function Ow(e,t,n,r,s){let a=t.length,o=w.sizeFromShape(t),i=w.computeStrides(t),u=w.computeStrides(s),l=w.getTypedArrayFromDType(n,w.sizeFromShape(s));for(let c=0;c<o;++c){let d=w.indexToLoc(c,a,i),p=new Array(d.length);for(let f=0;f<p.length;f++)p[f]=d[r[f]];let h=w.locToIndex(p,a,u);l[h]=e[c]}return l}function xr(e){let{inputs:t,attrs:n,backend:r}=e,{x:s}=t,{perm:a}=n;we(s,"transpose");let o=s.shape.length,i=new Array(o);for(let d=0;d<i.length;d++)i[d]=s.shape[a[d]];let u=r.data.get(s.dataId).values,l=Ow(u,s.shape,s.dtype,a,i);return{dataId:r.write(l,i,s.dtype),shape:i,dtype:s.dtype}}var Wj={kernelName:Ja,backendName:"cpu",kernelFunc:xr};function AT(e,t,n,r){let[s,a]=N.computeOutAndReduceShapes(e,r),o=In(t,"int32"),i=w.makeZerosTypedArray(w.sizeFromShape(s),o),u=w.sizeFromShape(a);for(let l=0;l<i.length;++l){let c=l*u,d=1;for(let p=0;p<u;++p)d*=n[c+p];i[l]=d}return{outVals:i,outShape:s,outDtype:o}}function Vj(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:o}=r;we(s,"prod");let i=s.shape.length,u=w.parseAxisParam(a,s.shape),l=N.getAxesPermutation(u,i),c=u,d=s,p=[];l!=null&&(d=xr({inputs:{x:s},backend:n,attrs:{perm:l}}),p.push(d),c=N.getInnerMostAxes(c.length,i));let h=n.data.get(d.dataId).values,{outVals:f,outShape:m,outDtype:g}=AT(d.shape,d.dtype,h,c),b=m;return o&&(b=N.expandShapeToKeepDim(m,u)),p.forEach(y=>n.disposeIntermediateTensorInfo(y)),n.makeTensorInfo(b,g,f)}var Uj={kernelName:pi,backendName:"cpu",kernelFunc:Vj};function Mw(e,t,n,r){let s=e===t,a=e<t&&n<0,o=t<e&&n>1;if(s||a||o)return w.makeZerosTypedArray(0,r);let i=Math.abs(Math.ceil((t-e)/n)),u=w.makeZerosTypedArray(i,r);t<e&&n===1&&(n=-1),u[0]=e;for(let l=1;l<u.length;l++)u[l]=u[l-1]+n;return u}var $T=Co(e=>1/Math.sqrt(e)),Gj=Bc(Ga,$T),Hj={kernelName:Ga,backendName:"cpu",kernelFunc:Gj},jj=Co(e=>1/(1+Math.exp(-e))),FT=ct(ja,e=>1/(1+Math.exp(-e))),qj={kernelName:ja,backendName:"cpu",kernelFunc:FT};function bm(e,t,n,r,s){let a=$t.isSliceContinous(r,t,n),o=w.sizeFromShape(n),i=w.computeStrides(r);if(a){let d=$t.computeFlatOffset(t,i);return s==="string"?e.slice(d,d+o):e.subarray(d,d+o)}let u=s==="string"?N.fromUint8ToStringArray(e):e,l=$e(r,s,u),c=$e(n,s);for(let d=0;d<c.size;++d){let p=c.indexToLoc(d),h=p.map((f,m)=>f+t[m]);c.set(l.get(...h),...p)}return s==="string"?N.fromStringArrayToUint8(c.values):c.values}function eu(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,size:o}=r;we(s,"slice");let[i,u]=$t.parseSliceParams(s,a,o);$t.assertParamsValid(s,i,u);let l=n.data.get(s.dataId).values,c=bm(l,i,u,s.shape,s.dtype);return n.makeTensorInfo(u,s.dtype,c)}var Kj={kernelName:yi,backendName:"cpu",kernelFunc:eu};function DT(e,t,n,r,s,a,o){let i=t[0],u=a[0],l=new Array(u),c=new Array(i),d=t[1];if(u===0){if(i!==0)throw new Error(N.getSparseFillEmptyRowsIndicesDenseShapeMismatch(i));let g=w.getArrayFromDType(n,0),b=w.getArrayFromDType(s,0);return[g,[0,d],b,l,c]}let p=!0,h=0,f=new Array(u).fill(0);for(let g=0;g<i;++g){let b=e[g*d];if(b<0)throw new Error(N.getSparseFillEmptyRowsNegativeIndexErrorMessage(g,b));if(b>=u)throw new Error(N.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(g,b,u));++f[b],p=p&&b>=h,h=b}let m=!0;for(let g=0;g<u;++g){let b=f[g]===0;l[g]=b,m=m&&!b,f[g]=Math.max(f[g],1),g>0&&(f[g]+=f[g-1])}if(m&&p){let g=e,b=r;for(let y=0;y<i;++y)c[y]=y;return[g,[i,d],b,l,c]}else{let g=f[u-1],b=w.getArrayFromDType(n,g*d),y=w.getArrayFromDType(s,g),v=new Array(u).fill(0);for(let x=0;x<i;++x){let k=e[x*d],T=v[k],C=(k===0?0:f[k-1])+T;v[k]++;for(let E=0;E<d;++E)b[C*d+E]=e[x*d+E];y[C]=r[x],c[x]=C}for(let x=0;x<u;++x)if(v[x]===0){let T=x===0?0:f[x-1];b[T*d+0]=x;for(let C=1;C<d;++C)b[T*d+C]=0;y[T]=o}return[b,[g,d],y,l,c]}}function RT(e,t,n,r,s){let a=w.sizeFromShape(r),o=t[0],i=s.length,u=[],l=1,c=-1;for(let g=0;g<i;++g){let b=s[g];if(b===-1){if(c!==-1)throw new Error(N.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(c,g));c=g,u.push(1)}else{if(b<0)throw new Error(N.getSparseReshapeNegativeOutputDimErrorMessage(g,b));l*=b,u.push(b)}}if(c!==-1){if(l<=0)throw new Error(N.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());let g=Math.trunc(a/l);if(l*g!==a)throw new Error(N.getSparseReshapeInputOutputMultipleErrorMessage(r,u));u[c]=g}if(w.sizeFromShape(u)!==a)throw new Error(N.getSparseReshapeInputOutputMismatchErrorMessage(r,u));let p=r.length,h=[];if(p>0){h[p-1]=1;for(let g=p-2;g>=0;--g)h[g]=h[g+1]*r[g+1]}let f=[];if(i>0){f[i-1]=1;for(let g=i-2;g>=0;--g)f[g]=f[g+1]*u[g+1]}let m=w.getArrayFromDType(n,o*i);for(let g=0;g<o;++g){let b=0;for(let y=0;y<p;++y)b+=e[g*p+y]*h[y];for(let y=0;y<i;++y)m[g*i+y]=Math.trunc(b/f[y]),b%=f[y]}return[m,[o,i],u]}function Lw(e,t,n,r,s,a=!1,o=0){let i=r.length,u=[t[0],e.length/t[0]],l=u[1],d=i>0?s[i-1]+1:0;if(d<0)throw new Error(N.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let p=t.slice();p[0]=d;let h=p.reduce((v,x)=>v*x,1),f=w.getArrayFromDType(n,h);if(i===0)return d>0&&f.fill(o),[f,p];if(d<=0)throw new Error(N.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let m=0,g=1,b=0,y=s[m];for(;;){let v=0;if(g<i){if(v=s[g],y===v){++g;continue}if(y>=v)throw new Error(N.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(y<0||y>=d)throw new Error(N.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(y,d));y>b&&f.fill(o,b*l,y*l);for(let x=m;x<g;++x){let k=r[x];if(k<0||k>=u[0])throw new Error(N.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(x,r[x],u[0]));for(let T=0;T<l;T++)f[y*l+T]+=e[k*l+T]}if(a)for(let x=0;x<l;x++)f[y*l+x]/=g-m;if(m=g,++g,b=y+1,y=v,g>i)break}return b<d&&f.fill(o,b*l,d*l),[f,p]}var Xj=Co(e=>Math.sqrt(e)),Yj=ct(qa,e=>Math.sqrt(e)),Qj={kernelName:qa,backendName:"cpu",kernelFunc:Yj},PT=Ht((e,t)=>{let n=e-t;return n*n}),Zj=an(Ya,PT),Jj={kernelName:Ya,backendName:"cpu",kernelFunc:Zj};function OT(e,t,n,r){let s=$e(e,t.dtype);for(let a=0;a<s.size;a++){let o=s.indexToLoc(a),i=new Array(o.length);for(let u=0;u<i.length;u++)i[u]=o[u]*n[u]+r[u];s.set(t.get(...i),...o)}return s}var eq=class{constructor(e,t,n,r,s,a){this.separator=w.encodeString(e),this.nGramWidths=t,this.leftPad=w.encodeString(n),this.rightPad=w.encodeString(r),this.padWidth=s,this.preserveShort=a}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){let n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,r,s,a){for(let o=0;o<s;++o){let i=this.getPadWidth(a),u=Math.max(0,i-o),l=Math.max(0,i-(s-(o+1))),c=a-(u+l),d=t+(u>0?0:o-i),p=0;p+=u*this.leftPad.length;for(let b=0;b<c;++b)p+=e[d+b].length;p+=l*this.rightPad.length,p+=(u+l+c-1)*this.separator.length,n[r+o]=new Uint8Array(p);let f=n[r+o],m=0,g=b=>b.forEach(y=>f[m++]=y);for(let b=0;b<u;++b)g(this.leftPad),g(this.separator);for(let b=0;b<c-1;++b)g(e[d+b]),g(this.separator);if(c>0){g(e[d+c-1]);for(let b=0;b<l;++b)g(this.separator),g(this.rightPad)}else{for(let b=0;b<l-1;++b)g(this.rightPad),g(this.separator);g(this.rightPad)}}}compute(e,t){let n=e.length,r=t.length;if(r>0){let i=t[0];if(i!==0)throw new Error(`First split value must be 0, got ${i}`);for(let u=1;u<r;++u){let l=t[u]>=i;if(l=l&&t[u]<=n,!l)throw new Error(`Invalid split value ${t[u]}, must be in [${i}, ${n}]`);i=t[u]}if(i!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${i}`)}let s=r-1,a=w.getArrayFromDType("int32",r);if(n===0||r===0){let i=new Array(n);for(let u=0;u<=s;++u)a[u]=0;return[i,a]}a[0]=0;for(let i=1;i<=s;++i){let u=t[i]-t[i-1],l=0;this.nGramWidths.forEach(c=>{l+=this.getNumNGrams(u,c)}),this.preserveShort&&u>0&&l===0&&(l=1),a[i]=a[i-1]+l}let o=new Array(a[s]);for(let i=0;i<s;++i){let u=t[i],l=a[i];if(this.nGramWidths.forEach(c=>{let d=t[i+1]-t[i],p=this.getNumNGrams(d,c);this.createNGrams(e,u,o,l,p,c),l+=p}),this.preserveShort&&l===a[i]){let c=t[i+1]-t[i];if(c===0)continue;let d=c+2*this.padWidth,p=1;this.createNGrams(e,u,o,l,p,d)}}return[o,a]}};function MT(e,t,n,r,s,a,o,i){return new eq(n,r,s,a,o,i).compute(e,t)}function tq(e,t,n,r){if(!e.length)return;if(t.length===0){for(let a=0;a<e.length;++a)r.push(e.subarray(a,a+1));return}if(t.length===1){let a=t[0],o=e.indexOf(a);for(;o!==-1;){let i=e.subarray(0,o);(!n||i.length!==0)&&r.push(i),e=e.subarray(o+1),o=e.indexOf(a)}(!n||e.length!==0)&&r.push(e);return}let s=0;for(let a=0;a<e.length+1;a++)if(a===e.length||t.indexOf(e[a])!==-1){let o=e.subarray(s,a);(!n||o.length!==0)&&r.push(o),s=a+1}}function LT(e,t,n){let r=e.length,s=[],a=0,o=0,i=new Array(r);for(let p=0;p<r;++p){let h=s.length;tq(e[p],t,n,s);let f=s.length-h;i[p]=f,a+=f,o=Math.max(o,f)}let u=w.getArrayFromDType("int32",a*2),l=new Array(a),c=[r,o],d=0;for(let p=0;p<r;++p)for(let h=0;h<i[p];++h)u[d*2]=p,u[d*2+1]=h,l[d]=s[d],++d;return[u,l,c]}function BT(e,t){let n=w.getArrayFromDType("int32",e.length);for(let r=0;r<e.length;++r)n[r]=w.fingerPrint64(e[r]).modulo(t).getLowBitsUnsigned();return n}var zT=Ht((e,t)=>e-t),nq=Fw((e,t,n,r)=>({real:e-n,imag:t-r})),Bw=an(Qa,zT,nq),rq={kernelName:Qa,backendName:"cpu",kernelFunc:Bw};function WT(e,t){let n=new Array(e.rank);for(let s=0;s<n.length;s++)n[s]=e.shape[s]*t[s];let r=$e(n,e.dtype);for(let s=0;s<r.values.length;++s){let a=r.indexToLoc(s),o=new Array(e.rank);for(let u=0;u<o.length;u++)o[u]=a[u]%e.shape[u];let i=e.locToIndex(o);r.values[s]=e.values[i]}return r}var Jd=(e,t)=>{let n=t.value-e.value;return n===0?e.index-t.index:n};function VT(e,t,n=0,r=e.length-1){for(;r>n;){if(r-n>600){let i=r-n+1,u=t-n+1,l=Math.log(i),c=.5*Math.exp(2*l/3),d=.5*Math.sqrt(l*c*(i-c)/i)*Math.sign(u-i/2),p=Math.max(n,Math.floor(t-u*c/i+d)),h=Math.min(r,Math.floor(t+(i-u)*c/i+d));VT(e,t,p,h)}let s=e[t],a=n,o=r;for(w.swap(e,n,t),Jd(e[r],s)>0&&w.swap(e,n,r);a<o;){for(w.swap(e,a,o),a++,o--;Jd(e[a],s)<0;)a=a+1;for(;Jd(e[o],s)>0;)o=o-1}Jd(e[n],s)===0?w.swap(e,n,o):(o=o+1,w.swap(e,o,r)),o<=t&&(n=o+1),t<=o&&(r=o-1)}}function UT(e,t,n,r,s){let a=t[t.length-1],[o,i]=[e.length/a,a],u=w.getTypedArrayFromDType(n,o*r),l=w.getTypedArrayFromDType("int32",o*r);for(let d=0;d<o;d++){let p=d*i,h=e.subarray(p,p+i),f=new Array(h.length);h.forEach((y,v)=>f[v]={value:y,index:v}),r<f.length&&(VT(f,r),f=f.slice(0,r)),s&&f.sort(Jd);let m=d*r,g=u.subarray(m,m+r),b=l.subarray(m,m+r);for(let y=0;y<r;y++)g[y]=f[y].value,b[y]=f[y].index}let c=t.slice();return c[c.length-1]=r,[$e(c,n,u),$e(c,"int32",l)]}function GT(e,t,n,r){let s=w.parseAxisParam(t,n)[0],a=[1,n[0],1];for(let f=0;f<s;f++)a[0]*=n[f];a[1]=n[s];for(let f=s+1;f<n.length;f++)a[2]*=n[f];let o={},i=new Int32Array(n[s]),u=new Kt(a,r,e),l=[],c=a[0]===1&&a[2]===1;for(let f=0;f<n[s];f++){let m;if(c)m=e[f].toString();else{let g=[];for(let b=0;b<a[0];b++)for(let y=0;y<a[2];y++)g.push(u.get(b,f,y));m=g.join(",")}if(o[m]!==void 0)i[f]=o[m];else{let g=Object.keys(o).length;o[m]=g,i[f]=g,l.push(f)}}let d=a.slice();d[1]=Object.keys(o).length;let p=new Kt(d,r);l.forEach((f,m)=>{for(let g=0;g<a[0];g++)for(let b=0;b<a[2];b++)p.set(u.get(g,f,b),g,m,b)});let h=n.slice();return h[s]=d[1],{outputValues:p.values,outputShape:h,indices:i}}var sq="0.0.0";wd("cpu",()=>new $w,1);var HT=ct(ka,e=>e>=0?e:Math.exp(e)-1),aq={kernelName:ka,backendName:"cpu",kernelFunc:HT};function jT(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{alpha:a}=r;we([s],"leakyRelu");let o=w.sizeFromShape(s.shape),i=n.data.get(s.dataId).values,u=w.getTypedArrayFromDType("float32",o);for(let l=0;l<i.length;l++)u[l]=i[l]<0?a*i[l]:i[l];return n.makeTensorInfo(s.shape,"float32",u)}var oq={kernelName:ti,backendName:"cpu",kernelFunc:jT},iq=Ht((e,t)=>e<0?t*e:e);function qT(e){let{inputs:t,backend:n}=e,{x:r,alpha:s}=t;we([r,s],"prelu");let a=n.data.get(r.dataId).values,o=n.data.get(s.dataId).values,[i,u]=iq(r.shape,s.shape,a,o,"float32");return n.makeTensorInfo(u,"float32",i)}var uq={kernelName:za,backendName:"cpu",kernelFunc:qT},KT=ct(Wa,e=>Math.max(0,e)),cq={kernelName:Wa,backendName:"cpu",kernelFunc:KT},XT=ct(Ua,e=>Math.min(Math.max(0,e),6)),lq={kernelName:Ua,backendName:"cpu",kernelFunc:XT};function zw(e,t,n,r,s){if(n==="linear")return bs({inputs:{x:t},backend:e});if(n==="relu")return KT({inputs:{x:t},backend:e});if(n==="elu")return HT({inputs:{x:t},backend:e});if(n==="relu6")return XT({inputs:{x:t},backend:e});if(n==="prelu")return qT({inputs:{x:t,alpha:r},backend:e});if(n==="leakyrelu")return jT({inputs:{x:t},backend:e,attrs:{alpha:s}});if(n==="sigmoid")return FT({inputs:{x:t},backend:e});throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}function Et(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{shape:a}=r,o=w.sizeFromShape(s.shape),i=w.inferFromImplicitShape(a,o),u=w.sizeFromShape(i);w.assert(o===u,()=>`The new shape (${i}) has ${u} elements and the old shape (${s.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`),n.incRef(s.dataId);let l=n.data.get(s.dataId);if(l.complexTensorInfos!=null){let c=l.complexTensorInfos.real,d=l.complexTensorInfos.imag;c.shape=i,d.shape=i}return{dataId:s.dataId,shape:i,dtype:s.dtype}}var dq={kernelName:hi,backendName:"cpu",kernelFunc:Et};function YT(e){let{inputs:t,backend:n,attrs:r}=e,{a:s,b:a}=t,{transposeA:o,transposeB:i}=r;we([s,a],"matMul");let u=s.shape.length,l=a.shape.length,c=o?s.shape[u-2]:s.shape[u-1],d=i?a.shape[l-1]:a.shape[l-2],p=o?s.shape[u-1]:s.shape[u-2],h=i?a.shape[l-2]:a.shape[l-1],f=s.shape.slice(0,-2),m=a.shape.slice(0,-2),g=w.sizeFromShape(f),b=w.sizeFromShape(m),v=Ri.assertAndGetBroadcastShape(s.shape.slice(0,-2),a.shape.slice(0,-2)).concat([p,h]);w.assert(c===d,()=>`Error in matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${s.shape} and ${a.shape} and transposeA=${o} and transposeB=${i} must match.`);let x=o?[g,c,p]:[g,p,c],k=i?[b,h,d]:[b,d,h],T=Et({inputs:{x:s},backend:n,attrs:{shape:x}}),C=Et({inputs:{x:a},backend:n,attrs:{shape:k}}),E=o?T.shape[1]:T.shape[2],F=o?T.shape[2]:T.shape[1],O=i?C.shape[1]:C.shape[2],D=Math.max(g,b),R=n.data.get(T.dataId).values,_=n.data.get(C.dataId).values,L=w.computeStrides(T.shape),U=w.computeStrides(C.shape),[j,K,q]=o?[L[0],1,L[1]]:[L[0],L[1],1],[Q,ee,re]=i?[1,U[1],U[0]]:[U[1],1,U[0]],se=F*O,ne=$e([D,F,O],T.dtype),ie=ne.values,te=n.blockSize;for(let pe=0;pe<D;pe++)for(let be=0;be<F;be+=te)for(let Ce=0;Ce<O;Ce+=te)for(let Ie=0;Ie<E;Ie+=te){let Ne=Math.min(be+te,F),Le=Math.min(Ce+te,O),Je=Math.min(Ie+te,E);for(let qe=be;qe<Ne;qe++)for(let Ge=Ce;Ge<Le;Ge++){let lt=0;for(let et=Ie;et<Je;et++){let pt=Math.min(pe,g-1)*j,Ct=Math.min(pe,b-1)*re,Bn=R[pt+qe*K+et*q],tt=_[et*Q+Ge*ee+Ct];lt+=Bn*tt}ie[pe*se+(qe*O+Ge)]+=lt}}return n.disposeIntermediateTensorInfo(T),n.disposeIntermediateTensorInfo(C),n.makeTensorInfo(v,ne.dtype,ne.values)}var pq={kernelName:ha,backendName:"cpu",kernelFunc:YT};function hq(e){let{inputs:t,backend:n,attrs:r}=e,{a:s,b:a,bias:o,preluActivationWeights:i}=t,{transposeA:u,transposeB:l,activation:c,leakyreluAlpha:d}=r,p,h,f,m=[];p=YT({inputs:{a:s,b:a},attrs:{transposeA:u,transposeB:l},backend:n}),o&&(h=Zd({inputs:{a:p,b:o},backend:n}),m.push(p),p=h),c&&(f=zw(n,p,c,i,d),m.push(p),p=f);for(let b of m)n.disposeIntermediateTensorInfo(b);return p}var fq={kernelName:to,backendName:"cpu",kernelFunc:hq},mq=ct(Wu,e=>Math.acos(e)),gq={kernelName:Wu,backendName:"cpu",kernelFunc:mq},bq=ct(Vu,e=>Math.acosh(e)),yq={kernelName:Vu,backendName:"cpu",kernelFunc:bq};function vq(e){let{inputs:t,backend:n}=e,r=t;we(t,"addN");let s=r.map(i=>n.data.get(i.dataId).values),a=$e(r[0].shape,r[0].dtype),o=a.values;for(let i=0;i<r.length;i++){let u=s[i];for(let l=0;l<o.length;l++)o[l]+=u[l]}return n.makeTensorInfo(a.shape,a.dtype,a.values)}var xq={kernelName:la,backendName:"cpu",kernelFunc:vq};function wq(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:o}=r;we(s,"all");let i=w.parseAxisParam(a,s.shape),u=i,l=N.getAxesPermutation(u,s.shape.length),c=s;l!=null&&(c=xr({inputs:{x:s},backend:n,attrs:{perm:l}}),u=N.getInnerMostAxes(u.length,s.shape.length)),N.assertAxesAreInnerMostDims("all",u,c.shape.length);let[d,p]=N.computeOutAndReduceShapes(c.shape,u),h=w.sizeFromShape(p),f=w.makeZerosTypedArray(w.sizeFromShape(d),c.dtype),m=n.data.get(c.dataId).values;for(let b=0;b<f.length;++b){let y=b*h,v=m[y];for(let x=0;x<h;++x){let k=m[y+x];v=v&&k}f[b]=v}l!=null&&n.disposeIntermediateTensorInfo(c);let g=n.makeTensorInfo(d,c.dtype,f);if(o){let b=N.expandShapeToKeepDim(d,i),y=Et({inputs:{x:g},backend:n,attrs:{shape:b}});return n.disposeIntermediateTensorInfo(g),y}return g}var kq={kernelName:Uu,backendName:"cpu",kernelFunc:wq};function Iq(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:o}=r;we(s,"any");let i=w.parseAxisParam(a,s.shape),u=i,l=N.getAxesPermutation(u,s.shape.length),c=s;l!=null&&(c=xr({inputs:{x:s},backend:n,attrs:{perm:l}}),u=N.getInnerMostAxes(u.length,s.shape.length)),N.assertAxesAreInnerMostDims("any",u,c.shape.length);let[d,p]=N.computeOutAndReduceShapes(c.shape,u),h=w.sizeFromShape(p),f=w.makeZerosTypedArray(w.sizeFromShape(d),c.dtype),m=n.data.get(c.dataId).values;for(let b=0;b<f.length;++b){let y=b*h,v=m[y];for(let x=0;x<h;++x){let k=m[y+x];v=v||k}f[b]=v}l!=null&&n.disposeIntermediateTensorInfo(c);let g=n.makeTensorInfo(d,c.dtype,f);if(o){let b=N.expandShapeToKeepDim(d,i),y=Et({inputs:{x:g},backend:n,attrs:{shape:b}});return n.disposeIntermediateTensorInfo(g),y}return g}var Sq={kernelName:Gu,backendName:"cpu",kernelFunc:Iq};function Cq(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r;we(s,"argMax");let o=w.parseAxisParam(a,s.shape),i=N.getAxesPermutation(o,s.shape.length),u=s,l=[];i!=null&&(u=xr({inputs:{x:s},backend:n,attrs:{perm:i}}),l.push(u),o=N.getInnerMostAxes(o.length,u.shape.length)),o=[o[0]],N.assertAxesAreInnerMostDims("argMax",o,u.shape.length);let[c,d]=N.computeOutAndReduceShapes(u.shape,o),p=w.sizeFromShape(c),h=w.makeZerosTypedArray(p,"int32"),f=w.sizeFromShape(d),m=n.data.get(u.dataId).values;for(let g=0;g<h.length;++g){let b=g*f,y=m[b],v=0;for(let x=0;x<f;++x){let k=m[b+x];k>y&&(y=k,v=x)}h[g]=v}return l.forEach(g=>n.disposeIntermediateTensorInfo(g)),n.makeTensorInfo(c,"int32",h)}var Tq={kernelName:da,backendName:"cpu",kernelFunc:Cq};function Nq(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r;we(s,"argMin");let o=w.parseAxisParam(a,s.shape),i=N.getAxesPermutation(o,s.shape.length),u=s,l=[];i!=null&&(u=xr({inputs:{x:s},backend:n,attrs:{perm:i}}),l.push(u),o=N.getInnerMostAxes(o.length,u.shape.length)),o=[o[0]],N.assertAxesAreInnerMostDims("argMin",o,u.shape.length);let[c,d]=N.computeOutAndReduceShapes(u.shape,o),p=w.sizeFromShape(c),h=w.makeZerosTypedArray(p,"int32"),f=w.sizeFromShape(d),m=n.data.get(u.dataId).values;for(let g=0;g<h.length;++g){let b=g*f,y=m[b],v=0;for(let x=0;x<f;++x){let k=m[b+x];k<y&&(y=k,v=x)}h[g]=v}return l.forEach(g=>n.disposeIntermediateTensorInfo(g)),n.makeTensorInfo(c,"int32",h)}var _q={kernelName:Hu,backendName:"cpu",kernelFunc:Nq},Eq=ct(ju,e=>Math.asin(e)),Aq={kernelName:ju,backendName:"cpu",kernelFunc:Eq},$q=ct(qu,e=>Math.asinh(e)),Fq={kernelName:qu,backendName:"cpu",kernelFunc:$q},Dq=ct(Ku,e=>Math.atan(e)),Rq={kernelName:Ku,backendName:"cpu",kernelFunc:Dq},Pq=Ht((e,t)=>Math.atan2(e,t)),Oq=an(Yu,Pq),Mq={kernelName:Yu,backendName:"cpu",kernelFunc:Oq},Lq=ct(Xu,e=>Math.atanh(e)),Bq={kernelName:Xu,backendName:"cpu",kernelFunc:Lq};function Ww(e,t,n,r,s,a){let o=s.strideHeight,i=s.strideWidth,u=s.dilationHeight,l=s.dilationWidth,c=s.effectiveFilterHeight,d=s.effectiveFilterWidth,p=s.padInfo.top,h=s.padInfo.left,f=a==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=$e(s.outShape,n),g=m.values,b=s.outShape[1]*s.outShape[2]*s.outShape[3],y=s.outShape[2]*s.outShape[3],v=s.outShape[3];for(let x=0;x<s.batchSize;++x){let k=x*b,T=x*r[0];for(let C=0;C<s.inChannels;++C)for(let E=0;E<s.outHeight;++E){let F=E*o-p,O=Math.max(0,F),D=Math.min(s.inHeight,c+F),R=k+E*y;for(let _=0;_<s.outWidth;++_){let L=_*i-h,U=Math.max(0,L),j=Math.min(s.inWidth,d+L),K=f,q=0,Q=0;for(let re=O;re<D;re+=u){let se=T+re*r[1];for(let ne=U;ne<j;ne+=l){let ie=se+ne*r[2],te=e[ie+C];a==="max"&&te>K?K=te:a==="avg"&&(q+=te,Q++)}if(isNaN(K))break}let ee=R+_*v+C;g[ee]=a==="avg"?q/Q:K}}}return m}function QT(e,t,n,r,s=!1,a=!1){let o=$e(r.outShape,"int32"),i=r.strideHeight,u=r.strideWidth,l=r.dilationHeight,c=r.dilationWidth,d=r.effectiveFilterHeight,p=r.effectiveFilterWidth,h=r.padInfo.top,f=r.padInfo.left,m=$e(t,n,e);for(let g=0;g<r.batchSize;++g)for(let b=0;b<r.inChannels;++b)for(let y=0;y<r.outHeight;++y){let v=y*i-h,x=v;for(;x<0;)x+=l;let k=Math.min(r.inHeight,d+v);for(let T=0;T<r.outWidth;++T){let C=T*u-f,E=C;for(;E<0;)E+=c;let F=Math.min(r.inWidth,p+C),O=Number.NEGATIVE_INFINITY,D=-1;for(let R=x;R<k;R+=l){let _=R-v;for(let L=E;L<F;L+=c){let U=L-C,j=m.get(g,R,L,b);j>O&&(O=j,s?D=a?((g*r.inHeight+R)*r.inWidth+L)*r.inChannels+b:(R*r.inWidth+L)*r.inChannels+b:D=_*p+U)}}o.set(D,g,y,T,b)}}return o}function ZT(e,t,n,r,s,a){let o=s.strideDepth,i=s.strideHeight,u=s.strideWidth,l=s.dilationDepth,c=s.dilationHeight,d=s.dilationWidth,p=s.effectiveFilterDepth,h=s.effectiveFilterHeight,f=s.effectiveFilterWidth,m=s.padInfo.front,g=s.padInfo.top,b=s.padInfo.left,y=a==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,v=$e(s.outShape,n),x=v.values,k=s.outShape[1]*s.outShape[2]*s.outShape[3]*s.outShape[4],T=s.outShape[2]*s.outShape[3]*s.outShape[4],C=s.outShape[3]*s.outShape[4],E=s.outShape[4];for(let F=0;F<s.batchSize;++F){let O=F*k,D=F*r[0];for(let R=0;R<s.inChannels;++R)for(let _=0;_<s.outDepth;++_){let L=_*o-m,U=L;for(;U<0;)U+=l;let j=Math.min(s.inDepth,p+L),K=O+_*T;for(let q=0;q<s.outHeight;++q){let Q=q*i-g,ee=Q;for(;ee<0;)ee+=c;let re=Math.min(s.inHeight,h+Q),se=K+q*C;for(let ne=0;ne<s.outWidth;++ne){let ie=ne*u-b,te=ie;for(;te<0;)te+=d;let pe=Math.min(s.inWidth,f+ie),be=se+ne*E,Ce=y,Ie=0,Ne=0;for(let Je=U;Je<j;Je+=l){let qe=D+Je*r[1];for(let Ge=ee;Ge<re;Ge+=c){let lt=qe+Ge*r[2];for(let et=te;et<pe;et+=d){let pt=lt+et*r[3],Ct=e[pt+R];if(a==="max"&&Ct>Ce?Ce=Ct:a==="avg"&&(Ie+=Ct,Ne++),isNaN(Ce))break}if(isNaN(Ce))break}if(isNaN(Ce))break}let Le=be+R;x[Le]=a==="avg"?Ie/Ne:Ce}}}}return v}function zq(e,t){let n=$e(t.outShape,"int32"),r=t.strideDepth,s=t.strideHeight,a=t.strideWidth,o=t.dilationDepth,i=t.dilationHeight,u=t.dilationWidth,l=t.effectiveFilterDepth,c=t.effectiveFilterHeight,d=t.effectiveFilterWidth,p=t.padInfo.front,h=t.padInfo.top,f=t.padInfo.left;for(let m=0;m<t.batchSize;++m)for(let g=0;g<t.inChannels;++g)for(let b=0;b<t.outDepth;++b){let y=b*r-p,v=y;for(;v<0;)v+=o;let x=Math.min(t.inDepth,l+y);for(let k=0;k<t.outHeight;++k){let T=k*s-h,C=T;for(;C<0;)C+=i;let E=Math.min(t.inHeight,c+T);for(let F=0;F<t.outWidth;++F){let O=F*a-f,D=O;for(;D<0;)D+=u;let R=Math.min(t.inWidth,d+O),_=Number.NEGATIVE_INFINITY,L=-1;for(let U=v;U<x;U+=o){let j=U-y;for(let K=C;K<E;K+=i){let q=K-T;for(let Q=D;Q<R;Q+=u){let ee=Q-O,re=e.get(m,U,K,Q,g);re>=_&&(_=re,L=j*c*d+q*c+ee)}}}n.set(L,m,b,k,F,g)}}}return n}function Wq(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t;we(s,"avgPool");let{filterSize:a,strides:o,pad:i,dimRoundingMode:u}=r,l=1;w.assert(N.eitherStridesOrDilationsAreOne(o,l),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${l}'`);let c=N.computePool2DInfo(s.shape,a,o,l,i,u),d;if(c.filterWidth===1&&c.filterHeight===1&&w.arraysEqual(c.inShape,c.outShape))d=bs({inputs:{x:s},backend:n});else{let p=n.data.get(s.dataId).values,h=w.computeStrides(s.shape),f=Ww(p,s.shape,s.dtype,h,c,"avg");d=n.makeTensorInfo(c.outShape,s.dtype,f.values)}return d}var Vq={kernelName:pa,backendName:"cpu",kernelFunc:Wq};function Uq(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:o,pad:i,dimRoundingMode:u,dataFormat:l}=r;we(s,"avgPool3d");let c=N.computePool3DInfo(s.shape,a,o,1,i,u,l),d=n.data.get(s.dataId).values,p=ZT(d,s.shape,s.dtype,w.computeStrides(s.shape),c,"avg");return n.makeTensorInfo(p.shape,"float32",p.values)}var Gq={kernelName:jl,backendName:"cpu",kernelFunc:Uq};function Hq(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,{filterSize:o,strides:i,pad:u,dimRoundingMode:l}=r;we([s,a],"avgPool3DGrad");let c=N.computePool3DInfo(a.shape,o,i,1,u,l),d=c.strideDepth,p=c.strideHeight,h=c.strideWidth,f=c.filterDepth,m=c.filterHeight,g=c.filterWidth,b=c.dilationDepth,y=c.dilationHeight,v=c.dilationWidth,x=c.effectiveFilterDepth,k=c.effectiveFilterHeight,T=c.effectiveFilterWidth,C=x-1-c.padInfo.front,E=T-1-c.padInfo.left,F=k-1-c.padInfo.top,O=$e(a.shape,"float32"),D=1/(f*m*g),R=n.bufferSync(s);for(let _=0;_<c.batchSize;++_)for(let L=0;L<c.inChannels;++L)for(let U=0;U<c.inDepth;++U)for(let j=0;j<c.inHeight;++j)for(let K=0;K<c.inWidth;++K){let q=U-C,Q=j-F,ee=K-E,re=0;for(let se=0;se<x;se+=b){let ne=(q+se)/d;if(!(ne<0||ne>=c.outDepth||Math.floor(ne)!==ne))for(let ie=0;ie<k;ie+=y){let te=(Q+ie)/p;if(!(te<0||te>=c.outHeight||Math.floor(te)!==te))for(let pe=0;pe<T;pe+=v){let be=(ee+pe)/h;if(be<0||be>=c.outWidth||Math.floor(be)!==be)continue;re+=R.get(_,ne,te,be,L)}}}O.set(re*D,_,U,j,K,L)}return n.makeTensorInfo(O.shape,O.dtype,O.values)}var jq={kernelName:gh,backendName:"cpu",kernelFunc:Hq};function qq(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,o=a;we([s,a],"avgPoolGrad");let{filterSize:i,strides:u,pad:l}=r,c=N.computePool2DInfo(o.shape,i,u,1,l),d=c.strideHeight,p=c.strideWidth,h=c.filterHeight,f=c.filterWidth,m=c.dilationHeight,g=c.dilationWidth,b=c.effectiveFilterHeight,y=c.effectiveFilterWidth,v=y-1-c.padInfo.left,x=b-1-c.padInfo.top,k=$e(o.shape,"float32"),T=1/(h*f),C=n.data.get(s.dataId).values,E=$e(s.shape,"float32",C);for(let F=0;F<c.batchSize;++F)for(let O=0;O<c.inChannels;++O)for(let D=0;D<c.inHeight;++D)for(let R=0;R<c.inWidth;++R){let _=D-x,L=R-v,U=0;for(let j=0;j<b;j+=m){let K=(_+j)/d;if(!(K<0||K>=c.outHeight||Math.floor(K)!==K))for(let q=0;q<y;q+=g){let Q=(L+q)/p;if(Q<0||Q>=c.outWidth||Math.floor(Q)!==Q)continue;U+=E.get(F,K,Q,O)}}k.set(U*T,F,D,R,O)}return n.makeTensorInfo(k.shape,k.dtype,k.values)}var Kq={kernelName:mh,backendName:"cpu",kernelFunc:qq};function Xq(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,scale:a,offset:o,mean:i,variance:u}=t;w.assert(i.shape.length===u.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),w.assert(o==null||i.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),w.assert(a==null||i.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),we([s,i,u,a,o],"batchNorm");let{varianceEpsilon:l}=r;l==null&&(l=.001);let c=n.data.get(s.dataId).values,d=n.data.get(i.dataId).values,p=n.data.get(u.dataId).values,h=a?n.data.get(a.dataId).values:new Float32Array([1]),f=o?n.data.get(o.dataId).values:new Float32Array([0]),m=new Float32Array(c.length),g=f.length,b=h.length,y=p.length,v=d.length,x=0,k=0,T=0,C=0;for(let E=0;E<c.length;++E)m[E]=f[x++]+(c[E]-d[k++])*h[T++]/Math.sqrt(p[C++]+l),x>=g&&(x=0),k>=v&&(k=0),T>=b&&(T=0),C>=y&&(C=0);return n.makeTensorInfo(s.shape,s.dtype,m)}var Yq={kernelName:Ta,backendName:"cpu",kernelFunc:Xq};function Qq(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,crops:o}=r;we([s],"batchToSpaceND");let i=a.reduce((b,y)=>b*y),u=N.getReshaped(s.shape,a,i),l=N.getPermuted(u.length,a.length),c=N.getReshapedPermuted(s.shape,a,i),d=N.getSliceBeginCoords(o,a.length),p=N.getSliceSize(c,o,a.length),h=Et({inputs:{x:s},backend:n,attrs:{shape:u}}),f=xr({inputs:{x:h},backend:n,attrs:{perm:l}}),m=Et({inputs:{x:f},backend:n,attrs:{shape:c}}),g=eu({inputs:{x:m},backend:n,attrs:{begin:d,size:p}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}var Zq={kernelName:Uo,backendName:"cpu",kernelFunc:Qq};function Jq(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:o}=r,i=n.data.get(s.dataId).values,u=n.data.get(a.dataId).values,l=Dw(i,u,a.dtype,a.shape,o);return n.makeTensorInfo([o],a.dtype,l)}var eK={kernelName:bh,backendName:"cpu",kernelFunc:Jq};function tK(e){let{inputs:t,backend:n}=e,{s0:r,s1:s}=t,a=n.data.get(r.dataId).values,o=n.data.get(s.dataId).values,i=N.assertAndGetBroadcastShape(Array.from(a),Array.from(o));return n.makeTensorInfo([i.length],"int32",Int32Array.from(i))}var nK={kernelName:yh,backendName:"cpu",kernelFunc:tK},rK=ct(Es,(e,t)=>{let n=t;return e>n.clipValueMax?n.clipValueMax:e<n.clipValueMin?n.clipValueMin:e}),sK={kernelName:Es,backendName:"cpu",kernelFunc:rK},aK=e=>{let{x:t}=e.inputs,n=e.backend,r=new Float32Array(w.sizeFromShape(t.shape)),s=n.data.get(t.dataId),a=s.complexTensorInfos.real,o=s.complexTensorInfos.imag,i=n.data.get(a.dataId).values,u=n.data.get(o.dataId).values;for(let l=0;l<i.length;l++){let c=i[l],d=u[l];r[l]=Math.hypot(c,d)}return n.makeOutput(r,t.shape,"float32")},oK={kernelName:Kl,backendName:"cpu",kernelFunc:aK};function zc(e){let{inputs:t,backend:n}=e,{input:r}=t,s=n.data.get(r.dataId).complexTensorInfos.imag,a=n.data.get(s.dataId).values;return n.makeTensorInfo(s.shape,s.dtype,a)}var iK={kernelName:Zl,backendName:"cpu",kernelFunc:zc};function Wc(e){let{inputs:t,backend:n,attrs:r}=e,{axis:s}=r,a=w.parseAxisParam(s,t[0].shape)[0],o=N.computeOutShape(t.map(m=>m.shape),a);if(w.sizeFromShape(o)===0)return n.makeTensorInfo(o,t[0].dtype,[]);let i=t.filter(m=>w.sizeFromShape(m.shape)>0);if(i.length===1)return bs({inputs:{x:i[0]},backend:n});let u=i.map(m=>m.shape);if(N.assertParamsConsistent(u,a),i[0].dtype==="complex64"){let m=i.map(x=>Ji({inputs:{input:x},backend:n})),g=i.map(x=>zc({inputs:{input:x},backend:n})),b=Wc({inputs:m,backend:n,attrs:{axis:a}}),y=Wc({inputs:g,backend:n,attrs:{axis:a}}),v=ur({inputs:{real:b,imag:y},backend:n});return m.forEach(x=>n.disposeIntermediateTensorInfo(x)),g.forEach(x=>n.disposeIntermediateTensorInfo(x)),n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(y),v}let l=i.map(m=>{let g=w.sizeFromShape(m.shape.slice(a));return Et({inputs:{x:m},backend:n,attrs:{shape:[-1,g]}})}),c=l.map(m=>({vals:n.data.get(m.dataId).values,shape:m.shape}));o=N.computeOutShape(l.map(m=>m.shape),1);let d=l[0].shape[0]===1,p=Rw(c,o,t[0].dtype,d),h=N.computeOutShape(i.map(m=>m.shape),a),f=n.makeTensorInfo(h,t[0].dtype,p);return l.forEach(m=>n.disposeIntermediateTensorInfo(m)),f}var uK={kernelName:Go,backendName:"cpu",kernelFunc:Wc};function JT(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:o,pad:i,dataFormat:u,dilations:l,dimRoundingMode:c}=r;we([s,a],"conv2d");let d=N.convertConv2DDataFormat(u),p=N.computeConv2DInfo(s.shape,a.shape,o,l,i,c,!1,d),h=p.filterHeight,f=p.filterWidth,m=p.dilationHeight,g=p.dilationWidth,b=p.padInfo.left,y=p.padInfo.top,v=p.dataFormat==="channelsLast",x=new Kt(p.outShape,s.dtype),k=w.computeStrides(s.shape),T=w.computeStrides(a.shape),C=k[0],E=v?k[1]:k[2],F=v?k[2]:1,O=v?1:k[1],D=x.strides[0],R=v?x.strides[1]:x.strides[2],_=v?x.strides[2]:1,L=v?1:x.strides[1],U=n.data.get(s.dataId).values,j=n.data.get(a.dataId).values,K=x.values;for(let q=0;q<p.batchSize;++q){let Q=q*C,ee=q*D;for(let re=0;re<p.outHeight;++re){let se=ee+re*R,ne=re*p.strideHeight-y;for(let ie=0;ie<h;++ie){let te=ne+ie*m;if(te<0||te>=p.inHeight)continue;let pe=ie*T[0],be=Q+te*E;for(let Ce=0;Ce<p.outWidth;++Ce){let Ie=se+Ce*_,Ne=Ce*p.strideWidth-b;for(let Le=0;Le<f;++Le){let Je=Ne+Le*g;if(Je<0||Je>=p.inWidth)continue;let qe=pe+Le*T[1],Ge=be+Je*F,lt=qe;for(let et=0;et<p.inChannels;++et){let pt=U[Ge+et*O];for(let Ct=0;Ct<p.outChannels;++Ct)K[Ie+Ct*L]+=pt*j[lt+Ct];lt+=p.outChannels}}}}}}return n.makeTensorInfo(x.shape,x.dtype,K)}var cK={kernelName:ga,backendName:"cpu",kernelFunc:JT};function lK(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:o,pad:i,dataFormat:u,dimRoundingMode:l,filterShape:c}=r;we([s,a],"conv2dBackpropFilter");let d=N.convertConv2DDataFormat(u),p=N.computeConv2DInfo(s.shape,c,o,1,i,l,!1,d),{strideHeight:h,strideWidth:f,filterHeight:m,filterWidth:g}=p,b=p.dataFormat==="channelsLast",y=new Kt(p.filterShape,"float32"),v=p.padInfo.left,x=p.padInfo.top,k=n.data.get(s.dataId).values,T=n.data.get(a.dataId).values,C=new Kt(s.shape,s.dtype,k),E=new Kt(a.shape,a.dtype,T);for(let F=0;F<m;++F){let O=Math.max(0,Math.ceil((x-F)/h)),D=Math.min(p.outHeight,(p.inHeight+x-F)/h);for(let R=0;R<g;++R){let _=Math.max(0,Math.ceil((v-R)/f)),L=Math.min(p.outWidth,(p.inWidth+v-R)/f);for(let U=0;U<p.inChannels;++U)for(let j=0;j<p.outChannels;++j){let K=0;for(let q=0;q<p.batchSize;++q)for(let Q=O;Q<D;++Q){let ee=F+Q*h-x;for(let re=_;re<L;++re){let se=R+re*f-v;b?K+=C.get(q,ee,se,U)*E.get(q,Q,re,j):K+=C.get(q,U,ee,se)*E.get(q,j,Q,re)}}y.set(K,F,R,U,j)}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}var dK={kernelName:vh,backendName:"cpu",kernelFunc:lK};function pK(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{inputShape:o,strides:i,pad:u,dataFormat:l,dimRoundingMode:c}=r;we([s,a],"conv2dBackpropInput");let d=w.computeStrides(a.shape),p=w.computeStrides(s.shape),h=N.convertConv2DDataFormat(l),f=N.computeConv2DInfo(o,a.shape,i,1,u,c,!1,h),m=new Kt(f.inShape,"float32"),g=m.values,b=n.data.get(s.dataId).values,y=n.data.get(a.dataId).values,[v,x,k]=d,{batchSize:T,filterHeight:C,filterWidth:E,inChannels:F,inHeight:O,inWidth:D,outChannels:R,outHeight:_,outWidth:L,strideHeight:U,strideWidth:j}=f;h=f.dataFormat;let K=C-1-f.padInfo.top,q=E-1-f.padInfo.left,Q=h==="channelsLast",ee=m.strides[0],re=Q?m.strides[1]:m.strides[2],se=Q?m.strides[2]:1,ne=Q?1:m.strides[1],ie=p[0],te=Q?p[1]:p[2],pe=Q?p[2]:1,be=Q?1:p[1];for(let Ce=0;Ce<T;++Ce)for(let Ie=0;Ie<F;++Ie)for(let Ne=0;Ne<O;++Ne){let Le=Ne-K,Je=Math.max(0,Math.ceil(Le/U)),qe=Math.min(_,(C+Le)/U);for(let Ge=0;Ge<D;++Ge){let lt=Ge-q,et=Math.max(0,Math.ceil(lt/j)),pt=Math.min(L,(E+lt)/j),Ct=0;for(let tt=Je;tt<qe;++tt){let Qn=tt*U-Le;for(let cn=et;cn<pt;++cn){let Cr=cn*j-lt,zn=ie*Ce+te*tt+pe*cn,Zn=v*(C-1-Qn)+x*(E-1-Cr)+k*Ie;for(let dr=0;dr<R;++dr){let Tr=b[zn+be*dr],pr=y[Zn+dr];Ct+=Tr*pr}}}let Bn=ee*Ce+re*Ne+se*Ge+ne*Ie;g[Bn]=Ct}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}var hK={kernelName:ba,backendName:"cpu",kernelFunc:pK};function fK(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:o,pad:i,dilations:u}=r;we([s,a],"conv3d");let l=N.computeConv3DInfo(s.shape,a.shape,o,u,i),{filterDepth:c,filterHeight:d,filterWidth:p,dilationDepth:h,dilationHeight:f,dilationWidth:m,padInfo:g}=l,b=g.front,y=g.left,v=g.top,x=new Kt(l.outShape,s.dtype),k=n.data.get(s.dataId).values,T=n.data.get(a.dataId).values,C=x.values,E=w.computeStrides(s.shape),F=w.computeStrides(a.shape);for(let O=0;O<l.batchSize;++O){let D=O*E[0],R=O*x.strides[0];for(let _=0;_<l.outDepth;++_){let L=R+_*x.strides[1],U=_*l.strideDepth-b;for(let j=0;j<c;++j){let K=U+j*h;if(K<0||K>=l.inDepth)continue;let q=j*F[0],Q=D+K*E[1];for(let ee=0;ee<l.outHeight;++ee){let re=L+ee*x.strides[2],se=ee*l.strideHeight-v;for(let ne=0;ne<d;++ne){let ie=se+ne*f;if(ie<0||ie>=l.inHeight)continue;let te=q+ne*F[1],pe=Q+ie*E[2];for(let be=0;be<l.outWidth;++be){let Ce=re+be*l.outChannels,Ie=be*l.strideWidth-y;for(let Ne=0;Ne<p;++Ne){let Le=Ie+Ne*m;if(Le<0||Le>=l.inWidth)continue;let Je=te+Ne*F[2],qe=pe+Le*l.inChannels,Ge=Je;for(let lt=0;lt<l.inChannels;++lt){let et=k[qe+lt];for(let pt=0;pt<l.outChannels;++pt)C[Ce+pt]+=et*T[Ge+pt];Ge+=l.outChannels}}}}}}}}return n.makeTensorInfo(x.shape,x.dtype,x.values)}var mK={kernelName:Xl,backendName:"cpu",kernelFunc:fK};function gK(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:o,pad:i,filterShape:u}=r;we([s,a],"conv3dBackpropFilterV2");let l=w.computeStrides(s.shape),c=w.computeStrides(a.shape),d=N.computeConv3DInfo(s.shape,u,o,1,i),p=d.strideDepth,h=d.strideHeight,f=d.strideWidth,m=d.filterDepth,g=d.filterHeight,b=d.filterWidth,y=new Kt(d.filterShape,"float32"),v=y.values,[x,k,T,C]=y.strides,E=n.data.get(a.dataId).values,[F,O,D,R]=c,_=n.data.get(s.dataId).values,[L,U,j,K]=l,q=d.padInfo.front,Q=d.padInfo.left,ee=d.padInfo.top;for(let re=0;re<m;++re){let se=Math.max(0,Math.ceil((q-re)/p)),ne=Math.min(d.outDepth,(d.inDepth+q-re)/p),ie=re*x;for(let te=0;te<g;++te){let pe=Math.max(0,Math.ceil((ee-te)/h)),be=Math.min(d.outHeight,(d.inHeight+ee-te)/h),Ce=te*k+ie;for(let Ie=0;Ie<b;++Ie){let Ne=Math.max(0,Math.ceil((Q-Ie)/f)),Le=Math.min(d.outWidth,(d.inWidth+Q-Ie)/f),Je=Ie*T+Ce;for(let qe=0;qe<d.inChannels;++qe){let Ge=qe*C+Je;for(let lt=0;lt<d.outChannels;++lt){let et=0;for(let pt=0;pt<d.batchSize;++pt){let Ct=pt*L,Bn=pt*F;for(let tt=se;tt<ne;++tt){let cn=(re+tt*p-q)*U+Ct,Cr=tt*O+Bn;for(let zn=pe;zn<be;++zn){let dr=(te+zn*h-ee)*j+cn,Tr=zn*D+Cr;for(let pr=Ne;pr<Le;++pr){let Js=(Ie+pr*f-Q)*K+dr,bn=pr*R+Tr;et+=_[Js+qe]*E[bn+lt]}}}}v[Ge+lt]=et}}}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}var bK={kernelName:xh,backendName:"cpu",kernelFunc:gK};function yK(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{pad:o,strides:i,inputShape:u}=r;we([s],"conv3dBackpropInputV2");let l=w.computeStrides(s.shape),c=w.computeStrides(a.shape),d=N.computeConv3DInfo(u,a.shape,i,1,o),p=new Kt(d.inShape,"float32"),h=p.values,[f,m,g,b]=p.strides,y=n.data.get(s.dataId).values,[v,x,k,T]=l,C=n.data.get(a.dataId).values,[E,F,O,D]=c,{batchSize:R,filterDepth:_,filterHeight:L,filterWidth:U,inChannels:j,inDepth:K,inHeight:q,inWidth:Q,outChannels:ee,outDepth:re,outHeight:se,outWidth:ne,strideDepth:ie,strideHeight:te,strideWidth:pe}=d,be=_-1-d.padInfo.front,Ce=L-1-d.padInfo.top,Ie=U-1-d.padInfo.left;for(let Ne=0;Ne<R;++Ne)for(let Le=0;Le<j;++Le)for(let Je=0;Je<K;++Je){let qe=Je-be,Ge=Math.max(0,Math.ceil(qe/ie)),lt=Math.min(re,(_+qe)/ie);for(let et=0;et<q;++et){let pt=et-Ce,Ct=Math.max(0,Math.ceil(pt/te)),Bn=Math.min(se,(L+pt)/te);for(let tt=0;tt<Q;++tt){let Qn=tt-Ie,cn=Math.max(0,Math.ceil(Qn/pe)),Cr=Math.min(ne,(U+Qn)/pe),zn=0;for(let Zn=Ge;Zn<lt;++Zn){let dr=Zn*ie-qe;for(let Tr=Ct;Tr<Bn;++Tr){let pr=Tr*te-pt;for(let Wn=cn;Wn<Cr;++Wn){let Js=Wn*pe-Qn,bn=v*Ne+x*Zn+k*Tr+T*Wn,ea=E*(_-1-dr)+F*(L-1-pr)+O*(U-1-Js)+D*Le;for(let hr=0;hr<ee;++hr){let El=y[bn+hr],Al=C[ea+hr];zn+=El*Al}}}}h[f*Ne+m*Je+g*et+b*tt+Le]=zn}}}return n.makeTensorInfo(p.shape,p.dtype,p.values)}var vK={kernelName:wh,backendName:"cpu",kernelFunc:yK},xK=ct(ya,e=>Math.cos(e)),wK={kernelName:ya,backendName:"cpu",kernelFunc:xK},kK=ct(va,e=>Math.cosh(e)),IK={kernelName:va,backendName:"cpu",kernelFunc:kK};function SK(e){let{inputs:t,backend:n,attrs:r}=e,{image:s,boxes:a,boxInd:o}=t,{cropSize:i,method:u,extrapolationValue:l}=r,[c,d,p,h]=s.shape,f=a.shape[0],[m,g]=i,b=$e([f,m,g,h],"float32"),y=n.data.get(a.dataId).values,v=n.data.get(o.dataId).values,x=n.data.get(s.dataId).values,k=w.computeStrides(s.shape),T=w.computeStrides(b.shape);for(let C=0;C<f;C++){let E=C*4,F=y[E],O=y[E+1],D=y[E+2],R=y[E+3],_=v[C];if(_>=c)continue;let L=m>1?(D-F)*(d-1)/(m-1):0,U=g>1?(R-O)*(p-1)/(g-1):0;for(let j=0;j<m;j++){let K=m>1?F*(d-1)+j*L:.5*(F+D)*(d-1);if(K<0||K>d-1){for(let q=0;q<g;q++)for(let Q=0;Q<h;Q++){let ee=Q+q*T[2]+j*T[1]+C*T[0];b.values[ee]=l}continue}if(u==="bilinear"){let q=Math.floor(K),Q=Math.ceil(K),ee=K-q;for(let re=0;re<g;re++){let se=g>1?O*(p-1)+re*U:.5*(O+R)*(p-1);if(se<0||se>p-1){for(let pe=0;pe<h;pe++){let be=pe+re*T[2]+j*T[1]+C*T[0];b.values[be]=l}continue}let ne=Math.floor(se),ie=Math.ceil(se),te=se-ne;for(let pe=0;pe<h;pe++){let be=pe+ne*k[2]+q*k[1]+_*k[0],Ce=x[be];be=pe+ie*k[2]+q*k[1]+_*k[0];let Ie=x[be];be=pe+ne*k[2]+Q*k[1]+_*k[0];let Ne=x[be];be=pe+ie*k[2]+Q*k[1]+_*k[0];let Le=x[be],Je=Ce+(Ie-Ce)*te,qe=Ne+(Le-Ne)*te;be=pe+re*T[2]+j*T[1]+C*T[0],b.values[be]=Je+(qe-Je)*ee}}}else for(let q=0;q<g;++q){let Q=g>1?O*(p-1)+q*U:.5*(O+R)*(p-1);if(Q<0||Q>p-1){for(let se=0;se<h;se++){let ne=se+q*T[2]+j*T[1]+C*T[0];b.values[ne]=l}continue}let ee=Math.round(Q),re=Math.round(K);for(let se=0;se<h;se++){let ne=se+ee*k[2]+re*k[1]+_*k[0],ie=se+q*T[2]+j*T[1]+C*T[0];b.values[ie]=x[ne]}}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}var CK={kernelName:jo,backendName:"cpu",kernelFunc:SK};function TK(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:o,reverse:i}=r;we(s,"cumsum");let u=N.getAxesPermutation([a],s.shape.length),l=s;u!=null&&(l=xr({inputs:{x:s},backend:n,attrs:{perm:u}}));let c=N.getInnerMostAxes(1,s.shape.length)[0];if(c!==l.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${l.shape.length-1} but got axis=${c}`);let d=In(l.dtype,"int32"),p=w.makeZerosTypedArray(w.sizeFromShape(l.shape),d),h=n.data.get(l.dataId).values,f=l.shape[l.shape.length-1],m=i?(b,y)=>b+f-y-1:(b,y)=>b+y;for(let b=0;b<h.length;b+=f)for(let y=0;y<f;y++){let v=m(b,y);if(y===0)p[v]=o?0:h[v];else{let x=m(b,y-1);p[v]=o?h[x]+p[x]:h[v]+p[x]}}let g=n.makeTensorInfo(l.shape,d,p);if(u!=null){let b=N.getUndoAxesPermutation(u),y=xr({inputs:{x:g},backend:n,attrs:{perm:b}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(l),y}return g}var NK={kernelName:Ho,backendName:"cpu",kernelFunc:TK};function _K(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:o,binaryOutput:i}=r;if(s.shape.length===1){let u=n.data.get(s.dataId).values,l=n.data.get(a.dataId).values,c=Dw(u,l,a.dtype,a.shape,o);return n.makeTensorInfo([o],a.dtype,c)}else if(s.shape.length===2){let u=n.bufferSync(s),l=n.bufferSync(a),c=cT(u,l,o,i);return n.makeTensorInfo(c.shape,a.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}var EK={kernelName:kh,backendName:"cpu",kernelFunc:_K};function AK(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockSize:a,dataFormat:o}=r;w.assert(o==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${o}`);let i=s.shape[0],u=s.shape[1],l=s.shape[2],c=s.shape[3],d=u*a,p=l*a,h=c/(a*a),f=n.data.get(s.dataId).values,m=new Float32Array(i*d*p*h),g=0;for(let b=0;b<i;++b)for(let y=0;y<d;++y){let v=Math.floor(y/a),x=y%a;for(let k=0;k<p;++k){let T=Math.floor(k/a),C=k%a,E=(x*a+C)*h;for(let F=0;F<h;++F){let D=F+E+c*(T+l*(v+u*b));m[g++]=f[D]}}}return n.makeTensorInfo([i,d,p,h],s.dtype,m)}var $K={kernelName:qo,backendName:"cpu",kernelFunc:AK};function eN(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:o,pad:i,dilations:u,dimRoundingMode:l}=r;we([s,a],"depthwiseConv2DNative");let c=w.computeStrides(s.shape),d=w.computeStrides(a.shape),p=u;p==null&&(p=[1,1]),w.assert(N.eitherStridesOrDilationsAreOne(o,p),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${p}'`);let h=N.computeConv2DInfo(s.shape,a.shape,o,p,i,l,!0),{filterHeight:f,filterWidth:m,dilationHeight:g,dilationWidth:b,padInfo:y}=h,v=y.left,x=y.top,k=h.outChannels/h.inChannels,T=new Kt(h.outShape,s.dtype),C=n.data.get(s.dataId).values,E=n.data.get(a.dataId).values,F=T.values;for(let O=0;O<h.batchSize;++O){let D=O*c[0],R=O*T.strides[0];for(let _=0;_<h.outHeight;++_){let L=R+_*T.strides[1],U=_*h.strideHeight-x;for(let j=0;j<f;++j){let K=U+j*g;if(K<0||K>=h.inHeight)continue;let q=j*d[0],Q=D+K*c[1];for(let ee=0;ee<h.outWidth;++ee){let re=L+ee*T.strides[2],se=ee*h.strideWidth-v;for(let ne=0;ne<m;++ne){let ie=se+ne*b;if(ie<0||ie>=h.inWidth)continue;let te=q+ne*d[1],pe=Q+ie*h.inChannels,be=re,Ce=te;for(let Ie=0;Ie<h.inChannels;++Ie){let Ne=C[pe+Ie];for(let Le=0;Le<k;++Le)F[be+Le]+=Ne*E[Ce+Le];be+=k,Ce+=k}}}}}}return n.makeTensorInfo(T.shape,T.dtype,T.values)}var FK={kernelName:xa,backendName:"cpu",kernelFunc:eN};function DK(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:o,dilations:i,pad:u,dimRoundingMode:l,filterShape:c}=r;we([s,a],"depthwiseConv2dNativeBackpropFilter");let d=N.computeConv2DInfo(s.shape,c,o,i,u,l,!0),{strideHeight:p,strideWidth:h,filterHeight:f,filterWidth:m}=d,g=new Kt(d.filterShape,"float32"),b=d.padInfo.left,y=d.padInfo.top,v=d.outChannels/d.inChannels,x=n.data.get(s.dataId).values,k=new Kt(s.shape,s.dtype,x),T=n.data.get(a.dataId).values,C=new Kt(a.shape,a.dtype,T);for(let E=0;E<f;++E){let F=Math.max(0,Math.ceil((y-E)/p)),O=Math.min(d.outHeight,(d.inHeight+y-E)/p);for(let D=0;D<m;++D){let R=Math.max(0,Math.ceil((b-D)/h)),_=Math.min(d.outWidth,(d.inWidth+b-D)/h);for(let L=0;L<d.outChannels;++L){let U=Math.trunc(L/v),j=L%v,K=0;for(let q=0;q<d.batchSize;++q)for(let Q=F;Q<O;++Q){let ee=E+Q*p-y;for(let re=R;re<_;++re){let se=D+re*h-b;K+=k.get(q,ee,se,U)*C.get(q,Q,re,L)}}g.set(K,E,D,U,j)}}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}var RK={kernelName:Ih,backendName:"cpu",kernelFunc:DK};function PK(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{strides:o,dilations:i,pad:u,dimRoundingMode:l,inputShape:c}=r;we([s,a],"depthwiseConv2DNativeBackpropInput");let d=w.computeStrides(s.shape),p=w.computeStrides(a.shape),h=N.computeConv2DInfo(c,a.shape,o,i,u,l,!0),f=new Kt(h.inShape,"float32"),m=f.values,[g,b,y]=f.strides,v=n.data.get(s.dataId).values,[x,k,T]=d,C=n.data.get(a.dataId).values,[E,F,O]=p,{batchSize:D,filterHeight:R,filterWidth:_,inChannels:L,inHeight:U,inWidth:j,outChannels:K,outHeight:q,outWidth:Q,strideHeight:ee,strideWidth:re}=h,se=R-1-h.padInfo.top,ne=_-1-h.padInfo.left,ie=K/L;for(let te=0;te<D;++te)for(let pe=0;pe<L;++pe)for(let be=0;be<U;++be){let Ce=be-se,Ie=Math.max(0,Math.ceil(Ce/ee)),Ne=Math.min(q,(R+Ce)/ee);for(let Le=0;Le<j;++Le){let Je=Le-ne,qe=Math.max(0,Math.ceil(Je/re)),Ge=Math.min(Q,(_+Je)/re),lt=0;for(let et=Ie;et<Ne;++et){let pt=et*ee-Ce;for(let Ct=qe;Ct<Ge;++Ct){let Bn=Ct*re-Je,tt=x*te+k*et+T*Ct,Qn=E*(R-1-pt)+F*(_-1-Bn)+O*pe;for(let cn=0;cn<ie;++cn){let Cr=pe*ie+cn,zn=v[tt+Cr],Zn=C[Qn+cn];lt+=zn*Zn}}}m[g*te+b*be+y*Le+pe]=lt}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}var OK={kernelName:Sh,backendName:"cpu",kernelFunc:PK};function MK(e){let{inputs:t,backend:n}=e,{x:r}=t,s=w.sizeFromShape(r.shape),a=n.data.get(r.dataId).values,o=$e([s,s],r.dtype),i=o.values;for(let l=0;l<a.length;l++)i[l*s+l]=a[l];let u=[...r.shape,...r.shape];return n.makeTensorInfo(u,o.dtype,o.values)}var LK={kernelName:Ch,backendName:"cpu",kernelFunc:MK},BK={kernelName:Yl,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:r,filter:s}=e,{strides:a,pad:o,dilations:i}=n,u=t,l=u.data.get(r.dataId).values,c=r.shape.length,d=u.data.get(s.dataId).values,p=s.shape.length,{batchSize:h,inHeight:f,inWidth:m,inChannels:g,outHeight:b,outWidth:y,padInfo:v,strideHeight:x,strideWidth:k,filterHeight:T,filterWidth:C,dilationHeight:E,dilationWidth:F,outShape:O}=N.computeDilation2DInfo(r.shape,s.shape,a,o,"NHWC",i),D=w.sizeFromShape(O),R=O.length,_=w.getArrayFromDType(r.dtype,D);for(let U=0;U<h;++U)for(let j=0;j<b;++j){let K=j*x-v.top;for(let q=0;q<y;++q){let Q=q*k-v.left;for(let ee=0;ee<g;++ee){let re=Number.MIN_SAFE_INTEGER;for(let ne=0;ne<T;++ne){let ie=K+ne*E;if(ie>=0&&ie<f)for(let te=0;te<C;++te){let pe=Q+te*F;if(pe>=0&&pe<m){let be=w.locToIndex([U,ie,pe,ee],c,w.computeStrides(r.shape)),Ce=w.locToIndex([ne,te,ee],p,w.computeStrides(s.shape)),Ie=l[be]+d[Ce];Ie>re&&(re=Ie)}}}let se=w.locToIndex([U,j,q,ee],R,w.computeStrides(O));_[se]=re}}}return{dataId:u.write(w.toTypedArray(_,r.dtype),O,r.dtype),shape:O,dtype:r.dtype}}},zK={kernelName:Nh,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:r,filter:s,dy:a}=e,{strides:o,pad:i,dilations:u}=n,l=t,c=w.toNestedArray(r.shape,l.data.get(r.dataId).values),d=w.toNestedArray(s.shape,l.data.get(s.dataId).values),{batchSize:p,inHeight:h,inWidth:f,inChannels:m,outHeight:g,outWidth:b,padInfo:y,strideHeight:v,strideWidth:x,filterHeight:k,filterWidth:T,dilationHeight:C,dilationWidth:E,outShape:F}=N.computeDilation2DInfo(r.shape,s.shape,o,i,"NHWC",u);w.assert(a.rank===F.length,()=>`Error in ${Nh}, dy must have the same rank as output ${F.length}, but got ${a.rank}`);let O=w.toNestedArray(F,l.data.get(a.dataId).values),D=w.makeZerosNestedTypedArray(s.shape,s.dtype);for(let _=0;_<p;++_)for(let L=0;L<g;++L){let U=L*v-y.top;for(let j=0;j<b;++j){let K=j*x-y.left;for(let q=0;q<m;++q){let Q=Number.MIN_SAFE_INTEGER,ee=0,re=0;for(let se=0;se<k;++se){let ne=U+se*C;if(ne>=0&&ne<h)for(let ie=0;ie<T;++ie){let te=K+ie*E;if(te>=0&&te<f){let pe=c[_][ne][te][q]+d[se][ie][q];pe>Q&&(Q=pe,ee=se,re=ie)}}}D[ee][re][q]+=O[_][L][j][q]}}}return{dataId:l.write(w.toTypedArray(D,r.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},WK={kernelName:Th,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:r,filter:s,dy:a}=e,{strides:o,pad:i,dilations:u}=n,l=t,c=w.toNestedArray(r.shape,l.data.get(r.dataId).values),d=w.toNestedArray(s.shape,l.data.get(s.dataId).values),{batchSize:p,inHeight:h,inWidth:f,inChannels:m,outHeight:g,outWidth:b,padInfo:y,strideHeight:v,strideWidth:x,filterHeight:k,filterWidth:T,dilationHeight:C,dilationWidth:E,outShape:F}=N.computeDilation2DInfo(r.shape,s.shape,o,i,"NHWC",u);w.assert(a.rank===F.length,()=>`Error in ${Th}, dy must have the same rank as output ${F.length}, but got ${a.rank}`);let O=w.toNestedArray(F,l.data.get(a.dataId).values),D=w.makeZerosNestedTypedArray(r.shape,r.dtype);for(let _=0;_<p;++_)for(let L=0;L<g;++L){let U=L*v-y.top;for(let j=0;j<b;++j){let K=j*x-y.left;for(let q=0;q<m;++q){let Q=Number.MIN_SAFE_INTEGER,ee=U<0?0:U,re=K<0?0:K;for(let se=0;se<k;++se){let ne=U+se*C;if(ne>=0&&ne<h)for(let ie=0;ie<T;++ie){let te=K+ie*E;if(te>=0&&te<f){let pe=c[_][ne][te][q]+d[se][ie][q];pe>Q&&(Q=pe,ee=ne,re=te)}}}D[_][ee][re][q]+=O[_][L][j][q]}}}return{dataId:l.write(w.toTypedArray(D,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};function ep(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:o}=r;we(s,"sum");let i;s.dtype==="bool"?i=So({inputs:{x:s},backend:n,attrs:{dtype:"int32"}}):i=bs({inputs:{x:s},backend:n});let u=i.shape.length,l=w.parseAxisParam(a,i.shape),c=N.getAxesPermutation(l,u),d=l,p=i;c!=null&&(p=xr({inputs:{x:i},backend:n,attrs:{perm:c}}),d=N.getInnerMostAxes(d.length,u)),N.assertAxesAreInnerMostDims("sum",d,p.shape.length);let[h,f]=N.computeOutAndReduceShapes(p.shape,d),m=N.upcastType(p.dtype,"int32"),g=mm(n,h,m),b=w.sizeFromShape(f),y=n.data.get(g.dataId).values,v=n.data.get(p.dataId).values;for(let x=0;x<y.length;++x){let k=x*b,T=0;for(let C=0;C<b;++C)T+=v[k+C];y[x]=T}if(o){let x=N.expandShapeToKeepDim(g.shape,l),k=g;g=Et({inputs:{x:g},backend:n,attrs:{shape:x}}),n.disposeIntermediateTensorInfo(k)}return n.disposeIntermediateTensorInfo(i),c!=null&&n.disposeIntermediateTensorInfo(p),g}var VK={kernelName:Ka,backendName:"cpu",kernelFunc:ep};function UK(e){let{inputs:t,backend:n,attrs:r}=e,{equation:s}=r,a=t,{allDims:o,summedDims:i,idDims:u}=N.decodeEinsumEquation(s,a.length);N.checkEinsumDimSizes(o.length,u,a);let{path:l,steps:c}=N.getEinsumComputePath(i,u),d=c.length,p=null,h=o.length,f=[];for(let m=0;m<d;++m){for(let g of c[m]){let{permutationIndices:b,expandDims:y}=N.getEinsumPermutation(h,u[g]),v;N.isIdentityPermutation(b)?v=a[g]:(v=xr({inputs:{x:a[g]},backend:n,attrs:{perm:b}}),f.push(v));let x=v.shape.slice();for(let k=0;k<y.length;++k)x.splice(y[k],0,1);w.arraysEqual(v.shape,x)||(v=Et({inputs:{x:v},backend:n,attrs:{shape:x}}),f.push(v)),p===null?p=v:(p=gm({inputs:{a:v,b:p},backend:n}),f.push(p))}m<d-1&&(l[m]>=0&&(p=ep({inputs:{x:p},backend:n,attrs:{axis:l[m]-(o.length-h),keepDims:!1}}),f.push(p)),h--)}for(let m of f)m!==p&&n.disposeIntermediateTensorInfo(m);return p}var GK={kernelName:Ql,backendName:"cpu",kernelFunc:UK};function HK(e){let{inputs:t,backend:n}=e,{dy:r,y:s}=t;we([r,s],"eluGrad");let a=new Float32Array(w.sizeFromShape(s.shape)),o=n.data.get(s.dataId).values,i=n.data.get(r.dataId).values;for(let u=0;u<o.length;++u){let l=o[u];l>=1?a[u]=i[u]:a[u]=i[u]*(l+1)}return n.makeTensorInfo(s.shape,"float32",a)}var jK={kernelName:_h,backendName:"cpu",kernelFunc:HK},qK=N.ERF_P,KK=N.ERF_A1,XK=N.ERF_A2,YK=N.ERF_A3,QK=N.ERF_A4,ZK=N.ERF_A5,JK=ct(Qu,e=>{let t=Math.sign(e),n=Math.abs(e),r=1/(1+qK*n);return t*(1-((((ZK*r+QK)*r+YK)*r+XK)*r+KK)*r*Math.exp(-n*n))}),e8={kernelName:Qu,backendName:"cpu",kernelFunc:JK};function ym(e){let{inputs:t,backend:n,attrs:r}=e,{input:s}=t,{dim:a}=r,o=s.shape.length,i=s.shape.slice(),u=a;return a<0&&(w.assert(-(o+1)<=a,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),u=o+a+1),i.splice(u,0,1),Et({inputs:{x:s},backend:n,attrs:{shape:i}})}var t8={kernelName:Xo,backendName:"cpu",kernelFunc:ym},n8=Ht((e,t)=>e/t),Vw=an(wa,n8),Uw={kernelName:wa,backendName:"cpu",kernelFunc:Vw};function tN(e,t,n){let r=e.shape,s=r[0],a=r[1],o=n.data.get(e.dataId),i=o.complexTensorInfos.real,u=o.complexTensorInfos.imag,l=[s,a],c=w.sizeFromShape(l),d=w.getTypedArrayFromDType("float32",c),p=w.getTypedArrayFromDType("float32",c);for(let g=0;g<s;g++){let b=eu({inputs:{x:i},backend:n,attrs:{begin:[g,0],size:[1,a]}}),y=eu({inputs:{x:u},backend:n,attrs:{begin:[g,0],size:[1,a]}}),v=ur({inputs:{real:b,imag:y},backend:n}),{real:x,imag:k}=r8(v,t,n),T=N.mergeRealAndImagArrays(x,k);for(let C=0;C<a;C++){let E=N.getComplexWithIndex(T,C);d[g*a+C]=E.real,p[g*a+C]=E.imag}n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(v)}let h=n.makeTensorInfo(l,"float32",d),f=n.makeTensorInfo(l,"float32",p),m=ur({inputs:{real:h,imag:f},backend:n});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(f),m}function r8(e,t,n){let r=w.sizeFromShape(e.shape),s=n.data.get(e.dataId),a=n.data.get(s.complexTensorInfos.real.dataId).values,o=n.data.get(s.complexTensorInfos.imag.dataId).values;if(s8(r)){let i=Gw(a,o,r,t,n),u=[e.shape[0],e.shape[1]];if(t){let l=n.makeTensorInfo(u,"float32",i.real),c=n.makeTensorInfo(u,"float32",i.imag),d=n.makeTensorInfo([],"float32",w.createScalarValue(r,"float32")),p=bs({inputs:{x:d},backend:n}),h=Uw.kernelFunc({inputs:{a:l,b:d},backend:n}),f=Uw.kernelFunc({inputs:{a:c,b:p},backend:n}),m=n.data.get(h.dataId).values,g=n.data.get(f.dataId).values;return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(f),{real:m,imag:g}}return i}else{let i=N.mergeRealAndImagArrays(a,o),u=a8(i,r,t);return N.splitRealAndImagArrays(u)}}function s8(e){return(e&e-1)==0}function Gw(e,t,n,r,s){if(n===1)return{real:e,imag:t};let a=N.mergeRealAndImagArrays(e,t),o=n/2,i=N.complexWithEvenIndex(a),u=i.real,l=i.imag,c=[u.length],d=s.makeTensorInfo(c,"float32",u),p=s.makeTensorInfo(c,"float32",l),h=ur({inputs:{real:d,imag:p},backend:s}),f=N.complexWithOddIndex(a),m=f.real,g=f.imag,b=[m.length],y=s.makeTensorInfo(b,"float32",m),v=s.makeTensorInfo(b,"float32",g),x=ur({inputs:{real:y,imag:v},backend:s}),k=Gw(u,l,o,r,s),T=k.real,C=k.imag,E=[T.length],F=s.makeTensorInfo(E,"float32",T),O=s.makeTensorInfo(E,"float32",C),D=ur({inputs:{real:F,imag:O},backend:s}),R=Gw(m,g,o,r,s),_=R.real,L=R.imag,U=[_.length],j=s.makeTensorInfo(U,"float32",_),K=s.makeTensorInfo(U,"float32",L),q=ur({inputs:{real:j,imag:K},backend:s}),Q=N.exponents(n,r),ee=[Q.real.length],re=s.makeTensorInfo(ee,"float32",Q.real),se=s.makeTensorInfo(ee,"float32",Q.imag),ne=ur({inputs:{real:re,imag:se},backend:s}),ie=gm({inputs:{a:ne,b:q},backend:s}),te=Zd({inputs:{a:D,b:ie},backend:s}),pe=Bw({inputs:{a:D,b:ie},backend:s}),be=Ji({inputs:{input:te},backend:s}),Ce=Ji({inputs:{input:pe},backend:s}),Ie=zc({inputs:{input:te},backend:s}),Ne=zc({inputs:{input:pe},backend:s}),Le=Wc({inputs:[be,Ce],backend:s,attrs:{axis:0}}),Je=Wc({inputs:[Ie,Ne],backend:s,attrs:{axis:0}}),qe=s.data.get(Le.dataId).values,Ge=s.data.get(Je.dataId).values;return s.disposeIntermediateTensorInfo(d),s.disposeIntermediateTensorInfo(p),s.disposeIntermediateTensorInfo(h),s.disposeIntermediateTensorInfo(y),s.disposeIntermediateTensorInfo(v),s.disposeIntermediateTensorInfo(x),s.disposeIntermediateTensorInfo(F),s.disposeIntermediateTensorInfo(O),s.disposeIntermediateTensorInfo(D),s.disposeIntermediateTensorInfo(j),s.disposeIntermediateTensorInfo(K),s.disposeIntermediateTensorInfo(q),s.disposeIntermediateTensorInfo(re),s.disposeIntermediateTensorInfo(se),s.disposeIntermediateTensorInfo(ne),s.disposeIntermediateTensorInfo(ie),s.disposeIntermediateTensorInfo(te),s.disposeIntermediateTensorInfo(pe),s.disposeIntermediateTensorInfo(be),s.disposeIntermediateTensorInfo(Ie),s.disposeIntermediateTensorInfo(Ce),s.disposeIntermediateTensorInfo(Ne),s.disposeIntermediateTensorInfo(Le),s.disposeIntermediateTensorInfo(Je),{real:qe,imag:Ge}}function a8(e,t,n){let r=new Float32Array(t*2);for(let s=0;s<t;s++){let a=0,o=0;for(let i=0;i<t;i++){let u=N.exponent(s*i,t,n),l=N.getComplexWithIndex(e,i);a+=l.real*u.real-l.imag*u.imag,o+=l.real*u.imag+l.imag*u.real}n&&(a/=t,o/=t),N.assignToTypedArray(r,a,o,s)}return r}function o8(e){let{inputs:t,backend:n}=e,{input:r}=t,s=w.sizeFromShape(r.shape),a=r.shape[r.shape.length-1],o=s/a,i=Et({inputs:{x:r},backend:n,attrs:{shape:[o,a]}}),u=tN(i,!1,n),l=Et({inputs:{x:u},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(u),l}var i8={kernelName:Eh,backendName:"cpu",kernelFunc:o8};function Hw(e){let{backend:t,attrs:n}=e,{shape:r,value:s,dtype:a}=n,o=a||w.inferDtype(s),i=w.getArrayFromDType(o,w.sizeFromShape(r));return c8(i,s,o),t.makeTensorInfo(r,o,i)}var u8={kernelName:Zu,backendName:"cpu",kernelFunc:Hw};function c8(e,t,n){e.fill(t)}var l8={kernelName:Qo,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{image:r}=e,s=n,a=w.getTypedArrayFromDType(r.dtype,w.sizeFromShape(r.shape)),[o,i,u,l]=r.shape,c=s.data.get(r.dataId).values;for(let p=0;p<o;p++){let h=p*u*i*l;for(let f=0;f<i;f++){let m=f*(u*l);for(let g=0;g<u;g++){let b=g*l;for(let y=0;y<l;y++){let v=Math.round(u-g-1),x=h+m+b+y,k=c[x];if(v>=0&&v<u){let T=v*l,C=h+m+T+y;k=c[C]}a[x]=k}}}}return{dataId:s.write(a,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},d8=Ht((e,t)=>Math.floor(e/t)),p8=an(Ca,d8,null,"int32"),h8={kernelName:Ca,backendName:"cpu",kernelFunc:p8};function f8(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:o,preluActivationWeights:i}=t,{strides:u,pad:l,dataFormat:c,dilations:d,dimRoundingMode:p,activation:h,leakyreluAlpha:f}=r,m=JT({inputs:{x:s,filter:a},backend:n,attrs:{strides:u,pad:l,dataFormat:c,dilations:d,dimRoundingMode:p}});if(o){let g=m;m=Zd({inputs:{a:m,b:o},backend:n}),n.disposeIntermediateTensorInfo(g)}if(h){let g=m;m=zw(n,m,h,i,f),n.disposeIntermediateTensorInfo(g)}return m}var m8={kernelName:no,backendName:"cpu",kernelFunc:f8};function g8(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:o,preluActivationWeights:i}=t,{strides:u,pad:l,dataFormat:c,dilations:d,dimRoundingMode:p,activation:h,leakyreluAlpha:f}=r,m=eN({inputs:{x:s,filter:a},backend:n,attrs:{strides:u,pad:l,dataFormat:c,dilations:d,dimRoundingMode:p}});if(o){let g=m;m=Zd({inputs:{a:m,b:o},backend:n}),n.disposeIntermediateTensorInfo(g)}if(h){let g=m;m=zw(n,m,h,i,f),n.disposeIntermediateTensorInfo(g)}return m}var b8={kernelName:ro,backendName:"cpu",kernelFunc:g8};function y8(e){let{inputs:t,backend:n}=e,{params:r,indices:s}=t,a=w.sizeFromShape(r.shape),o=s.shape,i=o[o.length-1],[u,l,c,d]=N.prepareAndValidate(r,s);if(l===0)return n.makeTensorInfo(u,r.dtype,[]);let p=n.data.get(s.dataId).values,h=n.bufferSync(r),f=bT(p,h,r.dtype,l,i,c,d,r.shape,a);return n.makeTensorInfo(u,r.dtype,f.values)}var v8={kernelName:Jo,backendName:"cpu",kernelFunc:y8};function x8(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,indices:a}=t,{axis:o,batchDims:i}=r;we([s,a],"gatherV2");let u=w.parseAxisParam(o,s.shape)[0],l=n.data.get(a.dataId).values,c=s.shape[u];for(let x=0;x<l.length;++x){let k=l[x];w.assert(k<=c-1&&k>=0,()=>`GatherV2: the index value ${k} is not in [0, ${c-1}]`)}let d=i;i==null&&(d=0);let p=w.sizeFromShape(a.shape),h=N.segment_util.collectGatherOpShapeInfo(s,a,u,d),f=Et({inputs:{x:s},backend:n,attrs:{shape:[h.batchSize,h.outerSize,h.dimSize,h.sliceSize]}}),m=Et({inputs:{x:a},backend:n,attrs:{shape:[h.batchSize,p/h.batchSize]}}),g=[h.batchSize,h.outerSize,p/h.batchSize,h.sliceSize],b=n.bufferSync(m),y=n.bufferSync(f),v=yT(y,b,g);return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.makeTensorInfo(h.outputShape,v.dtype,v.values)}var w8={kernelName:Zo,backendName:"cpu",kernelFunc:x8};function k8(e){let{inputs:t,backend:n}=e,{input:r}=t,s=w.sizeFromShape(r.shape),a=r.shape[r.shape.length-1],o=s/a,i=Et({inputs:{x:r},backend:n,attrs:{shape:[o,a]}}),u=tN(i,!0,n),l=Et({inputs:{x:u},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(u),l}var I8={kernelName:Ah,backendName:"cpu",kernelFunc:k8},S8=ct(Ju,e=>Number.isFinite(e)?1:0,"bool"),C8={kernelName:Ju,backendName:"cpu",kernelFunc:S8},T8=ct(ec,e=>Math.abs(e)===1/0?1:0,"bool"),N8={kernelName:ec,backendName:"cpu",kernelFunc:T8},_8=ct(tc,e=>Number.isNaN(e)?1:0,"bool"),E8={kernelName:tc,backendName:"cpu",kernelFunc:_8};function A8(e){let{backend:t,attrs:n}=e,{start:r,stop:s,num:a}=n,o=IT(r,s,a);return t.makeTensorInfo([o.length],"float32",o)}var $8={kernelName:$h,backendName:"cpu",kernelFunc:A8},F8=ct(nc,e=>Math.log1p(e)),D8={kernelName:nc,backendName:"cpu",kernelFunc:F8},R8=Ht((e,t)=>e&&t),P8=an(si,R8,null,"bool"),O8={kernelName:si,backendName:"cpu",kernelFunc:P8},M8=ct(rc,e=>e?0:1,"bool"),L8={kernelName:rc,backendName:"cpu",kernelFunc:M8},B8=Ht((e,t)=>e||t),z8=an(Jl,B8,null,"bool"),W8={kernelName:Jl,backendName:"cpu",kernelFunc:z8};function V8(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{depthRadius:a,bias:o,alpha:i,beta:u}=r;we(s,"LRN");let l=s.shape[3],c=l-1,d=n.data.get(s.dataId).values,p=w.sizeFromShape(s.shape),h=new Float32Array(p);function f(m){let g=m%l,b=m-g+Math.max(0,g-a),y=m-g+Math.min(g+a,c),v=0;for(;b<=y;b++){let x=d[b];v+=x*x}return v}for(let m=0;m<p;m++){let g=f(m),b=d[m]*Math.pow(o+i*g,-u);h[m]=b}return n.makeTensorInfo(s.shape,s.dtype,h)}var U8={kernelName:ed,backendName:"cpu",kernelFunc:V8};function G8(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,y:a,dy:o}=t,{depthRadius:i,bias:u,alpha:l,beta:c}=r;we(o,"LRNGrad");let d=w.sizeFromShape(o.shape),p=o.shape[3],h=n.data.get(o.dataId).values,f=n.data.get(s.dataId).values,m=n.data.get(a.dataId).values,g=new Float32Array(d),b=d;for(let y=0;y<b;y++){let v=y%p,x=y-v+Math.max(0,v-i),k=y-v+Math.min(p,v+i+1),T=0;for(let C=x;C<k;C++)T+=Math.pow(f[C],2);T=l*T+u;for(let C=x;C<k;C++){let E=-2*l*c*f[C]*m[y]/T;y===C&&(E+=Math.pow(T,-c)),E*=h[y],g[C]+=E}}return n.makeTensorInfo(o.shape,s.dtype,g)}var H8={kernelName:Fh,backendName:"cpu",kernelFunc:G8};function nN(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reductionIndices:a,keepDims:o}=r,i=n,u=s.shape,l=u.length,c=w.parseAxisParam(a,u),d=c,p=N.getAxesPermutation(d,l),h=i.data.get(s.dataId).values;if(p!=null){let x=new Array(l);for(let k=0;k<x.length;k++)x[k]=u[p[k]];h=Ow(h,u,s.dtype,p,x),d=N.getInnerMostAxes(d.length,l),u=x}we(s,"max"),N.assertAxesAreInnerMostDims("max",d,l);let[f,m]=N.computeOutAndReduceShapes(u,d),g=w.sizeFromShape(m),b=CT(h,g,f,s.dtype),y=i.write(b,f,s.dtype),v=f;return o&&(v=N.expandShapeToKeepDim(f,c)),{dataId:y,shape:v,dtype:s.dtype}}var j8={kernelName:Aa,backendName:"cpu",kernelFunc:nN};function q8(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t;we(s,"maxPool");let{filterSize:a,strides:o,pad:i,dimRoundingMode:u}=r,l=1;w.assert(N.eitherStridesOrDilationsAreOne(o,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${l}'`);let c=N.computePool2DInfo(s.shape,a,o,l,i,u),d;if(c.filterWidth===1&&c.filterHeight===1&&w.arraysEqual(c.inShape,c.outShape))d=bs({inputs:{x:s},backend:n});else{let p=n.data.get(s.dataId).values,h=w.computeStrides(s.shape),f=Ww(p,s.shape,s.dtype,h,c,"max");d=n.makeTensorInfo(c.outShape,s.dtype,f.values)}return d}var K8={kernelName:Fa,backendName:"cpu",kernelFunc:q8};function X8(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:o,pad:i,dimRoundingMode:u,dataFormat:l}=r;we(s,"maxPool3d");let c=N.computePool3DInfo(s.shape,a,o,1,i,u,l),d=n.data.get(s.dataId).values,p=ZT(d,s.shape,s.dtype,w.computeStrides(s.shape),c,"max");return n.makeTensorInfo(p.shape,"float32",p.values)}var Y8={kernelName:td,backendName:"cpu",kernelFunc:X8};function Q8(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,{filterSize:o,strides:i,pad:u,dimRoundingMode:l}=r;we([s,a],"maxPool3DGrad");let c=N.computePool3DInfo(a.shape,o,i,1,u,l),d=n.bufferSync(a),p=zq(d,c),h=c.strideDepth,f=c.strideHeight,m=c.strideWidth,g=c.dilationDepth,b=c.dilationHeight,y=c.dilationWidth,v=c.effectiveFilterDepth,x=c.effectiveFilterHeight,k=c.effectiveFilterWidth,T=v-1-c.padInfo.front,C=k-1-c.padInfo.left,E=x-1-c.padInfo.top,F=$e(a.shape,"float32"),O=n.bufferSync(s);for(let D=0;D<c.batchSize;++D)for(let R=0;R<c.inChannels;++R)for(let _=0;_<c.inDepth;++_)for(let L=0;L<c.inHeight;++L)for(let U=0;U<c.inWidth;++U){let j=_-T,K=L-E,q=U-C,Q=0;for(let ee=0;ee<v;ee+=g){let re=(j+ee)/h;if(!(re<0||re>=c.outDepth||Math.floor(re)!==re))for(let se=0;se<x;se+=b){let ne=(K+se)/f;if(!(ne<0||ne>=c.outHeight||Math.floor(ne)!==ne))for(let ie=0;ie<k;ie+=y){let te=(q+ie)/m;if(te<0||te>=c.outWidth||Math.floor(te)!==te)continue;let pe=v*x*k-1-p.get(D,re,ne,te,R),be=ee*x*k+se*k+ie,Ce=pe===be?1:0;if(Ce===0)continue;Q+=O.get(D,re,ne,te,R)*Ce}}}F.set(Q,D,_,L,U,R)}return n.makeTensorInfo(F.shape,F.dtype,F.values)}var Z8={kernelName:Rh,backendName:"cpu",kernelFunc:Q8};function J8(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a,output:o}=t,i=a;we([a,o],"maxPoolGrad");let{filterSize:u,strides:l,pad:c,dimRoundingMode:d}=r,p=N.computePool2DInfo(i.shape,u,l,1,c,d),h=n.data.get(i.dataId).values,f=$e(p.outShape,i.dtype,QT(h,i.shape,i.dtype,p).values),m=p.strideHeight,g=p.strideWidth,b=p.dilationHeight,y=p.dilationWidth,v=p.effectiveFilterHeight,x=p.effectiveFilterWidth,k=x-1-p.padInfo.left,T=v-1-p.padInfo.top,C=$e(i.shape,"float32"),E=n.data.get(s.dataId).values,F=$e(s.shape,"float32",E);for(let O=0;O<p.batchSize;++O)for(let D=0;D<p.inChannels;++D)for(let R=0;R<p.inHeight;++R)for(let _=0;_<p.inWidth;++_){let L=R-T,U=_-k,j=0;for(let K=0;K<v;K+=b){let q=(L+K)/m;if(!(q<0||q>=p.outHeight||Math.floor(q)!==q))for(let Q=0;Q<x;Q+=y){let ee=(U+Q)/g;if(ee<0||ee>=p.outWidth||Math.floor(ee)!==ee)continue;let re=v*x-1-f.get(O,q,ee,D),se=K*x+Q,ne=re===se?1:0;if(ne===0)continue;j+=F.get(O,q,ee,D)*ne}}C.set(j,O,R,_,D)}return n.makeTensorInfo(C.shape,C.dtype,C.values)}var eX={kernelName:Dh,backendName:"cpu",kernelFunc:J8};function tX(e,t,n,r,s){let a=w.computeStrides(t),o=Ww(e,t,n,a,s,"max"),i=QT(e,t,n,s,!0,r);return[o.values,i.values]}var nX={kernelName:Ph,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{x:r}=e,{filterSize:s,strides:a,pad:o,includeBatchInIndex:i}=t,u=n;we(r,"MaxPoolWithArgmax");let l=u.data.get(r.dataId).values,c=N.computePool2DInfo(r.shape,s,a,[1,1],o),[d,p]=tX(l,r.shape,r.dtype,i,c),h=u.write(d,c.outShape,r.dtype),f=u.write(p,c.outShape,r.dtype);return[{dataId:h,shape:c.outShape,dtype:r.dtype},{dataId:f,shape:c.outShape,dtype:"int32"}]}};function rX(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:o}=r,i=w.parseAxisParam(a,s.shape),l=N.computeOutAndReduceShapes(s.shape,i)[1],c=w.sizeFromShape(l),d=[],p=n.makeTensorInfo([],"float32",new Float32Array([c]));d.push(p);let h=So({inputs:{x:s},backend:n,attrs:{dtype:"float32"}});d.push(h);let f=Vw({inputs:{a:h,b:p},backend:n});d.push(f);let m=ep({inputs:{x:f},backend:n,attrs:{axis:a,keepDims:o}});return d.forEach(g=>n.disposeIntermediateTensorInfo(g)),m}var sX={kernelName:Da,backendName:"cpu",kernelFunc:rX};function aX(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:o}=r;we(s,"min");let i=w.parseAxisParam(a,s.shape),u=i,l=N.getAxesPermutation(u,s.shape.length),c=s;l!=null&&(c=xr({inputs:{x:s},backend:n,attrs:{perm:l}}),u=N.getInnerMostAxes(u.length,s.shape.length)),N.assertAxesAreInnerMostDims("min",u,c.shape.length);let[d,p]=N.computeOutAndReduceShapes(c.shape,u),h=w.sizeFromShape(p),f=w.makeZerosTypedArray(w.sizeFromShape(d),c.dtype),m=n.data.get(c.dataId).values;for(let b=0;b<f.length;++b){let y=b*h,v=m[y];for(let x=0;x<h;++x){let k=m[y+x];(Number.isNaN(k)||k<v)&&(v=k)}f[b]=v}l!=null&&n.disposeIntermediateTensorInfo(c);let g=n.makeTensorInfo(d,c.dtype,f);if(o){let b=N.expandShapeToKeepDim(d,i),y=Et({inputs:{x:g},backend:n,attrs:{shape:b}});return n.disposeIntermediateTensorInfo(g),y}return g}var oX={kernelName:Ra,backendName:"cpu",kernelFunc:aX};function iX(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{paddings:a,mode:o}=r;we(s,"mirrorPad");let i=a.map((v,x)=>v[0]+s.shape[x]+v[1]),u=a.map(v=>v[0]),l=a.map((v,x)=>v[0]+s.shape[x]),c=o==="reflect"?0:1,d=n.data.get(s.dataId).values,p=s.shape.length,h=w.computeStrides(s.shape),f=w.sizeFromShape(i),m=i.length,g=w.computeStrides(i),b=w.getTypedArrayFromDType(s.dtype,f);for(let v=0;v<f;v++){let x=w.indexToLoc(v,m,g);for(let T=0;T<m;T++)x[T]<u[T]?x[T]=u[T]*2-x[T]-c:x[T]>=l[T]&&(x[T]=(l[T]-1)*2-x[T]+c);x=x.map((T,C)=>T-u[C]);let k=w.locToIndex(x,p,h);b[v]=d[k]}return{dataId:n.write(b,i,s.dtype),shape:i,dtype:s.dtype}}var uX={kernelName:Oa,backendName:"cpu",kernelFunc:iX},cX=Ht((e,t)=>{let n=e%t;return e<0&&t<0||e>=0&&t>=0?n:(n+t)%t}),lX=an(sc,cX),dX={kernelName:sc,backendName:"cpu",kernelFunc:lX},pX=Bo(ch());function rN(e){let{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{dim:a}=r,o=s.shape.length,i=a;if(i===-1&&(i=o-1),i!==o-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${o} and dim was ${i}`);let u=w.parseAxisParam([i],s.shape),l=nN({inputs:{x:s},backend:n,attrs:{reductionIndices:u,keepDims:!1}}),c=N.expandShapeToKeepDim(l.shape,u),d=Et({inputs:{x:l},backend:n,attrs:{shape:c}}),p=Bw({inputs:{a:s,b:d},backend:n}),h=fT({inputs:{x:p},backend:n}),f=ep({inputs:{x:h},backend:n,attrs:{axis:u,keepDims:!1}}),m=Et({inputs:{x:f},backend:n,attrs:{shape:c}}),g=Vw({inputs:{a:h,b:m},backend:n});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}var hX={kernelName:Xa,backendName:"cpu",kernelFunc:rN};function fX(e){let{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{numSamples:a,seed:o,normalized:i}=r;we(s,"multinomial");let u=i?s:rN({inputs:{logits:s},backend:n,attrs:{dim:-1}}),l=u.shape[0],c=u.shape[1],d=n.data.get(u.dataId).values,p=[l,a],h=w.makeZerosTypedArray(w.sizeFromShape(p),"int32");for(let f=0;f<l;++f){let m=f*c,g=new Float32Array(c-1);g[0]=d[m];for(let v=1;v<g.length;++v)g[v]=g[v-1]+d[m+v];let b=pX.alea(o.toString()),y=f*a;for(let v=0;v<a;++v){let x=b();h[y+v]=g.length;for(let k=0;k<g.length;k++)if(x<g[k]){h[y+v]=k;break}}}return i||n.disposeIntermediateTensorInfo(u),n.makeTensorInfo(p,"int32",h)}var mX={kernelName:Oh,backendName:"cpu",kernelFunc:fX},gX=Dr.nonMaxSuppressionV3Impl;function bX(e){let{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:o,iouThreshold:i,scoreThreshold:u}=r;we(s,"NonMaxSuppression");let l=n.data.get(s.dataId).values,c=n.data.get(a.dataId).values,{selectedIndices:d}=gX(l,c,o,i,u);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}var yX={kernelName:ii,backendName:"cpu",kernelFunc:bX},vX=Dr.nonMaxSuppressionV4Impl;function xX(e){let{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:o,iouThreshold:i,scoreThreshold:u,padToMaxOutputSize:l}=r;we(s,"NonMaxSuppressionPadded");let c=n.data.get(s.dataId).values,d=n.data.get(a.dataId).values,{selectedIndices:p,validOutputs:h}=vX(c,d,o,i,u,l);return[n.makeTensorInfo([p.length],"int32",new Int32Array(p)),n.makeTensorInfo([],"int32",new Int32Array([h]))]}var wX={kernelName:ac,backendName:"cpu",kernelFunc:xX},kX=Dr.nonMaxSuppressionV5Impl;function IX(e){let{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:o,iouThreshold:i,scoreThreshold:u,softNmsSigma:l}=r;we(s,"NonMaxSuppressionWithScore");let c=n.data.get(s.dataId).values,d=n.data.get(a.dataId).values,p=o,h=i,f=u,m=l,{selectedIndices:g,selectedScores:b}=kX(c,d,p,h,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([b.length],"float32",new Float32Array(b))]}var SX={kernelName:ui,backendName:"cpu",kernelFunc:IX};function CX(e){let{inputs:t,backend:n,attrs:r}=e,{indices:s}=t,{depth:a,onValue:o,offValue:i}=r;we(s,"oneHot");let u=w.sizeFromShape(s.shape),l=new Float32Array(u*a);l.fill(i);let c=n.data.get(s.dataId).values;for(let d=0;d<u;++d)c[d]>=0&&c[d]<a&&(l[d*a+c[d]]=o);return n.makeTensorInfo([...s.shape,a],"int32",l)}var TX={kernelName:li,backendName:"cpu",kernelFunc:CX};function vm(e){let{inputs:t,backend:n}=e,{x:r}=t;if(r.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(r.dtype==="complex64"){let s=Ji({inputs:{input:r},backend:n}),a=vm({inputs:{x:s},backend:n}),o=zc({inputs:{input:r},backend:n}),i=vm({inputs:{x:o},backend:n}),u=ur({inputs:{real:a,imag:i},backend:n});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(i),u}else return Hw({backend:n,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}var NX={kernelName:Ni,backendName:"cpu",kernelFunc:vm};function sN(e){let{inputs:t,backend:n}=e,{x:r}=t;if(r.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(r.dtype==="complex64"){let s=Ji({inputs:{input:r},backend:n}),a=sN({inputs:{x:s},backend:n}),o=zc({inputs:{input:r},backend:n}),i=vm({inputs:{x:o},backend:n}),u=ur({inputs:{real:a,imag:i},backend:n});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(i),u}else return Hw({backend:n,attrs:{shape:r.shape,value:1,dtype:r.dtype}})}var _X={kernelName:ci,backendName:"cpu",kernelFunc:sN};function aN(e){let{inputs:t,backend:n,attrs:r}=e,{axis:s}=r;if(t.length===1)return ym({inputs:{input:t[0]},backend:n,attrs:{dim:s}});let a=t[0].shape,o=t[0].dtype;t.forEach(c=>{w.assertShapesMatch(a,c.shape,"All tensors passed to stack must have matching shapes"),w.assert(o===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});let i=[],u=t.map(c=>{let d=ym({inputs:{input:c},backend:n,attrs:{dim:s}});return i.push(d),d}),l=Wc({inputs:u,backend:n,attrs:{axis:s}});return i.forEach(c=>n.disposeIntermediateTensorInfo(c)),l}var EX={kernelName:di,backendName:"cpu",kernelFunc:aN};function AX(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{paddings:a,constantValue:o}=r;we(s,"pad");let i=a.map((y,v)=>y[0]+s.shape[v]+y[1]),u=a.map(y=>y[0]),l=n.data.get(s.dataId).values,c=w.sizeFromShape(s.shape),d=s.shape.length,p=w.computeStrides(s.shape),h=w.sizeFromShape(i),f=i.length,m=w.computeStrides(i),g=w.getTypedArrayFromDType(s.dtype,h);o!==0&&g.fill(o);for(let y=0;y<c;y++){let x=w.indexToLoc(y,d,p).map((T,C)=>T+u[C]),k=w.locToIndex(x,f,m);g[k]=l[y]}return{dataId:n.write(g,i,s.dtype),shape:i,dtype:s.dtype}}var oN={kernelName:La,backendName:"cpu",kernelFunc:AX},$X=Ht((e,t)=>Math.pow(e,t)),FX=an(Ba,$X),DX={kernelName:Ba,backendName:"cpu",kernelFunc:FX};function RX(e){let{backend:t,attrs:n}=e,{start:r,stop:s,dtype:a,step:o}=n,i=Mw(r,s,o,a);return t.makeTensorInfo([i.length],a,i)}var PX={kernelName:oc,backendName:"cpu",kernelFunc:RX},OX=ct(ic,e=>1/e),MX={kernelName:ic,backendName:"cpu",kernelFunc:OX};function LX(e){let{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:o,size:i}=r;we(s,"resizeBilinear");let u=w.computeStrides(s.shape),[l,c]=i,[d,p,h,f]=s.shape,m=n.data.get(s.dataId).values,g=new Float32Array(w.sizeFromShape([d,l,c,f])),b=[a&&l>1?p-1:p,a&&c>1?h-1:h],y=[a&&l>1?l-1:l,a&&c>1?c-1:c],v=0,x=b[0]/y[0],k=b[1]/y[1];for(let T=0;T<d;T++)for(let C=0;C<l;C++){let E;o?E=x*(C+.5)-.5:E=x*C;let F=Math.max(0,Math.floor(E)),O=E-F,D=Math.min(p-1,Math.ceil(E)),R=T*u[0]+F*u[1],_=T*u[0]+D*u[1];for(let L=0;L<c;L++){let U;o?U=k*(L+.5)-.5:U=k*L;let j=Math.max(0,Math.floor(U)),K=U-j,q=Math.min(h-1,Math.ceil(U)),Q=R+j*u[2],ee=_+j*u[2],re=R+q*u[2],se=_+q*u[2];for(let ne=0;ne<f;ne++){let ie=m[Q+ne],te=m[ee+ne],pe=m[re+ne],be=m[se+ne],Ce=ie+(pe-ie)*K,Ie=te+(be-te)*K,Ne=Ce+(Ie-Ce)*O;g[v++]=Ne}}}return n.makeTensorInfo([d,l,c,f],"float32",g)}var BX={kernelName:Va,backendName:"cpu",kernelFunc:LX};function zX(e){let{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:o}=r;we([a,s],"resizeBilinearGrad");let i=w.computeStrides(s.shape),[u,l,c,d]=s.shape,[,p,h]=a.shape,f=new Float32Array(u*l*c*d),m=[o&&p>1?l-1:l,o&&h>1?c-1:c],g=[o&&p>1?p-1:p,o&&h>1?h-1:h],b=m[0]/g[0],y=m[1]/g[1],v=n.data.get(a.dataId).values,x=0;for(let k=0;k<u;k++){let T=k*i[0];for(let C=0;C<p;C++){let E=C*b,F=Math.floor(E),O=Math.min(Math.ceil(E),l-1),D=T+F*i[1],R=T+O*i[1],_=E-F,L=1-_;for(let U=0;U<h;U++){let j=U*y,K=Math.floor(j),q=Math.min(Math.ceil(j),c-1),Q=j-K,ee=1-Q,re=D+K*i[2],se=D+q*i[2],ne=R+K*i[2],ie=R+q*i[2],te=L*ee,pe=L*Q,be=_*ee,Ce=_*Q;for(let Ie=0;Ie<d;Ie++){let Ne=v[x++];f[re+Ie]+=Ne*te,f[se+Ie]+=Ne*pe,f[ne+Ie]+=Ne*be,f[ie+Ie]+=Ne*Ce}}}}return n.makeTensorInfo([u,c,l,d],"float32",f)}var WX={kernelName:Lh,backendName:"cpu",kernelFunc:zX};function VX(e){let{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:o,size:i}=r;we(s,"resizeNearestNeighbor");let u=w.computeStrides(s.shape),[l,c]=i,[d,p,h,f]=s.shape,m=n.data.get(s.dataId).values,g=new Float32Array(d*l*c*f),b=[a&&l>1?p-1:p,a&&c>1?h-1:h],y=[a&&l>1?l-1:l,a&&c>1?c-1:c],v=b[0]/y[0],x=b[1]/y[1],k=0;for(let T=0;T<d;T++){let C=T*u[0];for(let E=0;E<l;E++){let F=o?v*(E+.5):v*E,O=Math.min(p-1,a?Math.round(F):Math.floor(F));o&&(O=Math.max(0,O));let D=C+O*u[1];for(let R=0;R<c;R++){let _=o?x*(R+.5):x*R,L=Math.min(h-1,a?Math.round(_):Math.floor(_));o&&(L=Math.max(0,L));let U=D+L*u[2];for(let j=0;j<f;j++){let K=m[U+j];g[k++]=K}}}}return n.makeTensorInfo([d,l,c,f],s.dtype,g)}var UX={kernelName:uc,backendName:"cpu",kernelFunc:VX};function GX(e){let{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:o}=r;we([a,s],"resizeNearestNeighborGrad");let i=w.computeStrides(s.shape),u=w.computeStrides(a.shape),[l,c,d,p]=s.shape,[,h,f]=a.shape,m=new Float32Array(l*c*d*p),g=n.data.get(a.dataId).values,b=[o&&h>1?c-1:c,o&&f>1?d-1:d],y=[o&&h>1?h-1:h,o&&f>1?f-1:f],v=b[0]/y[0],x=b[1]/y[1],k=1/v,T=1/x,C=Math.ceil(k)*2+2,E=Math.ceil(T)*2+2;for(let F=0;F<l;F++){let O=F*i[0];for(let D=0;D<c;D++){let R=O+D*i[1],_=Math.floor(D*k),L=Math.floor(_-C/2);for(let U=0;U<d;U++){let j=R+U*i[2],K=Math.floor(U*T),q=Math.floor(K-E/2);for(let Q=0;Q<p;Q++){let ee=0;for(let re=0;re<C;re++){let se=re+L;if(se<0||se>=h)continue;let ne=O+se*u[1],ie=se*v,te=Math.min(c-1,o?Math.round(ie):Math.floor(ie));if(D===te)for(let pe=0;pe<E;pe++){let be=pe+q;if(be<0||be>=f)continue;let Ce=ne+be*u[2],Ie=be*x,Ne=Math.min(d-1,o?Math.round(Ie):Math.floor(Ie));U===Ne&&(ee+=g[Ce+Q])}}m[j+Q]=ee}}}}return n.makeTensorInfo(s.shape,s.dtype,m)}var HX={kernelName:Mh,backendName:"cpu",kernelFunc:GX};function jX(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dims:a}=r;we(s,"reverse");let o=s.shape.length,i=w.parseAxisParam(a,s.shape);if(o===0)return bs({inputs:{x:s},backend:n});let u=new Kt(s.shape,s.dtype),l=n.bufferSync(s);for(let c=0;c<u.size;c++){let d=u.indexToLoc(c),p=d.slice();i.forEach(h=>p[h]=s.shape[h]-1-p[h]),u.set(l.get(...p),...d)}return n.makeTensorInfo(u.shape,u.dtype,u.values)}var qX={kernelName:fi,backendName:"cpu",kernelFunc:jX},KX={kernelName:_i,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{image:r}=e,{radians:s,fillValue:a,center:o}=t,i=n,u=w.getTypedArrayFromDType(r.dtype,w.sizeFromShape(r.shape)),[l,c,d,p]=r.shape,[h,f]=N.getImageCenter(o,c,d),m=255,g=Math.sin(s),b=Math.cos(s),y=i.data.get(r.dataId).values;for(let x=0;x<l;x++){let k=x*d*c*p;for(let T=0;T<c;T++){let C=T*(d*p);for(let E=0;E<d;E++){let F=E*p;for(let O=0;O<p;O++){let D=[l,T,E,O],R=D[2],_=D[1],L=(R-h)*b-(_-f)*g,U=(R-h)*g+(_-f)*b;L=Math.round(L+h),U=Math.round(U+f);let j=a;if(typeof a!="number"&&(O===3?j=m:j=a[O]),L>=0&&L<d&&U>=0&&U<c){let q=U*(d*p),Q=L*p,ee=k+q+Q+O;j=y[ee]}let K=k+C+F+O;u[K]=j}}}}return{dataId:i.write(u,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},XX=ct(mi,e=>{let t=Math.floor(e);return e-t<.5?Math.floor(e):e-t>.5?Math.ceil(e):t%2==0?t:t+1}),YX={kernelName:mi,backendName:"cpu",kernelFunc:XX};function iN(e,t,n,r,s,a,o,i,u,l){let c=[r/s,s],d=e.values,p=t.values;if(r===0)return $e(n,t.dtype);let h=$e(c,t.dtype);h.values.fill(u);for(let f=0;f<a;f++){let m=[],g=0;for(let b=0;b<o;b++){let y=d[f*o+b];m.push(y),g+=y*i[b]}if(g<0||g>=r/s)throw new Error(`Invalid indices: ${m} does not index into ${n}`);for(let b=0;b<s;b++)l?h.values[g*s+b]+=p[f*s+b]:h.values[g*s+b]=t.rank===0?p[0]:p[f*s+b]}return h}function QX(e){let{inputs:t,backend:n,attrs:r}=e,{indices:s,updates:a}=t,{shape:o}=r,{sliceRank:i,numUpdates:u,sliceSize:l,strides:c,outputSize:d}=N.calculateShapes(a,s,o),p=!0,h=n.bufferSync(s),f=n.bufferSync(a),m=iN(h,f,o,d,l,u,i,c,0,p);return n.makeTensorInfo(o,m.dtype,m.values)}var ZX={kernelName:gi,backendName:"cpu",kernelFunc:QX};function JX(e){let{inputs:t,backend:n}=e,{condition:r,t:s,e:a}=t;we([r,s,a],"select");let o=r.shape.length,i=n.data.get(r.dataId).values,u=n.data.get(s.dataId).values,l=n.data.get(a.dataId).values,c=In(s.dtype,a.dtype),d=w.makeZerosTypedArray(w.sizeFromShape(s.shape),c),p=0,h=o===0||o>1||s.shape.length===1?1:w.sizeFromShape(s.shape.slice(1));for(let f=0;f<i.length;f++)for(let m=0;m<h;m++)i[f]===1?d[p++]=u[f]:d[p++]=l[f];return n.makeTensorInfo(s.shape,c,d)}var e7={kernelName:bi,backendName:"cpu",kernelFunc:JX},t7=N.SELU_SCALEALPHA,n7=N.SELU_SCALE,r7=ct(cc,e=>e>=0?n7*e:t7*(Math.exp(e)-1)),s7={kernelName:cc,backendName:"cpu",kernelFunc:r7},a7=ct(lc,e=>e<0?-1:e>0?1:0),o7={kernelName:lc,backendName:"cpu",kernelFunc:a7},i7=ct(Ha,e=>Math.sin(e)),u7={kernelName:Ha,backendName:"cpu",kernelFunc:i7},c7=ct(vi,e=>Math.sinh(e)),l7={kernelName:vi,backendName:"cpu",kernelFunc:c7},d7=11920928955078125e-23,uN=Math.log(d7)+2,p7=ct(dc,e=>{let t=e>-uN,n=e<uN,r=Math.exp(e),s;return n?s=r:t?s=e:s=Math.log(1+r),s}),h7={kernelName:dc,backendName:"cpu",kernelFunc:p7};function f7(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,paddings:o}=r;we([s],"spaceToBatchND");let i=w.sizeFromShape(a),u=[[0,0]];u.push(...o);for(let T=1+a.length;T<s.shape.length;++T)u.push([0,0]);let l=oN.kernelFunc({inputs:{x:s},backend:n,attrs:{paddings:u,constantValue:0}}),c=N.getReshaped(l.shape,a,i,!1),d=N.getPermuted(c.length,a.length,!1),p=N.getReshapedPermuted(l.shape,a,i,!1),m=Et({inputs:{x:l},backend:n,attrs:{shape:c}}),y=xr({inputs:{x:m},backend:n,attrs:{perm:d}}),k=Et({inputs:{x:y},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(y),k}var m7={kernelName:xi,backendName:"cpu",kernelFunc:f7};function g7(e){let{inputs:t,backend:n}=e,{indices:r,values:s,denseShape:a,defaultValue:o}=t;if(a.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${a.shape}`);if(r.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${r.shape}`);if(s.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${s.shape}`);if(o.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${o.shape}`);let i=n.data.get(r.dataId).values,u=n.data.get(s.dataId).values,l=n.data.get(a.dataId).values,c=n.data.get(o.dataId).values[0],[d,p,h,f,m]=DT(i,r.shape,r.dtype,u,s.dtype,l,c);return[n.makeTensorInfo(p,r.dtype,d),n.makeTensorInfo([p[0]],s.dtype,h),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(g=>Number(g)))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}var b7={kernelName:rd,backendName:"cpu",kernelFunc:g7};function y7(e){let{inputs:t,backend:n}=e,{inputIndices:r,inputShape:s,newShape:a}=t;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${r.shape}`);if(s.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${s.shape}`);if(a.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${a.shape}`);let o=Array.from(n.data.get(s.dataId).values),i=n.data.get(r.dataId).values,u=Array.from(n.data.get(a.dataId).values),[l,c,d]=RT(i,r.shape,r.dtype,o,u);return[n.makeTensorInfo(c,r.dtype,l),n.makeTensorInfo([d.length],a.dtype,new Int32Array(d))]}var v7={kernelName:pc,backendName:"cpu",kernelFunc:y7};function x7(e){let{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${s.shape}`);if(a.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${a.shape}`);if(s.shape[0]!==a.shape[0])throw new Error("segmentIds and indices should have same size.");let o=n.data.get(r.dataId).values,i=n.data.get(s.dataId).values,u=n.data.get(a.dataId).values,[l,c]=Lw(o,r.shape,r.dtype,i,u,!0);return n.makeTensorInfo(c,r.dtype,l)}var w7={kernelName:sd,backendName:"cpu",kernelFunc:x7};function k7(e){let{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${s.shape}`);if(a.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${a.shape}`);if(s.shape[0]!==a.shape[0])throw new Error("segmentIds and indices should have same size.");let o=n.data.get(r.dataId).values,i=n.data.get(s.dataId).values,u=n.data.get(a.dataId).values,[l,c]=Lw(o,r.shape,r.dtype,i,u);return n.makeTensorInfo(c,r.dtype,l)}var I7={kernelName:ad,backendName:"cpu",kernelFunc:k7};function S7(e){let{inputs:t,backend:n,attrs:r}=e,{sparseIndices:s,sparseValues:a,defaultValue:o}=t,{outputShape:i}=r,{sliceRank:u,numUpdates:l,sliceSize:c,strides:d,outputSize:p}=N.calculateShapes(a,s,i),h=!1,f=n.bufferSync(s),m=n.bufferSync(a),g=n.data.get(o.dataId).values[0],b=iN(f,m,i,p,c,l,u,d,g,h);return n.makeTensorInfo(i,b.dtype,b.values)}var C7={kernelName:od,backendName:"cpu",kernelFunc:S7};function T7(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{numOrSizeSplits:a,axis:o}=r,i=w.parseAxisParam(o,s.shape)[0],u=N.prepareSplitSize(s,a,i),l=new Array(s.shape.length).fill(0),c=s.shape.slice();return u.map(d=>{let p=[...c];p[i]=d;let h=eu({inputs:{x:s},backend:n,attrs:{begin:l,size:p}});return l[i]+=d,h})}var N7={kernelName:wi,backendName:"cpu",kernelFunc:T7},_7={kernelName:hc,backendName:"cpu",kernelFunc:({inputs:e,backend:t})=>{let{x:n}=e,r=t;we(n,"square");let s=r.data.get(n.dataId).values,a=new Float32Array(s.length);for(let i=0;i<s.length;++i){let u=s[i];a[i]=u*u}return{dataId:r.write(a,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}},E7=ct(eo,(e,t)=>{let n=t;return isNaN(e)?NaN:e>0?1:n.alpha}),A7={kernelName:eo,backendName:"cpu",kernelFunc:E7};function $7(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,end:o,strides:i,beginMask:u,endMask:l,ellipsisMask:c,newAxisMask:d,shrinkAxisMask:p}=r;we(s,"stridedSlice");let{finalShapeSparse:h,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:b,begin:y,end:v,strides:x}=$t.sliceInfo(s.shape,a,o,i,u,l,c,d,p),k;if(m)k=Et({inputs:{x:s},backend:n,attrs:{shape:f}});else if(g||b){w.assert(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);let T=$t.computeOutShape(y,v,x),C=eu({inputs:{x:s},backend:n,attrs:{begin:y,size:T}});k=Et({inputs:{x:C},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(C)}else{let T=n.bufferSync(s),C=OT(h,T,x,y);k=n.makeTensorInfo(f,C.dtype,C.values)}return k}var F7={kernelName:ki,backendName:"cpu",kernelFunc:$7};function D7(e){let{inputs:t,backend:n,attrs:r}=e,{separator:s,nGramWidths:a,leftPad:o,rightPad:i,padWidth:u,preserveShortSequences:l}=r,{data:c,dataSplits:d}=t,p=n.data.get(c.dataId).values,h=n.data.get(d.dataId).values,[f,m]=MT(p,h,s,a,o,i,u,l);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(d.shape,"int32",m)]}var R7={kernelName:id,backendName:"cpu",kernelFunc:D7};function P7(e){let{inputs:t,backend:n,attrs:r}=e,{skipEmpty:s}=r,{input:a,delimiter:o}=t;if(a.dtype!=="string")throw new Error("Input must be of datatype string");if(a.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${a.shape}`);if(o.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);let i=n.data.get(a.dataId).values,u=n.data.get(o.dataId).values[0],[l,c,d]=LT(i,u,s),p=c.length;return[n.makeTensorInfo([p,2],"int32",l),n.makeTensorInfo([p],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(d))]}var O7={kernelName:Bh,backendName:"cpu",kernelFunc:P7};function M7(e){let{inputs:t,backend:n,attrs:r}=e,{numBuckets:s}=r,{input:a}=t;if(a.dtype!=="string")throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");let o=n.data.get(a.dataId).values,i=BT(o,s);return n.makeTensorInfo(a.shape,"int32",i)}var L7={kernelName:zh,backendName:"cpu",kernelFunc:M7},B7=ct(Ii,e=>Math.tan(e)),z7={kernelName:Ii,backendName:"cpu",kernelFunc:B7},W7=ct(Za,e=>Math.tanh(e)),V7={kernelName:Za,backendName:"cpu",kernelFunc:W7};function U7(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reps:a}=r;we(s,"tile");let o=WT(n.bufferSync(s),a);return n.makeTensorInfo(o.shape,o.dtype,o.values)}var G7={kernelName:As,backendName:"cpu",kernelFunc:U7};function H7(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{k:a,sorted:o}=r;we(s,"topk");let i=n.data.get(s.dataId).values,[u,l]=UT(i,s.shape,s.dtype,a,o);return[n.makeTensorInfo(u.shape,u.dtype,u.values),n.makeTensorInfo(l.shape,l.dtype,l.values)]}var j7={kernelName:Si,backendName:"cpu",kernelFunc:H7};function q7(e){let{inputs:t,attrs:n,backend:r}=e,{image:s,transforms:a}=t,{interpolation:o,fillMode:i,fillValue:u,outputShape:l}=n,[c,d,p,h]=s.shape,[f,m]=l!=null?l:[d,p],g=[c,f,m,h],b=w.computeStrides(s.shape),y=b[0],v=b[1],x=b[2],k=w.getTypedArrayFromDType(s.dtype,w.sizeFromShape(g));k.fill(u);let T=r.data.get(s.dataId).values,C=r.data.get(a.dataId).values;for(let F=0;F<c;++F){let O=a.shape[0]===1?C:C.subarray(F*8,F*8+8);for(let D=0;D<f;++D)for(let R=0;R<m;++R)for(let _=0;_<h;++_){let L,U=O[6]*R+O[7]*D+1;if(U===0)continue;let j=(O[0]*R+O[1]*D+O[2])/U,K=(O[3]*R+O[4]*D+O[5])/U,q=cN(j,p,i),Q=cN(K,d,i);switch(o){case"nearest":L=J7(T,d,p,y,v,x,F,Q,q,_,u);break;case"bilinear":L=eY(T,d,p,y,v,x,F,Q,q,_,u);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${o}`)}let ee=F*y+D*v+R*x+_;k[ee]=L}return r.makeTensorInfo(g,s.dtype,k)}return{dataId:r.write(k,g,s.dtype),shape:s.shape,dtype:s.dtype}}var K7={kernelName:Ci,backendName:"cpu",kernelFunc:q7};function cN(e,t,n){switch(n){case"reflect":return X7(e,t);case"wrap":return Y7(e,t);case"nearest":return Z7(e,t);case"constant":default:return Q7(e,t)}}function X7(e,t){let n=e;if(n<0)if(t<=1)n=0;else{let r=2*t;n<r&&(n=r*Math.trunc(-n/r)+n),n=n<-t?n+r:-n-1}else if(n>t-1)if(t<=1)n=0;else{let r=2*t;n-=r*Math.trunc(n/r),n>=t&&(n=r-n-1)}return w.clamp(0,n,t-1)}function Y7(e,t){let n=e;if(n<0)if(t<=1)n=0;else{let r=t-1;n+=t*(Math.trunc(-n/r)+1)}else if(n>t-1)if(t<=1)n=0;else{let r=t-1;n-=t*Math.trunc(n/r)}return w.clamp(0,n,t-1)}function Q7(e,t){return e}function Z7(e,t){return w.clamp(0,e,t-1)}function tp(e,t,n,r,s,a,o,i,u,l,c){let d=o*r+i*s+u*a+l;return 0<=i&&i<t&&0<=u&&u<n?e[d]:c}function J7(e,t,n,r,s,a,o,i,u,l,c){let d=Math.round(i),p=Math.round(u);return tp(e,t,n,r,s,a,o,d,p,l,c)}function eY(e,t,n,r,s,a,o,i,u,l,c){let d=Math.floor(i),p=Math.floor(u),h=d+1,f=p+1,m=(f-u)*tp(e,t,n,r,s,a,o,d,p,l,c)+(u-p)*tp(e,t,n,r,s,a,o,d,f,l,c),g=(f-u)*tp(e,t,n,r,s,a,o,h,p,l,c)+(u-p)*tp(e,t,n,r,s,a,o,h,f,l,c);return(h-i)*m+(i-d)*g}function tY(e){let{inputs:t,attrs:n,backend:r}=e,{axis:s}=n,{x:a}=t;we(a,"unique");let o=r.data.get(a.dataId).values,{outputValues:i,outputShape:u,indices:l}=GT(o,s,a.shape,a.dtype);return[r.makeTensorInfo(u,a.dtype,i),r.makeTensorInfo([l.length],"int32",l)]}var nY={kernelName:Wh,backendName:"cpu",kernelFunc:tY};function rY(e){let{inputs:t,backend:n,attrs:r}=e,{value:s}=t,{axis:a}=r;a<0&&(a+=s.shape.length);let o=s.shape.length,i=s.shape[a],u=new Array(o-1),l=0;for(let h=0;h<o;h++)h!==a&&(u[l++]=s.shape[h]);let c=new Array(o).fill(0),d=s.shape.slice();d[a]=1;let p=new Array(i);for(let h=0;h<p.length;h++){c[a]=h;let f=eu({inputs:{x:s},backend:n,attrs:{begin:c,size:d}});p[h]=Et({inputs:{x:f},backend:n,attrs:{shape:u}}),n.disposeIntermediateTensorInfo(f)}return p}var sY={kernelName:Ti,backendName:"cpu",kernelFunc:rY};function aY(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,segmentIds:a}=t,{numSegments:o}=r;we(s,"unsortedSegmentSum");let i=s.shape.length,u=a.shape.length,l=[],c=[],d=i-u,p=a;for(let f=0;f<d;++f){let m=ym({inputs:{input:p},backend:n,attrs:{dim:f+1}});p=m,c.push(m)}for(let f=0;f<o;++f){let m=w.createScalarValue(f,"int32"),g=n.makeTensorInfo([],"int32",m),b=pT({inputs:{a:g,b:p},backend:n}),y=So({inputs:{x:b},backend:n,attrs:{dtype:"float32"}}),v=gm({inputs:{a:y,b:s},backend:n}),x=ep({inputs:{x:v},backend:n,attrs:{axis:0,keepDims:!1}});l.push(x),c.push(g),c.push(b),c.push(y),c.push(v),c.push(x)}let h=aN({inputs:l,backend:n,attrs:{axis:0}});return c.forEach(f=>n.disposeIntermediateTensorInfo(f)),h}var oY={kernelName:ud,backendName:"cpu",kernelFunc:aY},iY=[fq,oj,gq,yq,pj,xq,kq,Sq,Tq,_q,Aq,Fq,Rq,Mq,Bq,Vq,Gq,jq,Kq,pq,Yq,Zq,eK,nK,lj,fj,sK,ij,oK,uK,dK,hK,cK,bK,vK,mK,wK,IK,CK,NK,EK,$K,FK,RK,OK,LK,BK,WK,zK,Uw,GK,aq,jK,mj,e8,gj,t8,yj,i8,u8,l8,xj,h8,m8,b8,v8,w8,kj,Sj,uj,I8,iK,C8,N8,E8,oq,Tj,_j,$8,Aj,D8,O8,L8,W8,U8,H8,Fj,K8,Y8,Z8,eX,nX,j8,sX,oX,Rj,uX,dX,mX,Oj,Lj,yX,wX,SX,zj,TX,_X,EX,oN,DX,uq,Uj,PX,cj,MX,cq,lq,dq,BX,WX,UX,HX,qX,KX,YX,Hj,ZX,e7,s7,qj,o7,u7,l7,Kj,hX,h7,m7,b7,v7,w7,I7,C7,N7,Qj,_7,Jj,A7,F7,R7,O7,L7,rq,VK,z7,V7,G7,j7,Wj,K7,nY,sY,oY,NX];for(let e of iY)mc(e);var lN={};Ee(lN,{assertNotComplex:()=>Uc,bindCanvasToFramebuffer:()=>vY,bindColorTextureToFramebuffer:()=>km,bindTextureToProgramUniformSampler:()=>TN,bindTextureUnit:()=>IN,bindVertexBufferToProgramAttribute:()=>Kw,callAndCheck:()=>ge,canBeRepresented:()=>pN,createFragmentShader:()=>mN,createFramebuffer:()=>kN,createProgram:()=>gN,createStaticIndexBuffer:()=>vN,createStaticVertexBuffer:()=>yN,createTexture:()=>xN,createVertexShader:()=>fN,getBatchDim:()=>nu,getExtensionOrThrow:()=>sp,getFramebufferErrorMessage:()=>NN,getMaxTexturesInShader:()=>$N,getNumChannels:()=>bY,getProgramUniformLocation:()=>CN,getProgramUniformLocationOrThrow:()=>SN,getRowsCols:()=>ru,getShapeAs3D:()=>Im,getTextureShapeFromLogicalShape:()=>EN,getWebGLDisjointQueryTimerVersion:()=>FN,getWebGLErrorMessage:()=>hN,getWebGLMaxTextureSize:()=>AN,hasExtension:()=>kr,isCapableOfRenderingToFloatTexture:()=>DN,isDownloadFloatTextureEnabled:()=>RN,isReshapeFree:()=>op,isWebGLFenceEnabled:()=>PN,isWebGLVersionEnabled:()=>Yw,linkProgram:()=>bN,resetMaxTextureSize:()=>xY,resetMaxTexturesInShader:()=>wY,unbindColorTextureFromFramebuffer:()=>Xw,unbindTextureUnit:()=>yY,validateFramebuffer:()=>ap,validateProgram:()=>wm,validateTextureSize:()=>wN});var tu={},jw={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function dN(e,t){tu[e]=t}function ys(e){if(!(e in tu)){let n=cY(e);if(n!==null)tu[e]=n;else return console.log("Could not get context for WebGL version",e),null}let t=tu[e];return t==null||t.isContextLost()?(delete tu[e],ys(e)):(t.disable(t.DEPTH_TEST),t.disable(t.STENCIL_TEST),t.disable(t.BLEND),t.disable(t.DITHER),t.disable(t.POLYGON_OFFSET_FILL),t.disable(t.SAMPLE_COVERAGE),t.enable(t.SCISSOR_TEST),t.enable(t.CULL_FACE),t.cullFace(t.BACK),tu[e])}function uY(e){if(typeof OffscreenCanvas!="undefined"&&e===2)return new OffscreenCanvas(300,150);if(typeof document!="undefined")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function cY(e){if(e!==1&&e!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");let t=uY(e);return t.addEventListener("webglcontextlost",n=>{n.preventDefault(),delete tu[e]},!1),e===1?t.getContext("webgl",jw)||t.getContext("experimental-webgl",jw):t.getContext("webgl2",jw)}var np;(function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"})(np||(np={}));var wr;(function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"})(wr||(wr={}));var pn;(function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(pn||(pn={}));function rp(e,t){return[t,e]}function lY(e,t){return e*t}function xm(e){let t=w.sizeFromShape(e),n=Math.ceil(t/4);return w.sizeToSquarishShape(n)}function Vc(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function dY(e,t){let[n,r]=Vc(e,t);return n*r*4}function qw(e,t){let n=e,r,s,a,o,i,u,l,c,d,p;return X().getNumber("WEBGL_VERSION")===2?(r=n.R32F,s=n.R16F,a=n.RGBA16F,o=n.RGBA32F,i=n.RED,l=4,c=1,d=n.HALF_FLOAT,p=n.FLOAT,u=n.RGBA8):(r=e.RGBA,s=e.RGBA,a=e.RGBA,o=n.RGBA,i=e.RGBA,l=4,c=4,d=t!=null?t.HALF_FLOAT_OES:null,p=e.FLOAT,u=e.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:s,internalFormatPackedHalfFloat:a,internalFormatPackedFloat:o,textureFormatFloat:i,downloadTextureFormat:u,downloadUnpackNumChannels:l,defaultNumChannels:c,textureTypeHalfFloat:d,textureTypeFloat:p}}function ge(e,t){let n=t();return X().getBool("DEBUG")&&pY(e),n}function pY(e){let t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+hN(e,t))}var hY=596e-10,fY=65504;function pN(e){return!!(X().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||e===0||hY<Math.abs(e)&&Math.abs(e)<fY)}function hN(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}function sp(e,t){return Vs(e,()=>e.getExtension(t),'Extension "'+t+'" not supported on this browser.')}function fN(e,t){let n=Vs(e,()=>e.createShader(e.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(ge(e,()=>e.shaderSource(n,t)),ge(e,()=>e.compileShader(n)),e.getShaderParameter(n,e.COMPILE_STATUS)===!1)throw console.log(e.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}function mN(e,t){let n=Vs(e,()=>e.createShader(e.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(ge(e,()=>e.shaderSource(n,t)),ge(e,()=>e.compileShader(n)),e.getShaderParameter(n,e.COMPILE_STATUS)===!1)throw gY(t,e.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}var mY=/ERROR: [0-9]+:([0-9]+):/g;function gY(e,t){let n=mY.exec(t);if(n==null){console.log(`Couldn't parse line number in error: ${t}`),console.log(e);return}let r=+n[1],s=e.split(`
`),a=s.length.toString().length+2,o=s.map((d,p)=>w.rightPad((p+1).toString(),a)+d),i=0;for(let d=0;d<o.length;d++)i=Math.max(o[d].length,i);let u=o.slice(0,r-1),l=o.slice(r-1,r),c=o.slice(r);console.log(u.join(`
`)),console.log(t.split(`
`)[0]),console.log(`%c ${w.rightPad(l[0],i)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join(`
`))}function gN(e){return Vs(e,()=>e.createProgram(),"Unable to create WebGLProgram.")}function bN(e,t){if(ge(e,()=>e.linkProgram(t)),e.getProgramParameter(t,e.LINK_STATUS)===!1)throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}function wm(e,t){if(ge(e,()=>e.validateProgram(t)),e.getProgramParameter(t,e.VALIDATE_STATUS)===!1)throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function yN(e,t){let n=Vs(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return ge(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),ge(e,()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW)),n}function vN(e,t){let n=Vs(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return ge(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n)),ge(e,()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW)),n}function bY(){return X().getNumber("WEBGL_VERSION")===2?1:4}function xN(e){return Vs(e,()=>e.createTexture(),"Unable to create WebGLTexture.")}function wN(e,t){let n=X().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0){let r=`[${e}x${t}]`;throw new Error("Requested texture size "+r+" is invalid.")}if(e>n||t>n){let r=`[${e}x${t}]`,s=`[${n}x${n}]`;throw new Error("Requested texture size "+r+" greater than WebGL maximum on this browser / GPU "+s+".")}}function kN(e){return Vs(e,()=>e.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function Kw(e,t,n,r,s,a,o){let i=e.getAttribLocation(t,n);return i===-1?!1:(ge(e,()=>e.bindBuffer(e.ARRAY_BUFFER,r)),ge(e,()=>e.vertexAttribPointer(i,s,e.FLOAT,!1,a,o)),ge(e,()=>e.enableVertexAttribArray(i)),!0)}function IN(e,t,n){_N(e,n),ge(e,()=>e.activeTexture(e.TEXTURE0+n)),ge(e,()=>e.bindTexture(e.TEXTURE_2D,t))}function yY(e,t){_N(e,t),ge(e,()=>e.activeTexture(e.TEXTURE0+t)),ge(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function SN(e,t,n){return Vs(e,()=>e.getUniformLocation(t,n),'uniform "'+n+'" not present in program.')}function CN(e,t,n){return e.getUniformLocation(t,n)}function TN(e,t,n,r){ge(e,()=>IN(e,t,r)),ge(e,()=>e.uniform1i(n,r))}function vY(e){ge(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),ge(e,()=>e.viewport(0,0,e.canvas.width,e.canvas.height)),ge(e,()=>e.scissor(0,0,e.canvas.width,e.canvas.height))}function km(e,t,n){ge(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,n)),ge(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0))}function Xw(e,t){ge(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,t)),ge(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0))}function ap(e){let t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+NN(e,t))}function NN(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}function Vs(e,t,n){let r=ge(e,()=>t());if(r==null)throw new Error(n);return r}function _N(e,t){let n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=t+e.TEXTURE0;if(r<e.TEXTURE0||r>n){let s=`[gl.TEXTURE0, gl.TEXTURE${n}]`;throw new Error(`textureUnit must be in ${s}.`)}}function nu(e,t=2){return w.sizeFromShape(e.slice(0,e.length-t))}function ru(e){if(e.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function Im(e){let t=[1,1,1];return e.length===0||e.length===1&&e[0]===1||(t=[nu(e),...ru(e)]),t}function EN(e,t=!1){let n=X().getNumber("WEBGL_MAX_TEXTURE_SIZE");t&&(n=n*2,e=e.map((s,a)=>a>=e.length-2?w.nearestLargerEven(e[a]):e[a]),e.length===1&&(e=[2,e[0]])),e.length!==2&&(e=w.squeezeShape(e).newShape);let r=w.sizeFromShape(e);if(e.length<=1&&r<=n)return[1,r];if(e.length===2&&e[0]<=n&&e[1]<=n)return e;if(e.length===3&&e[0]*e[1]<=n&&e[2]<=n)return[e[0]*e[1],e[2]];if(e.length===3&&e[0]<=n&&e[1]*e[2]<=n)return[e[0],e[1]*e[2]];if(e.length===4&&e[0]*e[1]*e[2]<=n&&e[3]<=n)return[e[0]*e[1]*e[2],e[3]];if(e.length===4&&e[0]<=n&&e[1]*e[2]*e[3]<=n)return[e[0],e[1]*e[2]*e[3]];if(t){let s=nu(e),a=2,o=2;return e.length&&([a,o]=ru(e)),r=s*(a/2)*(o/2),w.sizeToSquarishShape(r).map(i=>i*2)}return w.sizeToSquarishShape(r)}function Sm(e){return e%2==0}function op(e,t){if(e=e.slice(-2),t=t.slice(-2),w.arraysEqual(e,t)||!e.length||!t.length||e[0]===0||e[1]===0||t[0]===0||t[1]===0)return!0;if(e.length!==t.length){let n=e.slice(-1)[0],r=t.slice(-1)[0];if(n===r||Sm(n)&&Sm(r)&&(e[0]===1||t[0]===1))return!0}return e[1]===t[1]&&Sm(e[0])&&Sm(t[0])}var Cm,Tm;function AN(e){if(Cm==null){let t=ys(e);Cm=t.getParameter(t.MAX_TEXTURE_SIZE)}return Cm}function xY(){Cm=null}function wY(){Tm=null}function $N(e){if(Tm==null){let t=ys(e);Tm=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,Tm)}function FN(e){if(e===0)return 0;let t,n=ys(e);return kr(n,"EXT_disjoint_timer_query_webgl2")&&e===2?t=2:kr(n,"EXT_disjoint_timer_query")?t=1:t=0,t}function kr(e,t){return e.getExtension(t)!=null}function Yw(e){try{if(ys(e)!=null)return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function DN(e){if(e===0)return!1;let t=ys(e);if(e===1){if(!kr(t,"OES_texture_float"))return!1}else if(!kr(t,"EXT_color_buffer_float"))return!1;return Qw(t)}function RN(e){if(e===0)return!1;let t=ys(e);if(e===1){if(!kr(t,"OES_texture_float")||!kr(t,"WEBGL_color_buffer_float"))return!1}else{if(kr(t,"EXT_color_buffer_float"))return Qw(t);let r="EXT_color_buffer_half_float";if(kr(t,r)){let s=t.getExtension(r);return kY(t,s)}return!1}return Qw(t)}function Qw(e){let t=qw(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n);let r=1,s=1;e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,r,s,0,t.textureFormatFloat,t.textureTypeFloat,null);let a=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,a),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);let o=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(a),o}function kY(e,t){let n=qw(e,t),r=e.createTexture();e.bindTexture(e.TEXTURE_2D,r);let s=1,a=1;e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,s,a,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);let o=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,o),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,r,0);let i=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(r),e.deleteFramebuffer(o),i}function PN(e){return e!==2?!1:ys(e).fenceSync!=null}function Uc(e,t){Array.isArray(e)||(e=[e]),e.forEach(n=>{n!=null&&w.assert(n.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the WebGL backend.`)})}var Te=X();Te.registerFlag("HAS_WEBGL",()=>Te.getNumber("WEBGL_VERSION")>0);Te.registerFlag("WEBGL_VERSION",()=>Yw(2)?2:Yw(1)?1:0);Te.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);Te.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>Te.get("WEBGL_VERSION")===2);Te.registerFlag("WEBGL_CPU_FORWARD",()=>!0);Te.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);Te.registerFlag("WEBGL_PACK",()=>Te.getBool("HAS_WEBGL"));Te.registerFlag("WEBGL_PACK_NORMALIZATION",()=>Te.getBool("WEBGL_PACK"));Te.registerFlag("WEBGL_PACK_CLIP",()=>Te.getBool("WEBGL_PACK"));Te.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>Te.getBool("WEBGL_PACK"));Te.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>Te.getBool("WEBGL_PACK"));Te.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>Te.getBool("WEBGL_PACK"));Te.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>Te.getBool("WEBGL_PACK"));Te.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>Te.getBool("WEBGL_PACK"));Te.registerFlag("WEBGL_PACK_REDUCE",()=>Te.getBool("WEBGL_PACK"));Te.registerFlag("WEBGL_LAZILY_UNPACK",()=>Te.getBool("WEBGL_PACK"));Te.registerFlag("WEBGL_CONV_IM2COL",()=>Te.getBool("WEBGL_PACK"));Te.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>AN(Te.getNumber("WEBGL_VERSION")));Te.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>$N(Te.getNumber("WEBGL_VERSION")));Te.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{let e=Te.getNumber("WEBGL_VERSION");return e===0?0:FN(e)});Te.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>Te.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!bc.isMobile());Te.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>DN(Te.getNumber("WEBGL_VERSION")));Te.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>Te.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:Te.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));Te.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>RN(Te.getNumber("WEBGL_VERSION")));Te.registerFlag("WEBGL_FENCE_API_ENABLED",()=>PN(Te.getNumber("WEBGL_VERSION")));Te.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>Te.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);Te.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,e=>{if(e<0&&e!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`)});Te.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>bc.isMobile()?1:-1,e=>{if(e<0&&e!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${e}.`)});Te.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);Te.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);Te.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);Te.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);function $n(){let e,t,n,r,s,a,o,i,u,l;return X().getNumber("WEBGL_VERSION")===2?(e="#version 300 es",t="in",n="out",r="in",s="texture",a="outputColor",o="out vec4 outputColor;",i=`
      bool isnan_custom(float val) {
        return (val > 0.0 || val < 0.0) ? false : val != 0.0;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `,u="",l=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(e="",t="attribute",n="varying",r="varying",s="texture2D",a="gl_FragColor",o="",i=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,u=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,l=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:e,attribute:t,varyingVs:n,varyingFs:r,texture2D:s,output:a,defineOutput:o,defineSpecialNaN:i,defineSpecialInf:u,defineRound:l}}function su(e,t,n="index"){let r=w.computeStrides(t);return r.map((s,a)=>{let o=`int ${e[a]} = ${n} / ${s}`,i=a===r.length-1?`int ${e[a+1]} = ${n} - ${e[a]} * ${s}`:`index -= ${e[a]} * ${s}`;return`${o}; ${i};`}).join("")}function Nm(e,t,n="index"){let r=w.computeStrides(t);return r.map((s,a)=>{let o=`int ${e[a]} = ${n} / outShapeStrides[${a}]`,i=a===r.length-1?`int ${e[a+1]} = ${n} - ${e[a]} * outShapeStrides[${a}]`:`index -= ${e[a]} * outShapeStrides[${a}]`;return`${o}; ${i};`}).join("")}function IY(e,t){let n=e.length,r=e.map(a=>`${t}[${a}]`),s=new Array(n-1);s[n-2]=r[n-1];for(let a=n-3;a>=0;--a)s[a]=`(${s[a+1]} * ${r[a+1]})`;return s}function SY(e,t,n="index"){let r=e.map((a,o)=>o),s=IY(r,t);return s.map((a,o)=>{let i=`int ${e[o]} = ${n} / ${s[o]}`,u=o===s.length-1?`int ${e[o+1]} = ${n} - ${e[o]} * ${s[o]}`:`index -= ${e[o]} * ${s[o]}`;return`${i}; ${u};`}).join("")}function Zw(e){let t=w.computeStrides(e).map(n=>n.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;
  }
`}function Jw(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}var ON=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`,{getBroadcastDims:MN}=N;function CY(e,t,n){let r=[];if(e.forEach(h=>{let f=w.sizeFromShape(h.shapeInfo.logicalShape);if(h.shapeInfo.isUniform?r.push(`uniform float ${h.name}${f>1?`[${f}]`:""};`):(r.push(`uniform sampler2D ${h.name};`),r.push(`uniform int offset${h.name};`)),n.enableShapeUniforms){let{uniformShape:m}=ek(n.packedInputs,h.shapeInfo.logicalShape,h.shapeInfo.texShape);switch(m.length){case 1:r.push(`uniform int ${h.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${h.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${h.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${h.name}Shape;`);break;default:break}r.push(`uniform ivec2 ${h.name}TexShape;`)}}),n.enableShapeUniforms){switch(t.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;");break;default:break}r.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach(h=>{r.push(`uniform ${h.type} ${h.name}${h.arrayIndex?`[${h.arrayIndex}]`:""};`)});let s=r.join(`
`),a=e.map(h=>TY(h,t,n.packedInputs,n.enableShapeUniforms)).join(`
`),o=t.texShape,i=$n(),u=EY(i),l,c,d=FY(i);return t.isPacked?(l=NY(t.logicalShape,o,n.enableShapeUniforms),c=$Y(i)):(l=_Y(t.logicalShape,o,n.enableShapeUniforms),c=AY(i)),n.packedInputs&&(d+=OY),[d,u,c,s,l,a,n.userCode].join(`
`)}function Gc(e,t=!1){let n=e.shapeInfo.logicalShape;switch(n.length){case 0:return KY(e,t);case 1:return YY(e,t);case 2:return ZY(e,t);case 3:return e9(e,t);case 4:return n9(e,t);case 5:return r9(e);case 6:return s9(e);default:throw new Error(`${n.length}-D input sampling is not yet supported`)}}function LN(e,t){switch(e.shapeInfo.logicalShape.length){case 0:return qY(e);case 1:return XY(e,t);case 2:return QY(e,t);case 3:return JY(e,t);default:return t9(e,t)}}function TY(e,t,n=!1,r){let s="";n?s+=LN(e,r):s+=Gc(e,r);let a=e.shapeInfo.logicalShape,o=t.logicalShape;return a.length<=o.length&&(n?s+=a9(e,t):s+=o9(e,t)),s}function NY(e,t,n){switch(e.length){case 0:return BN();case 1:return MY(e,t,n);case 2:return HY(e,t,n);case 3:return BY(e,t,n);default:return WY(e,t,n)}}function _Y(e,t,n){switch(e.length){case 0:return BN();case 1:return LY(e,t,n);case 2:return jY(e,t,n);case 3:return zY(e,t,n);case 4:return VY(e,t,n);case 5:return UY(e,t);case 6:return GY(e,t);default:throw new Error(`${e.length}-D output sampling is not yet supported`)}}function EY(e){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${e.texture2D}(textureSampler, uv).r;
    }
  `}function AY(e){return`
    void setOutput(float val) {
      ${e.output} = vec4(val, 0, 0, 0);
    }
  `}function $Y(e){return`
    void setOutput(vec4 val) {
      ${e.output} = val;
    }
  `}function FY(e){return`${e.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${e.varyingFs} vec2 resultUV;
    ${e.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${e.defineSpecialNaN}
    ${e.defineSpecialInf}
    ${e.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${DY}
    ${RY}
    ${PY}
  `}var DY=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,RY=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,PY=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,OY=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function BN(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function MY(e,t,n){let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return r[0]===1?n?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${r[1]}.0);
      }
    `:r[1]===1?n?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${r[0]}.0);
      }
    `:n?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);
    }
  `}function LY(e,t,n){return t[0]===1?n?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${t[1]}.0);
      }
    `:t[1]===1?n?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${t[0]}.0);
      }
    `:n?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      return resTexRC.x * ${t[1]} + resTexRC.y;
    }
  `}function BY(e,t,n){if(n)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],s=Math.ceil(e[2]/2),a=s*Math.ceil(e[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      int b = index / ${a};
      index -= b * ${a};

      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec3(b, r, c);
    }
  `}function zY(e,t,n){if(n)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${Nm(["r","c","d"],e)}
    return ivec3(r, c, d);
  }
`;let r=su(["r","c","d"],e);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${r}
      return ivec3(r, c, d);
    }
  `}function WY(e,t,n){if(n)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],s=Math.ceil(e[e.length-1]/2),a=s*Math.ceil(e[e.length-2]/2),o=a,i="",u="b, r, c";for(let l=2;l<e.length-1;l++)o*=e[e.length-l-1],i=`
      int b${l} = index / ${o};
      index -= b${l} * ${o};
    `+i,u=`b${l}, `+u;return`
    ivec${e.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      ${i}

      int b = index / ${a};
      index -= b * ${a};

      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec${e.length}(${u});
    }
  `}function VY(e,t,n){if(n)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${Nm(["r","c","d","d2"],e)}
      return ivec4(r, c, d, d2);
    }
  `;let r=su(["r","c","d","d2"],e);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${r}
      return ivec4(r, c, d, d2);
    }
  `}function UY(e,t){let n=su(["r","c","d","d2","d3"],e);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},
                             ${t[1]}));

      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${n}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function GY(e,t){let n=su(["r","c","d","d2","d3","d4"],e);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${n}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function HY(e,t,n){let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(w.arraysEqual(e,t))return n?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));
      }
    `;let s=Math.ceil(e[1]/2);return n?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));

      int index = resTexRC.x * ${r[1]} + resTexRC.y;
      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec2(r, c);
    }
  `}function jY(e,t,n){return w.arraysEqual(e,t)?n?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));
      }
    `:e[1]===1?n?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:e[0]===1?n?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:n?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      int r = index / ${e[1]};
      int c = index - r * ${e[1]};
      return ivec2(r, c);
    }
  `}function au(e){return`offset${e}`}function qY(e){let t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),r=$n();return`
    vec4 ${n}() {
      return ${r.texture2D}(${t}, halfCR);
    }
  `}function KY(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`float ${r}() {return ${n};}`;let[s,a]=e.shapeInfo.texShape;if(s===1&&a===1)return`
      float ${r}() {
        return sampleTexture(${n}, halfCR);
      }
    `;let o=au(n);if(t)return`
    float ${r}() {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${o});
      return sampleTexture(${n}, uv);
    }
  `;let[i,u]=e.shapeInfo.texShape;return`
    float ${r}() {
      vec2 uv = uvFromFlat(${i}, ${u}, ${o});
      return sampleTexture(${n}, uv);
    }
  `}function XY(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=e.shapeInfo.texShape,a=$n();if(t)return`
    vec4 ${r}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${a.texture2D}(${n}, uv);
    }
  `;let o=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];return`
    vec4 ${r}(int index) {
      vec2 uv = packedUVfrom1D(
        ${o[0]}, ${o[1]}, index);
      return ${a.texture2D}(${n}, uv);
    }
  `}function YY(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`
      float ${r}(int index) {
        ${Hc(e)}
      }
    `;let s=e.shapeInfo.texShape,a=s[0],o=s[1];if(o===1&&a===1)return`
      float ${r}(int index) {
        return sampleTexture(${n}, halfCR);
      }
    `;let i=au(n);return o===1?t?`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${i}) + 0.5) / float(${n}TexShape[0]));
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${i}) + 0.5) / ${a}.0);
        return sampleTexture(${n}, uv);
      }
    `:a===1?t?`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${i}) + 0.5) / float(${n}TexShape[1]), 0.5);
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${i}) + 0.5) / ${o}.0, 0.5);
        return sampleTexture(${n}, uv);
      }
    `:t?`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${i});
      return sampleTexture(${n}, uv);
    }
  `:`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${a}, ${o}, index + ${i});
      return sampleTexture(${n}, uv);
    }
  `}function QY(e,t){let n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=e.shapeInfo.texShape,o=a[0],i=a[1],u=$n();if(a!=null&&w.arraysEqual(n,a))return t?`
      vec4 ${s}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);

        return ${u.texture2D}(${r}, uv);
      }
    `:`
      vec4 ${s}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${i}.0, ${o}.0);

        return ${u.texture2D}(${r}, uv);
      }
    `;if(t)return`
    vec4 ${s}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${u.texture2D}(${r}, uv);
    }
  `;let l=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],c=Math.ceil(n[1]/2);return`
    vec4 ${s}(int row, int col) {
      vec2 uv = packedUVfrom2D(${c}, ${l[0]}, ${l[1]}, row, col);
      return ${u.texture2D}(${r}, uv);
    }
  `}function ZY(e,t){let n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=e.shapeInfo.texShape;if(a!=null&&w.arraysEqual(n,a)){if(t)return`
      float ${s}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `;let p=a[0],h=a[1];return`
    float ${s}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${h}.0, ${p}.0);
      return sampleTexture(${r}, uv);
    }
  `}let{newShape:o,keptDims:i}=w.squeezeShape(n),u=o;if(u.length<n.length){let p=jc(e,u),h=["row","col"];return`
      ${Gc(p,t)}
      float ${s}(int row, int col) {
        return ${s}(${qc(h,i)});
      }
    `}if(e.shapeInfo.isUniform)return`
      float ${s}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));
        ${Hc(e)}
      }
    `;let l=a[0],c=a[1],d=au(r);return c===1?t?`
      float ${s}(int row, int col) {
        float index = dot(vec3(row, col, ${d}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${s}(int row, int col) {
      float index = dot(vec3(row, col, ${d}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${l}.0);
      return sampleTexture(${r}, uv);
    }
  `:l===1?t?`
      float ${s}(int row, int col) {
        float index = dot(vec3(row, col, ${d}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${s}(int row, int col) {
      float index = dot(vec3(row, col, ${d}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${c}.0, 0.5);
      return sampleTexture(${r}, uv);
    }
  `:t?`
      float ${s}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${r}Shape[1] + col + ${d};
        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
        return sampleTexture(${r}, uv);
      }
    `:`
  float ${s}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${n[1]} + col + ${d};
    vec2 uv = uvFromFlat(${l}, ${c}, index);
    return sampleTexture(${r}, uv);
  }
`}function JY(e,t){let n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=e.shapeInfo.texShape,o=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];if(n[0]===1){let p=n.slice(1),h=[1,2],f=jc(e,p),m=["b","row","col"];return`
        ${LN(f,t)}
        vec4 ${s}(int b, int row, int col) {
          return ${s}(${qc(m,h)});
        }
      `}let i=$n();if(t)return`
    vec4 ${s}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${i.texture2D}(${r}, uv);
    }
  `;let u=o[0],l=o[1],c=Math.ceil(n[2]/2),d=c*Math.ceil(n[1]/2);return`
    vec4 ${s}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${u}, ${l}, ${d}, ${c}, b, row, col);
      return ${i.texture2D}(${r}, uv);
    }
  `}function e9(e,t){let n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=n[1]*n[2],o=n[2],{newShape:i,keptDims:u}=w.squeezeShape(n),l=i;if(l.length<n.length){let m=jc(e,l),g=["row","col","depth"];return`
        ${Gc(m,t)}
        float ${s}(int row, int col, int depth) {
          return ${s}(${qc(g,u)});
        }
      `}if(e.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${a}, ${o}, 1)));
        ${Hc(e)}
      }
    `;let c=e.shapeInfo.texShape,d=c[0],p=c[1],h=e.shapeInfo.flatOffset;if(p===a&&h==null)return t?`
      float ${s}(int row, int col, int depth) {
        int stride1 = ${r}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
        float ${s}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${o}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${p}.0, ${d}.0);
          return sampleTexture(${r}, uv);
        }
      `;if(p===o&&h==null)return t?`
      float ${s}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${s}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${p}.0, ${d}.0);
      return sampleTexture(${r}, uv);
    }
  `;let f=au(r);return t?`
    float ${s}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${r}Shape[1] * ${r}Shape[2];
      int stride1 = ${r}Shape[2];
      int index = row * ${a} + col * ${o} + depth + ${f};
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
      return sampleTexture(${r}, uv);
    }
    `:`
      float ${s}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${a} + col * ${o} + depth + ${f};
        vec2 uv = uvFromFlat(${d}, ${p}, index);
        return sampleTexture(${r}, uv);
      }
  `}function t9(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=$n();if(t)return`
    vec4 ${r}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${n}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${s.texture2D}(${n}, uv);
    }
  `;let a=e.shapeInfo.logicalShape,o=a.length,i=e.shapeInfo.texShape,u=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)],l=u[0],c=u[1],d=Math.ceil(a[o-1]/2),p=d*Math.ceil(a[o-2]/2),h="int b, int row, int col",f=`b * ${p} + (row / 2) * ${d} + (col / 2)`;for(let m=2;m<o-1;m++)h=`int b${m}, `+h,p*=a[o-m-1],f=`b${m} * ${p} + `+f;return`
    vec4 ${r}(${h}) {
      int index = ${f};
      int texR = index / ${c};
      int texC = index - texR * ${c};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}, ${l});
      return ${s.texture2D}(${n}, uv);
    }
  `}function n9(e,t){let n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=n[3],o=n[2]*a,i=n[1]*o,{newShape:u,keptDims:l}=w.squeezeShape(n);if(u.length<n.length){let y=jc(e,u),v=["row","col","depth","depth2"];return`
      ${Gc(y,t)}
      float ${s}(int row, int col, int depth, int depth2) {
        return ${s}(${qc(v,l)});
      }
    `}if(e.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${i}, ${o}, ${a}, 1)));
        ${Hc(e)}
      }
    `;let c=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,p=d[0],h=d[1],f=`int stride2 = ${r}Shape[3];`,m=`int stride1 = ${r}Shape[2] * stride2;`,g=`int stride0 = ${r}Shape[1] * stride1;`;if(h===i&&c==null)return t?`
      float ${s}(int row, int col, int depth, int depth2) {
        ${f}
        ${m}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${o}, ${a}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${h}.0, ${p}.0);
        return sampleTexture(${r}, uv);
      }
    `;if(h===a&&c==null)return t?`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${n[1]*n[2]}, ${n[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${h}.0, ${p}.0);
        return sampleTexture(${r}, uv);
      }
    `;let b=au(r);return t?`
    float ${s}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${f}
      ${m}
      ${g}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${b});
      return sampleTexture(${r}, uv);
    }
  `:`
    float ${s}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${i} + col * ${o} +
          depth * ${a} + depth2;
      vec2 uv = uvFromFlat(${p}, ${h}, index + ${b});
      return sampleTexture(${r}, uv);
    }
  `}function r9(e){let t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=t[4],a=t[3]*s,o=t[2]*a,i=t[1]*o,{newShape:u,keptDims:l}=w.squeezeShape(t);if(u.length<t.length){let m=jc(e,u),g=["row","col","depth","depth2","depth3"];return`
      ${Gc(m)}
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        return ${r}(${qc(g,l)});
      }
    `}if(e.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${i}, ${o}, ${a}, ${s})) +
          depth3;
        ${Hc(e)}
      }
    `;let c=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,p=d[0],h=d[1];if(h===i&&c==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${o}, ${a}, ${s}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${h}.0, ${p}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(h===s&&c==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]},
               ${t[2]*t[3]}, ${t[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${h}.0, ${p}.0);
        return sampleTexture(${n}, uv);
      }
    `;let f=au(n);return`
    float ${r}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${i} + col * ${o} + depth * ${a} +
          depth2 * ${s} + depth3 + ${f};
      vec2 uv = uvFromFlat(${p}, ${h}, index);
      return sampleTexture(${n}, uv);
    }
  `}function s9(e){let t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:s,keptDims:a}=w.squeezeShape(t);if(s.length<t.length){let g=jc(e,s),b=["row","col","depth","depth2","depth3","depth4"];return`
      ${Gc(g)}
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${r}(${qc(b,a)});
      }
    `}let o=t[5],i=t[4]*o,u=t[3]*i,l=t[2]*u,c=t[1]*l;if(e.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${c}, ${l}, ${u}, ${i})) +
          dot(
            vec2(depth3, depth4),
            vec2(${o}, 1)));
        ${Hc(e)}
      }
    `;let d=e.shapeInfo.flatOffset,p=e.shapeInfo.texShape,h=p[0],f=p[1];if(f===c&&d==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${l}, ${u}, ${i}, ${o})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${h}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(f===o&&d==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]*t[4]},
               ${t[2]*t[3]*t[4]},
               ${t[3]*t[4]},
               ${t[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${h}.0);
        return sampleTexture(${n}, uv);
      }
    `;let m=au(n);return`
    float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${c} + col * ${l} + depth * ${u} +
          depth2 * ${i} + depth3 * ${o} + depth4 + ${m};
      vec2 uv = uvFromFlat(${h}, ${f}, index);
      return sampleTexture(${n}, uv);
    }
  `}function Hc(e){let t=e.name,n=w.sizeFromShape(e.shapeInfo.logicalShape);return n<2?`return ${t};`:`
    for (int i = 0; i < ${n}; i++) {
      if (i == index) {
        return ${t}[i];
      }
    }
  `}function a9(e,t){let n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),s="get"+r+"AtOutCoords",a=e.shapeInfo.logicalShape.length,o=t.logicalShape.length,i=MN(e.shapeInfo.logicalShape,t.logicalShape),u=gt(o),l=o-a,c,d=["x","y","z","w","u","v"];a===0?c="":o<2&&i.length>=1?c="coords = 0;":c=i.map(y=>`coords.${d[y+l]} = 0;`).join(`
`);let p="";o<2&&a>0?p="coords":p=e.shapeInfo.logicalShape.map((y,v)=>`coords.${d[v+l]}`).join(", ");let h="return outputValue;",m=w.sizeFromShape(e.shapeInfo.logicalShape)===1,b=w.sizeFromShape(t.logicalShape)===1;if(a===1&&!m&&!b)h=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(m&&!b)o===1?h=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:h=`
        return vec4(outputValue.x);
      `;else if(i.length){let y=a-2,v=a-1;i.indexOf(y)>-1&&i.indexOf(v)>-1?h="return vec4(outputValue.x);":i.indexOf(y)>-1?h="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":i.indexOf(v)>-1&&(h="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${s}() {
      ${u} coords = getOutputCoords();
      ${c}
      vec4 outputValue = get${r}(${p});
      ${h}
    }
  `}function o9(e,t){let n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),s="get"+r+"AtOutCoords",a=t.texShape,o=e.shapeInfo.texShape,i=e.shapeInfo.logicalShape.length,u=t.logicalShape.length;if(!e.shapeInfo.isUniform&&i===u&&e.shapeInfo.flatOffset==null&&w.arraysEqual(o,a))return`
      float ${s}() {
        return sampleTexture(${n}, resultUV);
      }
    `;let l=gt(u),c=MN(e.shapeInfo.logicalShape,t.logicalShape),d=u-i,p,h=["x","y","z","w","u","v"];i===0?p="":u<2&&c.length>=1?p="coords = 0;":p=c.map(m=>`coords.${h[m+d]} = 0;`).join(`
`);let f="";return u<2&&i>0?f="coords":f=e.shapeInfo.logicalShape.map((m,g)=>`coords.${h[g+d]}`).join(", "),`
    float ${s}() {
      ${l} coords = getOutputCoords();
      ${p}
      return get${r}(${f});
    }
  `}function gt(e){if(e<=1)return"int";if(e===2)return"ivec2";if(e===3)return"ivec3";if(e===4)return"ivec4";if(e===5)return"ivec5";if(e===6)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function ek(e,t,n){let{newShape:r,keptDims:s}=w.squeezeShape(t),a=t.length,o=e&&a===3&&t[0]===1,i=o?t.slice(1):r,u=!e&&a>1&&!w.arraysEqual(t,n)&&r.length<a||o;return{useSqueezeShape:u,uniformShape:u?i:t,keptDims:s}}function jc(e,t){let n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function qc(e,t){return t.map(n=>e[n]).join(", ")}function i9(e,t,n,r){let s=n.map((x,k)=>{let T={logicalShape:x.shape,texShape:x.isUniform?null:x.texData.texShape,isUniform:x.isUniform,isPacked:x.isUniform?!1:x.texData.isPacked,flatOffset:null};return x.texData!=null&&x.texData.slice!=null&&x.texData.slice.flatOffset>0&&(T.flatOffset=x.texData.slice.flatOffset),{name:t.variableNames[k],shapeInfo:T}}),a=s.map(x=>x.shapeInfo),o={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},i=CY(s,o,t),u=mN(e.gl,i),l=e.createProgram(u),c=null,d=e.getUniformLocation(l,"NAN",!1);X().getNumber("WEBGL_VERSION")===1&&(c=e.getUniformLocation(l,"INFINITY",!1));let p=!1,h={},f={},m={};for(let x=0;x<t.variableNames.length;x++){let k=t.variableNames[x];h[k]=e.getUniformLocation(l,k,p),h[`offset${k}`]=e.getUniformLocation(l,`offset${k}`,p),t.enableShapeUniforms&&(f[`${k}Shape`]=e.getUniformLocation(l,`${k}Shape`,p),m[`${k}TexShape`]=e.getUniformLocation(l,`${k}TexShape`,p))}let g,b,y;t.enableShapeUniforms&&(g=e.getUniformLocation(l,"outShape",p),y=e.getUniformLocation(l,"outShapeStrides",p),b=e.getUniformLocation(l,"outTexShape",p));let v=[];return t.customUniforms&&t.customUniforms.forEach((x,k)=>{v[k]=e.getUniformLocation(l,x.name,p)}),{program:t,fragmentShader:u,source:i,webGLProgram:l,uniformLocations:h,customUniformLocations:v,inShapeInfos:a,outShapeInfo:o,infLoc:c,nanLoc:d,inShapesLocations:f,inTexShapesLocations:m,outShapeLocation:g,outShapeStridesLocation:y,outTexShapeLocation:b}}function zN(e,t){if(e.length!==t.length)throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${t.length} inputs`);e.forEach((n,r)=>{let s=n.logicalShape,a=t[r],o=a.shape;if(!w.arraysEqual(s,o))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${s} and ${o} must match`);if(n.isUniform&&a.isUniform)return;let i=n.texShape,u=a.isUniform?null:a.texData.texShape;if(!w.arraysEqual(i,u))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${i} and ${u} must match`)})}function u9(e,t,n,r,s){t.program.enableShapeUniforms||(zN(t.inShapeInfos,n),zN([t.outShapeInfo],[r]));let a=r.texData.texture,o=r.texData.texShape;r.texData.isPacked?e.setOutputPackedMatrixTexture(a,o[0],o[1]):e.setOutputMatrixTexture(a,o[0],o[1]),e.setProgram(t.webGLProgram),X().getNumber("WEBGL_VERSION")===1&&t.infLoc!==null&&e.gl.uniform1f(t.infLoc,1/0),t.nanLoc!==null&&e.gl.uniform1f(t.nanLoc,NaN),n.forEach((u,l)=>{let c=t.program.variableNames[l],d=t.uniformLocations[c],p=t.uniformLocations[`offset${c}`],h=t.inShapesLocations[`${c}Shape`],f=t.inTexShapesLocations[`${c}TexShape`];if(h){let{uniformShape:m}=ek(t.program.packedInputs,u.shape,u.texData.texShape);switch(m.length){case 1:e.gl.uniform1iv(h,new Int32Array(m));break;case 2:e.gl.uniform2iv(h,new Int32Array(m));break;case 3:e.gl.uniform3iv(h,new Int32Array(m));break;case 4:e.gl.uniform4iv(h,new Int32Array(m));break;default:break}}if(f&&e.gl.uniform2i(f,u.texData.texShape[0],u.texData.texShape[1]),d!=null){if(u.isUniform){if(w.sizeFromShape(u.shape)<2)e.gl.uniform1f(d,u.uniformValues[0]);else{let m=u.uniformValues;m instanceof Float32Array||(m=new Float32Array(m)),e.gl.uniform1fv(d,m)}return}u.texData.slice!=null&&p!=null&&e.gl.uniform1i(p,u.texData.slice.flatOffset),e.setInputMatrixTexture(u.texData.texture,d,l)}});let i=t.outShapeLocation;if(i)switch(r.shape.length){case 1:e.gl.uniform1iv(i,new Int32Array(r.shape));break;case 2:e.gl.uniform2iv(i,new Int32Array(r.shape));break;case 3:e.gl.uniform3iv(i,new Int32Array(r.shape));break;case 4:e.gl.uniform4iv(i,new Int32Array(r.shape));break;default:break}if(t.outShapeStridesLocation){let u=w.computeStrides(r.shape);switch(r.shape.length){case 2:e.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(u));break;case 3:e.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(u));break;case 4:e.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(u));break;default:break}}t.outTexShapeLocation&&e.gl.uniform2i(t.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),t.program.customUniforms&&s&&t.program.customUniforms.forEach((u,l)=>{let c=t.customUniformLocations[l],d=s[l];if(u.type==="float")e.gl.uniform1fv(c,d);else if(u.type==="vec2")e.gl.uniform2fv(c,d);else if(u.type==="vec3")e.gl.uniform3fv(c,d);else if(u.type==="vec4")e.gl.uniform4fv(c,d);else if(u.type==="int")e.gl.uniform1iv(c,d);else if(u.type==="ivec2")e.gl.uniform2iv(c,d);else if(u.type==="ivec3")e.gl.uniform3iv(c,d);else if(u.type==="ivec4")e.gl.uniform4iv(c,d);else throw Error(`uniform type ${u.type} is not supported yet.`)}),e.executeProgram()}function c9(e,t,n){let r="";t.concat(n).forEach(o=>{let i=o.texData!=null&&o.texData.slice!=null&&o.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!o.isUniform){let u=o.texData.texShape,{useSqueezeShape:l,uniformShape:c,keptDims:d}=ek(e.packedInputs,o.shape,u),p="",h="",f="";if(c.length===1&&e.packedInputs){let k=[Math.ceil(u[0]/2),Math.ceil(u[1]/2)];p=`${k[0]>1}_${k[1]>1}`}else if(c.length===2&&!e.packedInputs)h=`${c[0]>1}_${c[1]>1}`;else if(c.length>2&&!e.packedInputs){let k=w.computeStrides(c);f=`${k[0]===u[1]}_${k[k.length-1]===u[1]}`}let m=o.shape.length,g=c.length===2&&w.arraysEqual(o.shape,u),b=w.sizeFromShape(o.shape)===1,y=N.getBroadcastDims(o.shape,n.shape),v=!e.packedInputs&&m===n.shape.length&&w.arraysEqual(u,n.texData.texShape),x=e.packedInputs||c.length>2?"":`${u[0]>1}_${u[1]>1}`;r+=`${m}_${v}_${l?d:""}_${c.length}_${b}_${y}_${g}_${p}_${h}_${f}_${x}_${i}`}else{let u=o.isUniform?"uniform":o.texData.texShape;r+=`${o.shape}_${u}_${i}`}});let s=e.userCode,a=e.constructor.name;return a+="_"+r+"_"+s+`${X().getNumber("WEBGL_VERSION")}`,a}function qn(e){return X().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}var l9=class{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=np.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let t=$n();this.outputShape=e,this.enableShapeUniforms=qn(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Nm(["r","c","d"],e):su(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${t.output} = result;
      }
    `}},d9=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=np.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let t=$n();this.outputShape=e,this.enableShapeUniforms=qn(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Nm(["r","c","d"],e):su(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${t.output} = result;
      }
    `}},p9=class{constructor(e){this.variableNames=["A"],this.outTexUsage=wr.DOWNLOAD;let t=$n();this.outputShape=e,this.userCode=`
      ${ON}

      void main() {
        float x = getAAtOutCoords();
        ${t.output} = encode_float(x);
      }
    `}},h9=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=wr.DOWNLOAD;let t=$n();this.outputShape=e,this.userCode=`
      ${ON}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${t.output} = encode_float(x);
      }
    `}},f9=class{constructor(e,t=!1){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];let n=$n();this.outputShape=e,this.enableShapeUniforms=qn(this.outputShape.length);let r="result";t&&(r="floor(result * 255. + 0.5)"),this.userCode=`
      ${this.enableShapeUniforms?Jw():Zw(e)}

      void main() {
        ivec3 coords = getOutputCoords();

        int flatIndex = getFlatIndex(coords);
        int offset = imod(flatIndex, 4);

        flatIndex = idiv(flatIndex, 4, 1.);

        int r = flatIndex / texShape[1];
        int c = imod(flatIndex, texShape[1]);
        vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
        vec4 values = ${n.texture2D}(A, uv);

        float result;

        if(offset == 0) {
          result = values[0];
        } else if(offset == 1) {
          result = values[1];
        } else if(offset == 2) {
          result = values[2];
        } else {
          result = values[3];
        }

        ${n.output} = vec4(${r}, 0., 0., 0.);
      }
    `}},m9=class{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];let n=$n();this.outputShape=e,this.enableShapeUniforms=qn(this.outputShape.length);let r="",s="result";t&&(s="floor(result * 255. + 0.5)");for(let a=0;a<=1;a++)for(let o=0;o<=1;o++){let i=a*2+o;r+=`
          localCoords = coords;
          if(localCoords[2] + ${o} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {
          localCoords[2] += ${o};
          if (localCoords[1] + ${a} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {
            localCoords[1] += ${a};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${n.texture2D}(A, uv);

            if (offset == 0) {
              result[${i}] = values[0];
            } else if (offset == 1) {
              result[${i}] = values[1];
            } else if (offset == 2) {
              result[${i}] = values[2];
            } else {
              result[${i}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?Jw():Zw(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${r}

          ${n.output} = ${s};
        }
    `}},WN={};Ee(WN,{bindVertexProgramAttributeStreams:()=>YN,createBufferFromOutputTexture:()=>JN,createFloat16MatrixTexture:()=>jN,createFloat16PackedMatrixTexture:()=>XN,createFloat32MatrixTexture:()=>HN,createIndexBuffer:()=>GN,createPackedMatrixTexture:()=>KN,createUnsignedBytesMatrixTexture:()=>qN,createVertexBuffer:()=>UN,createVertexShader:()=>VN,downloadByteEncodedFloatMatrixFromOutputTexture:()=>t_,downloadFloat32MatrixFromBuffer:()=>e_,downloadMatrixFromPackedOutputTexture:()=>r_,downloadPackedMatrixFromBuffer:()=>n_,getInternalFormatForFloat16MatrixTexture:()=>nk,getInternalFormatForFloat16PackedMatrixTexture:()=>ak,getInternalFormatForFloat32MatrixTexture:()=>tk,getInternalFormatForPackedMatrixTexture:()=>sk,getInternalFormatForUnsignedBytesMatrixTexture:()=>rk,uploadDenseMatrixToTexture:()=>QN,uploadPixelDataToTexture:()=>ZN});function VN(e){let t=$n(),n=`${t.version}
    precision highp float;
    ${t.attribute} vec3 clipSpacePos;
    ${t.attribute} vec2 uv;
    ${t.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return fN(e,n)}function UN(e){let t=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return yN(e,t)}function GN(e){let t=new Uint16Array([0,1,2,2,1,3]);return vN(e,t)}function ip(e,t,n,r,s,a){wN(t,n);let o=xN(e),i=e.TEXTURE_2D;return ge(e,()=>e.bindTexture(i,o)),ge(e,()=>e.texParameteri(i,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE)),ge(e,()=>e.texParameteri(i,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE)),ge(e,()=>e.texParameteri(i,e.TEXTURE_MIN_FILTER,e.NEAREST)),ge(e,()=>e.texParameteri(i,e.TEXTURE_MAG_FILTER,e.NEAREST)),X().getNumber("WEBGL_VERSION")===1?ge(e,()=>e.texImage2D(i,0,r,t,n,0,s,a,null)):ge(e,()=>e.texStorage2D(i,1,r,t,n)),ge(e,()=>e.bindTexture(e.TEXTURE_2D,null)),o}function tk(e){return e.internalFormatFloat}function HN(e,t,n,r){let[s,a]=rp(t,n);return ip(e,s,a,tk(r),r.textureFormatFloat,e.FLOAT)}function nk(e){return e.internalFormatHalfFloat}function jN(e,t,n,r){let[s,a]=rp(t,n);return ip(e,s,a,nk(r),r.textureFormatFloat,r.textureTypeHalfFloat)}function rk(e){return e.downloadTextureFormat}function qN(e,t,n,r){let[s,a]=rp(t,n);return ip(e,s,a,rk(r),e.RGBA,e.UNSIGNED_BYTE)}function sk(e){return e.internalFormatPackedFloat}function KN(e,t,n,r){let[s,a]=Vc(t,n);return ip(e,s,a,sk(r),e.RGBA,e.FLOAT)}function ak(e){return e.internalFormatPackedHalfFloat}function XN(e,t,n,r){let[s,a]=Vc(t,n);return ip(e,s,a,ak(r),e.RGBA,r.textureTypeHalfFloat)}function YN(e,t,n){let r=0,s=3*4,a=3*4+2*4;return ge(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),Kw(e,t,"clipSpacePos",n,3,a,r)&&Kw(e,t,"uv",n,2,a,s)}function QN(e,t,n,r,s,a){ge(e,()=>e.bindTexture(e.TEXTURE_2D,t));let o,i,u;s instanceof Uint8Array?(o=new Uint8Array(n*r*4),i=e.UNSIGNED_BYTE,u=e.RGBA):(o=new Float32Array(n*r*4),i=e.FLOAT,u=a.internalFormatPackedFloat),o.set(s),X().getNumber("WEBGL_VERSION")===2?ge(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n,r,e.RGBA,i,o)):ge(e,()=>e.texImage2D(e.TEXTURE_2D,0,u,n,r,0,e.RGBA,i,o)),ge(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function ZN(e,t,n){ge(e,()=>e.bindTexture(e.TEXTURE_2D,t)),n.data instanceof Uint8Array?X().getNumber("WEBGL_VERSION")===2?(ge(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n.width,n.height,e.RGBA,e.UNSIGNED_BYTE,n.data)),e.flush()):ge(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data)):X().getNumber("WEBGL_VERSION")===2?(ge(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,e.RGBA,e.UNSIGNED_BYTE,n)),e.flush()):ge(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n)),ge(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function JN(e,t,n,r){let s=e.createBuffer();ge(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,s));let i=4*4*t*n;return ge(e,()=>e.bufferData(e.PIXEL_PACK_BUFFER,i,e.STREAM_READ)),ge(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0)),ge(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null)),s}function e_(e,t,n){let r=e,s=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,t),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,s),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),s}function t_(e,t,n,r){let[s,a]=rp(t,n),o=4,i=new Uint8Array(lY(t*n,o));return ge(e,()=>e.readPixels(0,0,s,a,r.downloadTextureFormat,e.UNSIGNED_BYTE,i)),new Float32Array(i.buffer)}function n_(e,t,n,r,s,a,o,i){let u=e,l=new Float32Array(dY(a,o));return u.bindBuffer(u.PIXEL_PACK_BUFFER,t),u.getBufferSubData(u.PIXEL_PACK_BUFFER,0,l),u.bindBuffer(u.PIXEL_PACK_BUFFER,null),l}function r_(e,t,n){let r=new Float32Array(t*n*4);return ge(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,r)),r}var s_=class{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];let t=X().getNumber("WEBGL_VERSION");e!=null?(this.gl=e,dN(t,e)):this.gl=ys(t);let n="WEBGL_color_buffer_float",r="EXT_color_buffer_half_float";if(X().getNumber("WEBGL_VERSION")===1){let s="OES_texture_float",a="OES_texture_half_float";if(this.textureFloatExtension=sp(this.gl,s),kr(this.gl,a))this.textureHalfFloatExtension=sp(this.gl,a);else if(X().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),kr(this.gl,r))this.colorBufferHalfFloatExtension=sp(this.gl,r);else if(X().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",kr(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else if(kr(this.gl,r))this.colorBufferHalfFloatExtension=this.gl.getExtension(r);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=UN(this.gl),this.indexBuffer=GN(this.gl),this.framebuffer=kN(this.gl),this.textureConfig=qw(this.gl,this.textureHalfFloatExtension)}get debug(){return X().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");let e=this.gl;ge(e,()=>e.finish()),ge(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),ge(e,()=>e.deleteFramebuffer(this.framebuffer)),ge(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),ge(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),ge(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),HN(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),jN(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),qN(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),ZN(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,r){this.throwIfDisposed(),QN(this.gl,e,t,n,r,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),XN(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),KN(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(Xw(this.gl,this.framebuffer),this.outputTexture=null),ge(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,()=>t_(this.gl,t,n,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,n,r,s,a){return n_(this.gl,e,t,n,r,s,a,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return e_(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);let r=JN(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){let e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if(X().getBool("WEBGL_FENCE_API_ENABLED")){let r=e,s=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{let a=r.clientWaitSync(s,0,0);return a===r.ALREADY_SIGNALED||a===r.CONDITION_SATISFIED},t=s}else X().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,X().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,()=>r_(this.gl,t,n))}createProgram(e){this.throwIfDisposed();let t=this.gl;this.vertexShader==null&&(this.vertexShader=VN(t));let n=gN(t);return ge(t,()=>t.attachShader(n,this.vertexShader)),ge(t,()=>t.attachShader(n,e)),bN(t,n),this.debug&&wm(t,n),this.vertexAttrsAreBound||(this.setProgram(n),this.vertexAttrsAreBound=YN(t,this.program,this.vertexBuffer)),n}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),e!=null&&ge(this.gl,()=>this.gl.deleteProgram(e))}setProgram(e){this.throwIfDisposed(),this.program=e,this.program!=null&&this.debug&&wm(this.gl,this.program),ge(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,n=!0){return this.throwIfDisposed(),n?SN(this.gl,e,t):CN(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),ge(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),TN(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();let[r,s]=Vc(t,n);this.setOutputMatrixTextureDriver(e,r,s)}setOutputMatrixWriteRegion(e,t,n,r){this.setOutputMatrixWriteRegionDriver(n,e,r,t)}setOutputPackedMatrixWriteRegion(e,t,n,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&wm(this.gl,this.program),ap(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();let e=this.gl;this.debug&&this.debugValidate(),ge(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),ge(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=sp(this.gl,X().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(X().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let n=this.gl,r=this.getQueryTimerExtensionWebGL2(),s=n.createQuery();return n.beginQuery(r.TIME_ELAPSED_EXT,s),s}let e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(X().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let t=this.gl,n=this.getQueryTimerExtensionWebGL2();t.endQuery(n.TIME_ELAPSED_EXT);return}let e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await w.repeatedTry(()=>this.disposed||this.isQueryAvailable(e,X().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,X().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(t===0)return null;if(t===2){let n=this.gl;return n.getQueryParameter(e,n.QUERY_RESULT)/1e6}else{let n=this.getQueryTimerExtensionWebGL1();return n.getQueryObjectEXT(e,n.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(t===0)return!0;if(t===2){let n=this.gl,r=this.getQueryTimerExtensionWebGL2(),s=n.getQueryParameter(e,n.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),s&&!this.disjoint}else{let n=this.getQueryTimerExtensionWebGL1(),r=n.getQueryObjectEXT(e,n.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),r&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){let e=g9(this.itemsToPoll.map(t=>t.isDoneFn));for(let t=0;t<=e;++t){let{resolveFn:n}=this.itemsToPoll[t];n()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),!(this.itemsToPoll.length>1)&&w.repeatedTry(()=>(this.pollItems(),this.itemsToPoll.length===0))}bindTextureToFrameBuffer(e){this.throwIfDisposed(),km(this.gl,e,this.framebuffer),this.debug&&ap(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(km(this.gl,this.outputTexture,this.framebuffer),this.debug&&ap(this.gl)):Xw(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);let n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();let r=this.gl;km(r,e,this.framebuffer),this.debug&&ap(r),this.outputTexture=e,ge(r,()=>r.viewport(0,0,t,n)),ge(r,()=>r.scissor(0,0,t,n))}setOutputMatrixWriteRegionDriver(e,t,n,r){this.throwIfDisposed(),ge(this.gl,()=>this.gl.scissor(e,t,n,r))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}};function g9(e){let t=0;for(;t<e.length&&e[t]();++t);return t-1}var{addImpl:b9,bincountImpl:a_,bincountReduceImpl:y9,ceilImpl:v9,concatImpl:x9,equalImpl:w9,expImpl:k9,expm1Impl:I9,floorImpl:S9,gatherNdImpl:C9,gatherV2Impl:T9,greaterImpl:N9,greaterEqualImpl:_9,lessImpl:E9,lessEqualImpl:A9,linSpaceImpl:$9,logImpl:F9,maxImpl:D9,maximumImpl:R9,minimumImpl:P9,multiplyImpl:O9,negImpl:M9,notEqualImpl:L9,prodImpl:B9,rangeImpl:z9,rsqrtImpl:W9,sigmoidImpl:V9,simpleAbsImpl:o_,sliceImpl:U9,sparseFillEmptyRowsImpl:G9,sparseReshapeImpl:H9,sparseSegmentReductionImpl:i_,sqrtImpl:j9,stridedSliceImpl:q9,stringNGramsImpl:K9,stringSplitImpl:X9,stringToHashBucketFastImpl:Y9,subImpl:Q9,tileImpl:Z9,topKImpl:J9,transposeImpl:ok,uniqueImpl:eQ}=fm;function u_(e,t){return["x","y","z","w","u","v"].slice(0,t).map(n=>`${e}.${n}`)}function Fn(e,t){return t===1?[e]:u_(e,t)}function tQ(e,t){if(e===1)return"rc";let n="";for(let r=0;r<e;r++)n+=t[r],r<e-1&&(n+=",");return n}var nQ=class{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=qn(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{let t=Fn("rc",this.rank),n=gt(this.rank),r=this.getOutOfBoundsCondition(t),s=this.getSetup(t),a=this.getOutput(t);this.userCode=`
        void main() {
          ${n} rc = getOutputCoords();

          if(${r}) {
            setOutput(vec4(0));
          } else {
            ${s}

            setOutput(vec4(${a}));
          }
        }
      `}}getSourceCoordsArr(e){let t=[];for(let n=0;n<=1;n++)for(let r=0;r<=1;r++){let s=`${n===0?"r":"rp1"}, ${r===0?"c":"cp1"}`;for(let a=2;a<this.rank;a++)s=`${e[e.length-1-a]},`+s;t.push(s)}return t}getOutOfBoundsCondition(e){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let n=this.rank-2;n<this.rank;n++)t+=`${e[n]} >= ${this.enableShapeUniforms?`outShape[${n}]`:this.outputShape[n]}`,n<this.rank-1&&(t+="||");return t}getSetup(e){if(this.rank===1)return"";let t=e.slice(-2),n=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],r=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${t[0]};
      int c = ${t[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${n};
      bool rEdge = rp1 >= ${r};
    `}getOutput(e){let t=this.getSourceCoordsArr(e);return this.rank===1?`getA(rc),
              rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1),
              0, 0`:`getA(${t[0]}),
            cEdge ? 0. : getA(${t[1]}),
            rEdge ? 0. : getA(${t[2]}),
            rEdge || cEdge ? 0. : getA(${t[3]})`}},c_=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=qn(this.outputShape.length);let n="";for(let r=0;r<4;r++){let s="thisRC = rc;";r%2==1&&(s+="thisRC.z += 1;"),r>1&&(s+="thisRC.y += 1;"),n+=`
        ${s}
        ${r>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${r}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${r>0?"}":""}
      `}this.userCode=`
      ${rQ(t,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?Jw():Zw(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};

        ${n}

        setOutput(result);
      }
    `}};function rQ(e,t){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${t?SY(["r","c","d"],"inputShape"):su(["r","c","d"],e)}
      return ivec3(r, c, d);
    }
  `}var sQ=class{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(e,t,n){let r=d_(t,n),s=p_(e,r,n);s in this.freeTextures||(this.freeTextures[s]=[]),s in this.usedTextures||(this.usedTextures[s]=[]);let a=l_(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[s].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=a,this.log();let i=this.freeTextures[s].shift();return this.usedTextures[s].push(i),i}let o;return r===pn.PACKED_2X2_FLOAT32?o=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===pn.PACKED_2X2_FLOAT16?o=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===pn.UNPACKED_FLOAT32?o=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===pn.UNPACKED_FLOAT16?o=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===pn.PACKED_4X1_UNSIGNED_BYTE&&(o=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[s].push(o),this.numUsedTextures++,this._numBytesAllocated+=a,this.log(),o}releaseTexture(e,t,n,r){if(this.freeTextures==null)return;let s=d_(n,r),a=p_(t,s,r);a in this.freeTextures||(this.freeTextures[a]=[]);let o=l_(t,s,this.gpgpu.gl,this.gpgpu.textureConfig,r),i=X().get("WEBGL_DELETE_TEXTURE_THRESHOLD");i!==-1&&this._numBytesAllocated>i?(this.gpgpu.deleteMatrixTexture(e),this._numBytesAllocated-=o):(this.freeTextures[a].push(e),this.numFreeTextures++,this._numBytesFree+=o),this.numUsedTextures--;let u=this.usedTextures[a],l=u.indexOf(e);if(l<0)throw new Error("Cannot release a texture that was never provided by this texture manager");u.splice(l,1),this.log()}log(){if(!this.logEnabled)return;let e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);let t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(let e in this.freeTextures)this.freeTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t)});for(let e in this.usedTextures)this.usedTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}};function aQ(e,t){let n=e;if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F)return 16;if(t===e.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}function l_(e,t,n,r,s){let a=oQ(t,r),o;if(s){let[u,l]=Vc(e[0],e[1]);o=u*l}else{let[u,l]=rp(e[0],e[1]);o=u*l}let i=aQ(n,a);return o*i}function oQ(e,t){switch(e){case pn.PACKED_2X2_FLOAT32:return sk(t);case pn.PACKED_2X2_FLOAT16:return ak(t);case pn.UNPACKED_FLOAT32:return tk(t);case pn.UNPACKED_FLOAT16:return nk(t);case pn.PACKED_4X1_UNSIGNED_BYTE:return rk(t);default:throw new Error(`Unknown physical texture type ${e}`)}}function iQ(e){return X().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?pn.PACKED_2X2_FLOAT32:pn.UNPACKED_FLOAT32:e?pn.PACKED_2X2_FLOAT16:pn.UNPACKED_FLOAT16}function d_(e,t){if(e===wr.UPLOAD)return pn.PACKED_2X2_FLOAT32;if(e===wr.RENDER||e==null)return iQ(t);if(e===wr.DOWNLOAD||e===wr.PIXELS)return pn.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${e}`)}function p_(e,t,n){return`${e[0]}_${e[1]}_${t}_${n}`}var To=class{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=qn(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${t}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}},ts="if (isnan(x)) return x;",uQ="return x;",h_="return abs(x);",cQ="return (x >= 0.0) ? x : (exp(x) - 1.0);",lQ=ts+`
  return (x < 0.0) ? 0.0 : x;
`,dQ=ts+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,_m="return x;",pQ="return 1.0 / (1.0 + exp(-1.0 * x));",hQ="return x;",fQ=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,mQ=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,gQ=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,bQ="return 1.0 / (1.0 + exp(-1.0 * x));",Kc=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=qn(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${t}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}},yQ=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=qn(this.outputShape.length);let t=e.length,n=Fn("rc",t),r=gt(t),s=tQ(t,n),a=n.slice(-2),o=t<=1?"rc":`vec2(${a.join(",")})`;this.userCode=`
      void main() {
        ${r} rc = getOutputCoords();
        vec4 packedInput = getA(${s});

        setOutput(getChannel(packedInput, ${o}));
      }
    `}},vQ=Dr.whereImpl,xQ=1e-7,wQ=1e-4,Em={};function kQ(e){return e in Em||(Em[e]={}),Em[e]}var IQ=X().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),SQ=600;function CQ(){return X().global.screen==null?1024:X().global.screen.height*X().global.screen.width*window.devicePixelRatio*SQ/1024/1024}var f_=class extends Mu{constructor(e){super();if(this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!X().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");if(e==null){let t=ys(X().getNumber("WEBGL_VERSION"));this.binaryCache=kQ(X().getNumber("WEBGL_VERSION")),this.gpgpu=new s_(t),this.canvas=t.canvas,this.gpgpuCreatedLocally=!0}else this.gpgpu=e,this.binaryCache={},this.gpgpuCreatedLocally=!1,this.canvas=e.gl.canvas;this.textureManager=new sQ(this.gpgpu),this.numMBBeforeWarning=CQ(),this.texData=new Ul(this,is())}nextDataId(){return f_.nextDataId++}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}write(e,t,n){if((X().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||X().getBool("DEBUG"))&&this.checkNumericalProblems(e),n==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");let r={id:this.nextDataId()};return this.texData.set(r,{shape:t,dtype:n,values:e,usage:wr.UPLOAD,refCount:1}),r}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){let t=this.texData.get(e);t.refCount++}decRef(e){if(this.texData.has(e)){let t=this.texData.get(e);t.refCount--}}move(e,t,n,r,s){if(X().getBool("DEBUG")&&this.checkNumericalProblems(t),r==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:n,dtype:r,values:t,usage:wr.UPLOAD,refCount:s})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){let t=this.texData.get(e),{values:n,dtype:r,complexTensorInfos:s,slice:a,shape:o,isPacked:i}=t;if(a!=null){let d;i?d=new Kc(o,_m):d=new To(o,_m);let p=this.runWebGLProgram(d,[{dataId:e,shape:o,dtype:r}],r),h=this.readSync(p.dataId);return this.disposeIntermediateTensorInfo(p),h}if(n!=null)return this.convertAndCacheOnCPU(e);if(r==="string")return n;let u=this.activeTimers!=null,l;u&&(l=w.now());let c;if(r==="complex64"){let d=this.readSync(s.real.dataId),p=this.readSync(s.imag.dataId);c=N.mergeRealAndImagArrays(d,p)}else c=this.getValuesFromTexture(e);return u&&(this.downloadWaitMs+=w.now()-l),this.convertAndCacheOnCPU(e,c)}async read(e){if(this.pendingRead.has(e)){let h=this.pendingRead.get(e);return new Promise(f=>h.push(f))}let t=this.texData.get(e),{values:n,shape:r,slice:s,dtype:a,complexTensorInfos:o,isPacked:i}=t;if(s!=null){let h;i?h=new Kc(r,_m):h=new To(r,_m);let f=this.runWebGLProgram(h,[{dataId:e,shape:r,dtype:a}],a),m=this.read(f.dataId);return this.disposeIntermediateTensorInfo(f),m}if(n!=null)return this.convertAndCacheOnCPU(e);if(X().getBool("DEBUG")&&!X().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&X().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let u=null,l;if(a!=="complex64"&&X().get("WEBGL_BUFFER_SUPPORTED")){l=this.decode(e);let h=this.texData.get(l.dataId);u=this.gpgpu.createBufferFromTexture(h.texture,...xm(r))}this.pendingRead.set(e,[]),a!=="complex64"&&await this.gpgpu.createAndWaitForFence();let c;if(a==="complex64"){let h=await Promise.all([this.read(o.real.dataId),this.read(o.imag.dataId)]),f=h[0],m=h[1];c=N.mergeRealAndImagArrays(f,m)}else if(u==null)c=this.getValuesFromTexture(e);else{let h=w.sizeFromShape(r);c=this.gpgpu.downloadFloat32MatrixFromBuffer(u,h)}if(l!=null&&this.disposeIntermediateTensorInfo(l),u!=null){let h=this.gpgpu.gl;ge(h,()=>h.deleteBuffer(u))}let d=this.convertAndCacheOnCPU(e,c),p=this.pendingRead.get(e);return this.pendingRead.delete(e),p.forEach(h=>h(d)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&is().removeDataId(e,this),this.pendingDeletes--),d}bufferSync(e){let t=this.readSync(e.dataId),n=t;if(e.dtype==="string")try{n=t.map(r=>w.decodeString(r))}catch(r){throw new Error("Failed to decode encoded string bytes into utf-8")}return $e(e.shape,e.dtype,n)}checkNumericalProblems(e){if(e!=null)for(let t=0;t<e.length;t++){let n=e[t];if(!pN(n))throw X().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${n} cannot be represented on this device.`)}}getValuesFromTexture(e){let{shape:t,dtype:n,isPacked:r}=this.texData.get(e),s=w.sizeFromShape(t);if(X().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){let d=this.decode(e),p=this.texData.get(d.dataId),h=this.gpgpu.downloadMatrixFromPackedTexture(p.texture,...xm(t)).subarray(0,s);return this.disposeIntermediateTensorInfo(d),h}let a=X().getBool("WEBGL_PACK")&&r===!0,o=a?Im(t):t,i=a?new h9(o):new p9(o),u=this.runWebGLProgram(i,[{shape:o,dtype:n,dataId:e}],"float32"),l=this.texData.get(u.dataId),c=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(l.texture,l.texShape[0],l.texShape[1]).subarray(0,s);return this.disposeIntermediateTensorInfo(u),c}timerAvailable(){return X().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}async time(e){let t=this.activeTimers,n=[],r=!1;this.programTimersStack==null?(this.programTimersStack=n,r=!0):this.activeTimers.push(n),this.activeTimers=n,e();let s=w.flatten(this.activeTimers.map(i=>i.query)).filter(i=>i!=null),a=w.flatten(this.activeTimers.map(i=>i.name)).filter(i=>i!=null);this.activeTimers=t,r&&(this.programTimersStack=null);let o={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};if(X().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){let i=await Promise.all(s);o.kernelMs=w.sum(i),o.getExtraProfileInfo=()=>i.map((u,l)=>({name:a[l],ms:u})).map(u=>`${u.name}: ${u.ms}`).join(", ")}else o.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,o}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return X().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:w.now(),endMs:null}}endTimer(e){return X().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=w.now(),e)}async getQueryTime(e){if(X().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);let t=e;return t.endMs-t.startMs}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);let{complexTensorInfos:n}=this.texData.get(e);return n!=null&&(this.disposeData(n.real.dataId,t),this.disposeData(n.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){let{texture:t,dtype:n,texShape:r,usage:s,isPacked:a,slice:o}=this.texData.get(e),i=o&&o.origDataId||e,u=this.dataRefCount.get(i);u>1?this.dataRefCount.set(i,u-1):(this.dataRefCount.delete(i),t!=null&&(this.numBytesInGPU-=this.computeBytes(r,n),this.textureManager.releaseTexture(t,r,s,a)));let l=this.texData.get(e);l.texture=null,l.texShape=null,l.isPacked=!1,l.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=IQ){return X().getBool("WEBGL_CPU_FORWARD")&&e.every(n=>this.texData.get(n.dataId).texture==null&&w.sizeFromShape(n.shape)<t)}getGPGPUContext(){return this.gpgpu}where(e){N.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");let t=e.dataSync();return vQ(e.shape,t)}packedUnaryOp(e,t,n){let r=new Kc(e.shape,t),s=this.compileAndRun(r,[e],n);return is().makeTensorFromDataId(s.dataId,s.shape,s.dtype)}abs(e){if(this.shouldExecuteOnCPU([e])&&e.dtype!=="complex64"){let r=o_(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,r)}if(X().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,h_,e.dtype);let t=new To(e.shape,h_),n=this.compileAndRun(t,[e]);return is().makeTensorFromDataId(n.dataId,n.shape,n.dtype)}makeTensorInfo(e,t,n){let r;if(t==="string"&&n!=null&&n.length>0&&w.isString(n[0])){let s=n.map(a=>w.encodeString(a));r=this.write(s,e,t)}else r=this.write(n,e,t);return this.texData.get(r).usage=null,{dataId:r,shape:e,dtype:t}}makeOutput(e,t,n){let{dataId:r}=this.makeTensorInfo(e,t,n);return is().makeTensorFromDataId(r,e,t,this)}unpackTensor(e){let t=new yQ(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){let t=new nQ(e.shape),n=!0;return this.runWebGLProgram(t,[e],e.dtype,null,n)}packedReshape(e,t){let n=[nu(e.shape),...ru(e.shape)],r={dtype:e.dtype,shape:n,dataId:e.dataId},s=[nu(t),...ru(t)],a=new c_(s,n),o=!0,i=[n],u=this.runWebGLProgram(a,[r],e.dtype,i,o);return{dataId:u.dataId,shape:t,dtype:u.dtype}}decode(e){let t=this.texData.get(e),{isPacked:n,shape:r,dtype:s}=t,a=Im(r),o,i=xm(a);n?o=new d9(a):o=new l9(a);let u=!0,l=[i],c=this.runWebGLProgram(o,[{shape:a,dtype:s,dataId:e}],s,l,u);return{dtype:s,shape:r,dataId:c.dataId}}runWebGLProgram(e,t,n,r,s=!1){let a=this.makeTensorInfo(e.outputShape,n),o=this.texData.get(a.dataId);if(e.packedOutput&&(o.isPacked=!0),e.outPackingScheme===np.DENSE){let m=xm(e.outputShape);o.texShape=m.map(g=>g*2)}if(e.outTexUsage!=null&&(o.usage=e.outTexUsage),w.sizeFromShape(a.shape)===0)return o.values=w.getTypedArrayFromDType(a.dtype,0),a;let i=[],u=t.map(m=>{if(m.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let g=this.texData.get(m.dataId);if(g.texture==null){if(!e.packedInputs&&w.sizeFromShape(m.shape)<=X().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:m.shape,texData:null,isUniform:!0,uniformValues:g.values};e.packedInputs&&(g.isPacked=!0,g.shape=m.shape)}if(this.uploadToGPU(m.dataId),!!g.isPacked!=!!e.packedInputs)m=g.isPacked?this.unpackTensor(m):this.packTensor(m),i.push(m),g=this.texData.get(m.dataId);else if(g.isPacked&&!op(g.shape,m.shape)){let b=m,y=m.shape;m.shape=g.shape,m=this.packedReshape(m,y),i.push(m),g=this.texData.get(m.dataId),b.shape=y}return{shape:m.shape,texData:g,isUniform:!1}});this.uploadToGPU(a.dataId);let l={shape:a.shape,texData:o,isUniform:!1},c=c9(e,u,l),d=this.getAndSaveBinary(c,()=>i9(this.gpgpu,e,u,l)),p=this.activeTimers!=null,h;p&&(h=this.startTimer()),u9(this.gpgpu,d,u,l,r),i.forEach(m=>this.disposeIntermediateTensorInfo(m)),p&&(h=this.endTimer(h),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(h)}));let f=X().get("WEBGL_FLUSH_THRESHOLD");if(f>0){let m=w.now();m-this.lastGlFlushTime>f&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=m)}if(!X().getBool("WEBGL_LAZILY_UNPACK")&&o.isPacked&&s===!1){let m=this.unpackTensor(a);return this.disposeIntermediateTensorInfo(a),m}return a}compileAndRun(e,t,n,r,s=!1){return n=n||t[0].dtype,this.runWebGLProgram(e,t,n,r,s)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(X().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(t=>{this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram),delete this.binaryCache[t]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement!="undefined"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=M(()=>{if(!X().get("WEBGL_RENDER_FLOAT32_ENABLED")){let e=X().getBool("DEBUG");X().set("DEBUG",!1);let t=this.abs(ke(1e-8)).dataSync()[0];if(X().set("DEBUG",e),t>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?xQ:wQ}uploadToGPU(e){let t=this.texData.get(e),{shape:n,dtype:r,values:s,texture:a,usage:o,isPacked:i}=t;if(a!=null)return;let u=this.activeTimers!=null,l;u&&(l=w.now());let c=t.texShape;if(c==null&&(c=EN(n,i),t.texShape=c),s!=null){let d=Im(n),p,h=c[1],f=c[0],m=s instanceof Uint8Array||s instanceof Uint8ClampedArray;(i||!m)&&([h,f]=Vc(c[0],c[1])),i?p=new m9(d,m):p=new f9(d,m);let g=m?[f,h]:c,b=this.makeTensorInfo(g,r),y=this.texData.get(b.dataId);m?y.usage=wr.PIXELS:y.usage=wr.UPLOAD,y.texShape=g,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(b.dataId),h,f,s);let v=[[f,h]],x=!0,k=this.runWebGLProgram(p,[b],r,v,x),T=this.texData.get(k.dataId);t.texture=T.texture,t.texShape=T.texShape,t.isPacked=T.isPacked,t.usage=T.usage,this.disposeIntermediateTensorInfo(b),this.texData.delete(k.dataId),t.values=null,u&&(this.uploadWaitMs+=w.now()-l)}else{let d=this.acquireTexture(c,o,r,i);t.texture=d}}convertAndCacheOnCPU(e,t){let n=this.texData.get(e),{dtype:r}=n;return this.releaseGPUData(e),t!=null&&(n.values=TQ(t,r)),n.values}acquireTexture(e,t,n,r){if(this.numBytesInGPU+=this.computeBytes(e,n),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){let s=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${s} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,r)}computeBytes(e,t){return e[0]*e[1]*w.bytesPerElement(t)}},ik=f_;ik.nextDataId=0;function TQ(e,t){if(t==="float32"||t==="complex64")return e;if(t==="int32"||t==="bool"){let n=t==="int32"?new Int32Array(e.length):new Uint8Array(e.length);for(let r=0;r<n.length;++r)n[r]=Math.round(e[r]);return n}else throw new Error(`Unknown dtype ${t}`)}var NQ="0.0.0";function m_(){X().set("WEBGL_FORCE_F16_TEXTURES",!0)}bc.isBrowser()&&wd("webgl",()=>new ik,2);var _Q={forceHalfFloat:m_},g_=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`,Xc=class{constructor(e,t,n){this.variableNames=["A","B"],this.outputShape=N.assertAndGetBroadcastShape(t,n),this.enableShapeUniforms=qn(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}},Am=`
  result.r = isNaN.r > 0. ? NAN : result.r;
  result.g = isNaN.g > 0. ? NAN : result.g;
  result.b = isNaN.b > 0. ? NAN : result.b;
  result.a = isNaN.a > 0. ? NAN : result.a;
`,up=class{constructor(e,t,n,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=N.assertAndGetBroadcastShape(t,n);let s=this.outputShape.length;this.enableShapeUniforms=qn(s);let a="";if(r)if(s===0||w.sizeFromShape(this.outputShape)===1)a=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(a=`
          ${gt(s)} coords = getOutputCoords();
        `,s===1)this.enableShapeUniforms?a+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:a+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{let i=Fn("coords",s);this.enableShapeUniforms?a+=`
            bool nextRowOutOfBounds =
              (${i[s-2]} + 1) >= outShape[${s} - 2];
            bool nextColOutOfBounds =
              (${i[s-1]} + 1) >= outShape[${s} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:a+=`
            bool nextRowOutOfBounds =
              (${i[s-2]} + 1) >= ${this.outputShape[s-2]};
            bool nextColOutOfBounds =
              (${i[s-1]} + 1) >= ${this.outputShape[s-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${a}

        setOutput(result);
      }
    `}};function cr(e){let{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}var EQ={kernelName:_a,backendName:"webgl",kernelFunc:cr};function No(e){let{inputs:t,backend:n}=e,{real:r,imag:s}=t,a=n.makeTensorInfo(r.shape,"complex64"),o=n.texData.get(a.dataId),i=cr({inputs:{x:r},backend:n}),u=cr({inputs:{x:s},backend:n});return o.complexTensorInfos={real:i,imag:u},a}var AQ={kernelName:ql,backendName:"webgl",kernelFunc:No},b_="return (a < 0.) ? b * a : a;",y_=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function $Q(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{alpha:a}=r,o=n.makeTensorInfo([],"float32",w.createScalarValue(a,"float32")),i=X().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new up(y_,s.shape,o.shape):new Xc(b_,s.shape,o.shape),u=n.runWebGLProgram(i,[s,o],"float32");return n.disposeIntermediateTensorInfo(o),u}var FQ={kernelName:ti,backendName:"webgl",kernelFunc:$Q},v_="return (a < 0.) ? b * a : a;",x_=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function DQ(e){let{inputs:t,backend:n}=e,{x:r,alpha:s}=t,a=X().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new up(x_,r.shape,s.shape):new Xc(v_,r.shape,s.shape);return n.runWebGLProgram(a,[r,s],"float32")}var RQ={kernelName:za,backendName:"webgl",kernelFunc:DQ},w_="if (isnan(x)) return x;",PQ=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`,OQ=`
  result.r = isNaN.r > 0. ? NAN : result.r;
  result.g = isNaN.g > 0. ? NAN : result.g;
  result.b = isNaN.b > 0. ? NAN : result.b;
  result.a = isNaN.a > 0. ? NAN : result.a;
`;function Ze({opSnippet:e,packedOpSnippet:t,cpuKernelImpl:n,dtype:r}){return({inputs:s,backend:a})=>{let{x:o}=s,i=a,u=r||o.dtype;if(i.shouldExecuteOnCPU([o])&&n!=null){let d=i.texData.get(o.dataId),p=n(d.values,u);return i.makeTensorInfo(o.shape,u,p)}let l=X().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&t!=null,c;return l?c=new Kc(o.shape,t):c=new To(o.shape,e),i.runWebGLProgram(c,[o],u)}}function hn({opSnippet:e,packedOpSnippet:t,checkOutOfBounds:n=!1,supportsComplex:r=!1,cpuKernelImpl:s,dtype:a}){return({inputs:o,backend:i})=>{let{a:u,b:l}=o,c=i;if(r&&u.dtype==="complex64"){let f=c.texData.get(u.dataId),m=c.texData.get(l.dataId),[g,b]=[[f.complexTensorInfos.real,m.complexTensorInfos.real],[f.complexTensorInfos.imag,m.complexTensorInfos.imag]].map(v=>{let[x,k]=v,T={dataId:x.dataId,dtype:x.dtype,shape:u.shape},C={dataId:k.dataId,dtype:k.dtype,shape:l.shape},E=new Xc(e,u.shape,l.shape);return c.runWebGLProgram(E,[T,C],In(x.dtype,k.dtype))}),y=No({inputs:{real:g,imag:b},backend:c});return c.disposeIntermediateTensorInfo(g),c.disposeIntermediateTensorInfo(b),y}let d=a||In(u.dtype,l.dtype);if((u.dtype==="string"||l.dtype==="string"||c.shouldExecuteOnCPU([u,l]))&&s!=null){let f=c.texData.get(u.dataId).values,m=c.texData.get(l.dataId).values,g=u.dtype==="string"?N.fromUint8ToStringArray(f):f,b=u.dtype==="string"?N.fromUint8ToStringArray(m):m,[y,v]=s(u.shape,l.shape,g,b,d),x=c.makeTensorInfo(v,d),k=c.texData.get(x.dataId);return k.values=y,x}let p=X().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&t!=null,h;return p?h=new up(t,u.shape,l.shape,n):h=new Xc(e,u.shape,l.shape),c.runWebGLProgram(h,[u,l],d)}}function $m(e,t=!1){if(e==="linear")return t?hQ:uQ;if(e==="relu")return t?mQ:lQ;if(e==="elu")return t?fQ:cQ;if(e==="relu6")return t?gQ:dQ;if(e==="prelu")return t?x_:v_;if(e==="leakyrelu")return t?y_:b_;if(e==="sigmoid")return t?bQ:pQ;throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`)}var k_=class{constructor(e,t,n,r=!1,s=!1,a=!1,o=null,i=!1,u=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=qn(this.outputShape.length);let l=r?e[1]:e[2],c=Math.ceil(l/2),d=r?"i * 2, rc.y":"rc.y, i * 2",p=s?"rc.z, i * 2":"i * 2, rc.z",h=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],f=s?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"],m="",g="";o&&(i?m=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${o}
        }`:u?m=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${o}
        }`:m=`vec4 activation(vec4 x) {
          ${o}
        }`,g="result = activation(result);");let b=a?"result += getBiasAtOutCoords();":"";a&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),u&&this.variableNames.push("leakyreluAlpha");let y="rc.x",v="rc.x";e[0]<t[0]?y=`int(min(float(rc.x), ${e[0]-1}.))`:t[0]<e[0]&&(v=`int(min(float(rc.x), ${t[0]-1}.))`),this.userCode=`
      ${m}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${c}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        for (int i = 0; i < ${c}; i++) {
          int batchA = ${y};
          int batchB = ${v};
          vec4 a = getMatrixA(batchA, ${d});
          vec4 b = getMatrixB(batchB, ${p});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${h[0]} * ${f[0]});
          result += (${h[1]} * ${f[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${b}

        ${g}

        setOutput(result);
      }
    `}},I_={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"},S_=class{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=N.assertAndGetBroadcastShape(t,n),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}},C_="return a * b;";function uk(e){let{inputs:t,backend:n}=e,{a:r,b:s}=t,a=N.upcastType(r.dtype,s.dtype);if(r.dtype==="complex64"){let i=n.texData.get(r.dataId),u=n.texData.get(s.dataId),l=new S_(I_.REAL,r.shape,s.shape),c=new S_(I_.IMAG,r.shape,s.shape),d=[{dataId:i.complexTensorInfos.real.dataId,dtype:i.complexTensorInfos.real.dtype,shape:r.shape},{dataId:i.complexTensorInfos.imag.dataId,dtype:i.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:u.complexTensorInfos.real.dataId,dtype:u.complexTensorInfos.real.dtype,shape:s.shape},{dataId:u.complexTensorInfos.imag.dataId,dtype:u.complexTensorInfos.imag.dtype,shape:s.shape}],p=n.runWebGLProgram(l,d,"float32"),h=n.runWebGLProgram(c,d,"float32"),f=No({inputs:{real:p,imag:h},backend:n});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(h),f}if(n.shouldExecuteOnCPU([r,s])){let i=n.texData.get(r.dataId),u=n.texData.get(s.dataId),[l,c]=O9(r.shape,s.shape,i.values,u.values,a),d=n.makeTensorInfo(c,a),p=n.texData.get(d.dataId);return p.values=l,d}let o;return X().getBool("WEBGL_PACK_BINARY_OPERATIONS")?o=new up(C_,r.shape,s.shape):o=new Xc(C_,r.shape,s.shape),n.runWebGLProgram(o,[r,s],a)}var MQ={kernelName:Ma,backendName:"webgl",kernelFunc:uk};function LQ(e,t,n){let r=[nu(e.shape),...ru(e.shape)],s={dtype:e.dtype,shape:r,dataId:e.dataId},a=[nu(t),...ru(t)],o=new c_(a,r),i=!0,u=[r],l=n.runWebGLProgram(o,[s],e.dtype,u,i);return{dataId:l.dataId,shape:t,dtype:l.dtype}}function fe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{shape:a}=r,o=n,i=w.sizeFromShape(s.shape),u=w.inferFromImplicitShape(a,i),l=w.sizeFromShape(u);w.assert(i===l,()=>`The new shape (${u}) has ${l} elements and the old shape (${s.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`);let c=o.texData.get(s.dataId);return c.isPacked&&!op(s.shape,u)&&!(c.texture!==null&&op(c.shape,u))?LQ(s,u,o):(o.incRef(s.dataId),{dataId:s.dataId,shape:u,dtype:s.dtype})}var BQ={kernelName:hi,backendName:"webgl",kernelFunc:fe},T_=class{constructor(e,t){this.variableNames=["x"];let{windowSize:n,batchSize:r,inSize:s,outSize:a}=e;this.outputShape=[r,a];let o=Math.floor(n/4)*4,i=n%4,u="sumValue += dot(values, ones);";if(t!=null){let c=1/t;u=`sumValue += dot(values * ${w.isInt(c)?c.toPrecision(2):c}, ones);`}let l="";s%n>0&&(l=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${l}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n};

        float sumValue = 0.0;

        for (int i = 0; i < ${o}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${u}
        }

        int inIdx = inOffset + ${o};
        if (${i===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${u}
        } else if (${i===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${u}
        } else if (${i===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${u}
        }
        setOutput(sumValue);
      }
    `}},zQ=class{constructor(e,t){this.variableNames=["x"];let{windowSize:n,batchSize:r,inSize:s,outSize:a}=e;this.outputShape=[r,a];let o="0.0",i="";t==="prod"?o="1.0":t==="min"?(o="1.0 / 1e-20",i="min"):t==="max"&&(o="-1.0 / 1e-20",i="max");let u=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="sum"?u="sumValue":t==="prod"?u="prodValue":t==="all"?u="allValue":t==="any"&&(u="anyValue");let l=Math.floor(n/4)*4,c=n%4,d=`
      if (${t==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${t==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${i}(values, minMaxValue);
        if (${t==="min"} || ${t==="max"}) {
          minMaxValue = ${i}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,p="vec4";t==="all"?(o="1.0",d=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,p="bvec4"):t==="any"&&(o="0.0",d=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,p="bvec4");let h="";s%n>0&&(h=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${o};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${h}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n};

        vec4 minMaxValue = vec4(${o});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${l}; i += 4) {
          int inIdx = inOffset + i;
          ${p} values = ${p}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${d}
        }

        int inIdx = inOffset + ${l};
        if (${c===1}) {
          ${p} values = ${p}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${d}
        } else if (${c===2}) {
          ${p} values = ${p}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${d}
        } else if (${c===3}) {
          ${p} values = ${p}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${d}
        }
        setOutput(${u});
      }
    `}};function WQ(e){let t=[];for(;t.length===0||t[t.length-1].outSize!==1;){let n=t.length?t[t.length-1].outSize:e[1],r=N.computeOptimalWindowSize(n);t.push({inSize:n,windowSize:r,outSize:Math.ceil(n/r)})}return t}function ou(e,t,n,r){let s=WQ(e.shape),a=e;for(let o=0;o<s.length;o++){let{inSize:i,windowSize:u,outSize:l}=s[o],c,d;n==="mean"?c=o===0?new T_({windowSize:u,inSize:i,batchSize:e.shape[0],outSize:l},i):new T_({windowSize:u,inSize:i,batchSize:e.shape[0],outSize:l}):c=new zQ({windowSize:u,inSize:i,batchSize:e.shape[0],outSize:l},n),d=a,a=r.runWebGLProgram(c,[a],t),d.dataId!==e.dataId&&r.disposeIntermediateTensorInfo(d)}return a}var VQ=class{constructor(e,t){this.variableNames=["A"];let n=new Array(e.length);for(let a=0;a<n.length;a++)n[a]=e[t[a]];this.outputShape=n,this.rank=n.length;let r=gt(this.rank),s=UQ(t);this.userCode=`
    void main() {
      ${r} resRC = getOutputCoords();
      setOutput(getA(${s}));
    }
    `}};function UQ(e){let t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);let n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(t);for(let s=0;s<e.length;s++)r[e[s]]=n[s];return r.join()}var GQ=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;let n=new Array(e.length);for(let l=0;l<n.length;l++)n[l]=e[t[l]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);let r=gt(this.rank),s=u_("rc",this.rank),a=new Array(this.rank);for(let l=0;l<t.length;l++)a[t[l]]=s[l];let o=`vec2(${a.slice(-2).join()})`,i=`++${s[this.rank-1]} < ${n[this.rank-1]}`,u=`getChannel(getA(${a.join()}), ${o})`;this.userCode=`
    void main() {
      ${r} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${u};
      if(${i}) {
        result[1] = ${u};
      }
      --${s[this.rank-1]};
      if(++${s[this.rank-2]} < ${n[this.rank-2]}) {
        result[2] = ${u};
        if(${i}) {
          result[3] = ${u};
        }
      }
      setOutput(result);
    }
    `}};function Fm(e,t,n){let r=X().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new GQ(e.shape,t):new VQ(e.shape,t);return n.runWebGLProgram(r,[e],e.dtype)}function HQ(e,t,n,r){let s=t,a=e.shape.length,o=w.parseAxisParam(s,e.shape),i=o,u=N.getAxesPermutation(i,a),l=u!=null,c=e;l&&(c=Fm(e,u,r),i=N.getInnerMostAxes(i.length,a)),N.assertAxesAreInnerMostDims("sum",i,a);let[d,p]=N.computeOutAndReduceShapes(c.shape,i),h=d;n&&(h=N.expandShapeToKeepDim(d,o));let f=w.sizeFromShape(p),g=w.sizeFromShape(e.shape)/f,b=fe({inputs:{x:c},attrs:{shape:[g,f]},backend:r}),y=bd(e.dtype),v=ou(b,y,"sum",r),x=fe({inputs:{x:v},attrs:{shape:h},backend:r});return r.disposeIntermediateTensorInfo(b),r.disposeIntermediateTensorInfo(v),l&&r.disposeIntermediateTensorInfo(c),x}function Dm(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:o}=r;return HQ(s,a,o,n)}var jQ={kernelName:Ka,backendName:"webgl",kernelFunc:Dm};function Dn(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{perm:a}=r,o=n,i=s.shape.length,u=new Array(i);for(let c=0;c<u.length;c++)u[c]=s.shape[a[c]];let l;if(o.shouldExecuteOnCPU([s])){let d=o.texData.get(s.dataId).values,p=ok(d,s.shape,s.dtype,a,u);l=o.makeTensorInfo(u,s.dtype);let h=o.texData.get(l.dataId);h.values=p}else l=Fm(s,a,o);return l}var qQ={kernelName:Ja,backendName:"webgl",kernelFunc:Dn},N_=1e3;function Rm({a:e,b:t,transposeA:n,transposeB:r,backend:s,bias:a=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:u=null}){let l=e.shape.length,c=t.shape.length,d=n?e.shape[l-2]:e.shape[l-1],p=r?t.shape[c-1]:t.shape[c-2],h=n?e.shape[l-1]:e.shape[l-2],f=r?t.shape[c-2]:t.shape[c-1],m=e.shape.slice(0,-2),g=t.shape.slice(0,-2),b=w.sizeFromShape(m),y=w.sizeFromShape(g),x=Ri.assertAndGetBroadcastShape(e.shape.slice(0,-2),t.shape.slice(0,-2)).concat([h,f]);w.assert(d===p,()=>`Error in matMul: inner shapes (${d}) and (${p}) of Tensors with shapes ${e.shape} and ${t.shape} and transposeA=${n} and transposeB=${r} must match.`);let k=n?[b,d,h]:[b,h,d],T=r?[y,f,p]:[y,p,f],C=fe({inputs:{x:e},backend:s,attrs:{shape:k}}),E=fe({inputs:{x:t},backend:s,attrs:{shape:T}}),F=[C,E],O=Math.max(b,y),D=n?C.shape[1]:C.shape[2],R=a!=null,_=o!=null,L=u==="leakyrelu",U=u!=null?$m(u,!0):null,j=R||_||L||U!=null,K;if((h===1||f===1)&&D>N_&&j===!1){let Q=C,ee=E;n&&(Q=Dn({inputs:{x:C},backend:s,attrs:{perm:[0,2,1]}}),F.push(Q)),r&&(ee=Dn({inputs:{x:E},backend:s,attrs:{perm:[0,2,1]}}),F.push(ee));let re=f!==1,se=f===1,ne=Q;re&&(ne=fe({inputs:{x:Q},backend:s,attrs:{shape:[O,D,1]}}),F.push(ne));let ie=f===1?2:1,te=ee;se&&(te=fe({inputs:{x:ee},backend:s,attrs:{shape:[O,1,D]}}),F.push(te));let pe=uk({inputs:{a:ne,b:te},backend:s});K=Dm({inputs:{x:pe},backend:s,attrs:{axis:ie,keepDims:!0}}),F.push(pe)}else{let Q=In(e.dtype,t.dtype),ee=new k_(k,T,[O,h,f],n,r,R,U,_,L),re=[C,E];if(a!=null&&re.push(a),_&&re.push(o),L){let se=s.makeTensorInfo([],"float32",w.createScalarValue(i,"float32"));re.push(se),F.push(se)}K=s.runWebGLProgram(ee,re,Q)}let q=fe({inputs:{x:K},backend:s,attrs:{shape:x}});F.push(K);for(let Q of F)s.disposeIntermediateTensorInfo(Q);return q}function KQ(e){let{inputs:t,backend:n,attrs:r}=e,{a:s,b:a,bias:o,preluActivationWeights:i}=t,{transposeA:u,transposeB:l,activation:c,leakyreluAlpha:d}=r;return Rm({a:s,b:a,transposeA:u,transposeB:l,backend:n,bias:o,preluActivationWeights:i,leakyreluAlpha:d,activation:c})}var XQ={kernelName:to,backendName:"webgl",kernelFunc:KQ},__="return abs(x);";function YQ(e){let{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])&&r.dtype!=="complex64"){let a=n.texData.get(r.dataId),o=o_(a.values);return n.makeTensorInfo(r.shape,r.dtype,o)}let s;return X().getBool("WEBGL_PACK_UNARY_OPERATIONS")?s=new Kc(r.shape,__):s=new To(r.shape,__),n.runWebGLProgram(s,[r],r.dtype)}var QQ={kernelName:Vo,backendName:"webgl",kernelFunc:YQ},ZQ=ts+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,JQ=Ze({opSnippet:ZQ}),eZ={kernelName:Wu,backendName:"webgl",kernelFunc:JQ},tZ=ts+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,nZ=Ze({opSnippet:tZ}),rZ={kernelName:Vu,backendName:"webgl",kernelFunc:nZ},E_="return a + b;",sZ=hn({opSnippet:E_,packedOpSnippet:E_,supportsComplex:!0,cpuKernelImpl:b9}),aZ={kernelName:_s,backendName:"webgl",kernelFunc:sZ},oZ=class{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((s,a)=>`T${a}`);let n=[];this.variableNames.forEach(s=>{n.push(`float v${s} = get${s}AtOutCoords();`)});let r=this.variableNames.map(s=>`v${s}`).join(" + ");this.userCode=`
      void main() {
        ${n.join(`
        `)}

        float result = ${r};
        setOutput(result);
      }
    `}},iZ=class{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((s,a)=>`T${a}`);let n=[];this.variableNames.forEach(s=>{n.push(`vec4 v${s} = get${s}AtOutCoords();`)});let r=this.variableNames.map(s=>`v${s}`).join(" + ");this.userCode=`
      void main() {
        ${n.join(`
        `)}

        vec4 result = ${r};
        setOutput(result);
      }
    `}};function Pm(e){let{inputs:t,backend:n}=e,r=t;if(r.length===1)return cr({inputs:{x:r[0]},backend:n});if(r.length>X().get("WEBGL_MAX_TEXTURES_IN_SHADER")){let u=Math.floor(r.length/2),l=Pm({inputs:r.slice(0,u),backend:n}),c=Pm({inputs:r.slice(u),backend:n});return Pm({inputs:[l,c],backend:n})}let s=r.map(u=>u.dtype).reduce((u,l)=>In(u,l)),a=r.map(u=>u.shape),i=X().getBool("WEBGL_PACK")?new iZ(r[0].shape,a):new oZ(r[0].shape,a);return n.runWebGLProgram(i,r,s)}var uZ={kernelName:la,backendName:"webgl",kernelFunc:Pm};function cZ(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:o}=r,i=s.shape.length,u=w.parseAxisParam(a,s.shape),l=u,c=N.getAxesPermutation(l,i),d=s;c!=null&&(d=Dn({inputs:{x:s},backend:n,attrs:{perm:c}}),l=N.getInnerMostAxes(l.length,i)),N.assertAxesAreInnerMostDims("all",l,i);let[p,h]=N.computeOutAndReduceShapes(d.shape,l),f=w.sizeFromShape(h),m=fe({inputs:{x:d},backend:n,attrs:{shape:[-1,f]}}),g=ou(m,m.dtype,"all",n),b;if(o){let y=N.expandShapeToKeepDim(p,u);b=fe({inputs:{x:g},backend:n,attrs:{shape:y}})}else b=fe({inputs:{x:g},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),c!=null&&n.disposeIntermediateTensorInfo(d),b}var lZ={kernelName:Uu,backendName:"webgl",kernelFunc:cZ};function dZ(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:o}=r,i=s.shape.length,u=w.parseAxisParam(a,s.shape),l=u,c=N.getAxesPermutation(l,i),d=s;c!=null&&(d=Dn({inputs:{x:s},backend:n,attrs:{perm:c}}),l=N.getInnerMostAxes(l.length,i)),N.assertAxesAreInnerMostDims("any",l,i);let[p,h]=N.computeOutAndReduceShapes(d.shape,l),f=w.sizeFromShape(h),m=fe({inputs:{x:d},backend:n,attrs:{shape:[-1,f]}}),g=ou(m,m.dtype,"any",n),b;if(o){let y=N.expandShapeToKeepDim(p,u);b=fe({inputs:{x:g},backend:n,attrs:{shape:y}})}else b=fe({inputs:{x:g},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),c!=null&&n.disposeIntermediateTensorInfo(d),b}var pZ={kernelName:Gu,backendName:"webgl",kernelFunc:dZ},hZ=class{constructor(e,t,n){this.variableNames=["A"];let{windowSize:r,batchSize:s,outSize:a}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[s,a];let o=t==="max"?">":"<",i=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${r}; i++) {
          int inIdx = ${i};
          float candidate = getA(batch, inIdx);
          if (candidate ${o} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}},fZ=class{constructor(e,t,n,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,w.assert(e.length>2,()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`);let s=e[e.length-1],a=Math.ceil(s/t);this.outputShape=e.slice(0,-1),a>1&&this.outputShape.push(a),r||this.variableNames.push("bestIndicesA");let o=this.outputShape,i=o.length,u=gt(i),l=Fn("coords",i),c,d;if(a===1){d=i+1;let C=gt(d);c=`
        ${C} sourceLocR = ${C}(${l.join()}, 0);
        ++${l[i-1]};
        ${C} sourceLocG = ${C}(${l.join()}, 0);
        ++${l[i-2]};
        ${C} sourceLocA = ${C}(${l.join()}, 0);
        --${l[i-1]};
        ${C} sourceLocB = ${C}(${l.join()}, 0);
        --${l[i-2]};`}else d=i,c=`
        ${u} sourceLocR = coords;
        ++${l[i-1]};
        ${u} sourceLocG = coords;
        ++${l[i-2]};
        ${u} sourceLocA = coords;
        --${l[i-1]};
        ${u} sourceLocB = coords;
        --${l[i-2]};`;let p=["x","y","z","w","u","v"].slice(0,d),h="."+p[d-1],f=p.map(C=>"int "+C),m=Fn("sourceLocR",d-1).concat("inIdx.r"),g=Fn("sourceLocG",d-1).concat("inIdx.g"),b=Fn("sourceLocB",d-1).concat("inIdx.b"),y=Fn("sourceLocA",d-1).concat("inIdx.a"),v=n==="max"?"greaterThan":"lessThan",x=r?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${m.join()}),
                             getBestIndicesAChannel(${g.join()}),
                             getBestIndicesAChannel(${b.join()}),
                             getBestIndicesAChannel(${y.join()})));`,k=`vec4(
            getAChannel(${m.join()}),
            hasNextCol ? getAChannel(${g.join()}) : 0.,
            hasNextRow ? getAChannel(${b.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${y.join()}) : 0.)`,T=r?"":`
      float getBestIndicesAChannel(${f.join()}) {
        return getChannel(getBestIndicesA(${p.join()}),
                                          vec2(${p.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${f.join()}) {
        return getChannel(getA(${p.join()}),
                               vec2(${p.slice(-2).join()}));
      }
      ${T}
      void main() {
        ${u} coords = getOutputCoords();
        bool hasNextCol = ${l[i-1]} < ${o[i-1]-1};
        bool hasNextRow = ${l[i-2]} < ${o[i-2]-1};
        ${c}
        ivec4 srcIdx = ivec4(sourceLocR${h}, sourceLocG${h},
          sourceLocB${h}, sourceLocA${h}) * ${t};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${k};

        for (int i = 0; i < ${t}; i++) {
          inIdx = srcIdx;
          ${x}
          vec4 candidate = ${k};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${v}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}};function A_(e,t,n,r=null){let s=t.shape[0],a=t.shape[1];r!=null&&(s=r.shape[0],a=r.shape[1]);let o=N.computeOptimalWindowSize(a),i={windowSize:o,inSize:a,batchSize:s,outSize:Math.ceil(a/o)},u=new hZ(i,n,r==null),l=[t];r!=null&&l.push(r);let c=e.runWebGLProgram(u,l,"int32");if(c.shape[1]===1)return c;let d=A_(e,t,n,c);return e.disposeIntermediateTensorInfo(c),d}function $_(e,t,n,r=null){let s=r!=null?r.shape:t.shape,a=s[s.length-1],o=N.computeOptimalWindowSize(a),i=new fZ(s,o,n,r==null),u=r==null?[t]:[t,r],l=e.runWebGLProgram(i,u,"int32");if(l.shape.length===t.shape.length){let c=$_(e,t,n,l);return e.disposeIntermediateTensorInfo(l),c}return l}function F_(e,t,n,r){let s=[n];if(N.assertAxesAreInnerMostDims("arg"+r.charAt(0).toUpperCase()+r.slice(1),s,t.shape.length),!X().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){let a=[],o=e.texData.get(t.dataId),i=o!==null&&o.isPacked,u=t;i&&(u=e.unpackTensor(t),a.push(u));let[l,c]=N.computeOutAndReduceShapes(u.shape,s),d=w.sizeFromShape(c),p=fe({inputs:{x:u},backend:e,attrs:{shape:[-1,d]}});a.push(p);let h=A_(e,p,r);a.push(h);let f=fe({inputs:{x:h},backend:e,attrs:{shape:l}});return a.forEach(m=>e.disposeIntermediateTensorInfo(m)),f}return $_(e,t,r)}function mZ(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r,o=w.parseAxisParam(a,s.shape),i=N.getAxesPermutation(o,s.shape.length),u=s,l=[];i!=null&&(u=Dn({inputs:{x:s},backend:n,attrs:{perm:i}}),l.push(u),o=N.getInnerMostAxes(o.length,u.shape.length)),N.assertAxesAreInnerMostDims("argMax",[o[0]],u.shape.length);let c=F_(n,u,o[0],"max");return l.forEach(d=>n.disposeIntermediateTensorInfo(d)),c}var gZ={kernelName:da,backendName:"webgl",kernelFunc:mZ};function bZ(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r,o=w.parseAxisParam(a,s.shape),i=N.getAxesPermutation(o,s.shape.length),u=s,l=[];i!=null&&(u=Dn({inputs:{x:s},backend:n,attrs:{perm:i}}),l.push(u),o=N.getInnerMostAxes(o.length,u.shape.length)),N.assertAxesAreInnerMostDims("argMin",[o[0]],u.shape.length);let c=F_(n,u,o[0],"min");return l.forEach(d=>n.disposeIntermediateTensorInfo(d)),c}var yZ={kernelName:Hu,backendName:"webgl",kernelFunc:bZ},vZ=ts+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,xZ=Ze({opSnippet:vZ}),wZ={kernelName:ju,backendName:"webgl",kernelFunc:xZ},kZ=ts+"return log(x + sqrt(x * x + 1.0));",IZ=Ze({opSnippet:kZ}),SZ={kernelName:qu,backendName:"webgl",kernelFunc:IZ},CZ=ts+`
  return atan(x);
`,TZ=Ze({opSnippet:CZ}),NZ={kernelName:Ku,backendName:"webgl",kernelFunc:TZ},_Z=PQ+`
  return atan(a, b);
`,EZ=`
  vec4 result = atan(a, b);
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  `+OQ+`
  return result;
`,AZ=hn({opSnippet:_Z,packedOpSnippet:EZ}),$Z={kernelName:Yu,backendName:"webgl",kernelFunc:AZ},FZ=ts+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,DZ=Ze({opSnippet:FZ}),RZ={kernelName:Xu,backendName:"webgl",kernelFunc:DZ},cp=class{constructor(e,t,n,r=!1,s=!1){if(this.variableNames=["x"],t==="avg"&&n)throw new Error("Cannot compute positions for average pool.");let a=e.filterWidth,o=e.strideHeight,i=e.strideWidth,u=e.dilationHeight,l=e.dilationWidth,c=e.effectiveFilterHeight,d=e.effectiveFilterWidth,p=e.padInfo.top,h=e.padInfo.left;this.outputShape=e.outShape;let f=t==="avg",m=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,g=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`,b="0.0";if(f||(b="-1.0 / 1e-20"),n){let C=">=";this.userCode=`
        const ivec2 strides = ivec2(${o}, ${i});
        const ivec2 pads = ivec2(${p}, ${h});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${c};
              wR += ${u}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${d};
                wC += ${l}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${C} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${r?s?m:g:`wR * ${d} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let y="max",v=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(v="avgValue / count");let x=Math.floor(a/4)*4,k=a%4,T=`
      if (${f}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${y}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${o}, ${i});
      const ivec2 pads = ivec2(${p}, ${h});
      const float initializationValue = ${b};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${b});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${c};
            wR += ${u}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${x}; wC += 4) {
            int xC = xCCorner + wC * ${l};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${l}, d),
              getValue(batch, xR, xC + 2 * ${l}, d),
              getValue(batch, xR, xC + 3 * ${l}, d)
            );

            ${T}
          }

          int xC = xCCorner + ${x};
          if (${k===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${T}
          } else if (${k===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${l}, d),
              initializationValue,
              initializationValue
            );

            ${T}
          } else if (${k===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${l}, d),
              getValue(batch, xR, xC + 2 * ${l}, d),
              initializationValue
            );

            ${T}
          }
        }
        setOutput(${v});
      }
    `}},ck=class{constructor(e,t,n,r=!1,s=!1){if(this.variableNames=["x"],t==="avg"&&n)throw new Error("Cannot compute positions for average pool.");let a=e.filterWidth,o=e.strideDepth,i=e.strideHeight,u=e.strideWidth,l=e.dilationDepth,c=e.dilationHeight,d=e.dilationWidth,p=e.effectiveFilterDepth,h=e.effectiveFilterHeight,f=e.effectiveFilterWidth,m=e.padInfo.front,g=e.padInfo.top,b=e.padInfo.left;this.outputShape=e.outShape;let y=t==="avg",v="0.0";if(y||(v="-1.0 / 1e-20"),n){let F=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${o}, ${i}, ${u});
        const ivec3 pads = ivec3(${m}, ${g}, ${b});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${p};
              wD += ${l}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${h};
                wR += ${c}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${f};
                  wC += ${d}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${F} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${r?s?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${h} * ${f} +
                      wR * ${f} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let x="max",k=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(k="avgValue / count");let T=Math.floor(a/4)*4,C=a%4,E=`
      if (${y}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${x}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${o}, ${i}, ${u});
      const ivec3 pads = ivec3(${m}, ${g}, ${b});
      const float initializationValue = ${v};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${v});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${p};
            wD += ${l}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${h};
            wR += ${c}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${T}; wC += 4) {
              int xC = xCCorner + wC * ${d};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                getValue(batch, xD, xR, xC + 2 * ${d}, ch),
                getValue(batch, xD, xR, xC + 3 * ${d}, ch)
              );

              ${E}
            }

            int xC = xCCorner + ${T};
            if (${C===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${E}
            } else if (${C===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                initializationValue,
                initializationValue
              );

              ${E}
            } else if (${C===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                getValue(batch, xD, xR, xC + 2 * ${d}, ch),
                initializationValue
              );

              ${E}
            }
          }
          setOutput(${k});
        }
      }
    `}};function PZ(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t;Uc(s,"avgPool");let{filterSize:a,strides:o,pad:i,dimRoundingMode:u}=r,l=1;w.assert(N.eitherStridesOrDilationsAreOne(o,l),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${l}'`);let c=N.computePool2DInfo(s.shape,a,o,l,i,u);if(c.filterWidth===1&&c.filterHeight===1&&w.arraysEqual(c.inShape,c.outShape))return cr({inputs:{x:s},backend:n});let d=new cp(c,"avg",!1);return n.runWebGLProgram(d,[s],"float32")}var OZ={kernelName:pa,backendName:"webgl",kernelFunc:PZ};function MZ(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:o,pad:i,dimRoundingMode:u,dataFormat:l}=r,c=[1,1,1],d=N.computePool3DInfo(s.shape,a,o,c,i,u,l),p=new ck(d,"avg",!1);return n.runWebGLProgram(p,[s],"float32")}var LZ={kernelName:jl,backendName:"webgl",kernelFunc:MZ},BZ=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,s=e.strideWidth,a=e.dilationHeight,o=e.dilationWidth,i=e.effectiveFilterHeight,u=e.effectiveFilterWidth,l=i-1-e.padInfo.top,c=u-1-e.padInfo.left,d=1/(t*n);this.userCode=`
      const ivec2 pads = ivec2(${l}, ${c});
      const float avgMultiplier = float(${d});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${i};
            wR += ${a}) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${u};
            wC+= ${o}) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}},zZ=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;let t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,s=e.strideDepth,a=e.strideHeight,o=e.strideWidth,i=e.dilationDepth,u=e.dilationHeight,l=e.dilationWidth,c=e.effectiveFilterDepth,d=e.effectiveFilterHeight,p=e.effectiveFilterWidth,h=c-1-e.padInfo.front,f=d-1-e.padInfo.top,m=p-1-e.padInfo.left,g=1/(t*n*r);this.userCode=`
      const ivec3 pads = ivec3(${h}, ${f}, ${m});
      const float avgMultiplier = float(${g});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${c};
            wD += ${i}) {
          float dyD = float(dyDCorner + wD) / ${s}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${d};
              wR += ${u}) {
            float dyR = float(dyRCorner + wR) / ${a}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${p};
                wC += ${l}) {
              float dyC = float(dyCCorner + wC) / ${o}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function WZ(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,o=a,{filterSize:i,strides:u,pad:l,dimRoundingMode:c}=r,d=[1,1,1],p=N.computePool3DInfo(o.shape,i,u,d,l,c),h=new zZ(p);return n.runWebGLProgram(h,[s],o.dtype)}var VZ={kernelName:gh,backendName:"webgl",kernelFunc:WZ};function UZ(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,o=a;Uc([s,a],"avgPoolGrad");let{filterSize:i,strides:u,pad:l}=r,c=N.computePool2DInfo(o.shape,i,u,1,l),d=new BZ(c);return n.runWebGLProgram(d,[s],o.dtype)}var GZ={kernelName:mh,backendName:"webgl",kernelFunc:UZ};function HZ(e){let{inputs:t,backend:n,attrs:r}=e,{a:s,b:a}=t,{transposeA:o,transposeB:i}=r;return Rm({a:s,b:a,transposeA:o,transposeB:i,backend:n})}var jZ={kernelName:ha,backendName:"webgl",kernelFunc:HZ},qZ=class{constructor(e,t,n,r,s,a){this.outputShape=[],this.variableNames=["x","mean","variance"],N.assertAndGetBroadcastShape(e,t),N.assertAndGetBroadcastShape(e,n);let o="0.0";r!=null&&(N.assertAndGetBroadcastShape(e,r),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let i="1.0";s!=null&&(N.assertAndGetBroadcastShape(e,s),this.variableNames.push("scale"),i="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${o};
        float scale = ${i};
        float inv = scale * inversesqrt(variance + float(${a}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}},KZ=class{constructor(e,t,n,r,s,a){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],N.assertAndGetBroadcastShape(e,t),N.assertAndGetBroadcastShape(e,n);let o="vec4(0.0)";r!=null&&(N.assertAndGetBroadcastShape(e,r),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let i="vec4(1.0)";s!=null&&(N.assertAndGetBroadcastShape(e,s),this.variableNames.push("scale"),i="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        vec4 offset = ${o};
        vec4 scale = ${i};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${a}));

        setOutput((x - mean) * inv + offset);
      }
    `}},XZ=({inputs:e,backend:t,attrs:n})=>{let{x:r,mean:s,variance:a,offset:o,scale:i}=e;w.assert(s.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),w.assert(o==null||s.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),w.assert(i==null||s.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:u}=n;u==null&&(u=.001);let l=[r,s,a],c=null;o!=null&&(c=o.shape,l.push(o));let d=null;i!=null&&(d=i.shape,l.push(i));let p=X().getBool("WEBGL_PACK_NORMALIZATION")?new KZ(r.shape,s.shape,a.shape,c,d,u):new qZ(r.shape,s.shape,a.shape,c,d,u);return t.runWebGLProgram(p,l,l[0].dtype)},YZ={kernelName:Ta,backendName:"webgl",kernelFunc:XZ},QZ=class{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;let t=gt(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let n=ZZ(this.rank),r,s=e.map((a,o)=>`sourceLoc.${lk[o]} = start[${o}] + coords.${lk[o]};`);r=`
        ${t} sourceLoc;
        ${t} coords = getOutputCoords();
        ${s.join(`
`)}
      `,this.userCode=`
      void main() {
        ${r}
        setOutput(getSource(${n}));
      }
    `}},lk=["x","y","z","w","u","v"];function ZZ(e){if(e===1)return"sourceLoc";if(e<=6)return lk.slice(0,e).map(t=>"sourceLoc."+t).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}var JZ=class{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let t=gt(this.rank),n=Fn("coords",this.rank),r=Fn("sourceLoc",this.rank),s=this.rank===1?"sourceLoc":`vec2(${r.slice(-2).join()})`,a=`getChannel(getSource(${r.join()}), ${s})`,o=`
      result.x = ${a};
      if (++${n[this.rank-1]} < ${e[this.rank-1]}) {
        ++${r[this.rank-1]};
        result.y = ${a};
        --${r[this.rank-1]};
      }
    `,i=this.rank===1?"":`
      --${n[this.rank-1]};
      if (++${n[this.rank-2]} < ${e[this.rank-2]}) {
        ++${r[this.rank-2]};
        result.z = ${a};
        if (++${n[this.rank-1]} < ${e[this.rank-1]}) {
          ++${r[this.rank-1]};
          result.w = ${a};
        }
      }
    `,u=this.rank<=4?`sourceLoc = coords +
            ${t}(${e.map((l,c)=>`start[${c}]`).join()});`:e.map((l,c)=>`${r[c]} = ${n[c]} + start[${c}];`).join(`
`);this.userCode=`
      void main() {
        ${t} coords = getOutputCoords();
        ${t} sourceLoc;
        ${u}
        vec4 result = vec4(0.);
        ${o}
        ${i}
        setOutput(result);
      }
    `}};function eJ(e,t,n,r){let s=r.texData.get(e.dataId),a=r.makeTensorInfo(n,e.dtype),o=r.texData.get(a.dataId);Object.assign(o,s),o.refCount=1,o.shape=n,o.dtype=e.dtype;let i=$t.computeFlatOffset(t,w.computeStrides(e.shape));s.slice&&(i+=s.slice.flatOffset),o.slice={flatOffset:i,origDataId:s.slice&&s.slice.origDataId||e.dataId};let u=r.dataRefCount.get(o.slice.origDataId)||1;return r.dataRefCount.set(o.slice.origDataId,u+1),a}function Yc(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,size:o}=r,[i,u]=$t.parseSliceParams(s,a,o);if($t.assertParamsValid(s,i,u),w.sizeFromShape(u)===0)return n.makeTensorInfo(u,s.dtype,[]);if(n.shouldExecuteOnCPU([s])||s.dtype==="string"){let d=n.texData.get(s.dataId),p=U9(d.values,i,u,s.shape,s.dtype);return n.makeTensorInfo(u,s.dtype,p)}let{isPacked:l}=n.texData.get(s.dataId),c=$t.isSliceContinous(s.shape,i,u);if(l||!c){let d=X().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new JZ(u):new QZ(u),p=[i];return n.runWebGLProgram(d,[s],s.dtype,p)}return n.uploadToGPU(s.dataId),eJ(s,i,u,n)}var tJ={kernelName:yi,backendName:"webgl",kernelFunc:Yc},nJ=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,crops:o}=r;w.assert(s.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");let i=a.reduce((y,v)=>y*v),u=N.getReshaped(s.shape,a,i),l=N.getPermuted(u.length,a.length),c=N.getReshapedPermuted(s.shape,a,i),d=N.getSliceBeginCoords(o,a.length),p=N.getSliceSize(c,o,a.length),h=[],f=fe({inputs:{x:s},backend:n,attrs:{shape:u}}),m=Dn({inputs:{x:f},backend:n,attrs:{perm:l}}),g=fe({inputs:{x:m},backend:n,attrs:{shape:c}}),b=Yc({inputs:{x:g},backend:n,attrs:{begin:d,size:p}});return h.push(f),h.push(m),h.push(g),h.forEach(y=>n.disposeIntermediateTensorInfo(y)),b},rJ={kernelName:Uo,backendName:"webgl",kernelFunc:nJ};function sJ(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:o}=r,i=n.readSync(s.dataId),u=n.readSync(a.dataId),l=a_(i,u,a.dtype,a.shape,o);return n.makeTensorInfo([o],a.dtype,l)}var aJ={kernelName:bh,backendName:"webgl",kernelFunc:sJ};function oJ(e){let{inputs:t,backend:n}=e,{s0:r,s1:s}=t,a=n.readSync(r.dataId),o=n.readSync(s.dataId),i=N.assertAndGetBroadcastShape(Array.from(a),Array.from(o));return n.makeTensorInfo([i.length],"int32",Int32Array.from(i))}var iJ={kernelName:yh,backendName:"webgl",kernelFunc:oJ},uJ="return float(a != b);",D_=hn({opSnippet:uJ,cpuKernelImpl:L9,dtype:"bool"}),cJ={kernelName:oi,backendName:"webgl",kernelFunc:D_};function lp(e){let{inputs:t,backend:n}=e,{input:r}=t,s=n.texData.get(r.dataId);return cr({inputs:{x:s.complexTensorInfos.real},backend:n})}var lJ={kernelName:nd,backendName:"webgl",kernelFunc:lp},dJ="return float(int(x));";function pJ(e,t){let n=new To(e.shape,dJ),r=t.runWebGLProgram(n,[e],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}function dk(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dtype:a}=r;if(a==="complex64"){if(s.dtype==="complex64")return cr({inputs:{x:s},backend:n});let o=kt(s.shape),i=dk({inputs:{x:s},backend:n,attrs:{dtype:"float32"}}),u=No({inputs:{real:i,imag:o},backend:n});return o.dispose(),n.disposeIntermediateTensorInfo(i),u}if(s.dtype==="complex64"){let o=lp({inputs:{input:s},backend:n}),i=dk({inputs:{x:o},backend:n,attrs:{dtype:a}});return n.disposeIntermediateTensorInfo(o),i}if(!w.hasEncodingLoss(s.dtype,a)){let o=cr({inputs:{x:s},backend:n});return{dataId:o.dataId,shape:o.shape,dtype:a}}if(a==="int32")return pJ(s,n);if(a==="bool"){let o=n.makeTensorInfo([],"bool",w.getTypedArrayFromDType("bool",1)),u=D_({inputs:{a:s,b:o},backend:n});return n.disposeIntermediateTensorInfo(o),u}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${a}`)}var hJ={kernelName:fa,backendName:"webgl",kernelFunc:dk},R_="return ceil(x);",fJ=Ze({opSnippet:R_,packedOpSnippet:R_,cpuKernelImpl:v9}),mJ={kernelName:ma,backendName:"webgl",kernelFunc:fJ},gJ=class{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}},bJ=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}};function yJ(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{clipValueMin:a,clipValueMax:o}=r,i;X().getBool("WEBGL_PACK_CLIP")?i=new bJ(s.shape):i=new gJ(s.shape);let u=[[a],[o]];return n.runWebGLProgram(i,[s],s.dtype,u)}var vJ={kernelName:Es,backendName:"webgl",kernelFunc:yJ},xJ=class{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}};function P_(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}function wJ(e){let{inputs:t,backend:n}=e,{x:r}=t,s=n.texData.get(r.dataId),a=new xJ(r.shape),o=[P_(r,s.complexTensorInfos.real),P_(r,s.complexTensorInfos.imag)];return n.runWebGLProgram(a,o,o[0].dtype)}var kJ={kernelName:Kl,backendName:"webgl",kernelFunc:wJ},IJ=class{constructor(e){this.outputShape=[],this.outputShape=N.computeOutShape(e,1),this.variableNames=e.map((a,o)=>`T${o}`);let t=new Array(e.length-1);t[0]=e[0][1];for(let a=1;a<t.length;a++)t[a]=t[a-1]+e[a][1];let n=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let a=1;a<t.length;a++){let o=t[a-1];n.push(`else if (yC < ${t[a]}) setOutput(getT${a}(yR, yC-${o}));`)}let r=t.length,s=t[t.length-1];n.push(`else setOutput(getT${r}(yR, yC-${s}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${n.join(`
        `)}
      }
    `}},SJ=class{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=N.computeOutShape(e,t);let n=this.outputShape,r=n.length,s=gt(r),a=Fn("coords",r),o=["x","y","z","w","u","v"].slice(0,r);this.variableNames=e.map((f,m)=>`T${m}`);let i=new Array(e.length-1);i[0]=e[0][t];for(let f=1;f<i.length;f++)i[f]=i[f-1]+e[f][t];let u=o[t],l=o.slice(-2),c=o.join(),d=`if (${u} < ${i[0]}) {
        return getChannel(
            getT0(${c}), vec2(${l.join()}));
        }`;for(let f=1;f<i.length;f++){let m=i[f-1];d+=`
        if (${u} < ${i[f]}  && ${u} >= ${i[f-1]}) {
          return getChannel(
            getT${f}(${Om(o,u,m)}),
            vec2(${Om(l,u,m)}));
        }`}let p=i.length,h=i[i.length-1];d+=`
        return getChannel(
          getT${p}(${Om(o,u,h)}),
          vec2(${Om(l,u,h)}));`,this.userCode=`
      float getValue(${o.map(f=>"int "+f)}) {
        ${d}
      }

      void main() {
        ${s} coords = getOutputCoords();
        vec4 result = vec4(getValue(${a}), 0., 0., 0.);

        ${a[r-1]} = ${a[r-1]} + 1;
        if (${a[r-1]} < ${n[r-1]}) {
          result.g = getValue(${a});
        }

        ${a[r-2]} = ${a[r-2]} + 1;
        if (${a[r-2]} < ${n[r-2]}) {
          result.a = getValue(${a});
        }

        ${a[r-1]} = ${a[r-1]} - 1;
        if (${a[r-2]} < ${n[r-2]} &&
            ${a[r-1]} < ${n[r-1]}) {
          result.b = getValue(${a});
        }
        setOutput(result);
      }
    `}};function Om(e,t,n){let r=e.indexOf(t);return e.map((a,o)=>o===r?`${a} - ${n}`:a).join()}function Mm(e){let{inputs:t,backend:n}=e,{input:r}=t,s=n.texData.get(r.dataId);return cr({inputs:{x:s.complexTensorInfos.imag},backend:n})}var CJ={kernelName:Zl,backendName:"webgl",kernelFunc:Mm};function Qc(e,t,n){let r=e[0].dtype;if(r==="complex64"){let c=e.map(m=>lp({inputs:{input:m},backend:n})),d=e.map(m=>Mm({inputs:{input:m},backend:n})),p=Qc(c,t,n),h=Qc(d,t,n),f=No({inputs:{real:p,imag:h},backend:n});return c.forEach(m=>n.disposeIntermediateTensorInfo(m)),d.forEach(m=>n.disposeIntermediateTensorInfo(m)),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(h),f}let s=n.shouldExecuteOnCPU(e);if(r==="string"&&(s=!0),s){let c=e.map(b=>{let y=w.sizeFromShape(b.shape.slice(t));return fe({inputs:{x:b},backend:n,attrs:{shape:[-1,y]}})}),d=c.map(b=>({vals:n.readSync(b.dataId),shape:b.shape})),p=N.computeOutShape(c.map(b=>b.shape),1),h=c[0].shape[0]===1,f=x9(d,p,r,h),m=N.computeOutShape(e.map(b=>b.shape),t),g=n.makeTensorInfo(m,r,f);return c.forEach(b=>n.disposeIntermediateTensorInfo(b)),g}if(e.length>X().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){let c=Math.floor(e.length/2),d=Qc(e.slice(0,c),t,n),p=Qc(e.slice(c),t,n),h=Qc([d,p],t,n);return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),h}if(X().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&e[0].shape.length>1){let c=new SJ(e.map(d=>d.shape),t);return n.runWebGLProgram(c,e,r)}let{tensors2D:a,outShape:o}=TJ(e,t,n),i=new IJ(a.map(c=>c.shape)),u=n.runWebGLProgram(i,a,r);a.forEach(c=>n.disposeIntermediateTensorInfo(c));let l=fe({inputs:{x:u},attrs:{shape:o},backend:n});return n.disposeIntermediateTensorInfo(u),l}function TJ(e,t,n){let r=N.computeOutShape(e.map(a=>a.shape),t);return{tensors2D:e.map(a=>fe({inputs:{x:a},attrs:{shape:[-1,w.sizeFromShape(a.shape.slice(t))]},backend:n})),outShape:r}}function O_(e){let{inputs:t,backend:n,attrs:r}=e,{axis:s}=r,a=w.parseAxisParam(s,t[0].shape)[0],o=N.computeOutShape(t.map(l=>l.shape),a);if(w.sizeFromShape(o)===0)return n.makeTensorInfo(o,t[0].dtype,[]);let i=t.filter(l=>w.sizeFromShape(l.shape)>0);if(i.length===1)return cr({inputs:{x:i[0]},backend:n});let u=i.map(l=>l.shape);return N.assertParamsConsistent(u,a),Qc(i,a,n)}var NJ={kernelName:Go,backendName:"webgl",kernelFunc:O_},M_=class{constructor(e,t=!1,n=null,r=!1,s=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;let a=e.padInfo.top,o=e.padInfo.left,i=e.strideHeight,u=e.strideWidth,l=e.dilationHeight,c=e.dilationWidth,d=e.filterHeight,p=e.filterWidth,h=Math.floor(e.inChannels/4)*4,f=e.inChannels%4,m=e.dataFormat==="channelsLast",g=m?1:2,b=m?2:3,y=m?3:1,v="",x="";n&&(r?v=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:s?v=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:v=`
          float activation(float x) {
            ${n}
          }
        `,x="result = activation(result);");let k=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${v}

      const ivec2 strides = ivec2(${i}, ${u});
      const ivec2 pads = ivec2(${a}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${y}];

        ivec2 xRCCorner =
            ivec2(coords[${g}], coords[${b}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${d}; wR++) {
          int xR = xRCorner + wR * ${l};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${p}; wC++) {
            int xC = xCCorner + wC * ${c};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${h}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${m}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${f===1}) {

              if (${m}) {
                dotProd +=
                    getX(batch, xR, xC, ${h}) *
                    getW(wR, wC, ${h}, d2);
              } else {
                dotProd +=
                    getX(batch, ${h}, xR, xC) *
                    getW(wR, wC, ${h}, d2);
              }

            } else if (${f===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${h}, d2),
                getW(wR, wC, ${h} + 1, d2)
              );

              if (${m}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${h}),
                  getX(batch, xR, xC, ${h} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${h}, xR, xC),
                  getX(batch, ${h} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${f===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${h}, d2),
                getW(wR, wC, ${h} + 1, d2),
                getW(wR, wC, ${h} + 2, d2)
              );

              if (${m}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${h}),
                  getX(batch, xR, xC, ${h} + 1),
                  getX(batch, xR, xC, ${h} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${h}, xR, xC),
                  getX(batch, ${h} + 1, xR, xC),
                  getX(batch, ${h} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${k}
        ${x}
        setOutput(result);
      }
    `}},_J=class{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;let t=e.padInfo.front,n=e.padInfo.top,r=e.padInfo.left,s=e.strideDepth,a=e.strideHeight,o=e.strideWidth,i=e.dilationDepth,u=e.dilationHeight,l=e.dilationWidth,c=e.filterDepth,d=e.filterHeight,p=e.filterWidth,h=Math.floor(e.inChannels/4)*4,f=e.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${s}, ${a}, ${o});
      const ivec3 pads = ivec3(${t}, ${n}, ${r});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${c}; wF++) {
          int xF = xFCorner + wF * ${i};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${d}; wR++) {
            int xR = xRCorner + wR * ${u};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${p}; wC++) {
              int xC = xCCorner + wC * ${l};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${h}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${f===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${h}) *
                  getW(wF, wR, wC, ${h}, d2);
              } else if (${f===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${h}),
                  getX(batch, xF, xR, xC, ${h} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${h}, d2),
                  getW(wF, wR, wC, ${h} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${f===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${h}),
                  getX(batch, xF, xR, xC, ${h} + 1),
                  getX(batch, xF, xR, xC, ${h} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${h}, d2),
                  getW(wF, wR, wC, ${h} + 1, d2),
                  getW(wF, wR, wC, ${h} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}},EJ=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=qn(this.outputShape.length);let{dataFormat:n}=t,r=$n(),s=n==="channelsLast",a=s?0:1,o=s?1:2,i=this.enableShapeUniforms?"if(blockIndex < outShape[1] && pos < outShape[0]) {":`if(blockIndex < ${e[1]} && pos < ${e[0]}) {`,u="";for(let l=0;l<=1;l++)for(let c=0;c<=1;c++)u+=`
          blockIndex = rc.y + ${c};
          pos = rc.x + ${l};

          ${i}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${a}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${o}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${s}) {
                  innerDims = vec2(d1, ch);
                  result[${l*2+c}] = getChannel(
                    getA(d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${l*2+c}] = getChannel(
                    getA(ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec2 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${u}

        ${r.output} = result;
      }
    `}};function L_({x:e,filter:t,convInfo:n,backend:r,bias:s=null,preluActivationWeights:a=null,leakyreluAlpha:o=0,activation:i=null}){let u=e.shape,l=r.texData.get(e.dataId),c=n.inChannels,d=u[0]*u[1]*u[2],p=n.outChannels,h=n.dataFormat==="channelsLast",f=!1,m=!1,g,b=[];if(!((d===1||p===1)&&c>N_)&&l.isPacked&&h&&l.texture!=null&&u[2]%2!=0&&w.arraysEqual(l.shape.slice(-3),u.slice(-3))){let x=u[0]*u[1]*(u[2]+1),k={dataId:e.dataId,shape:[1,x,n.inChannels],dtype:e.dtype},T=l.shape;l.shape=l.shape.slice(),l.shape[l.shape.length-2]++,w.assert(op(l.shape,k.shape),()=>`packed reshape ${l.shape} to ${k.shape} isn't free`);let C=fe({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}});b.push(C);let E=Rm({a:k,b:C,backend:r,transposeA:f,transposeB:m,bias:s,activation:i,preluActivationWeights:a,leakyreluAlpha:o}),F=r.texData.get(E.dataId);w.assert(F.isPacked,()=>"batchMatMul result is expected to be packed"),l.shape=T,F.shape=n.outShape,g=cr({inputs:{x:E},backend:r}),g.shape=n.outShape,b.push(E)}else{let x=h?u[0]*u[1]*u[2]:u[0]*u[2]*u[3],k=fe({inputs:{x:e},backend:r,attrs:{shape:[1,x,n.inChannels]}}),T=fe({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}}),C=Rm({a:k,b:T,transposeA:f,transposeB:m,backend:r,bias:s,activation:i,preluActivationWeights:a,leakyreluAlpha:o});g=fe({inputs:{x:C},backend:r,attrs:{shape:n.outShape}}),b.push(k),b.push(T),b.push(C)}for(let x of b)r.disposeIntermediateTensorInfo(x);return g}function B_({x:e,filter:t,convInfo:n,backend:r,bias:s=null,preluActivationWeights:a=null,leakyreluAlpha:o=0,activation:i=null}){let{filterWidth:u,filterHeight:l,inChannels:c,outWidth:d,outHeight:p,dataFormat:h}=n,f=h==="channelsLast",m=u*l*c,g=p*d,b=[m,g],y=!0,v=!1,x=[],k=fe({inputs:{x:e},backend:r,attrs:{shape:e.shape.slice(1)}}),T=fe({inputs:{x:t},backend:r,attrs:{shape:[1,m,w.sizeFromShape(t.shape)/m]}});x.push(k),x.push(T);let C=new EJ(b,n),E=[k.shape,[n.padInfo.top,n.padInfo.left],[n.strideHeight,n.strideWidth],[n.dilationHeight,n.dilationWidth],[n.inChannels],[n.filterWidth*n.inChannels],[n.outWidth]],F=r.runWebGLProgram(C,[k],"float32",E),O=fe({inputs:{x:F},backend:r,attrs:{shape:[1,b[0],b[1]]}});x.push(F),x.push(O);let D=s!=null,R=a!=null,_=i==="leakyrelu",L=i?$m(i,!0):null,U=new k_(O.shape,T.shape,[1,g,n.outChannels],y,v,D,L,R,_),j=[O,T];if(s&&j.push(s),R&&j.push(a),_){let ee=r.makeTensorInfo([],"float32",w.createScalarValue(o,"float32"));j.push(ee),x.push(ee)}let K=r.runWebGLProgram(U,j,"float32"),q=f?[1,p,d,n.outChannels]:[1,n.outChannels,p,d],Q=fe({inputs:{x:K},backend:r,attrs:{shape:q}});x.push(K);for(let ee of x)r.disposeIntermediateTensorInfo(ee);return Q}function AJ(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:o,pad:i,dataFormat:u,dilations:l,dimRoundingMode:c}=r,d=N.convertConv2DDataFormat(u),p=N.computeConv2DInfo(s.shape,a.shape,o,l,i,c,!1,d),h;if(p.filterHeight===1&&p.filterWidth===1&&p.dilationHeight===1&&p.dilationWidth===1&&p.strideHeight===1&&p.strideWidth===1&&(p.padInfo.type==="SAME"||p.padInfo.type==="VALID"))h=L_({x:s,filter:a,convInfo:p,backend:n});else if(X().getBool("WEBGL_CONV_IM2COL")&&s.shape[0]===1)h=B_({x:s,filter:a,convInfo:p,backend:n});else{let m=new M_(p);h=n.runWebGLProgram(m,[s,a],"float32")}let f=fe({inputs:{x:h},backend:n,attrs:{shape:p.outShape}});return n.disposeIntermediateTensorInfo(h),f}var $J={kernelName:ga,backendName:"webgl",kernelFunc:AJ},FJ=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,s=e.padInfo.left,a=e.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${r};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${n} - ${s};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              if (${a}) {
                float dyValue = getDy(b, yR, yC, d2);
                float xValue = getX(b, xR, xC, d1);
                dotProd += (xValue * dyValue);
              } else {
                float dyValue = getDy(b, d2, yR, yC);
                float xValue = getX(b, d1, xR, xC);
                dotProd += (xValue * dyValue);
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}},DJ=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,s=e.strideWidth,a=e.dataFormat==="channelsLast",o=t-1-e.padInfo.top,i=n-1-e.padInfo.left,u=a?1:2,l=a?2:3,c=a?3:1;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${c}];

        ivec2 dyCorner = ivec2(coords[${u}], coords[${l}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${n} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${a}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}},RJ=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,s=e.padInfo.front,a=e.padInfo.top,o=e.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${t} - ${s};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${n} - ${a};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${r} - ${o};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}},PJ=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,s=e.strideDepth,a=e.strideHeight,o=e.strideWidth,i=t-1-e.padInfo.front,u=n-1-e.padInfo.top,l=r-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${i}, ${u}, ${l});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${t}; wF++) {
          float dyF = float(dyFCorner + wF) / ${s}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${t} - 1 - wF;

          for (int wR = 0; wR < ${n}; wR++) {
            float dyR = float(dyRCorner + wR) / ${a}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${n} - 1 - wR;

            for (int wC = 0; wC < ${r}; wC++) {
              float dyC = float(dyCCorner + wC) / ${o}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${r} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function OJ(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:o,pad:i,dataFormat:u,dimRoundingMode:l,filterShape:c}=r,d=N.convertConv2DDataFormat(u),p=N.computeConv2DInfo(s.shape,c,o,1,i,l,!1,d),h=new FJ(p);return n.runWebGLProgram(h,[s,a],"float32")}var MJ={kernelName:vh,backendName:"webgl",kernelFunc:OJ};function LJ(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{inputShape:o,strides:i,pad:u,dataFormat:l,dimRoundingMode:c}=r,d=N.convertConv2DDataFormat(l),p=N.computeConv2DInfo(o,a.shape,i,1,u,c,!1,d),h=new DJ(p);return n.runWebGLProgram(h,[s,a],"float32")}var BJ={kernelName:ba,backendName:"webgl",kernelFunc:LJ};function zJ(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:o,pad:i,dilations:u}=r,l=N.computeConv3DInfo(s.shape,a.shape,o,u,i),c=new _J(l);return n.runWebGLProgram(c,[s,a],"float32")}var WJ={kernelName:Xl,backendName:"webgl",kernelFunc:zJ};function VJ(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:o,pad:i,filterShape:u}=r,l=N.computeConv3DInfo(s.shape,u,o,1,i),c=new RJ(l);return n.runWebGLProgram(c,[s,a],"float32")}var UJ={kernelName:xh,backendName:"webgl",kernelFunc:VJ};function GJ(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{pad:o,strides:i,inputShape:u}=r,l=N.computeConv3DInfo(u,a.shape,i,1,o),c=new PJ(l);return n.runWebGLProgram(c,[s,a],"float32")}var HJ={kernelName:wh,backendName:"webgl",kernelFunc:GJ},jJ=w_+`
  return cos(x);
`,qJ=Ze({opSnippet:jJ}),KJ={kernelName:ya,backendName:"webgl",kernelFunc:qJ},XJ=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,YJ=Ze({opSnippet:XJ}),QJ={kernelName:va,backendName:"webgl",kernelFunc:YJ},ZJ=class{constructor(e,t,n,r,s){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];let[a,o,i,u]=e,[l]=t,[c,d]=n;this.outputShape=[l,c,d,u];let p=r==="bilinear"?1:0,[h,f]=[`${o-1}.0`,`${i-1}.0`],[m,g,b]=c>1?[`${(o-1)/(c-1)}`,"(y2-y1) * height_ratio",`y1*${h} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${h}`],[y,v,x]=d>1?[`${(i-1)/(d-1)}`,"(x2-x1) * width_ratio",`x1*${f} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${f}`];this.userCode=`
      const float height_ratio = float(${m});
      const float width_ratio = float(${y});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${a}) {
          return;
        }

        float height_scale = ${g};
        float width_scale = ${v};

        float in_y = ${b};
        if( in_y < 0.0 || in_y > ${h} ) {
          setOutput(float(${s}));
          return;
        }
        float in_x = ${x};
        if( in_x < 0.0 || in_x > ${f} ) {
          setOutput(float(${s}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${p} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}},JJ=e=>{let{inputs:t,backend:n,attrs:r}=e,{image:s,boxes:a,boxInd:o}=t,{cropSize:i,method:u,extrapolationValue:l}=r,c=new ZJ(s.shape,a.shape,i,u,l);return n.runWebGLProgram(c,[s,a,o],"float32")},eee={kernelName:jo,backendName:"webgl",kernelFunc:JJ},z_=class{constructor(e,t,n){this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}],this.outputShape=e;let r=e.length,s=t?"0.0":`getX(${W_(r,"coords")})`,a=e[e.length-1],o="",i="";t?(o=n?`end != ${a-1}`:"end != 0",i=n?"end + 1":"end - 1"):(o=n?`end + pow2 < ${a}`:"end >= pow2",i=n?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${gt(r)} coords = getOutputCoords();
        int end = ${V_(r,"coords")};
        float val = ${s};
        int pow2 = int(pow(2.0, index));
        if (${o}) {
          int idx = ${i};
          ${V_(r,"coords")} = idx;
          val += getX(${W_(r,"coords")});
        }
        setOutput(val);
      }
    `}};function W_(e,t){if(e===1)return`${t}`;if(e===2)return`${t}.x, ${t}.y`;if(e===3)return`${t}.x, ${t}.y, ${t}.z`;if(e===4)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw Error(`Cumulative sum for rank ${e} is not yet supported`)}function V_(e,t){if(e===1)return`${t}`;if(e===2)return`${t}.y`;if(e===3)return`${t}.z`;if(e===4)return`${t}.w`;throw Error(`Cumulative sum for rank ${e} is not yet supported`)}function tee(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:o,reverse:i}=r,u=s.shape.length,l=N.getAxesPermutation([a],u),c=s;l!=null&&(c=Dn({inputs:{x:s},backend:n,attrs:{perm:l}}));let d=N.getInnerMostAxes(1,u)[0];if(d!==u-1)throw new Error(`WebGL cumsum shader expects an inner-most axis=${s.shape.length-1} but got axis=${a}`);let p=c.shape[d],h=cr({inputs:{x:c},backend:n});for(let f=0;f<=Math.ceil(Math.log2(p))-1;f++){let m=new z_(c.shape,!1,i),g=[[f]],b=h;h=n.runWebGLProgram(m,[h],h.dtype,g),n.disposeIntermediateTensorInfo(b)}if(o){let f=new z_(c.shape,o,i),m=h;h=n.runWebGLProgram(f,[h],h.dtype),n.disposeIntermediateTensorInfo(m)}if(l!=null){let f=N.getUndoAxesPermutation(l),m=Dn({inputs:{x:h},backend:n,attrs:{perm:f}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(c),m}return h}var nee={kernelName:Ho,backendName:"webgl",kernelFunc:tee};function ree(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:o,binaryOutput:i}=r;if(s.shape.length===1){let u=n.readSync(s.dataId),l=n.readSync(a.dataId),c=a_(u,l,a.dtype,a.shape,o);return n.makeTensorInfo([o],a.dtype,c)}else if(s.shape.length===2){let u=n.bufferSync(s),l=n.bufferSync(a),c=y9(u,l,o,i);return n.makeTensorInfo(c.shape,a.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}var see={kernelName:kh,backendName:"webgl",kernelFunc:ree},aee=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${t};
      int offset_h = imod(h, ${t});
      int in_w = w / ${t};
      int offset_w = imod(w, ${t});
      int offset_d = (offset_h * ${t} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}};function oee(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockSize:a,dataFormat:o}=r,i=s.shape[0],u=o==="NHWC"?s.shape[1]:s.shape[2],l=o==="NHWC"?s.shape[2]:s.shape[3],c=o==="NHWC"?s.shape[3]:s.shape[1],d=u*a,p=l*a,h=c/(a*a),f=o==="NHWC"?[i,d,p,h]:[i,h,d,p],m=new aee(f,a,o);return n.runWebGLProgram(m,[s],s.dtype)}var iee={kernelName:qo,backendName:"webgl",kernelFunc:oee},U_=class{constructor(e,t=!1,n=null,r=!1,s=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=qn(this.outputShape.length);let a=e.filterHeight,o=e.filterWidth,i=e.outChannels/e.inChannels,u="",l="";n&&(r?u=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:s?u=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:u=`
          float activation(float x) {
            ${n}
          }
        `,l="result = activation(result);");let c=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${u}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${i};
        int q = d2 - d1 * ${i};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${a}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${o}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${c}
        ${l}
        setOutput(result);
      }
    `}},G_=class{constructor(e,t=!1,n=null,r=!1,s=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=qn(this.outputShape.length);let a=e.outChannels/e.inChannels,o=e.padInfo.left,i=e.strideWidth,u=e.dilationWidth,l=e.filterHeight,c=e.filterWidth,d=c,p=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let g=0;g<c;g++)p+=`
          vec4 xTexelC${g*2};
          int xTexelC${g*2}Ready;
          vec4 xTexelC${g*2+1};
          int xTexelC${g*2+1}Ready;
          vec4 xC${g};`;p+=`
    for (int r = 0; r < ${l}; r++) {
      `;for(let g=0;g<c;g++)p+=`
          xTexelC${g*2} = vec4(0.0);
          xTexelC${g*2}Ready = 0;
          xTexelC${g*2+1} = vec4(0.0);
          xTexelC${g*2+1}Ready = 0;
          xC${g} = vec4(0.0);`;p+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let g=0;g<(d+1)/2;g++){let b=g*2;if(p+=`
          xC = xCCorner + ${b*u};
          `,i===1){if(b<c&&(o%2==1?(p+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }
              `,u===1&&b>0?p+=`
                xC${b} = vec4(xTexelC${b-2}.zw, xTexelC${b}.xy);
                `:p+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${b} = vec4(previous.zw, xTexelC${b}.xy);
                  } else {
                    xC${b} = vec4(0.0, 0.0, xTexelC${b}.xy);
                  }
                  `):p+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                xC${b} = xTexelC${b};
                `,b+1<c)){let y=o%2==0?w.nearestLargerEven(u):u;u%2==0&&o%2==1||u%2!=0&&o%2!=1?(p+=`
                  xCOffset = xC + imod(pads[1], 2) + ${y};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                    xTexelC${b+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${b+1}.zw = vec2(0.0);
                    }
                    xTexelC${b+1}Ready = 1;
                  }
                  `,u>1&&(p+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                      xTexelC${b} = getX(batch, xR, xCOffset, d1);
                      xTexelC${b}Ready = 1;
                    }
                    `),p+=`
                  xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.xy);
                  `):y===1?p+=`
                    xC${b+1} = xTexelC${b};
                    `:p+=`
                    xCOffset = xC + ${y};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                      xTexelC${b+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${b+1}.zw = vec2(0.0);
                      }
                      xTexelC${b+1}Ready = 1;
                    }

                    xC${b+1} = xTexelC${b+1};
                    `}}else b<c&&(o%2==1?(p+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${b+1}Ready == 0) {
                  xTexelC${b+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${b+1}.zw = vec2(0.0);
                  }
                  xTexelC${b+1}Ready = 1;
                }

                xC${b} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);
              `,b+1<c&&(p+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${b+1} = vec4(xTexelC${b+1}.xy, final.xy);
                `)):(p+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                  xTexelC${b+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b+1}.zw = vec2(0.);
                  }
                  xTexelC${b+1}Ready = 1;
                }

                xC${b} = vec4(
                  xTexelC${b}.xy, xTexelC${b+1}.xy);
              `,b+1<c&&(p+=`
                  xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);
                `)));b<c&&(p+=`
            wTexel = getW(r, ${b}, d1, q);
            dotProd += xC${b} * vec4(wTexel.xz, wTexel.xz);
          `,b+1<c&&(p+=`
              wTexel = getW(r, ${b+1}, d1, q);
              dotProd += xC${b+1} * vec4(wTexel.xz, wTexel.xz);
            `))}p+=`
    }
  `,p+=`
      }
    `;let h="",f="";n&&(r?h=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:s?h=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:h=`vec4 activation(vec4 x) {
          ${n}
        }`,f="result = activation(result);");let m=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${h}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${a};
        int q = d2 - d1 * ${a};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${p}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${m}
        ${f}
        setOutput(result);
      }
    `}};function uee(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:o,pad:i,dilations:u,dimRoundingMode:l}=r,c=u;c==null&&(c=[1,1]),w.assert(N.eitherStridesOrDilationsAreOne(o,c),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);let d=N.computeConv2DInfo(s.shape,a.shape,o,c,i,l,!0),p;X().getBool("WEBGL_PACK_DEPTHWISECONV")&&d.strideWidth<=2&&d.outChannels/d.inChannels==1?p=new G_(d):p=new U_(d);let h=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];return n.runWebGLProgram(p,[s,a],"float32",h)}var cee={kernelName:xa,backendName:"webgl",kernelFunc:uee},lee=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,s=e.padInfo.left,a=e.outChannels/e.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${a} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${r};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${n} - ${s};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}},dee=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,s=e.strideWidth,a=t-1-e.padInfo.top,o=n-1-e.padInfo.left,i=e.outChannels/e.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${n} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${i}; dm++) {
              int d2 = d1 * ${i} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function pee(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:o,dilations:i,pad:u,dimRoundingMode:l,filterShape:c}=r,d=N.computeConv2DInfo(s.shape,c,o,i,u,l,!0),p=new lee(d);return n.runWebGLProgram(p,[s,a],"float32")}var hee={kernelName:Ih,backendName:"webgl",kernelFunc:pee};function fee(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{strides:o,dilations:i,pad:u,dimRoundingMode:l,inputShape:c}=r,d=N.computeConv2DInfo(c,a.shape,o,i,u,l,!0),p=new dee(d);return n.runWebGLProgram(p,[s,a],"float32")}var mee={kernelName:Sh,backendName:"webgl",kernelFunc:fee},gee=class{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}};function bee(e){let{inputs:t,backend:n}=e,{x:r}=t,s=[...r.shape,...r.shape],a=w.sizeFromShape(r.shape),o=fe({inputs:{x:r},backend:n,attrs:{shape:[a]}}),i=new gee(a),u=n.runWebGLProgram(i,[o],o.dtype),l=fe({inputs:{x:u},backend:n,attrs:{shape:s}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(u),l}var yee={kernelName:Ch,backendName:"webgl",kernelFunc:bee},vee=class{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;let{inHeight:t,inWidth:n,padInfo:r,strideHeight:s,strideWidth:a,filterHeight:o,filterWidth:i,dilationHeight:u,dilationWidth:l}=e,{top:c,left:d}=r;this.userCode=`
      const ivec2 strides = ivec2(${s}, ${a});
      const ivec2 pads = ivec2(${c}, ${d});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${o}; h++) {
          int hIn = hBeg + h * ${u};

          if (hIn >= 0 && hIn < ${t}) {
            for (int w = 0; w < ${i}; w++) {
              int wIn = wBeg + w * ${l};

              if (wIn >= 0 && wIn < ${n}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}};function xee(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:o,pad:i,dilations:u}=r,l=N.computeDilation2DInfo(s.shape,a.shape,o,i,"NHWC",u),c,d=new vee(l);c=n.runWebGLProgram(d,[s,a],"float32");let p=fe({inputs:{x:c},backend:n,attrs:{shape:l.outShape}});return n.disposeIntermediateTensorInfo(c),p}var wee={kernelName:Yl,backendName:"webgl",kernelFunc:xee};function kee(e){let{inputs:t,backend:n,attrs:r}=e,{equation:s}=r,a=t,{allDims:o,summedDims:i,idDims:u}=N.decodeEinsumEquation(s,a.length);N.checkEinsumDimSizes(o.length,u,a);let{path:l,steps:c}=N.getEinsumComputePath(i,u),d=c.length,p=null,h=o.length,f=[];for(let m=0;m<d;++m){for(let g of c[m]){let{permutationIndices:b,expandDims:y}=N.getEinsumPermutation(h,u[g]),v;N.isIdentityPermutation(b)?v=a[g]:(v=Dn({inputs:{x:a[g]},backend:n,attrs:{perm:b}}),f.push(v));let x=v.shape.slice();for(let k=0;k<y.length;++k)x.splice(y[k],0,1);w.arraysEqual(v.shape,x)||(v=fe({inputs:{x:v},backend:n,attrs:{shape:x}}),f.push(v)),p===null?p=v:(p=uk({inputs:{a:v,b:p},backend:n}),f.push(p))}m<d-1&&(l[m]>=0&&(p=Dm({inputs:{x:p},backend:n,attrs:{axis:l[m]-(o.length-h),keepDims:!1}}),f.push(p)),h--)}for(let m of f)m!==p&&n.disposeIntermediateTensorInfo(m);return p}var Iee={kernelName:Ql,backendName:"webgl",kernelFunc:kee},See="return (x >= 0.0) ? x : (exp(x) - 1.0);",Cee=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,Tee=Ze({opSnippet:See,packedOpSnippet:Cee}),Nee={kernelName:ka,backendName:"webgl",kernelFunc:Tee},_ee="return (b >= 1.0) ? a : a * (b + 1.0);",Eee=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,Aee=e=>{let{inputs:t,backend:n}=e,{dy:r,y:s}=t,a=X().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new up(Eee,r.shape,s.shape):new Xc(_ee,r.shape,s.shape);return n.runWebGLProgram(a,[r,s],r.dtype)},$ee={kernelName:_h,backendName:"webgl",kernelFunc:Aee},Fee=`
  return vec4(equal(a, b));
`,Dee="return float(a == b);",Ree=hn({opSnippet:Dee,packedOpSnippet:Fee,dtype:"bool",cpuKernelImpl:w9}),Pee={kernelName:Ko,backendName:"webgl",kernelFunc:Ree},Oee=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${N.ERF_P};
  float a1 = ${N.ERF_A1};
  float a2 = ${N.ERF_A2};
  float a3 = ${N.ERF_A3};
  float a4 = ${N.ERF_A4};
  float a5 = ${N.ERF_A5};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,Mee=Ze({opSnippet:Oee}),Lee={kernelName:Qu,backendName:"webgl",kernelFunc:Mee},H_="return exp(x);",j_=Ze({opSnippet:H_,packedOpSnippet:H_,cpuKernelImpl:k9,dtype:"float32"}),Bee={kernelName:Ia,backendName:"webgl",kernelFunc:j_};function pk(e){let{inputs:t,attrs:n,backend:r}=e,{dim:s}=n,{input:a}=t,o=a.shape.length,i=a.shape.slice(),u=s;return s<0&&(w.assert(-(o+1)<=s,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),u=o+s+1),i.splice(u,0,1),fe({inputs:{x:a},backend:r,attrs:{shape:i}})}var zee={kernelName:Xo,backendName:"webgl",kernelFunc:pk},q_="return exp(x) - 1.0;",Wee=Ze({opSnippet:q_,packedOpSnippet:q_,cpuKernelImpl:I9}),Vee={kernelName:Yo,backendName:"webgl",kernelFunc:Wee},K_=class{constructor(e,t,n){this.variableNames=["real","imag"];let r=t[1];this.outputShape=t;let s=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,a=n?`${r}.0`:"1.0",o;if(e==="real")o="return real * expR - imag * expI;";else if(e==="imag")o="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);this.userCode=`
      const float exponentMultiplier = ${s};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${o}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${r});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${r}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${a};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}};function X_(e,t,n){let r=n.texData.get(e.dataId),s=w.sizeFromShape(e.shape),a=e.shape[e.shape.length-1],o=s/a,i=fe({inputs:{x:e},backend:n,attrs:{shape:[o,a]}}),u=i.shape,l=new K_("real",u,t),c=new K_("imag",u,t),d=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:u},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:u}],p=n.runWebGLProgram(l,d,"float32"),h=n.runWebGLProgram(c,d,"float32"),f=No({inputs:{real:p,imag:h},backend:n});n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(h);let m=fe({inputs:{x:f},backend:n,attrs:{shape:e.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(f),m}function Uee(e){let{inputs:t,backend:n}=e,{input:r}=t;return X_(r,!1,n)}var Gee={kernelName:Eh,backendName:"webgl",kernelFunc:Uee},Hee=class{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}};function dp(e){let{backend:t,attrs:n}=e,{shape:r,value:s}=n,{dtype:a}=n;if(a=a||w.inferDtype(s),a==="string"){let o=w.getArrayFromDType(a,w.sizeFromShape(r));return o.fill(s),t.makeTensorInfo(r,a,o)}else{let o=new Hee(r,s),i=[[s]];return t.runWebGLProgram(o,[],a,i)}}var jee={kernelName:Zu,backendName:"webgl",kernelFunc:dp},qee=class{constructor(e){this.variableNames=["Image"],this.outputShape=[];let t=e[2];this.outputShape=e,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${t} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${t}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}},Kee={kernelName:Qo,backendName:"webgl",kernelFunc:({inputs:e,backend:t})=>{let{image:n}=e,r=t,s=new qee(n.shape);return r.runWebGLProgram(s,[n],n.dtype)}},Y_="return floor(x);",Xee=Ze({opSnippet:Y_,packedOpSnippet:Y_,cpuKernelImpl:S9}),Yee={kernelName:Sa,backendName:"webgl",kernelFunc:Xee},Qee=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,Zee=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,Jee=hn({opSnippet:Qee,packedOpSnippet:Zee,dtype:"int32"}),ete={kernelName:Ca,backendName:"webgl",kernelFunc:Jee},tte=class{constructor(e){this.variableNames=["A"];let t=$n(),[n,r]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${n}.0);

        vec4 values = ${t.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}},nte=class{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;let t=$n(),[n,r]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${r}.0, ${n}.0);
            vec4 values = ${t.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${t.output} = result;
      }
    `}},rte={kernelName:cd,backendName:"webgl",kernelFunc:ste},Zc;function ste(e){let{inputs:t,backend:n,attrs:r}=e,{pixels:s}=t,{numChannels:a}=r,o=typeof HTMLVideoElement!="undefined"&&s instanceof HTMLVideoElement,i=typeof HTMLImageElement!="undefined"&&s instanceof HTMLImageElement,[u,l]=o?[s.videoWidth,s.videoHeight]:[s.width,s.height],c=[l,u],d=[l,u,a];(i||o)&&(Zc==null&&(Zc=document.createElement("canvas").getContext("2d")),Zc.canvas.width=u,Zc.canvas.height=l,Zc.drawImage(s,0,0,u,l),s=Zc.canvas);let p=n.makeTensorInfo(c,"int32");n.texData.get(p.dataId).usage=wr.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(p.dataId),s);let h=X().getBool("WEBGL_PACK")?new nte(d):new tte(d),f=n.runWebGLProgram(h,[p],"int32");return n.disposeData(p.dataId),f}function ate(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:o,preluActivationWeights:i}=t,{strides:u,pad:l,dataFormat:c,dilations:d,dimRoundingMode:p,activation:h,leakyreluAlpha:f}=r,m=N.convertConv2DDataFormat(c),g=N.computeConv2DInfo(s.shape,a.shape,u,d,l,p,!1,m),b,y=[];if(g.filterHeight===1&&g.filterWidth===1&&g.dilationHeight===1&&g.dilationWidth===1&&g.strideHeight===1&&g.strideWidth===1&&(g.padInfo.type==="SAME"||g.padInfo.type==="VALID"))b=L_({x:s,filter:a,convInfo:g,backend:n,bias:o,activation:h,preluActivationWeights:i,leakyreluAlpha:f});else if(X().getBool("WEBGL_CONV_IM2COL")&&s.shape[0]===1)b=B_({x:s,filter:a,convInfo:g,backend:n,bias:o,activation:h,preluActivationWeights:i,leakyreluAlpha:f});else{let x=o!=null,k=i!=null,T=h==="leakyrelu",C=h?$m(h,!1):null,E=new M_(g,x,C,k,T),F=[s,a];if(o&&F.push(o),i&&F.push(i),T){let O=n.makeTensorInfo([],"float32",w.createScalarValue(f,"float32"));F.push(O),y.push(O)}b=n.runWebGLProgram(E,F,"float32")}let v=fe({inputs:{x:b},backend:n,attrs:{shape:g.outShape}});return y.push(b),y.forEach(x=>n.disposeIntermediateTensorInfo(x)),v}var ote={kernelName:no,backendName:"webgl",kernelFunc:ate};function ite(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:o,preluActivationWeights:i}=t,{strides:u,pad:l,dilations:c,dimRoundingMode:d,activation:p,leakyreluAlpha:h}=r,f=[],m=c;m==null&&(m=[1,1]),w.assert(N.eitherStridesOrDilationsAreOne(u,m),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${u} and dilations '${m}'`);let g=N.computeConv2DInfo(s.shape,a.shape,u,m,l,d,!0),b=X().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels==1,y=p?$m(p,b):null,v=[s,a],x=o!=null,k=i!=null,T=p==="leakyrelu";if(x&&v.push(o),k&&v.push(i),T){let O=n.makeTensorInfo([],"float32",w.createScalarValue(h,"float32"));v.push(O),f.push(O)}let C;b?C=new G_(g,x,y,k,T):C=new U_(g,x,y,k,T);let E=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],F=n.runWebGLProgram(C,v,"float32",E);return f.forEach(O=>n.disposeIntermediateTensorInfo(O)),F}var ute={kernelName:ro,backendName:"webgl",kernelFunc:ite},cte=class{constructor(e,t,n){this.sliceDim=e,this.strides=t,this.variableNames=["x","indices"],this.outputShape=n;let r=gt(t.length),s=gt(n.length),a=this.sliceDim>1?"strides[j]":"strides";this.userCode=`
        ${r} strides = ${r}(${this.strides});
         void main() {
          ${s} coords = getOutputCoords();
          int flattenIndex = 0;
          for (int j = 0; j < ${this.sliceDim}; j++) {
            int index = round(getIndices(coords[0], j));
            flattenIndex += index * ${a};
          }
          setOutput(getX(flattenIndex, coords[1]));
        }
      `}};function lte(e){let{inputs:t,backend:n}=e,{params:r,indices:s}=t,a=s.shape,o=a[a.length-1],i=w.sizeFromShape(r.shape),[u,l,c,d]=N.prepareAndValidate(r,s),p=fe({inputs:{x:s},backend:n,attrs:{shape:[l,o]}}),h=fe({inputs:{x:r},backend:n,attrs:{shape:[w.sizeFromShape(r.shape)/c,c]}});if(n.shouldExecuteOnCPU([r,s])||r.dtype==="string"){let b=n.readSync(s.dataId),y=n.bufferSync(r),v=C9(b,y,r.dtype,l,o,c,d,r.shape,i);return n.makeTensorInfo(u,r.dtype,v.values)}let f=new cte(o,d,[l,c]),m=n.runWebGLProgram(f,[h,p],h.dtype),g=fe({inputs:{x:m},backend:n,attrs:{shape:u}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(m),g}var dte={kernelName:Jo,backendName:"webgl",kernelFunc:lte},pte=class{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;let n=gt(this.rank),r=hte(e,2);this.userCode=`
      void main() {
        ${n} resRC = getOutputCoords();
        setOutput(getA(${r}));
      }
    `}};function hte(e,t){let n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let s=0;s<e.length;s++)s===2?r.push("int(getIndices(resRC.x, resRC.z))"):r.push(`${n[s]}`);return r.join()}function Q_(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,indices:a}=t,{axis:o,batchDims:i}=r,u=w.parseAxisParam(o,s.shape)[0],l=n.readSync(a.dataId),c=s.shape[u];for(let x=0;x<l.length;++x){let k=l[x];w.assert(k<=c-1&&k>=0,()=>`GatherV2: the index value ${k} is not in [0, ${c-1}]`)}let d=N.segment_util.collectGatherOpShapeInfo(s,a,u,i),p=w.sizeFromShape(a.shape),h=[],f=fe({inputs:{x:s},backend:n,attrs:{shape:[d.batchSize,d.outerSize,d.dimSize,d.sliceSize]}}),m=fe({inputs:{x:a},backend:n,attrs:{shape:[d.batchSize,p/d.batchSize]}});h.push(f),h.push(m);let g=[d.batchSize,d.outerSize,p/d.batchSize,d.sliceSize];if(n.shouldExecuteOnCPU([s,a])||s.dtype==="string"){let x=n.bufferSync(m),k=n.bufferSync(f),T=T9(k,x,g);return h.forEach(C=>n.disposeIntermediateTensorInfo(C)),n.makeTensorInfo(d.outputShape,T.dtype,T.values)}let b=new pte(f.shape,g),y=n.runWebGLProgram(b,[f,m],f.dtype);h.push(y);let v=fe({inputs:{x:y},backend:n,attrs:{shape:d.outputShape}});return h.forEach(x=>n.disposeIntermediateTensorInfo(x)),v}var fte={kernelName:Zo,backendName:"webgl",kernelFunc:Q_},mte="return float(a > b);",gte=`
  return vec4(greaterThan(a, b));
`,bte=hn({opSnippet:mte,packedOpSnippet:gte,cpuKernelImpl:N9,dtype:"bool"}),yte={kernelName:ei,backendName:"webgl",kernelFunc:bte},vte="return float(a >= b);",xte=`
  return vec4(greaterThanEqual(a, b));
`,wte=hn({opSnippet:vte,packedOpSnippet:xte,dtype:"bool",cpuKernelImpl:_9}),kte={kernelName:Na,backendName:"webgl",kernelFunc:wte};function Ite(e){let{inputs:t,backend:n}=e,{input:r}=t;return X_(r,!0,n)}var Ste={kernelName:Ah,backendName:"webgl",kernelFunc:Ite},Cte="return float(!isnan(x) && !isinf(x));",Tte=Ze({opSnippet:Cte,dtype:"bool"}),Nte={kernelName:Ju,backendName:"webgl",kernelFunc:Tte},_te="return float(isinf(x));",Ete=Ze({opSnippet:_te,dtype:"bool"}),Ate={kernelName:ec,backendName:"webgl",kernelFunc:Ete},$te="return float(isnan(x));",Fte=Ze({opSnippet:$te,dtype:"bool"}),Dte={kernelName:tc,backendName:"webgl",kernelFunc:Fte},Rte="return float(a < b);",Pte=`
  return vec4(lessThan(a, b));
`,Ote=hn({opSnippet:Rte,packedOpSnippet:Pte,cpuKernelImpl:E9,dtype:"bool"}),Mte={kernelName:ni,backendName:"webgl",kernelFunc:Ote},Lte="return float(a <= b);",Bte=`
  return vec4(lessThanEqual(a, b));
`,zte=hn({opSnippet:Lte,packedOpSnippet:Bte,cpuKernelImpl:A9,dtype:"bool"}),Wte={kernelName:ri,backendName:"webgl",kernelFunc:zte};function Vte(e){let{backend:t,attrs:n}=e,{start:r,stop:s,num:a}=n,o=$9(r,s,a);return t.makeTensorInfo([o.length],"float32",o)}var Ute={kernelName:$h,backendName:"webgl",kernelFunc:Vte},Gte=`if (x < 0.0) return NAN;
  return log(x);`,Hte=`
  vec4 result = log(x);
  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));
  result.r = isNaN.r == 1.0 ? NAN : result.r;
  result.g = isNaN.g == 1.0 ? NAN : result.g;
  result.b = isNaN.b == 1.0 ? NAN : result.b;
  result.a = isNaN.a == 1.0 ? NAN : result.a;

  return result;
`,jte=Ze({opSnippet:Gte,packedOpSnippet:Hte,cpuKernelImpl:F9}),qte={kernelName:Ea,backendName:"webgl",kernelFunc:jte},Kte="return log(1.0 + x);",Xte=Ze({opSnippet:Kte}),Yte={kernelName:nc,backendName:"webgl",kernelFunc:Xte},Qte="return float(a >= 1.0 && b >= 1.0);",Zte=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,Jte=hn({opSnippet:Qte,packedOpSnippet:Zte,dtype:"bool"}),ene={kernelName:si,backendName:"webgl",kernelFunc:Jte},tne="return float(!(x >= 1.0));",nne=Ze({opSnippet:tne}),rne={kernelName:rc,backendName:"webgl",kernelFunc:nne},sne="return float(a >= 1.0 || b >= 1.0);",ane=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,one=hn({opSnippet:sne,packedOpSnippet:ane,dtype:"bool"}),ine={kernelName:Jl,backendName:"webgl",kernelFunc:one},une=class{constructor(e,t,n,r,s){this.variableNames=["x"],this.outputShape=[];let a=t,o=e[3]-1;this.outputShape=e;let i,u=`float(${n}) + float(${r}) * sum`;s===.5?i=`inversesqrt(${u})`:s===1?i=`1.0/(${u})`:i=`exp(log(${u}) * float(-${s}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${a}; j <= ${a}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${o}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${i};
        setOutput(val);
      }
    `}},cne=class{constructor(e,t,n,r,s){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;let a=t,o=e[3]-1;this.outputShape=e;let i,u=`float(${n}) + float(${r}) * sum`;s===.5?i=`inversesqrt(${u})`:s===1?i=`1.0/(${u})`:i=`exp(log(${u}) * float(-${s}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${a};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${a}; j <= ${a}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${o}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${i};
        setOutput(result);
      }
    `}},lne=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{depthRadius:a,bias:o,alpha:i,beta:u}=r,l=X().getBool("WEBGL_PACK_NORMALIZATION")?new cne(s.shape,a,o,i,u):new une(s.shape,a,o,i,u);return n.runWebGLProgram(l,[s],s.dtype)},dne={kernelName:ed,backendName:"webgl",kernelFunc:lne},pne=class{constructor(e,t,n,r,s){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=r,this.beta=s,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${t})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${t} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${r}) * norm + float(${n});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${r})
                * float(${s})
                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${s});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}},hne=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:s,y:a,dy:o}=t,{depthRadius:i,bias:u,alpha:l,beta:c}=r,d=new pne(s.shape,i,u,l,c);return n.runWebGLProgram(d,[s,a,o],s.dtype)},fne={kernelName:Fh,backendName:"webgl",kernelFunc:hne};function mne(e,t,n,r){let s=w.sizeFromShape(t),o=w.sizeFromShape(e.shape)/s,i=fe({inputs:{x:e},attrs:{shape:[o,s]},backend:r}),u=ou(i,e.dtype,"max",r),l=fe({inputs:{x:u},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(i),r.disposeIntermediateTensorInfo(u),l}function Z_(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reductionIndices:a,keepDims:o}=r,i=s.shape.length,u=w.parseAxisParam(a,s.shape),l=u,c=N.getAxesPermutation(l,i),d=c!=null,p=n.shouldExecuteOnCPU([s]),h=s;if(d){if(p){let v=n.texData.get(h.dataId).values,x=new Array(i);for(let C=0;C<x.length;C++)x[C]=s.shape[c[C]];let k=ok(v,s.shape,s.dtype,c,x);h=n.makeTensorInfo(x,s.dtype);let T=n.texData.get(h.dataId);T.values=k}else h=Fm(s,c,n);l=N.getInnerMostAxes(l.length,i)}N.assertAxesAreInnerMostDims("max",l,i);let[f,m]=N.computeOutAndReduceShapes(h.shape,l),g=f;o&&(g=N.expandShapeToKeepDim(f,u));let b;if(p){let v=n.texData.get(h.dataId).values,x=D9(v,w.sizeFromShape(m),g,s.dtype);b=n.makeTensorInfo(g,s.dtype);let k=n.texData.get(b.dataId);k.values=x}else b=mne(h,m,g,n);return d&&n.disposeIntermediateTensorInfo(h),b}var gne={kernelName:Aa,backendName:"webgl",kernelFunc:Z_},bne=g_+`
  return max(a, b);
`,yne=`
  vec4 result = vec4(max(a, b));
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  `+Am+`
  return result;
`,vne=hn({opSnippet:bne,packedOpSnippet:yne,cpuKernelImpl:R9}),xne={kernelName:$a,backendName:"webgl",kernelFunc:vne};function wne(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t;Uc(s,"maxPool");let{filterSize:a,strides:o,pad:i,dimRoundingMode:u}=r,l=1;w.assert(N.eitherStridesOrDilationsAreOne(o,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${l}'`);let c=N.computePool2DInfo(s.shape,a,o,l,i,u);if(c.filterWidth===1&&c.filterHeight===1&&w.arraysEqual(c.inShape,c.outShape))return cr({inputs:{x:s},backend:n});let d=new cp(c,"max",!1);return n.runWebGLProgram(d,[s],s.dtype)}var kne={kernelName:Fa,backendName:"webgl",kernelFunc:wne};function Ine(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:o,pad:i,dataFormat:u,dimRoundingMode:l}=r,c=[1,1,1],d=N.computePool3DInfo(s.shape,a,o,c,i,l,u),p=new ck(d,"max",!1);return n.runWebGLProgram(p,[s],s.dtype)}var Sne={kernelName:td,backendName:"webgl",kernelFunc:Ine},Cne=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;let t=e.strideHeight,n=e.strideWidth,r=e.dilationHeight,s=e.effectiveFilterHeight,a=e.effectiveFilterWidth,o=s-1-e.padInfo.top,i=a-1-e.padInfo.left,u=s*a-1;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${s};
          wR += ${r}) {
          float dyR = float(dyRCorner + wR) / ${t}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${a}; wC++) {
            float dyC = float(dyCCorner + wC) / ${n}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${u} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${a} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}},Tne=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;let t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,s=e.dilationDepth,a=e.dilationHeight,o=e.dilationWidth,i=e.effectiveFilterDepth,u=e.effectiveFilterHeight,l=e.effectiveFilterWidth,c=i-1-e.padInfo.front,d=u-1-e.padInfo.top,p=l-1-e.padInfo.left,h=i*u*l-1;this.userCode=`
      const ivec3 pads = ivec3(${c}, ${d}, ${p});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${i};
           wD += ${s}) {
          float dyD = float(dyDCorner + wD) / ${t}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${u};
              wR += ${a}) {
            float dyR = float(dyRCorner + wR) / ${n}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${l};
                wC += ${o}) {
              float dyC = float(dyCCorner + wC) / ${r}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${h} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${u} * ${l} +
                  wR * ${l} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function Nne(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,o=a,{filterSize:i,strides:u,pad:l,dimRoundingMode:c}=r,d=[1,1,1],p=N.computePool3DInfo(o.shape,i,u,d,l,c),h=new ck(p,"max",!0),f=n.runWebGLProgram(h,[o],o.dtype),m=new Tne(p),g=n.runWebGLProgram(m,[s,f],o.dtype);return n.disposeIntermediateTensorInfo(f),g}var _ne={kernelName:Rh,backendName:"webgl",kernelFunc:Nne};function Ene(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a,output:o}=t,i=a;Uc([a,o],"maxPoolGrad");let{filterSize:u,strides:l,pad:c,dimRoundingMode:d}=r,p=N.computePool2DInfo(i.shape,u,l,1,c,d),h=!0,f=new cp(p,"max",h),m=n.runWebGLProgram(f,[i],i.dtype),g=new Cne(p),b=n.runWebGLProgram(g,[s,m],i.dtype);return n.disposeIntermediateTensorInfo(m),b}var Ane={kernelName:Dh,backendName:"webgl",kernelFunc:Ene};function $ne(e,t,n,r){let s=new cp(n,"max",!1),a=r.runWebGLProgram(s,[e],"float32");s=new cp(n,"max",!0,!0,t);let o=r.runWebGLProgram(s,[e],"float32");return[a,o]}var Fne={kernelName:Ph,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{x:r}=e,{filterSize:s,strides:a,pad:o,includeBatchInIndex:i}=t,u=n;w.assert(r.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);let l=[1,1];w.assert(N.eitherStridesOrDilationsAreOne(a,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${l}'`);let c=N.computePool2DInfo(r.shape,s,a,l,o),[d,p]=$ne(r,i,c,u);return[d,p]}};function Dne(e,t,n,r){let s=w.sizeFromShape(t),o=w.sizeFromShape(e.shape)/s,i=fe({inputs:{x:e},attrs:{shape:[o,s]},backend:r}),u=ou(i,"float32","mean",r),l=fe({inputs:{x:u},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(i),r.disposeIntermediateTensorInfo(u),l}var Rne={kernelName:Da,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{x:r}=e,{keepDims:s,axis:a}=t,o=n,i=r.shape.length,u=w.parseAxisParam(a,r.shape),l=u,c=N.getAxesPermutation(l,i),d=c!=null,p=o.shouldExecuteOnCPU([r]),h=[],f=r;if(d){if(p){let x=o.texData.get(f.dataId).values,k=new Array(i);for(let E=0;E<k.length;E++)k[E]=r.shape[c[E]];let T=ok(x,r.shape,r.dtype,c,k);f=o.makeTensorInfo(k,r.dtype);let C=o.texData.get(f.dataId);C.values=T}else f=Fm(r,c,o);h.push(f),l=N.getInnerMostAxes(l.length,i)}N.assertAxesAreInnerMostDims("sum",l,i);let[m,g]=N.computeOutAndReduceShapes(f.shape,l),b=m;s&&(b=N.expandShapeToKeepDim(m,u));let y=Dne(f,g,b,o);for(let v of h)o.disposeIntermediateTensorInfo(v);return y}};function Pne(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:o}=r,i=s.shape.length,u=w.parseAxisParam(a,s.shape),l=u,c=N.getAxesPermutation(l,i),d=s;c!=null&&(d=Dn({inputs:{x:s},backend:n,attrs:{perm:c}}),l=N.getInnerMostAxes(l.length,s.shape.length)),N.assertAxesAreInnerMostDims("min",l,i);let[p,h]=N.computeOutAndReduceShapes(d.shape,l),f=w.sizeFromShape(h),m=fe({inputs:{x:d},backend:n,attrs:{shape:[-1,f]}}),g=ou(m,m.dtype,"min",n),b;if(o){let y=N.expandShapeToKeepDim(p,u);b=fe({inputs:{x:g},backend:n,attrs:{shape:y}})}else b=fe({inputs:{x:g},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),c!=null&&n.disposeIntermediateTensorInfo(d),b}var One={kernelName:Ra,backendName:"webgl",kernelFunc:Pne},Mne=g_+`
  return min(a, b);
`,Lne=`
  vec4 result = vec4(min(a, b));
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  `+Am+`
  return result;
`,Bne=hn({opSnippet:Mne,packedOpSnippet:Lne,cpuKernelImpl:P9}),zne={kernelName:Pa,backendName:"webgl",kernelFunc:Bne},Wne=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map((l,c)=>l[0]+e[c]+l[1]);let r=e.length,s=gt(r),a=t.map(l=>l[0]).join(","),o=t.map((l,c)=>l[0]+e[c]).join(","),i=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),u=n==="reflect"?0:1;if(r===1){this.userCode=`
        int start = ${a};
        int end = ${o};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${u};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${u};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${s} start = ${s}(${a});
      ${s} end = ${s}(${o});

      void main() {
        ${s} outC = getOutputCoords();
        for (int i = 0; i < ${r}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${u};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${u};
          }
        }
        ${s} coords = outC - start;
        setOutput(getX(${i}));
      }
    `}},Vne=class{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((h,f)=>h[0]+e[f]+h[1]);let r=e.length,s=gt(r),a=t.map(h=>h[0]).join(","),o=t.map((h,f)=>h[0]+e[f]).join(","),i=Fn("rc",r),u=Fn("source",r),l=`${i[r-1]} < ${this.outputShape[r-1]}`,c=r===1?"source":`vec2(${u.slice(-2).join()})`,d=n==="reflect"?0:1,p="";if(r===1){let h=`
        ${s} source = rc;
        if (source < start) {
          source = start * 2 - source - ${d};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${d};
        }
        source -= start;
      `;p=`
        ${s} rc = outputLoc;
        ${h}
        result[0] = getChannel(getX(${u.join()}), ${c});
        ${i[r-1]} += 1;
        if(${l}) {
          ${h}
          result[1] = getChannel(getX(${u.join()}), ${c});
        }
      `}else{let h=`
        ${s} source = rc;
        ${s} lt = ${s}(lessThan(source, start));
        ${s} gte = ${s}(greaterThanEqual(source, end));
        ${s} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${d}) +
                gte * ((end - 1) * 2 - source + ${d});
        source -= start;
      `;p=`
        ${s} rc = outputLoc;
        ${h}
        result[0] = getChannel(getX(${u.join()}), ${c});
        ${i[r-1]} += 1;
        if(${l}) {
          ${h}
          result[1] = getChannel(getX(${u.join()}), ${c});
        }
        rc = outputLoc;
        ${i[r-2]} += 1;
        if(${i[r-2]} < ${this.outputShape[r-2]}) {
          ${h}
          result[2] = getChannel(getX(${u.join()}), ${c});
          ${i[r-1]} += 1;
          if(${l}) {
            ${h}
            result[3] = getChannel(getX(${u.join()}), ${c});
          }
        }
      `}this.userCode=`
      const ${s} start = ${s}(${a});
      const ${s} end = ${s}(${o});

      void main() {
        ${s} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${p}
        setOutput(result);
      }
    `}},Une=({inputs:e,backend:t,attrs:n})=>{let{x:r}=e,{paddings:s,mode:a}=n,o=X().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Vne(r.shape,s,a):new Wne(r.shape,s,a);return t.runWebGLProgram(o,[r],r.dtype)},Gne={kernelName:Oa,backendName:"webgl",kernelFunc:Une},Hne=`if (b == 0.0) return NAN;
  return mod(a, b);`,jne=`
  vec4 result = mod(a, b);
  vec4 isNaN = vec4(equal(b, vec4(0.0)));
  `+Am+`
  return result;
`,qne=hn({opSnippet:Hne,packedOpSnippet:jne}),Kne={kernelName:sc,backendName:"webgl",kernelFunc:qne},Xne=class{constructor(e,t,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,n],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${t-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${t-1}));
      }
    `}},Yne=`
if (a == b) {
  return 1.0;
};
return a / b;`,Qne=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,J_=hn({opSnippet:Yne,packedOpSnippet:Qne,checkOutOfBounds:!0}),Zne={kernelName:wa,backendName:"webgl",kernelFunc:J_},eE="return a - b;",tE=hn({opSnippet:eE,packedOpSnippet:eE,supportsComplex:!0,cpuKernelImpl:Q9}),Jne={kernelName:Qa,backendName:"webgl",kernelFunc:tE};function nE(e){let{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{dim:a}=r,o=w.parseAxisParam([a],s.shape),i=Z_({inputs:{x:s},backend:n,attrs:{reductionIndices:o,keepDims:!1}}),u=N.expandShapeToKeepDim(i.shape,o),l=fe({inputs:{x:i},backend:n,attrs:{shape:u}}),c=tE({inputs:{a:s,b:l},backend:n}),d=j_({inputs:{x:c},backend:n}),p=Dm({inputs:{x:d},backend:n,attrs:{axis:o,keepDims:!1}}),h=fe({inputs:{x:p},backend:n,attrs:{shape:u}}),f=J_({inputs:{a:d,b:h},backend:n});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(h),f}var ere={kernelName:Xa,backendName:"webgl",kernelFunc:nE};function tre(e){let{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{numSamples:a,seed:o,normalized:i}=r,u=i?s:nE({inputs:{logits:s},backend:n,attrs:{dim:s.shape.length-1}}),l=u.shape[0],c=u.shape[1],d=new Xne(l,c,a),p=[[o]],h=n.runWebGLProgram(d,[u],"int32",p);return i||n.disposeIntermediateTensorInfo(u),h}var nre={kernelName:Oh,backendName:"webgl",kernelFunc:tre},rE="return -x;";function rre(e){let{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])){let a=n.texData.get(r.dataId),[o,i]=M9(a.values,r.shape,r.dtype);return n.makeTensorInfo(i,r.dtype,o)}let s;return X().getBool("WEBGL_PACK_UNARY_OPERATIONS")?s=new Kc(r.shape,rE):s=new To(r.shape,rE),n.runWebGLProgram(s,[r],r.dtype)}var sre={kernelName:ai,backendName:"webgl",kernelFunc:rre},are=Dr.nonMaxSuppressionV3Impl;function ore(e){N.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:o,iouThreshold:i,scoreThreshold:u}=r,l=n.readSync(s.dataId),c=n.readSync(a.dataId),{selectedIndices:d}=are(l,c,o,i,u);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}var ire={kernelName:ii,backendName:"webgl",kernelFunc:ore},ure=Dr.nonMaxSuppressionV4Impl;function cre(e){N.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:o,iouThreshold:i,scoreThreshold:u,padToMaxOutputSize:l}=r,c=n.readSync(s.dataId),d=n.readSync(a.dataId),{selectedIndices:p,validOutputs:h}=ure(c,d,o,i,u,l);return[n.makeTensorInfo([p.length],"int32",new Int32Array(p)),n.makeTensorInfo([],"int32",new Int32Array([h]))]}var lre={kernelName:ac,backendName:"webgl",kernelFunc:cre},dre=Dr.nonMaxSuppressionV5Impl;function pre(e){N.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:o,iouThreshold:i,scoreThreshold:u,softNmsSigma:l}=r,c=n.readSync(s.dataId),d=n.readSync(a.dataId),p=o,h=i,f=u,m=l,{selectedIndices:g,selectedScores:b}=dre(c,d,p,h,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([b.length],"float32",new Float32Array(b))]}var hre={kernelName:ui,backendName:"webgl",kernelFunc:pre},fre=class{constructor(e,t,n,r){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${r}), float(${n}),
                      float(index == coords.y)));
      }
    `}},mre=e=>{let{inputs:t,backend:n,attrs:r}=e,{indices:s}=t,{depth:a,onValue:o,offValue:i}=r,u=w.sizeFromShape(s.shape),l=new fre(u,a,o,i),c=fe({inputs:{x:s},backend:n,attrs:{shape:[u]}}),d=n.runWebGLProgram(l,[c],s.dtype);n.disposeIntermediateTensorInfo(c);let p=[...s.shape,a],h=fe({inputs:{x:d},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(d),h},gre={kernelName:li,backendName:"webgl",kernelFunc:mre};function Lm(e){let{inputs:t,backend:n}=e,{x:r}=t;if(r.dtype==="complex64"){let s=lp({inputs:{input:r},backend:n}),a=Lm({inputs:{x:s},backend:n}),o=Mm({inputs:{input:r},backend:n}),i=Lm({inputs:{x:o},backend:n}),u=No({inputs:{real:a,imag:i},backend:n});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(i),u}else return dp({attrs:{shape:r.shape,dtype:r.dtype,value:r.dtype==="string"?"":0},backend:n})}var bre={kernelName:Ni,backendName:"webgl",kernelFunc:Lm};function sE(e){let{inputs:t,backend:n}=e,{x:r}=t;if(r.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(r.dtype==="complex64"){let s=lp({inputs:{input:r},backend:n}),a=sE({inputs:{x:s},backend:n}),o=Mm({inputs:{input:r},backend:n}),i=Lm({inputs:{x:o},backend:n}),u=No({inputs:{real:a,imag:i},backend:n});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(i),u}else return dp({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:n})}var yre={kernelName:ci,backendName:"webgl",kernelFunc:sE};function vre(e){let{inputs:t,backend:n,attrs:r}=e,{axis:s}=r;if(t.length===1)return pk({inputs:{input:t[0]},backend:n,attrs:{dim:s}});let a=t[0].shape,o=t[0].dtype;t.forEach(c=>{w.assertShapesMatch(a,c.shape,"All tensors passed to stack must have matching shapes"),w.assert(o===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});let i=[],u=t.map(c=>{let d=pk({inputs:{input:c},backend:n,attrs:{dim:s}});return i.push(d),d}),l=O_({inputs:u,backend:n,attrs:{axis:s}});return i.forEach(c=>n.disposeIntermediateTensorInfo(c)),l}var xre={kernelName:di,backendName:"webgl",kernelFunc:vre},wre=class{constructor(e,t,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((u,l)=>u[0]+e[l]+u[1]);let r=e.length,s=gt(r),a=t.map(u=>u[0]).join(","),o=t.map((u,l)=>u[0]+e[l]).join(","),i=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);if(r===1){this.userCode=`
        int start = ${a};
        int end = ${o};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${s} start = ${s}(${a});
      ${s} end = ${s}(${o});

      void main() {
        ${s} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${s} coords = outC - start;
          setOutput(getX(${i}));
        }
      }
    `}},kre=class{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((f,m)=>f[0]+e[m]+f[1]);let r=e.length,s=gt(r),a=t.map(f=>f[0]).join(","),o=t.map((f,m)=>f[0]+e[m]).join(","),i=Fn("rc",r),u=Fn("source",r),l=`${i[r-1]} < ${this.outputShape[r-1]}`,c=r===1?"source":`vec2(${u.slice(-2).join()})`,d=[`${s} rc = outputLoc;`,`${i[r-1]} += 1;
       if(${l}) {
      `,r===1?"":`}
       rc = outputLoc;
       ${i[r-2]} += 1;
       if(${i[r-2]} < ${this.outputShape[r-2]}) {`,r===1?"":`  ${i[r-1]} += 1;
         if(${l}) {`],p=r===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))",h="";for(let f=0,m=r===1?2:4;f<m;f++)h+=`
        ${d[f]}
        if (${p}) {
          result[${f}] = float(value);
        } else {
          ${s} source = rc - start;
          result[${f}] = getChannel(getX(${u.join()}), ${c});
        }
      `;h+=r===1?"} ":"}}",this.userCode=`
      const ${s} start = ${s}(${a});
      const ${s} end = ${s}(${o});

      void main() {
        ${s} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${h}
        setOutput(result);
      }
    `}},aE=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{paddings:a,constantValue:o}=r;if(w.sizeFromShape(s.shape)===0){let l=a.map((c,d)=>c[0]+s.shape[d]+c[1]);return dp({backend:n,attrs:{shape:l,value:o,dtype:s.dtype}})}let i=X().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new kre(s.shape,a,o):new wre(s.shape,a,o),u=[[o]];return n.runWebGLProgram(i,[s],s.dtype,u)},Ire={kernelName:La,backendName:"webgl",kernelFunc:aE},Sre=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,Cre=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));
  `+Am+`
  return result;
`,Tre=hn({opSnippet:Sre,packedOpSnippet:Cre}),Nre={kernelName:Ba,backendName:"webgl",kernelFunc:Tre};function _re(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:o}=r,i=s.shape.length,u=[],l=w.parseAxisParam(a,s.shape),c=l,d=N.getAxesPermutation(c,i),p=s;d!=null&&(p=Dn({inputs:{x:s},backend:n,attrs:{perm:d}}),c=N.getInnerMostAxes(c.length,i),u.push(p)),N.assertAxesAreInnerMostDims("prod",c,i);let h;if(n.shouldExecuteOnCPU([p])){let f=n.texData.get(p.dataId).values,{outVals:m,outShape:g,outDtype:b}=B9(p.shape,p.dtype,f,c);h=n.makeTensorInfo(g,b,m)}else{let[f,m]=N.computeOutAndReduceShapes(p.shape,c),g=w.sizeFromShape(m),b=fe({inputs:{x:p},backend:n,attrs:{shape:[-1,g]}}),y=bd(s.dtype),v=ou(b,y,"prod",n);h=fe({inputs:{x:v},backend:n,attrs:{shape:f}}),u.push(b),u.push(v)}if(o){u.push(h);let f=N.expandShapeToKeepDim(h.shape,l);h=fe({inputs:{x:h},backend:n,attrs:{shape:f}})}return u.forEach(f=>n.disposeIntermediateTensorInfo(f)),h}var Ere={kernelName:pi,backendName:"webgl",kernelFunc:_re},oE=e=>{let{backend:t,attrs:n}=e,{start:r,stop:s,step:a,dtype:o}=n,i=z9(r,s,a,o);return t.makeTensorInfo([i.length],o,i)},Are={kernelName:oc,backendName:"webgl",kernelFunc:oE},$re="return 1.0 / x;",Fre=Ze({opSnippet:$re}),Dre={kernelName:ic,backendName:"webgl",kernelFunc:Fre},Rre=ts+`
  return (x < 0.0) ? 0.0 : x;
`,Pre=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Ore=Ze({opSnippet:Rre,packedOpSnippet:Pre}),Mre={kernelName:Wa,backendName:"webgl",kernelFunc:Ore},Lre=ts+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Bre=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,zre=Ze({opSnippet:Lre,packedOpSnippet:Bre}),Wre={kernelName:Ua,backendName:"webgl",kernelFunc:zre},Vre=class{constructor(e,t,n,r,s){this.variableNames=["A"],this.outputShape=[];let[a,o,i,u]=e;this.outputShape=[a,t,n,u];let l=[r&&t>1?o-1:o,r&&n>1?i-1:i],c=[r&&t>1?t-1:t,r&&n>1?n-1:n],d;s?d="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":d="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${l[0]/c[0]},
          ${l[1]/c[1]});
      const vec2 inputShapeRC = vec2(${o}.0, ${i}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${d};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}},Ure=class{constructor(e,t,n,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[a,o,i,u]=e;this.outputShape=[a,t,n,u];let l=[r&&t>1?o-1:o,r&&n>1?i-1:i],c=[r&&t>1?t-1:t,r&&n>1?n-1:n],d;s?d="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":d="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${l[0]/c[0]},
          ${l[1]/c[1]},
          ${l[1]/c[1]});
      const vec3 inputShapeRC = vec3(${o}.0, ${i}.0,
                                     ${i}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${d};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${u-1};
        bool hasNextRow = coords.z < ${n-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}};function Gre(e){let{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:o,size:i}=r,[u,l]=i,c=X().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new Ure(s.shape,u,l,a,o):new Vre(s.shape,u,l,a,o);return n.runWebGLProgram(c,[s],"float32")}var Hre={kernelName:Va,backendName:"webgl",kernelFunc:Gre},jre=class{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;let[,r,s]=t,[,a,o]=e,i=[n&&a>1?r-1:r,n&&o>1?s-1:s],u=[n&&a>1?a-1:a,n&&o>1?o-1:o],l=i[0]/u[0],c=i[1]/u[1],d=1/l,p=1/c,h=Math.ceil(d)*2+2,f=Math.ceil(p)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${l});
        const float widthScale = float(${c});

        const float invHeightScale = float(${d});
        const float invWidthScale = float(${p});

        const int winHeight = int(${h});
        const int winWidth = int(${f});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${a}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${o}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${s-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function qre(e){let{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:o}=r,i=new jre(a.shape,s.shape,o);return n.runWebGLProgram(i,[a],a.dtype)}var Kre={kernelName:Lh,backendName:"webgl",kernelFunc:qre},Xre=class{constructor(e,t,n,r,s){this.variableNames=["A"],this.outputShape=[];let[a,o,i,u]=e;this.outputShape=[a,t,n,u];let l=[r&&t>1?o-1:o,r&&n>1?i-1:i],c=[r&&t>1?t-1:t,r&&n>1?n-1:n],d=r?"0.5":"0.0",p;s?p="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":p="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${l[0]/c[0]},
          ${l[1]/c[1]});
      const vec2 inputShapeRC = vec2(${o}.0, ${i}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${p};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}},Yre=class{constructor(e,t,n,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[a,o,i,u]=e;this.outputShape=[a,t,n,u];let l=[r&&t>1?o-1:o,r&&n>1?i-1:i],c=[r&&t>1?t-1:t,r&&n>1?n-1:n],d=r?"0.5":"0.0",p;s?p="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":p="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${l[0]/c[0]},
          ${l[1]/c[1]},
          ${l[1]/c[1]});
      const vec3 inputShapeRC = vec3(${o}.0, ${i}.0,
                                     ${i}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${p};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${u-1};
        bool hasNextRow = coords.z < ${n-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}};function Qre(e){let{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:o,size:i}=r,[u,l]=i,c=X().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new Yre(s.shape,u,l,a,o):new Xre(s.shape,u,l,a,o);return n.runWebGLProgram(c,[s],s.dtype)}var Zre={kernelName:uc,backendName:"webgl",kernelFunc:Qre},Jre=class{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;let[,r,s]=t,[,a,o]=e,i=[n&&a>1?r-1:r,n&&o>1?s-1:s],u=[n&&a>1?a-1:a,n&&o>1?o-1:o],l=i[0]/u[0],c=i[1]/u[1],d=1/l,p=1/c,h=Math.ceil(d)*2+2,f=Math.ceil(p)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${l});
        const float widthScale = float(${c});

        const float invHeightScale = float(${d});
        const float invWidthScale = float(${p});

        const int winHeight = int(${h});
        const int winWidth = int(${f});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${a}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${o}) {
              continue;
            }

            float sourceFracRow =
              float(${i[0]}) *
                (float(dyR) / float(${u[0]}));

            float sourceFracCol =
                float(${i[1]}) *
                  (float(dyC) / float(${u[1]}));

            int sourceNearestRow = int(min(
                float(int(${r}) - 1),
                ${n} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${s}) - 1),
                ${n} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function ese(e){let{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:o}=r,i=new Jre(a.shape,s.shape,o);return n.runWebGLProgram(i,[a],a.dtype)}var tse={kernelName:Mh,backendName:"webgl",kernelFunc:ese},nse=class{constructor(e,t){this.variableNames=["x"];let n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=e,n===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `;return}let r=o=>t.indexOf(o)!==-1&&e[o]!==1?`${e[o]} - coords[${o}] - 1`:`coords[${o}]`,s=e.map((o,i)=>r(i)).join(","),a=gt(n);this.userCode=`
      void main() {
        ${a} coords = getOutputCoords();
        setOutput(getX(${s}));
      }
    `}},rse=class{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;let n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=e;let r=Fn("rc",n),s=`${r[n-1]} + 1 < ${this.outputShape[n-1]}`,a=`${r[n-2]} + 1 < ${this.outputShape[n-2]}`,o=gt(n);n===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${s}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${o} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${i(r.slice())};
          if(${s}){
            result.g = ${u(r.slice())};
          }
          if(${a}) {
            result.b = ${l(r.slice())};
            if(${s}) {
              result.a = ${c(r.slice())};
            }
          }
          setOutput(result);
        }
    `;function i(h){return d(h)}function u(h){return h[n-1]="("+h[n-1]+" + 1)",d(h)}function l(h){return h[n-2]="("+h[n-2]+" + 1)",d(h)}function c(h){return h[n-1]="("+h[n-1]+" + 1)",h[n-2]="("+h[n-2]+" + 1)",d(h)}function d(h){let f=e.map((b,y)=>p(y,h)),m=f.join(","),g=f.slice(-2).join(",");return`getChannel(getX(${m}), vec2(${g}))`}function p(h,f){return t.indexOf(h)!==-1&&e[h]!==1?`${e[h]} - ${f[h]} - 1`:`${f[h]}`}}};function sse(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dims:a}=r,o=s.shape.length,i=w.parseAxisParam(a,s.shape);if(o===0)return cr({inputs:{x:s},backend:n});let u=X().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new rse(s.shape,i):new nse(s.shape,i);return n.runWebGLProgram(u,[s],s.dtype)}var ase={kernelName:fi,backendName:"webgl",kernelFunc:sse},ose=class{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];let n=e[1],r=e[2];this.outputShape=e;let s="";typeof t=="number"?s=`float outputValue = ${t.toFixed(2)};`:s=`
        vec3 fill = vec3(${t.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${s}
          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${n}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}},ise={kernelName:_i,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{image:r}=e,{radians:s,fillValue:a,center:o}=t,i=n,u=new ose(r.shape,a),[l,c]=N.getImageCenter(o,r.shape[1],r.shape[2]),d=[[l,c,Math.sin(s),Math.cos(s)]];return i.runWebGLProgram(u,[r],r.dtype,d)}},use=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,cse=Ze({opSnippet:use}),lse={kernelName:mi,backendName:"webgl",kernelFunc:cse},dse="return inversesqrt(x);",pse=Ze({opSnippet:dse,cpuKernelImpl:W9}),hse={kernelName:Ga,backendName:"webgl",kernelFunc:pse},iE=class{constructor(e,t,n,r,s,a,o=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=a;let i=gt(s.length),u=gt(a.length),l="";n===1?l="i":n===2&&(l="i, j");let c=`getIndices(${l})`,d="";r===1?d="i":r===2&&(d="i, coords[1]");let p=`getUpdates(${d})`,h=t>1?"strides[j]":"strides";this.userCode=`
        ${i} strides = ${i}(${s});

        void main() {
          ${u} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${t}; j++) {
              int index = round(${c});
              flattenedIndex += index * ${h};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${p};
              found = true;
            }
          }
          setOutput(mix(getDefaultValue(), sum, float(found)));
        }
      `}};function fse(e){let{inputs:t,backend:n,attrs:r}=e,{indices:s,updates:a}=t,{shape:o}=r,{sliceRank:i,numUpdates:u,sliceSize:l,strides:c,outputSize:d}=N.calculateShapes(a,s,o),p=[d/l,l];if(d===0)return n.makeTensorInfo(o,s.dtype);let h=fe({inputs:{x:s},backend:n,attrs:{shape:[u,i]}}),f=fe({inputs:{x:a},backend:n,attrs:{shape:[u,l]}}),m=n.makeTensorInfo([],"float32",new Float32Array([0])),g=new iE(u,i,h.shape.length,f.shape.length,c,p),b=n.runWebGLProgram(g,[f,h,m],f.dtype),y=fe({inputs:{x:b},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(m),y}var mse={kernelName:gi,backendName:"webgl",kernelFunc:fse},gse=class{constructor(e,t,n){this.variableNames=["c","a","b"],this.outputShape=t;let r,s;if(n>4)throw Error(`Where for rank ${n} is not yet supported`);if(n===1)s="resRC",r="resRC";else{let o=["resRC.x","resRC.y","resRC.z","resRC.w"],i=[],u=[];for(let l=0;l<t.length;l++)u.push(`${o[l]}`),l<e&&i.push(`${o[l]}`);r=i.join(),s=u.join()}let a=gt(n);this.userCode=`
      void main() {
        ${a} resRC = getOutputCoords();
        float cVal = getC(${r});
        if (cVal >= 1.0) {
          setOutput(getA(${s}));
        } else {
          setOutput(getB(${s}));
        }
      }
    `}};function bse(e){let{inputs:t,backend:n}=e,{condition:r,t:s,e:a}=t,o=new gse(r.shape.length,s.shape,s.shape.length);return n.runWebGLProgram(o,[r,s,a],In(s.dtype,a.dtype))}var yse={kernelName:bi,backendName:"webgl",kernelFunc:bse},vse=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${N.SELU_SCALEALPHA};
  float scale = ${N.SELU_SCALE};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,xse=Ze({opSnippet:vse}),wse={kernelName:cc,backendName:"webgl",kernelFunc:xse},uE="return 1.0 / (1.0 + exp(-1.0 * x));",kse=Ze({opSnippet:uE,packedOpSnippet:uE,cpuKernelImpl:V9}),Ise={kernelName:ja,backendName:"webgl",kernelFunc:kse},Sse=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,Cse=Ze({opSnippet:Sse}),Tse={kernelName:lc,backendName:"webgl",kernelFunc:Cse},Nse=w_+`
  return sin(x);
`,_se=Ze({opSnippet:Nse}),Ese={kernelName:Ha,backendName:"webgl",kernelFunc:_se},Ase=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,$se=Ze({opSnippet:Ase}),Fse={kernelName:vi,backendName:"webgl",kernelFunc:$se},Dse=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,Rse=Ze({opSnippet:Dse}),Pse={kernelName:dc,backendName:"webgl",kernelFunc:Rse},Ose=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,paddings:o}=r;w.assert(s.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");let i=a.reduce((b,y)=>b*y),u=[[0,0]];u.push(...o);for(let b=1+a.length;b<s.shape.length;++b)u.push([0,0]);let l=[],c=aE({inputs:{x:s},backend:n,attrs:{paddings:u,constantValue:0}}),d=N.getReshaped(c.shape,a,i,!1),p=N.getPermuted(d.length,a.length,!1),h=N.getReshapedPermuted(c.shape,a,i,!1),f=fe({inputs:{x:c},backend:n,attrs:{shape:d}}),m=Dn({inputs:{x:f},backend:n,attrs:{perm:p}}),g=fe({inputs:{x:m},backend:n,attrs:{shape:h}});return l.push(c),l.push(f),l.push(m),l.forEach(b=>n.disposeIntermediateTensorInfo(b)),g},Mse={kernelName:xi,backendName:"webgl",kernelFunc:Ose};function Lse(e){let{inputs:t,backend:n}=e,{indices:r,values:s,denseShape:a,defaultValue:o}=t;if(a.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${a.shape}`);if(r.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${r.shape}`);if(s.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${s.shape}`);if(o.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${o.shape}`);let i=n.readSync(r.dataId),u=n.readSync(s.dataId),l=n.readSync(a.dataId),c=n.readSync(o.dataId)[0],[d,p,h,f,m]=G9(i,r.shape,r.dtype,u,s.dtype,l,c);return[n.makeTensorInfo(p,r.dtype,d),n.makeTensorInfo([p[0]],s.dtype,h),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(g=>Number(g)))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}var Bse={kernelName:rd,backendName:"webgl",kernelFunc:Lse};function zse(e){let{inputs:t,backend:n}=e,{inputIndices:r,inputShape:s,newShape:a}=t;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(s.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${s.shape}`);if(a.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${a.shape}`);let o=Array.from(n.readSync(s.dataId)),i=n.readSync(r.dataId),u=Array.from(n.readSync(a.dataId)),[l,c,d]=H9(i,r.shape,r.dtype,o,u);return[n.makeTensorInfo(c,r.dtype,l),n.makeTensorInfo([d.length],a.dtype,new Int32Array(d))]}var Wse={kernelName:pc,backendName:"webgl",kernelFunc:zse};function Vse(e){let{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${s.shape}`);if(a.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${a.shape}`);let o=n.readSync(r.dataId),i=n.readSync(s.dataId),u=n.readSync(a.dataId),[l,c]=i_(o,r.shape,r.dtype,i,u,!0);return n.makeTensorInfo(c,r.dtype,l)}var Use={kernelName:sd,backendName:"webgl",kernelFunc:Vse};function Gse(e){let{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${s.shape}`);if(a.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${a.shape}`);let o=n.readSync(r.dataId),i=n.readSync(s.dataId),u=n.readSync(a.dataId),[l,c]=i_(o,r.shape,r.dtype,i,u);return n.makeTensorInfo(c,r.dtype,l)}var Hse={kernelName:ad,backendName:"webgl",kernelFunc:Gse};function jse(e){let{inputs:t,backend:n,attrs:r}=e,{sparseIndices:s,sparseValues:a,defaultValue:o}=t,{outputShape:i}=r,{sliceRank:u,numUpdates:l,strides:c,outputSize:d}=N.calculateShapes(a,s,i),p=!1,h=new iE(l,u,s.shape.length,a.shape.length,c,[d,1],p),f=n.runWebGLProgram(h,[a,s,o],a.dtype),m=fe({inputs:{x:f},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(f),m}var qse={kernelName:od,backendName:"webgl",kernelFunc:jse};function Kse(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{numOrSizeSplits:a,axis:o}=r,i=w.parseAxisParam(o,s.shape)[0],u=N.prepareSplitSize(s,a,i),l=s.shape.length,c=new Array(l).fill(0),d=s.shape.slice();return u.map(p=>{let h=[...d];h[i]=p;let f=Yc({inputs:{x:s},backend:n,attrs:{begin:c,size:h}});return c[i]+=p,f})}var Xse={kernelName:wi,backendName:"webgl",kernelFunc:Kse},cE="return sqrt(x);",Yse=Ze({opSnippet:cE,packedOpSnippet:cE,cpuKernelImpl:j9}),Qse={kernelName:qa,backendName:"webgl",kernelFunc:Yse},Zse="return x * x;",Jse=Ze({opSnippet:Zse}),eae={kernelName:hc,backendName:"webgl",kernelFunc:Jse},lE="return (a - b) * (a - b);",tae=hn({opSnippet:lE,packedOpSnippet:lE}),nae={kernelName:Ya,backendName:"webgl",kernelFunc:tae};function rae({inputs:e,attrs:t,backend:n}){let{x:r}=e,s=ts+`
    return x > 0.0 ? 1.0 : float(${t.alpha});
  `,a=new To(r.shape,s);return n.runWebGLProgram(a,[r],r.dtype)}var sae={kernelName:eo,backendName:"webgl",kernelFunc:rae},aae=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=n;let r=n.length,s=gt(n.length),a=gt(n.length),o="";if(r===1)o="coords * strides + begin";else{let i=0;o=n.map((u,l)=>(i++,n.length===1?`coords * strides[${l}] + begin[${l}]`:`coords[${i-1}] * strides[${l}] + begin[${l}]`)).join(",")}this.userCode=`
      ${s} begin = ${s}(${e});
      ${s} strides = ${s}(${t});

      void main() {
        ${a} coords = getOutputCoords();
        setOutput(getX(${o}));
      }
    `}};function oae(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,end:o,strides:i,beginMask:u,endMask:l,ellipsisMask:c,newAxisMask:d,shrinkAxisMask:p}=r,{finalShapeSparse:h,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:b,begin:y,end:v,strides:x}=$t.sliceInfo(s.shape,a,o,i,u,l,c,d,p),k;if(m)k=fe({inputs:{x:s},backend:n,attrs:{shape:f}});else if(g||b){w.assert(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);let C=$t.computeOutShape(y,v,x),E=Yc({inputs:{x:s},backend:n,attrs:{begin:y,size:C}});k=fe({inputs:{x:E},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(E)}else if(n.shouldExecuteOnCPU([s])){let E=n.readSync(s.dataId),F=$e(s.shape,s.dtype,E),O=q9(h,F,x,y);k=n.makeTensorInfo(f,s.dtype,O.values)}else{let E=new aae(y,x,h);k=n.runWebGLProgram(E,[s],s.dtype)}let T=fe({inputs:{x:k},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(k),T}var iae={kernelName:ki,backendName:"webgl",kernelFunc:oae};function uae(e){let{inputs:t,backend:n,attrs:r}=e,{separator:s,nGramWidths:a,leftPad:o,rightPad:i,padWidth:u,preserveShortSequences:l}=r,{data:c,dataSplits:d}=t,p=n.readSync(c.dataId),h=n.readSync(d.dataId),[f,m]=K9(p,h,s,a,o,i,u,l);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(d.shape,"int32",m)]}var cae={kernelName:id,backendName:"webgl",kernelFunc:uae};function lae(e){let{inputs:t,backend:n,attrs:r}=e,{skipEmpty:s}=r,{input:a,delimiter:o}=t;if(a.dtype!=="string")throw new Error("Input must be of datatype string");if(a.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${a.shape}`);if(o.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);let i=n.readSync(a.dataId),u=n.readSync(o.dataId)[0],[l,c,d]=X9(i,u,s),p=c.length;return[n.makeTensorInfo([p,2],"int32",l),n.makeTensorInfo([p],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(d))]}var dae={kernelName:Bh,backendName:"webgl",kernelFunc:lae};function pae(e){let{inputs:t,backend:n,attrs:r}=e,{numBuckets:s}=r,{input:a}=t;if(a.dtype!=="string")throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");let o=n.readSync(a.dataId),i=Y9(o,s);return n.makeTensorInfo(a.shape,"int32",i)}var hae={kernelName:zh,backendName:"webgl",kernelFunc:pae},fae="return tan(x);",mae=Ze({opSnippet:fae}),gae={kernelName:Ii,backendName:"webgl",kernelFunc:mae},bae=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,yae=Ze({opSnippet:bae}),vae={kernelName:Za,backendName:"webgl",kernelFunc:yae},xae=class{constructor(e,t){this.variableNames=["A"];let n=new Array(e.length);for(let a=0;a<n.length;a++)n[a]=e[a]*t[a];this.outputShape=n,this.rank=n.length;let r=gt(this.rank),s=wae(e);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        setOutput(getA(${s}));
      }
    `}};function wae(e){let t=e.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(t===1)return`imod(resRC, ${e[0]})`;let n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let s=0;s<e.length;s++)r.push(`imod(${n[s]}, ${e[s]})`);return r.join()}function dE(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reps:a}=r;if(s.dtype==="string"||s.shape.length>5){let u=n.readSync(s.dataId),l=s.dtype==="string"?u.map(p=>w.decodeString(p)):u,c=$e(s.shape,s.dtype,l),d=Z9(c,a);return n.makeTensorInfo(d.shape,d.dtype,d.values)}let o=new xae(s.shape,a);return n.runWebGLProgram(o,[s],s.dtype)}var kae={kernelName:As,backendName:"webgl",kernelFunc:dE},Iae=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}},Sae=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}};function iu(e,t){t!==null&&e.disposeIntermediateTensorInfo(t)}function pE(e){let t=1;for(;t<e;)t*=2;return t}function Cae(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{k:a,sorted:o}=r,i=X().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),u=X().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),l=s.shape,c=l[l.length-1];if(n.shouldExecuteOnCPU([s])||c<i||a>u){let O=n.readSync(s.dataId),[D,R]=J9(O,l,s.dtype,a,o);return[n.makeTensorInfo(D.shape,D.dtype,D.values),n.makeTensorInfo(R.shape,R.dtype,R.values)]}if(a===0)return l[l.length-1]=0,[n.makeTensorInfo(l,s.dtype,[]),n.makeTensorInfo(l,"int32",[])];if(c===1)return[s,dp({attrs:{shape:l,dtype:"int32",value:0},backend:n})];let d=n.texData.get(s.dataId),p=d!==null&&d.isPacked,h=p?n.unpackTensor(s):s,m=w.sizeFromShape(l)/c,g=fe({inputs:{x:h},attrs:{shape:[m,c]},backend:n});p&&iu(n,h);let b=pE(a),y=pE(c),v=null,x=()=>v===null?[g,g]:[g,v],k=(O,D,R)=>{let _=x(),L=new Iae(R),j=[[c],[v===null?1:0],[Number.NEGATIVE_INFINITY],[O],[D]],K=v;v=n.runWebGLProgram(L,_,"int32",j),iu(n,K)};for(let O=1;O<b;O*=2){let D=O*2;for(let R=O;R>=1;R/=2)k(D,R,[m,y])}for(let O=y;O>b;O/=2){let D=x(),R=new Sae([m,O/2]),L=[[c],[v===null?1:0],[b]],U=v;v=n.runWebGLProgram(R,D,"int32",L),iu(n,U);let j=b/2,K=j*2;for(let q=j;q>=1;q/=2)k(K,q,v.shape)}let T=v;v=Yc({inputs:{x:v},backend:n,attrs:{begin:0,size:[m,a]}}),iu(n,T);let C=Q_({inputs:{x:g,indices:v},backend:n,attrs:{axis:1,batchDims:1}});iu(n,g);let E=l.slice(0,-1);E.push(a),T=v,v=fe({inputs:{x:v},attrs:{shape:E},backend:n}),iu(n,T);let F=C;return C=fe({inputs:{x:C},attrs:{shape:E},backend:n}),iu(n,F),[C,v]}var Tae={kernelName:Si,backendName:"webgl",kernelFunc:Cae},Nae=class{constructor(e,t,n,r,s,a){this.variableNames=["Image","Transforms"],this.outputShape=a;let o=n==="nearest"?1:2,i;switch(r){case"constant":i=1;break;case"reflect":i=2;break;case"wrap":i=3;break;case"nearest":i=4;break;default:i=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${i} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${i} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${i} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${s});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${s});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${t}));
                float mapY = mapCoord(inY, float(${e}));

                if (${o} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}};function _ae(e){let{inputs:t,backend:n,attrs:r}=e,{image:s,transforms:a}=t,{interpolation:o,fillMode:i,fillValue:u,outputShape:l}=r,[c,d,p,h]=s.shape,[f,m]=l!=null?l:[d,p],g=[c,f,m,h],b=new Nae(d,p,o,i,u,g);return n.runWebGLProgram(b,[s,a],"float32")}var Eae={kernelName:Ci,backendName:"webgl",kernelFunc:_ae};function Aae(e){let{inputs:t,attrs:n,backend:r}=e,{axis:s}=n,{x:a}=t;Uc(a,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");let o=r.readSync(a.dataId),{outputValues:i,outputShape:u,indices:l}=eQ(o,s,a.shape,a.dtype);return[r.makeTensorInfo(u,a.dtype,i),r.makeTensorInfo([l.length],"int32",l)]}var $ae={kernelName:Wh,backendName:"webgl",kernelFunc:Aae};function Fae(e){let{inputs:t,backend:n,attrs:r}=e,{value:s}=t,{axis:a}=r;a<0&&(a+=s.shape.length);let o=s,i=o.shape.length,u=s.shape[a],l=new Array(i-1),c=0;for(let m=0;m<i;m++)m!==a&&(l[c++]=o.shape[m]);let d=[],p=new Array(i).fill(0),h=o.shape.slice();h[a]=1;let f=new Array(u);for(let m=0;m<f.length;m++){p[a]=m;let g=Yc({inputs:{x:o},backend:n,attrs:{begin:p,size:h}}),b=fe({inputs:{x:g},backend:n,attrs:{shape:l}});f[m]=b,d.push(g)}return d.forEach(m=>n.disposeIntermediateTensorInfo(m)),f}var Dae={kernelName:Ti,backendName:"webgl",kernelFunc:Fae},Rae=class{constructor(e,t){this.variableNames=["x","segmentIds"];let n=e.windowSize,r=e.batchSize,s=e.inSize,a=e.numSegments,o=a*Math.ceil(s/n);this.outputShape=[r,o];let i="0.0",u="sumValue",l=Math.floor(n/4)*4,c=n%4,d=`
        sumValue += dot(values, segFilter);
    `,p="";s%n>0&&(p=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return initializationValue;
        }
      `);let h="";s%n>0&&(h=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${i};

      float getValue(int batch, int inIdx) {
        ${p}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${h}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${a})) * float(${n}));
        int currentSeg = int(mod(float(outIdx), float(${a})));

        float sumValue = 0.0;

        for (int i = 0; i < ${l}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${d}
        }

        int inIdx = inOffset + ${l};
        if (${c===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${d}
        } else if (${c===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${d}
        } else if (${c===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${d}
        }
        setOutput(${u});
      }
    `}};function Pae(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,segmentIds:a}=t,{numSegments:o}=r,i=s.shape.length,u=[],l=0,c=N.getAxesPermutation([l],i),d=s;c!=null&&(d=Dn({inputs:{x:s},backend:n,attrs:{perm:c}}),u.push(d),l=N.getInnerMostAxes(1,i)[0]);let p=N.segment_util.computeOutShape(d.shape,l,o),h=w.sizeFromShape([d.shape[l]]),f=fe({inputs:{x:d},backend:n,attrs:{shape:[-1,h]}});u.push(f);let m=bd(s.dtype),g=(x,k,T,C,E)=>{let F=x.shape[0],O=x.shape[1],D=N.segment_util.segOpComputeOptimalWindowSize(O,E),R={windowSize:D,inSize:O,batchSize:F,numSegments:E},_=new Rae(R,k),L=n.compileAndRun(_,[x,T],C);if(u.push(L),L.shape[1]===E)return L;let U=oE({backend:n,attrs:{start:0,stop:E,step:1,dtype:"float32"}}),j=dE({inputs:{x:U},backend:n,attrs:{reps:[O/D]}});return u.push(U),u.push(j),g(L,k,j,C,E)},b=g(f,"unsortedSegmentSum",a,m,o),y=fe({inputs:{x:b},backend:n,attrs:{shape:p}}),v=y;if(c!=null){u.push(y);let x=N.getUndoAxesPermutation(c);v=Dn({inputs:{x:v},backend:n,attrs:{perm:x}})}return u.forEach(x=>n.disposeIntermediateTensorInfo(x)),v}var Oae={kernelName:ud,backendName:"webgl",kernelFunc:Pae},Mae=[dne,fne,XQ,QQ,eZ,rZ,aZ,uZ,lZ,pZ,gZ,yZ,wZ,SZ,$Z,NZ,RZ,LZ,OZ,VZ,GZ,jZ,YZ,rJ,aJ,iJ,hJ,mJ,vJ,kJ,AQ,NJ,MJ,BJ,$J,UJ,HJ,WJ,KJ,QJ,eee,nee,see,iee,hee,mee,cee,yee,wee,Iee,Nee,$ee,Pee,Lee,Bee,zee,Vee,Gee,jee,Kee,Yee,ete,rte,ote,ute,dte,fte,yte,kte,EQ,Ste,CJ,Nte,Ate,Dte,FQ,Mte,Wte,Ute,Yte,qte,ene,rne,ine,gne,Sne,kne,_ne,Ane,Fne,xne,Rne,One,zne,Gne,Kne,nre,MQ,sre,ire,lre,hre,cJ,gre,yre,xre,Ire,Nre,RQ,Ere,Are,lJ,Zne,Dre,Wre,Mre,BQ,Hre,Kre,Zre,tse,ase,ise,lse,hse,mse,yse,wse,Ise,Tse,Ese,Fse,tJ,ere,Pse,Mse,Bse,Wse,Use,Hse,qse,Xse,Qse,eae,nae,sae,iae,cae,dae,hae,Jne,jQ,gae,vae,kae,Tae,Eae,qQ,$ae,Dae,Oae,bre];for(let e of Mae)mc(e);var vs=X();vs.registerFlag("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE",()=>15);vs.registerFlag("WEBGPU_CPU_FORWARD",()=>!0);vs.registerFlag("WEBGPU_MATMUL_WORK_PER_THREAD",()=>4);vs.registerFlag("WEBGPU_USE_NAIVE_CONV2D",()=>!1);vs.registerFlag("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE",()=>!1);vs.registerFlag("WEBGPU_CONV_SEPARATE_IM2COL_SHADER",()=>!1);vs.registerFlag("WEBGPU_USE_LOW_POWER_GPU",()=>!1);vs.registerFlag("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e3);vs.registerFlag("WEBGPU_USE_PROFILE_TOOL",()=>!1);vs.registerFlag("WEBGPU_USE_IMPORT",()=>!1);function Lae(e,t){if(Math.max(...e)>3)throw new Error("Cannot symbolically compute strides for rank > 4 tensor.");let n=e.length,r=e.map(a=>`${t}[${a}]`),s=new Array(n-1);s[n-2]=r[n-1];for(let a=n-3;a>=0;--a)s[a]=`(${s[a+1]} * ${r[a+1]})`;return s}function on(e){if(e<=1)return"i32";if(e===2)return"vec2<i32>";if(e===3)return"vec3<i32>";if(e===4)return"vec4<i32>";throw Error(`GPU for rank ${e} is not yet supported`)}function Bm(e,t){return e==="float32"?t?"vec4<f32>":"f32":e==="int32"||e==="bool"?t?"vec4<i32>":"i32":e}function zm(){return`
  [[stage(compute), workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)]]
`}function hk(){return`
  ${zm()}
  fn main([[builtin(local_invocation_id)]] localId : vec3<u32>,
          [[builtin(global_invocation_id)]] globalId : vec3<u32>,
          [[builtin(num_workgroups)]] numWorkgroups: vec3<u32>)
`}function Jc(){return`
  ${zm()}
  fn main([[builtin(local_invocation_id)]] localId : vec3<u32>,
          [[builtin(global_invocation_id)]] globalId : vec3<u32>)
`}function Ue(){return`
    ${hk()} {
      let index = getGlobalIndex(globalId, localId, numWorkgroups);
`}function Bae(e,t,n,r=!1){let s=`
    let workGroupSizeX = ${n.workGroupSize[0]}u;
    let workGroupSizeY = ${n.workGroupSize[1]}u;
    let workGroupSizeZ = ${n.workGroupSize[2]}u;`;if(r===!0){let h=mE(t.shape),f=`
      [[block]] struct Matrix0 {
        numbers: array<${Bm(t.dtype,n.isVec4)}>;
      };
      [[block]] struct Uniform {
        size            : i32;
        numChannels     : i32;
        outShapeStrides : vec2<i32>;
        dispatchSize    : vec3<u32>;
      };

      [[group(0), binding(0)]] var<storage, write> result : Matrix0;
      [[group(0), binding(2)]] var<uniform> uniforms: Uniform;
    `;return[hE,f,s,fE,h,n.getUserCode()].join(`
`)}let a=[],o="[[block]] struct Uniforms { NAN : f32; ";n.variableNames.forEach((h,f)=>{o+=`${h.charAt(0).toLowerCase()+h.slice(1)}Shape : ${on(e[f].shape.length)}; `}),o+=`outShape : ${on(t.shape.length)} ; `;let i=t.shape.length-1;o+=`
       outShapeStrides: ${on(i)}; `,n.size&&(o+="size : i32; "),n.uniforms&&(o+=n.uniforms),o+="};",a.push(o),n.atomic?a.push(`
    [[block]] struct Matrix0 {
        numbers: array<atomic<i32>>;
    };

    [[group(0), binding(0)]] var<storage, read_write> result : Matrix0;
  `):a.push(`
    [[block]] struct Matrix0 {
        numbers: array<${Bm(t.dtype,n.isVec4)}>;
    };

    [[group(0), binding(0)]] var<storage, write> result : Matrix0;
  `),n.variableNames.forEach((h,f)=>{a.push(`
    [[block]] struct Matrix${1+f} {
      numbers: array<${Bm(e[f].dtype,n.isVec4)}>;
    };
    [[group(0), binding(${1+f})]] var<storage, read> ${h} : Matrix${1+f};
    `)}),o!==""&&a.push(`
    [[group(0), binding(${1+n.variableNames.length})]] var<uniform> uniforms : Uniforms;
    `),a.push(s);let[u,l]=Hae(t.shape,n.dispatchLayout),c=mE(t.shape),d=[hE,a.join(`
`),fE,c,u,zae(t.shape.length)];if(n.atomic||d.push(Wae(t.shape,t.dtype,n.isVec4)),l===t.shape.length){let h=e.map(f=>Vae(f,t.shape,n.isVec4,n.dispatchLayout.x.length===t.shape.length)).join(`
`);d.push(h)}return d.push(n.getUserCode()),d.join(`
`)}var hE=`
  fn idiv(a: i32, b: i32, sign: f32) -> i32 {
    var res: i32 = a / b;
    let mod: i32 = a % b;
    if (sign < 0. && mod != 0) {
      res = res - 1;
    }
    return res;
  }

  fn isNanCustom(val : f32) -> bool {
    if (val > 0.0) {
      return false;
    }
    if (val < 0.0) {
      return false;
    }
    if (val == 0.0) {
      return false;
    }
    return true;
  }

  fn isNanCustomVec4F32(val : vec4<f32>) -> vec4<f32> {
    var res = vec4<f32> (0.0);
    for (var i = 0u; i < 4u; i = i + 1u) {
      if (isNanCustom(val[i])) {
        res[i] = 1.0;
      } else {
        res[i] = 0.0;
      }
    }
    return res;
  }

  // Checks whether coordinates lie within the bounds of the shape.
  fn coordsInBounds4D(coord : vec4<i32>, shape : vec4<i32>) -> bool {
    return all(coord >= vec4<i32>(0)) &&
        all(coord < shape);
  }

  fn coordsInBounds3D(coord : vec3<i32>, shape : vec3<i32>) -> bool {
    return all(coord >= vec3<i32>(0)) &&
        all(coord < shape);
  }

  fn coordsInBounds2D(coord : vec2<i32>, shape : vec2<i32>) -> bool {
    return all(coord >= vec2<i32>(0)) &&
        all(coord < shape);
  }
  `,fE=`
  fn getFlatIndex1D(coord : i32, shape : i32) -> i32 {
    return coord;
  }

  fn getFlatIndex2D(coords : vec2<i32>, shape : vec2<i32>) -> i32 {
    return dot(coords, vec2<i32>(shape.y, 1));
  }

  fn getFlatIndex3D(coords : vec3<i32>, shape : vec3<i32>) -> i32 {
    return dot(coords, vec3<i32>(shape.y * shape.z, shape.z, 1));
  }

  fn getFlatIndex4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
    return dot(coords, vec4<i32>(
        shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
  }

  // Only used when the y/z dimension of workgroup size is 1.
  fn getGlobalIndex(globalId : vec3<u32>, localId : vec3<u32>, numWorkgroups: vec3<u32>) -> i32 {
    if (numWorkgroups.y == 1u && numWorkgroups.z == 1u) {
      return i32(globalId.x);
    }

    let localInvocationIndex = localId.z * workGroupSizeX * workGroupSizeY +
        localId.y * workGroupSizeX + localId.x;
    let workGroupID = (globalId - localId)/vec3<u32>(
        workGroupSizeX, workGroupSizeY, workGroupSizeZ);

    return i32((workGroupID.z * numWorkgroups.x * numWorkgroups.y +
      workGroupID.y * numWorkgroups.x + workGroupID.x) *
      (workGroupSizeX * workGroupSizeY * workGroupSizeZ) +
      localInvocationIndex);
  }
`;function zae(e){let t="";switch(e){case 0:case 1:t+=`
        fn getOutputFlatIndex(coords : i32) -> i32 {
          return coords;
        }
        `;break;case 2:t+=`
        fn getOutputFlatIndex(coords : vec2<i32>) -> i32 {
          return dot(coords, vec2<i32>(uniforms.outShapeStrides, 1));
        }
        `;break;case 3:t+=`
        fn getOutputFlatIndex(coords : vec3<i32>) -> i32 {
          return dot(coords, vec3<i32>(uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, 1));
        }
        `;break;case 4:t+=`
        fn getOutputFlatIndex(coords : vec4<i32>) -> i32 {
          return dot(coords, vec4<i32>(
            uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, uniforms.outShapeStrides.z, 1));
        }
        `;break;default:w.assert(!1,()=>`Unsupported ${e}D shape`);break}return t}function Wae(e,t,n){let r=e.length,s=Bm(t,n),a;if(n?a=`fn setOutputFlat(flatIndex : i32, value : vec4<f32>) {
      result.numbers[flatIndex] = ${s}(value);
    }
    fn setOutputFlatI32(flatIndex : i32, value : vec4<i32>) {
      result.numbers[flatIndex] = ${s}(value);
    }`:a=`fn setOutputFlat(flatIndex : i32, value : f32) {
      result.numbers[flatIndex] = ${s}(value);
    }
    fn setOutputFlatI32(flatIndex : i32, value : i32) {
      result.numbers[flatIndex] = ${s}(value);
    }`,r>=2){let o=["d0","d1","d2","d3"].slice(0,r),i=on(r);n?a+=`
      fn setOutput(${o.map(u=>`${u} : i32`).join(", ")}, value : vec4<f32>) {
        let flatIndex = getOutputFlatIndex(${i}(${o.join(", ")}));
        setOutputFlat(flatIndex / 4, value);
      }
      fn setOutputI32(${o.map(u=>`${u} : i32`).join(", ")}, value : vec4<i32>) {
        let flatIndex = getOutputFlatIndex(${i}(${o.join(", ")}));
        setOutputFlatI32(flatIndex / 4, value);
      }
    `:a+=`
      fn setOutput(${o.map(u=>`${u} : i32`).join(", ")}, value : f32) {
        let flatIndex = getOutputFlatIndex(${i}(${o.join(", ")}));
        setOutputFlat(flatIndex, value);
      }
      fn setOutputI32(${o.map(u=>`${u} : i32`).join(", ")}, value : i32) {
        let flatIndex = getOutputFlatIndex(${i}(${o.join(", ")}));
        setOutputFlatI32(flatIndex, value);
      }
    `}return a}function Vae(e,t,n,r){let s=Uae(e,n);return e.shape.length<=t.length&&(s+=Gae(e,t,n,r)),s}function Uae(e,t){let n=e.name,r=e.shape.length,s=on(r),a="get"+n.charAt(0).toUpperCase()+n.slice(1),o=["d0","d1","d2","d3"].slice(0,r),i=o.map(c=>`${c} : i32`).join(", ");if(r<1)return t?`
        fn ${a}() -> vec4<f32> {
          return vec4<f32>(${n}.numbers[0]);
        }
      `:`
      fn ${a}() ->f32 {
        return f32(${n}.numbers[0]);
      }
    `;let u=`uniforms.${n.charAt(0).toLowerCase()+n.slice(1)}Shape`,l=`${r}D`;return r===0&&(l="1D"),t?`
      fn ${a}(${i}) -> vec4<f32> {
        return vec4<f32>(${n}.numbers[getFlatIndex${l}(${s}(${o.join(",")}),
          ${u}) / 4]);
      }
      `:`
    fn ${a}(${i}) -> f32 {
      return f32(${n}.numbers[getFlatIndex${l}(${s}(${o.join(",")}),
        ${u})]);
    }
   `}function Gae(e,t,n,r){let s=e.name,a=s.charAt(0).toUpperCase()+s.slice(1),o="get"+a+"AtOutCoords",i=e.shape.length,u=t.length,l=on(u);if(w.arraysEqual(e.shape,t)&&r)return n?`
        fn ${o}ByGlobalIndex(globalIndex : i32) -> vec4<f32> {
          return vec4<f32>(${s}.numbers[globalIndex]);
        }

        fn ${o}ByCoords(coords : ${l}) -> vec4<f32> {
          return vec4<f32>(${s}.numbers[${u>1?"getOutputFlatIndex(coords)":"coords"} / 4]);
        }
        `:`
      fn ${o}ByGlobalIndex(globalIndex : i32) -> f32 {
        return f32(${s}.numbers[globalIndex]);
      }

      fn ${o}ByCoords(coords : ${l}) -> f32 {
        return f32(${s}.numbers[${u>1?"getOutputFlatIndex(coords)":"coords"}]);
      }
      `;let c=N.getBroadcastDims(e.shape,t),d=u-i,p="";if(i===0)return n?`
      fn ${o}ByGlobalIndex(globalIndex : i32) -> vec4<f32> {
        return get${a}();
      }

      fn ${o}ByCoords(coords : ${l}) -> vec4<f32> {
        return get${a}();
      }
    `:`
      fn ${o}ByGlobalIndex(globalIndex : i32) -> f32{
        return get${a}();
      }

      fn ${o}ByCoords(coords : ${l}) -> f32{
        return get${a}();
      }
    `;u<2&&c.length>=1?p="coords = 0;":p=c.map(g=>`coords[${g+d}] = 0;`).join(`
`);let h="";if(u<2&&i>0)h="coords";else if(u>1){let g=on(i),b=e.shape.map((y,v)=>`coords[${v+d}]`).join(", ");h=`${g}(${b})`}else h="coords";let f=`uniforms.${s.charAt(0).toLowerCase()+s.slice(1)}Shape`,m=`${i}D`;return n?`
      fn ${o}ByGlobalIndex(globalIndex : i32) -> vec4<f32> {
        var coords = getCoordsFromFlatIndex(globalIndex);
        ${p}
        return ${s}.numbers[getFlatIndex${m}(${h}, ${f}) / 4];
      }

      fn ${o}ByCoords(coordsIn : ${l}) -> vec4<f32> {
        var coords = coordsIn;
        ${p}
        return ${s}.numbers[getFlatIndex${m}(${h}, ${f}) / 4];
      }
    `:`
    fn ${o}ByGlobalIndex(globalIndex : i32) -> f32 {
      var coords = getCoordsFromFlatIndex(globalIndex);
      ${p}
      return f32(${s}.numbers[getFlatIndex${m}(${h}, ${f})]);
    }

    fn ${o}ByCoords(coordsIn : ${l}) -> f32 {
      var coords = coordsIn;
      ${p}
      return f32(${s}.numbers[getFlatIndex${m}(${h}, ${f})]);
    }
  `}function Hae(e,t){let{x:n,y:r=[],z:s=[]}=t,a=e.length;if(n.length===a)return[`fn getOutputCoordsWithFlatDispatchLayout(globalId : vec3<u32>, localId : vec3<u32>, numWorkgroups: vec3<u32>) -> ${on(a)}{
      let globalIndex = getGlobalIndex(globalId, localId, numWorkgroups);
      return getCoordsFromFlatIndex(globalIndex);
    }
    `,a];let o="",i=[n,r,s],u=0;for(let p=0;p<i.length;p++){let h=i[p];if(h.length!==0)if(u+=h.length,h.length===1)o+=`let d${h[0]} = i32(globalId[${p}]);`;else{let f=Lae(h,"uniforms.outShape");o+=`var index${p} = i32(globalId[${p}]);`;for(let m=0;m<f.length;m++)o+=`let d${h[m]} = index${p} / ${f[m]};`,m===f.length-1?o+=`let d${h[m+1]} = index${p} - d${h[m]} * ${f[m]};`:o+=`index${p} = index${p} - d${h[m]} * ${f[m]};`}}let l=[];for(let p=0;p<u;p++)l.push(`d${p}`);let c=on(u),d=`fn getOutputCoordsWithNonFlatDispatchLayout(globalId : vec3<u32>) -> ${c} {
    ${o}
  `;return l.length===0?d+=`return ${c}(0); }`:d+=`return ${c}(${l.join(",")}); }`,[d,u]}function mE(e){let t=e.length;if(t<=1)return"fn getCoordsFromFlatIndex(index : i32) -> i32 { return index; }";let n=w.computeStrides(e),r=on(t),s=[];for(let o=0;o<t;o++)s.push(`d${o}`);if(n.length===1)return`    fn getCoordsFromFlatIndex(index : i32) -> vec2<i32> {
      let d0 = index / uniforms.outShapeStrides; let d1 = index - d0 * uniforms.outShapeStrides;
      return vec2<i32>(d0, d1);
    }`;let a="var index2 = index;"+n.map((o,i)=>{let u=`let ${s[i]} = index2 / uniforms.outShapeStrides[${i}]`,l=i===n.length-1?`let ${s[i+1]} = index2 - ${s[i]} * uniforms.outShapeStrides[${i}]`:`index2 = index2 - ${s[i]} * uniforms.outShapeStrides[${i}]`;return`${u}; ${l};`}).join("");return`
    fn getCoordsFromFlatIndex(index : i32) -> ${r} {
      ${a}
      return ${r}(${s.join(",")});
    }
  `}var gE={};Ee(gE,{ArrayBufferToTypedArray:()=>bE,GPUBytesPerElement:()=>bk,computeDispatch:()=>_e,computeWorkGroupSizeForConv2d:()=>fk,computeWorkGroupSizeForMatMul:()=>mk,computeWorkPerThreadForConv2d:()=>gk,flatDispatchLayout:()=>ze,isWebGPUSupported:()=>yk,tilesFitEvenlyIntoShape:()=>Us});var el=65535,uu=e=>{let t=1;for(let n=0;n<e.length;n++)t*=e[n];return t};function Us(e,t){if(e.length!==t.length)throw new Error(`Cannot compute whether rank ${e.length} tiles fit evenly into rank ${t.length} shape - ranks must match.`);return t.every((n,r)=>n%e[r]==0)}function _e(e,t,n=[1,1,1],r=[1,1,1]){let[s,a,o]=[Math.ceil(uu(e.x.map(u=>t[u]))/(n[0]*r[0])),e.y?Math.ceil(uu(e.y.map(u=>t[u]))/(n[1]*r[1])):1,e.z?Math.ceil(uu(e.z.map(u=>t[u]))/(n[2]*r[2])):1];if(s<=el&&a<=el&&o<=el)return[s,a,o];w.assert(s>el&&e.y===void 0&&e.z===void 0,()=>"Dispatch size exceeds WebGPU limits in Y or Z dimension.");let i=Math.ceil(Math.sqrt(s));return i>el?(i=Math.ceil(Math.cbrt(s)),w.assert(i<=el,()=>"Total dispatch size exceeds WebGPU maximum."),[i,i,i]):[i,i,1]}function fk(e,t){let n=uu(e.x.map(s=>t[s])),r=uu(e.y.map(s=>t[s]));return n<=4?[4,16,1]:r<=4?[16,4,1]:[16,16,1]}function mk(e,t,n){return e===1?[32,1,1]:n===1?[1,32,1]:[8,8,1]}function gk(e,t){let n=uu(e.x.map(s=>t[s])),r=uu(e.y.map(s=>t[s]));return n<=4?[1,2,1]:r<=4?[2,1,1]:[2,2,1]}function ze(e){return{x:e.map((t,n)=>n)}}function bk(e){if(e==="float32"||e==="int32"||e==="bool"||e==="string")return 4;if(e==="complex64")return 8;throw new Error(`Unknown dtype ${e}`)}function bE(e,t){if(t==="float32")return new Float32Array(e);if(t==="int32")return new Int32Array(e);if(t==="bool"||t==="string"){let n=new Int32Array(e),r=new ArrayBuffer(n.length),s=new Uint8Array(r);for(let a=0;a<n.length;a++)s[a]=n[a];return s}else throw new Error(`Unknown dtype ${t}`)}function yk(){return!!navigator.gpu}var Mt;(function(e){e[e.MUL=0]="MUL",e[e.ADD=1]="ADD",e[e.SUB=2]="SUB",e[e.DIV=3]="DIV",e[e.EQUAL=4]="EQUAL",e[e.GREATER=5]="GREATER",e[e.GREATER_EQUAL=6]="GREATER_EQUAL",e[e.LESS=7]="LESS",e[e.LESS_EQUAL=8]="LESS_EQUAL",e[e.LOGICAL_AND=9]="LOGICAL_AND",e[e.NOT_EQUAL=10]="NOT_EQUAL",e[e.SQUARED_DIFFERENCE=11]="SQUARED_DIFFERENCE",e[e.INT_DIV=12]="INT_DIV",e[e.POW=13]="POW",e[e.PRELU=14]="PRELU",e[e.MAX=15]="MAX",e[e.MIN=16]="MIN",e[e.COMPLEX_MULTIPLY_REAL=17]="COMPLEX_MULTIPLY_REAL",e[e.COMPLEX_MULTIPLY_IMAG=18]="COMPLEX_MULTIPLY_IMAG"})(Mt||(Mt={}));var jae="return a + b;",qae="return areal * breal - aimag * bimag;",Kae="return areal * bimag + aimag * breal;",Xae="return a / b;",Yae="return a * b;",Qae="return (a - b) * (a - b);",Zae="return a - b;",Jae="return f32(a == b);",eoe="return vec4<f32>(a == b);",toe="return f32(a > b);",noe="return vec4<f32>(a > b);",roe="return f32(a >= b);",soe="return vec4<f32>(a >= b);",aoe="return f32(a < b);",ooe="return vec4<f32>(a < b);",ioe="return f32(a <= b);",uoe="return vec4<f32>(a <= b);",coe="return f32(f32(a) >= 1.0 && f32(b) >= 1.0);",loe=`return (vec4<f32>(a >= vec4<f32>(1.0)) *
  vec4<f32>(b >= vec4<f32>(1.0)));`,doe=`
  if (isNanCustom(a)) { return a; }
  if (isNanCustom(b)) { return b; }
  `,yE=`
  if (isNaN.r > 0.) {
    resultTemp.r = uniforms.NAN;
  }
  if (isNaN.g > 0.) {
    resultTemp.g = uniforms.NAN;
  }
  if (isNaN.b > 0.) {
    resultTemp.b = uniforms.NAN;
  }
  if (isNaN.a > 0.) {
    resultTemp.a = uniforms.NAN;
  }
  `,poe=`
  let s = sign(a) * sign(b);
  let ia = i32(round(a));
  let ib = i32(round(b));
  return f32(idiv(ia, ib, s));
  `,hoe=`
  let ia = vec4<i32>(round(a));
  let ib = vec4<i32>(round(b));
  let cond = ib != vec4<i32>(0);
  var resultTemp = vec4<i32>(0);
  let s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    resultTemp[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    resultTemp[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    resultTemp[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    resultTemp[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4<f32>(resultTemp);
  `,foe="return f32(a != b);",moe="return vec4<f32>(a != b);",goe=`
  if(a < 0.0 && floor(b) < b) {
    return uniforms.NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  if (round(abs(b) % 2.0) != 1.0) {
    return pow(abs(a), b);
  }
  return sign(a) * pow(abs(a), b);
  `,boe=`
  let isModRound1Bool = vec4<i32>(round(abs(b) % vec4<f32>(2.0))) == vec4<i32>(1);
  let isModRound1 = vec4<f32>(isModRound1Bool);
  let multiplier = sign(a) * isModRound1 + (vec4<f32>(1.0) - isModRound1);
  var resultTemp = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  let isExpZero = b == vec4<f32>(0.0);
  if (isExpZero.r) {
    resultTemp.r = 1.0;
  }
  if (isExpZero.g) {
    resultTemp.g = 1.0;
  }
  if (isExpZero.b) {
    resultTemp.b = 1.0;
  }
  if (isExpZero.a) {
    resultTemp.a = 1.0;
  }
  let isNaN = vec4<f32>(a < vec4<f32>(0.0)) * vec4<f32>(floor(b) < b);
  ${yE}
  return resultTemp;
  `,yoe="if (a < 0.0) { return b * a; }  return a;",voe=`
  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));
  return (aLessThanZero * (b * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);
  `;function vE(e,t){let n=t?yE:doe;return t?`
    var resultTemp = vec4<f32>(${e}(a, b));
    let isNaN = min(vec4<f32>(isNanCustomVec4F32(a)) + vec4<f32>(isNanCustomVec4F32(b)), vec4<f32>(1.0));
    `+n+`
    return resultTemp;
  `:n+`
    return ${e}(a, b);
  `}function pp(e,t){switch(e){case 0:return Yae;case 1:return jae;case 2:return Zae;case 3:return Xae;case 4:return t?eoe:Jae;case 5:return t?noe:toe;case 6:return t?soe:roe;case 7:return t?ooe:aoe;case 8:return t?uoe:ioe;case 9:return t?loe:coe;case 10:return t?moe:foe;case 11:return Qae;case 12:return t?hoe:poe;case 14:return t?voe:yoe;case 15:return vE("max",t);case 16:return vE("min",t);case 13:return t?boe:goe;case 17:return qae;case 18:return Kae;default:throw new Error(`BinaryType ${e} is not implemented!`)}}var bt;(function(e){e[e.ABS=0]="ABS",e[e.CEIL=1]="CEIL",e[e.COS=2]="COS",e[e.COSH=3]="COSH",e[e.ELU=4]="ELU",e[e.EXP=5]="EXP",e[e.EXPM1=6]="EXPM1",e[e.FLOOR=7]="FLOOR",e[e.LINEAR=8]="LINEAR",e[e.LOG=9]="LOG",e[e.LOGICAL_NOT=10]="LOGICAL_NOT",e[e.NEG=11]="NEG",e[e.PRELU=12]="PRELU",e[e.RELU=13]="RELU",e[e.RELU6=14]="RELU6",e[e.RSQRT=15]="RSQRT",e[e.SIN=16]="SIN",e[e.SINH=17]="SINH",e[e.SIGMOID=18]="SIGMOID",e[e.SQRT=19]="SQRT",e[e.SQUARE=20]="SQUARE",e[e.TANH=21]="TANH",e[e.TO_INT=22]="TO_INT"})(bt||(bt={}));var xoe="return abs(a);",woe="return ceil(a);",koe="return cos(a);",Ioe=`
  let e2x = exp(-a);
  return (e2x + 1.0 / e2x) / 2.0;
`,Soe="return exp(a) - 1.0;",Coe="if (a >= 0.0) { return a; }  return (exp(a) - 1.0);",Toe=`
  var resFloat = exp(a) - vec4<f32>(1.0);
  if (a.r >= 0.0) {
    resFloat.r = a.r;
  }
  if (a.g >= 0.0) {
    resFloat.g = a.g;
  }
  if (a.b >= 0.0) {
    resFloat.b = a.b;
  }
  if (a.a >= 0.0) {
    resFloat.a = a.a;
  }
  return resFloat;
`,Noe="return exp(a);",_oe="return floor(a);",Eoe="return a;",Aoe=`if (a < 0.0) { return 1.0/0.0; }
  return log(a);`,$oe="return f32(!(a >= 1.0));",Foe="return -a;",Doe="return (a < 0.0) ? b * a : a;",Roe="return max(a, 0.0);",Poe="return clamp(a, 0.0, 6.0);",Ooe="return clamp(a, vec4<f32>(0.0, 0.0, 0.0, 0.0), vec4<f32>(6.0, 6.0, 6.0, 6.0));",Moe=`
  var resFloat = a * vec4<f32>(a >= vec4<f32>(0.0));
  let isNaN = isNan(a);

  if (isNaN.r) {
    resFloat.r = a.r;
  }
  if (isNaN.g) {
    resFloat.g = a.g;
  }
  if (isNaN.b) {
    resFloat.b = a.b;
  }
  if (isNaN.a) {
    resFloat.a = a.a;
  }
  return resFloat;
`,Loe="return 1.0/sqrt(a);",Boe="return 1.0 / (1.0 + exp(-1.0 * a));",zoe="return sin(a);",Woe=`
  let e2x = exp(a);
  return (e2x - 1.0 / e2x) / 2.0;
`,Voe="return sqrt(a);",Uoe="return a * a;",Goe=`
  let e2x = exp(-2.0 * abs(a));
  return sign(a) * (1.0 - e2x) / (1.0 + e2x);
`,Hoe="return f32(i32((a)));";function tl(e,t){switch(e){case 0:return xoe;case 2:return koe;case 3:return Ioe;case 1:return woe;case 4:return t?Toe:Coe;case 5:return Noe;case 6:return Soe;case 7:return _oe;case 8:return Eoe;case 9:return Aoe;case 10:return $oe;case 11:return Foe;case 12:return Doe;case 13:return t?Moe:Roe;case 14:return t?Ooe:Poe;case 15:return Loe;case 18:return Boe;case 16:return zoe;case 17:return Woe;case 19:return Voe;case 20:return Uoe;case 21:return Goe;case 22:return Hoe;default:throw new Error(`BinaryType ${e} is not implemented!`)}}function Gs(e,t=!1){if(e===null)return null;if(e==="linear")return tl(bt.LINEAR);if(e==="relu")return tl(bt.RELU,t);if(e==="elu")return tl(bt.ELU,t);if(e==="relu6")return tl(bt.RELU6,t);if(e==="prelu")return pp(Mt.PRELU,t);if(e==="sigmoid")return tl(bt.SIGMOID);throw new Error(`Activation ${e} has not been implemented for the WebGPU backend.`)}function xE(e,t){let n={RowPerThread:e[1],ColPerThread:e[0],TileAOuter:t[1]*e[1],TileBOuter:t[0]*e[0],TileInner:t[0]*e[0]};return`
  var<workgroup> mm_Asub : array<array<vec4<f32>, ${n.TileInner/n.ColPerThread}>, ${n.TileAOuter}>;
  var<workgroup> mm_Bsub : array<array<vec4<f32>, ${n.TileBOuter/n.ColPerThread}>, ${n.TileInner}>;

  let RowPerThread = ${n.RowPerThread};
  let ColPerThread = ${n.ColPerThread}; // only support ColPerThread = 4
  let TileAOuter = ${n.TileAOuter};
  let TileBOuter = ${n.TileBOuter};
  let TileInner = ${n.TileInner};

  ${Jc()} {

    let tileRow = i32(localId.y) * RowPerThread;
    let tileCol = i32(localId.x);

    let globalRow = i32(globalId.y) * RowPerThread;
    let globalCol = i32(globalId.x);
    let numTiles = (uniforms.dimInner - 1) / TileInner + 1;

    var acc: array<vec4<f32>, ${n.RowPerThread}>;
    var ACached : vec4<f32>;
    var BCached : array<vec4<f32>, 4>;

    // Loop over shared dimension.
    var globalColA = tileCol;
    let RowPerThreadB = TileInner / ${t[1]};
    let tileRowB = i32(localId.y) * RowPerThreadB;
    for (var t = 0; t < numTiles; t = t + 1) {
        // Load one tile of A into local memory.
        for (var innerRow = 0; innerRow < RowPerThread; innerRow = innerRow + 1) {
            let inputRow = tileRow + innerRow;
            let inputCol = tileCol;
            mm_Asub[inputRow][inputCol] = mm_readA(globalRow + innerRow, globalColA, globalId);
        }
        globalColA = globalColA + TileInner / ColPerThread;

        // Load one tile of B into local memory.
        for (var innerRow = 0; innerRow < RowPerThreadB; innerRow = innerRow + 1) {
            let inputRow = tileRowB + innerRow;
            let inputCol = tileCol;
            mm_Bsub[inputRow][inputCol] = mm_readB(t * TileInner + inputRow, globalCol, globalId);
        }

        workgroupBarrier();

        // Compute acc values for a single thread.
        for (var k = 0; k < TileInner / ColPerThread; k = k + 1) {
            BCached[0] = mm_Bsub[k * ColPerThread][tileCol];
            BCached[1] = mm_Bsub[k * ColPerThread + 1][tileCol];
            BCached[2] = mm_Bsub[k * ColPerThread + 2][tileCol];
            BCached[3] = mm_Bsub[k * ColPerThread + 3][tileCol];

            for (var i = 0; i < RowPerThread; i = i + 1) {
                ACached = mm_Asub[tileRow + i][k];
                acc[i] = BCached[0] * ACached.x + acc[i];
                acc[i] = BCached[1] * ACached.y + acc[i];
                acc[i] = BCached[2] * ACached.z + acc[i];
                acc[i] = BCached[3] * ACached.w + acc[i];
            }
        }

        workgroupBarrier();
    }

    for (var innerRow = 0; innerRow < RowPerThread; innerRow = innerRow + 1) {
        mm_write(globalRow + innerRow,
                 globalCol,
                 acc[innerRow], globalId);
    }
}`}function joe(e){return`
  var<workgroup> mm_Asub : array<vec4<f32>, ${e[0]}>;
  let tileSize = ${e[0]*4};
  ${Jc()} {
    let tileCol = i32(localId.x);
    let globalCol = i32(globalId.x);
    let globalRow = i32(globalId.y);

    let numTiles = (uniforms.dimInner - 1) / tileSize + 1;

    // Without this initialization strange values show up in acc.
    var acc = vec4<f32>(0.0);

    // Loop over shared dimension.
    for (var t = 0; t < numTiles; t = t + 1) {
      // Load one tile of A into local memory.
      let colA = t * tileSize / 4 + tileCol;
      mm_Asub[tileCol] = mm_readA(globalRow, colA, globalId);

      workgroupBarrier();

      // Compute acc values for a single thread.
      for (var k = 0; k < tileSize / 4; k = k + 1) {
        let rowB = t * tileSize + k * 4;
        let BCached0 = mm_readB(rowB, globalCol, globalId);
        let BCached1 = mm_readB(rowB + 1, globalCol, globalId);
        let BCached2 = mm_readB(rowB + 2, globalCol, globalId);
        let BCached3 = mm_readB(rowB + 3, globalCol, globalId);

        let ACached = mm_Asub[k];
        acc = acc + BCached0 * ACached.x;
        acc = acc + BCached1 * ACached.y;
        acc = acc + BCached2 * ACached.z;
        acc = acc + BCached3 * ACached.w;
      }

      workgroupBarrier();
    }

    if (globalRow < uniforms.dimAOuter && globalCol < uniforms.dimBOuter) {
      mm_write(globalRow, globalCol, acc, globalId);
    }
  }
`}var qoe=class{constructor(e,t,n,r=null,s=null,a=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32; dimBOuter : i32; dimInner : i32;",this.workGroupSize=[16,16,1],this.isVec4=!0,this.vecSize=4,this.outputShape=t,this.workGroupSize=mk(t[1],e[2],t[2]),this.dispatchLayout={x:[2],y:[1],z:[0]},t[1]===1&&(n=1),this.dispatch=_e(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.vecSize,n,1]);let o=r!=null,i=a!=null;o&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),this.workPerThread=n,this.aShape=e,this.addBias=o,this.activation=s,this.hasPreluActivationWeights=i,[this.fitA,this.fitB]=this.getShapeFit(),this.shaderKey=`matMulPackedVec4_${n}_${this.activation}_${this.fitA}_${this.fitB}_${this.outputShape[1]>1}`}getShapeFit(){let e=this.aShape[2],t=this.outputShape[2],n=[this.outputShape[0],e,t],r=this.workGroupSize[1]*this.workPerThread,s=this.workGroupSize[0]*this.vecSize,a=s,o=[r,a],i=[a,s];return[Us(o,this.aShape.slice(1)),Us(i,n.slice(1))]}getUserCode(){let e=this.fitA?"return A.numbers[batch * batchASize + row * uniforms.dimInner / 4 + col]":`if (coordsInBounds2D(vec2<i32>(row, col * 4), vec2<i32>(uniforms.dimAOuter, uniforms.dimInner))) {
            return A.numbers[batch * batchASize + row * uniforms.dimInner / 4 + col];
        }
        return vec4<f32>(0.0)`,t=this.fitB?"return B.numbers[batch * batchBSize + row * uniforms.dimBOuter / 4 + col]":`if(coordsInBounds2D(vec2<i32>(row, col * 4), vec2<i32>(uniforms.dimInner, uniforms.dimBOuter))) {
             return B.numbers[batch * batchBSize + row * uniforms.dimBOuter / 4 + col];
        }
        return vec4<f32>(0.0)`,n="",r="";if(this.activation){let o=Gs(this.activation,this.isVec4);this.hasPreluActivationWeights?n=`fn activation(a : vec4<f32>, outCoord : vec3<i32>) -> vec4<f32> {
                  let b = getPreluActivationWeightsAtOutCoordsByCoords(outCoord);
                  ${o}
                }`:n=`
            fn activation(a : vec4<f32>, outCoord : vec3<i32>) -> vec4<f32> {
              ${o}
            }`,r="value = activation(value, outCoord);"}let s=this.addBias?"value = value + getBiasAtOutCoordsByCoords(outCoord);":"";return`
      ${n}
      fn mm_readA(row : i32, col : i32,  globalId : vec3<u32>) -> vec4<f32> {
        let batchASize = uniforms.aShape[1] * uniforms.aShape[2] / ${this.vecSize};
        let batch = i32(globalId.z);
        ${e};
      }

      fn mm_readB(row : i32, col : i32,  globalId : vec3<u32>) -> vec4<f32> {
        let batchBSize = uniforms.bShape[1] * uniforms.bShape[2] / ${this.vecSize};
        let batch = i32(globalId.z);
        ${t};
      }

      fn mm_write(row : i32, col : i32, valueIn : vec4<f32>, globalId : vec3<u32>) {
        if (row < uniforms.aShape[1] && col * 4 < uniforms.bShape[2])
        {
          var value = valueIn;
          let batch = i32(globalId.z);
          let outCoord = vec3<i32>(batch, row, col * 4);
          ${s}
          ${r}
          setOutput(outCoord[0], outCoord[1], outCoord[2], value);
        }
      }
      ${this.outputShape[1]>1?xE([this.vecSize,this.workPerThread,1],this.workGroupSize):joe(this.workGroupSize)}

    `}};function vk(e,t){let n=t[1]*e[1],r=t[0]*e[0],s=n>r?n:r;return`
    var<workgroup> mm_Asub : array<array<f32, ${s}>, ${n}>;
    var<workgroup> mm_Bsub : array<array<f32, ${r}>, ${s}>;
    ${Jc()} {
      let tileRow = i32(localId.y) * ${e[1]};
      let tileCol = i32(localId.x) * ${e[0]};

      let globalRow = i32(globalId.y) * ${e[1]};
      let globalCol = i32(globalId.x) * ${e[0]};

      let numTiles = (uniforms.dimInner - 1) / ${s} + 1;

      var acc : array<array<f32, ${e[0]}>, ${e[1]}>;
      var ACached : f32;
      var BCached : array<f32, ${e[0]}>;

      // Without this initialization strange values show up in acc.
      for (var innerRow = 0; innerRow < ${e[1]}; innerRow = innerRow + 1) {
        for (var innerCol = 0; innerCol < ${e[0]}; innerCol = innerCol + 1) {
          acc[innerRow][innerCol] = 0.0;
        }
      }

      let ColPerThreadA = ${s} / ${t[0]};
      let tileColA = i32(localId.x) * ColPerThreadA;
      let RowPerThreadB = ${s} / ${t[1]};
      let tileRowB = i32(localId.y) * RowPerThreadB;

      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t = t + 1) {
        // Load one tile of A into local memory.
        for (var innerRow = 0; innerRow < ${e[1]}; innerRow = innerRow + 1) {
          for (var innerCol = 0; innerCol < ColPerThreadA; innerCol = innerCol + 1) {
            let inputRow = tileRow + innerRow;
            let inputCol = tileColA + innerCol;

            mm_Asub[inputRow][inputCol] = mm_readA(
                globalRow + innerRow,
                t * ${s} + inputCol, globalId);
          }
        }
        // Load one tile of B into local memory.
        for (var innerRow = 0; innerRow < RowPerThreadB; innerRow = innerRow + 1) {
          for (var innerCol = 0; innerCol < ${e[0]}; innerCol = innerCol + 1) {
            let inputRow = tileRowB + innerRow;
            let inputCol = tileCol + innerCol;

            mm_Bsub[inputRow][inputCol] = mm_readB(
              t * ${s} + inputRow,
              globalCol + innerCol, globalId);
          }
        }

        workgroupBarrier();

        // Compute acc values for a single thread.
        for (var k = 0; k < ${s}; k = k + 1) {
          for (var inner = 0; inner < ${e[0]}; inner = inner + 1) {
            BCached[inner] = mm_Bsub[k][tileCol + inner];
          }

          for (var innerRow = 0; innerRow < ${e[1]}; innerRow = innerRow + 1) {
            ACached = mm_Asub[tileRow + innerRow][k];
            for (var innerCol = 0; innerCol < ${e[0]}; innerCol = innerCol + 1) {
              acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];
            }
          }
        }

        workgroupBarrier();
      }

      for (var innerRow = 0; innerRow < ${e[1]}; innerRow = innerRow + 1) {
        for (var innerCol = 0; innerCol < ${e[0]}; innerCol = innerCol + 1) {

          if ((globalCol + innerCol) < uniforms.dimBOuter &&
              (globalRow + innerRow) < uniforms.dimAOuter) {
            mm_write(globalRow + innerRow,
                     globalCol + innerCol,
                     acc[innerRow][innerCol], globalId);
          }
        }
      }
    }
  `}function Koe(e){return`
    let TileSize = ${e[0]*4};
    var<workgroup> mm_Asub : array<vec4<f32>, ${e[0]}>;

    ${Jc()} {
      let tileCol = i32(localId.x);
      let globalCol = i32(globalId.x);
      let globalRow = i32(globalId.y);

      let numTiles = (uniforms.dimInner - 1) / TileSize + 1;

      // Without this initialization strange values show up in acc.
      var acc = 0.0;

      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t = t + 1) {
        // Load one tile of A into local memory.
        let colA = t * TileSize + tileCol * 4;
        mm_Asub[tileCol] = vec4<f32>(mm_readA(globalRow, colA, globalId),
                                mm_readA(globalRow, colA + 1, globalId),
                                mm_readA(globalRow, colA + 2, globalId),
                                mm_readA(globalRow, colA + 3, globalId));
        workgroupBarrier();

        // Compute acc values for a single thread.
        for (var k = 0; k < TileSize / 4; k = k + 1) {
          let rowB = t * TileSize + k * 4;
          let BCached = vec4<f32>(mm_readB(rowB, globalCol, globalId),
                              mm_readB(rowB + 1, globalCol, globalId),
                              mm_readB(rowB + 2, globalCol, globalId),
                              mm_readB(rowB + 3, globalCol, globalId));

          let ACached = mm_Asub[k];
          acc = acc + dot(ACached, BCached);
        }

        workgroupBarrier();
      }

      if (globalRow < uniforms.dimAOuter && globalCol < uniforms.dimBOuter) {
        mm_write(globalRow, globalCol, acc, globalId);
      }
    }
  `}var wE=class{constructor(e,t,n,r=!1,s=!1,a=null,o=null,i=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32; dimBOuter : i32; dimInner : i32;",this.workGroupSize=[16,16,1],this.outputShape=t,this.dispatchLayout={x:[2],y:[1],z:[0]};let u=r?e[1]:e[2];this.workGroupSize=mk(t[1],u,t[2]),(t[1]===1||t[2]===1)&&(n=1),this.dispatch=_e(this.dispatchLayout,this.outputShape,this.workGroupSize,[n,n,1]),w.arraysEqual(this.dispatch,[1,1,1])&&(n=1,this.dispatch=_e(this.dispatchLayout,this.outputShape,this.workGroupSize,[n,n,1]));let l=a!=null,c=i!=null;l&&this.variableNames.push("bias"),c&&this.variableNames.push("preluActivationWeights"),this.workPerThread=n,this.aShape=e,this.transposeA=r,this.transposeB=s,this.addBias=l,this.activation=o,this.hasPreluActivationWeights=c;let d=this.outputShape[2],p=this.transposeB?[this.outputShape[0],d,u]:[this.outputShape[0],u,d];[this.fitA,this.fitB]=this.getShapeFit(p),this.shaderKey=`matMulPacked_${this.workPerThread}_${r}_${s}_${this.activation}_${this.fitA}_${this.fitB}_${this.outputShape[1]>1}`}getShapeFit(e){let t=this.workGroupSize[1]*this.workPerThread,n=this.workGroupSize[0]*this.workPerThread,r=t>n?t:n;this.outputShape[1]===1&&(r*=4),w.assert(r%this.workGroupSize[0]==0&&r%this.workGroupSize[1]==0,()=>"tileInner must be multiple of workgroupsize.x and workgroupsize.y");let s=[t,r],a=[r,n];return[Us(s,this.aShape.slice(1)),Us(a,e.slice(1))]}getUserCode(){let e;this.transposeA===!1?e=this.fitA?"return A.numbers[batch * batchASize + row * uniforms.dimInner + col];":`if(coordsInBounds2D(vec2<i32>(row, col), vec2<i32>(uniforms.dimAOuter, uniforms.dimInner))) {
             return A.numbers[batch * batchASize + row * uniforms.dimInner + col];
           }
           return 0.0;`:e=this.fitA?"return A.numbers[batch * batchASize + col * uniforms.dimAOuter + row];":`if(coordsInBounds2D(vec2<i32>(row, col), vec2<i32>(uniforms.dimAOuter, uniforms.dimInner))) {
             return A.numbers[batch* batchASize + col * uniforms.dimAOuter + row];
           }
           return 0.0;`;let t;this.transposeB===!1?t=this.fitB?"return B.numbers[batch * batchBSize + row * uniforms.dimBOuter + col];":`if(coordsInBounds2D(vec2<i32>(row, col), vec2<i32>(uniforms.dimInner, uniforms.dimBOuter))) {
             return B.numbers[batch * batchBSize + row * uniforms.dimBOuter + col];
           }
           return 0.0;`:t=this.fitB?"return B.numbers[batch * batchBSize + col * uniforms.dimInner + row];":`if(coordsInBounds2D(vec2<i32>(row, col), vec2<i32>(uniforms.dimInner, uniforms.dimBOuter))) {
             return B.numbers[batch * batchBSize + col * uniforms.dimInner + row];
           }
           return 0.0;`;let n="",r="";if(this.activation){let o=Gs(this.activation,!1);this.hasPreluActivationWeights?n=`fn activation(a : f32, outCoord : vec3<i32>) -> f32 {
               let b = getPreluActivationWeightsAtOutCoordsByCoords(outCoord);
               ${o}
            }`:n=`
              fn activation(a : f32, outCoord : vec3<i32>) -> f32 {
                ${o}
              }
            `,r="value = activation(value, outCoord);"}let s=this.addBias?"value = value + getBiasAtOutCoordsByCoords(outCoord);":"";return`
      ${n}

      fn mm_readA(row : i32, col : i32,  globalId : vec3<u32>) -> f32 {
        let batchASize = uniforms.aShape[1] * uniforms.aShape[2];
        let batch = i32(globalId.z);
        ${e}
      }

      fn mm_readB(row : i32, col : i32,  globalId : vec3<u32>) -> f32 {
        let batch = i32(globalId.z);
        let batchBSize = uniforms.bShape[1] * uniforms.bShape[2];
        ${t}
      }

      fn mm_write(row : i32, col : i32, valueIn : f32, globalId : vec3<u32>) {
        var value = valueIn;
        let batch = i32(globalId.z);
        let outCoord = vec3<i32>(batch, row, col);
        ${s}
        ${r}
        setOutput(batch, row, col, value);
      }
      ${this.outputShape[1]>1?vk([this.workPerThread,this.workPerThread,1],this.workGroupSize):Koe(this.workGroupSize)}
    `}};function Xoe(){return`
    var<workgroup> sumValues : array<f32, workGroupSizeX>;
    ${Jc()} {
      let coords = getOutputCoordsWithNonFlatDispatchLayout(globalId);
      let batch = coords[0];
      let row = coords[1];
      let col = coords[2];
      var sum = 0.0;
      let Length = uniforms.dimInner;
      for (var k = i32(localId.x); k < Length; k = k + i32(workGroupSizeX)) {
        let dataA = mm_readA(batch, row, k);
        let dataB = mm_readB(batch, k, col);
        sum = sum + dataA * dataB;
      }
      sumValues[localId.x] = sum;
      workgroupBarrier();

      for(var currentSize = workGroupSizeX / 2u; currentSize > 1u;
          currentSize = currentSize / 2u) {
        if (localId.x < currentSize)
        {
          sumValues[localId.x] = sumValues[localId.x] + sumValues[localId.x + currentSize];
        }
        workgroupBarrier();
      }

      if (localId.x == 0u) {
        sum = sumValues[0] + sumValues[1];
        mm_write(batch, row, col, sum);
      }
    }
  `}var Yoe=class{constructor(e,t=!1,n=!1,r=null,s=null,a=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32; dimBOuter : i32; dimInner : i32;",this.workGroupSize=[256,1,1],this.outputShape=e,this.dispatchLayout={x:[],y:[1,2],z:[0]},this.dispatch=_e(this.dispatchLayout,this.outputShape,this.workGroupSize);let o=r!=null,i=a!=null;o&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),this.transposeA=t,this.transposeB=n,this.addBias=o,this.activation=s,this.hasPreluActivationWeights=i,this.shaderKey=`matMulReduce_${this.activation}_${t}_${n}`}getUserCode(){let e;this.transposeA===!1?e="return A.numbers[batch * batchASize + row * uniforms.dimInner + col];":e="return A.numbers[batch * batchASize + col * uniforms.dimAOuter + row];";let t;this.transposeB===!1?t="return B.numbers[batch * batchBSize + row * uniforms.dimBOuter + col];":t="return B.numbers[batch * batchBSize + col * uniforms.dimInner + row];";let n="",r="";if(this.activation){let o=Gs(this.activation,!1);this.hasPreluActivationWeights?n=`fn activation(a : f32, outCoord : vec3<i32>) -> f32 {
               let b = getPreluActivationWeightsAtOutCoordsByCoords(outCoord);
               ${o}
            }`:n=`
              fn activation(a : f32, outCoord : vec3<i32>) -> f32 {
                ${o}
              }
            `,r="value = activation(value, outCoord);"}let s=this.addBias?"value = value + getBiasAtOutCoordsByCoords(outCoord);":"";return`
      ${n}

      fn mm_readA(batch: i32, row : i32, col : i32) -> f32 {
        let batchASize = uniforms.aShape[1] * uniforms.aShape[2];
        ${e}
      }

      fn mm_readB(batch: i32, row : i32, col : i32) -> f32 {
        let batchBSize = uniforms.bShape[1] * uniforms.bShape[2];
        ${t}
      }

      fn mm_write(batch: i32, row : i32, col : i32, valueIn : f32) {
        var value = valueIn;
        let outCoord = vec3<i32>(batch, row, col);
        ${s}
        ${r}
        setOutput(batch, row, col, value);
      }
      ${Xoe()}
    `}};function Qoe(e){let t=e[1]/2,n=e[0],r=t>n?t:n;return`
  var<workgroup> mm_Asub1 : array<array<f32, ${r}>, ${t}>;
  var<workgroup> mm_Bsub1 : array<array<f32, ${n}>, ${r}>;
  var<workgroup> mm_Asub2 : array<array<f32, ${r}>, ${t}>;
  var<workgroup> mm_Bsub2 : array<array<f32, ${n}>, ${r}>;

  // If the output size is small for matrix multiplication, avoid to use vec4
  // and handle some elements per thread to optimally utilize the ALU.
  // Introduces two shared memory buffers, some logical threads could handle
  // arithmetic operations and others handle IO operations between barrier api,
  // makes ALUs and load/store units work simultaneously, could improves
  // the performance.
  ${Jc()} {
    let tileRow = i32(localId.y);
    let tileCol = i32(localId.x);
    let globalRow = i32(globalId.y);
    let globalCol = i32(globalId.x);

    // uniforms.dimInner should be greater than 0.
    let numTiles = (uniforms.dimInner - 1) / ${r} + 1;
    var acc = 0.0;

    var globalColA = tileCol;
    var globalRowB = tileRow;
    for (var t = 0; t < numTiles; t = t + 1) {
      if (t == 0) {
        if (tileRow < ${t}) {
          // Load one tile of A and B into local memory.
          // globalRow is always greater than or equal tileRow.
          mm_Asub1[tileRow][tileCol] =
              mm_readA((globalRow - tileRow) / 2 + tileRow, globalColA, globalId);
          globalColA = globalColA + ${r};
          mm_Bsub1[tileRow][tileCol] = mm_readB(globalRowB, globalCol, globalId);
          globalRowB = globalRowB + ${r};
        }
      } else {
        if (tileRow < ${t}) {
          // Load one tile of A and B into local memory.
          // globalRow is always greater than or equal tileRow.
          mm_Asub1[tileRow][tileCol] =
              mm_readA((globalRow - tileRow) / 2 + tileRow, globalColA, globalId);
          globalColA = globalColA + ${r};
          mm_Bsub1[tileRow][tileCol] = mm_readB(globalRowB, globalCol, globalId);
          globalRowB = globalRowB + ${r};
        } else {
          // Compute acc values for a single thread.
          for (var k = 0; k < ${r}; k = k + 1) {
            let subRow = tileRow - ${t};
            if (subRow < 0) {
              continue;
            }
            acc = acc + mm_Asub2[subRow][k] * mm_Bsub2[k][tileCol];
          }
        }
      }
      workgroupBarrier();
      if (t != 0) {
        t = t + 1;
      }

      if (t < numTiles) {
        if (tileRow < ${t}) {
          // Load one tile of A and B into local memory.
          // globalRow is always greater than or equal tileRow.
          mm_Asub2[tileRow][tileCol] =
              mm_readA((globalRow - tileRow) / 2 + tileRow, globalColA, globalId);
          globalColA = globalColA + ${r};
          mm_Bsub2[tileRow][tileCol] = mm_readB(globalRowB, globalCol, globalId);
          globalRowB = globalRowB + ${r};
        } else {
          // Compute acc values for a single thread.
          for (var k = 0; k < ${r}; k = k + 1) {
            let subRow = tileRow - ${t};
            if (subRow < 0) {
              continue;
            }
            acc = acc + mm_Asub1[subRow][k] * mm_Bsub1[k][tileCol];
          }
        }
      }
      workgroupBarrier();
    }
    let writeCol = (globalRow - tileRow) / 2 + tileRow - ${t};
    if (tileRow >= ${t} && writeCol >= 0) {
      mm_write(writeCol, globalCol, acc, globalId);
    }
  }
  `}var Zoe=class{constructor(e,t,n,r=null,s=null,a=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32; dimBOuter : i32; dimInner : i32;",this.workGroupSize=[8,16,1],w.assert(e[1]<=16||t[2]<=16,()=>"This program can be only used when A width or B Height are small"),this.outputShape=n,this.dispatchLayout={x:[2],y:[1],z:[0]},this.dispatch=[Math.ceil(n[2]/this.workGroupSize[0]),Math.ceil(n[1]*2/this.workGroupSize[1]),n[0]];let o=r!=null;o&&this.variableNames.push("bias");let i=a!=null;i&&this.variableNames.push("preluActivationWeights"),this.addBias=o,this.activation=s,this.hasPreluActivationWeights=i,this.shaderKey=`matMulSmallOutputSize_${this.activation}`}getUserCode(){let e=`if (coordsInBounds2D(vec2<i32>(row, col), vec2<i32>(uniforms.dimAOuter, uniforms.dimInner))) {
          return A.numbers[batch * batchASize + row * uniforms.dimInner + col];
        }
        return 0.0;`,t=`if (coordsInBounds2D(vec2<i32>(row, col), vec2<i32>(uniforms.dimInner, uniforms.dimBOuter))) {
           return B.numbers[batch * batchBSize + row * uniforms.dimBOuter + col];
         }
         return 0.0;`,n="",r="";if(this.activation){let o=Gs(this.activation,!1);this.hasPreluActivationWeights?n=`fn activation(a : f32, outCoord : vec3<i32>) -> f32 {
            let b = getPreluActivationWeightsAtOutCoordsByCoords(outCoord);
            ${o}
            }`:n=`fn activation(a : f32, outCoord : vec3<i32>) -> f32 {
            ${o}
        }`,r="value = activation(value, outCoord);"}let s=this.addBias?"value = value + getBiasAtOutCoordsByCoords(outCoord);":"";return`
      ${n}

      fn mm_readA(row : i32, col : i32,  globalId : vec3<u32>) -> f32 {
        let batchASize = uniforms.aShape[1] * uniforms.aShape[2];
        let batch = i32(globalId.z);
        ${e}
      }
      fn mm_readB(row : i32, col : i32,  globalId : vec3<u32>) -> f32 {
        let batch = i32(globalId.z);
        let batchBSize = uniforms.bShape[1] * uniforms.bShape[2];
        ${t}
      }
      fn mm_write(row : i32, col : i32, valueIn : f32, globalId : vec3<u32>) {
        if (coordsInBounds2D(vec2<i32>(row, col), vec2<i32>(uniforms.dimAOuter, uniforms.dimBOuter))) {
          let batch = i32(globalId.z);
          let outCoord = vec3<i32>(batch, row, col);
          var value = valueIn;
          ${s}
          ${r}
          setOutput(batch, row, col, value);
        }
      }
      ${Qoe(this.workGroupSize)}
    `}};function We(e){let{inputs:t,attrs:n}=e,{x:r}=t,{shape:s}=n,a=w.sizeFromShape(r.shape),o=w.inferFromImplicitShape(s,a),i=w.sizeFromShape(o);return w.assert(a===i,()=>`The new shape (${o}) has ${i} elements and the old shape (${r.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`),e.backend.incRef(r.dataId),{dataId:r.dataId,shape:o,dtype:r.dtype}}var Joe={kernelName:hi,backendName:"webgpu",kernelFunc:We};function xk({a:e,b:t,transposeA:n,transposeB:r,backend:s,bias:a=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:u=null}){let l=e.shape.length,c=t.shape.length,d=n?e.shape[l-2]:e.shape[l-1],p=r?t.shape[c-1]:t.shape[c-2],h=n?e.shape[l-1]:e.shape[l-2],f=r?t.shape[c-2]:t.shape[c-1],m=e.shape.slice(0,-2),g=t.shape.slice(0,-2),b=w.sizeFromShape(m),y=w.sizeFromShape(g),x=Ri.assertAndGetBroadcastShape(e.shape.slice(0,-2),t.shape.slice(0,-2)).concat([h,f]);w.assert(d===p,()=>`Error in matMul: inner shapes (${d}) and (${p}) of Tensors with shapes ${e.shape} and ${t.shape} and transposeA=${n} and transposeB=${r} must match.`);let k=n?[b,d,h]:[b,h,d],T=r?[y,f,p]:[y,p,f],C=We({inputs:{x:e},backend:s,attrs:{shape:k}}),E=We({inputs:{x:t},backend:s,attrs:{shape:T}}),F=[C,E],O=Math.max(b,y),D=d%4==0&&f%4==0&&!n&&!r&&f>=32,R;h*f<=32?R=new Yoe([O,h,f],n,r,a,u,o):!n&&!r&&(h<=16&&(f<=512||p>=2*f)||f<=16&&(h<=512||d>=2*h))?R=new Zoe(k,T,[O,h,f],a,u,o):D?R=new qoe(k,[O,h,f],X().get("WEBGPU_MATMUL_WORK_PER_THREAD"),a,u,o):R=new wE(k,[O,h,f],X().get("WEBGPU_MATMUL_WORK_PER_THREAD"),n,r,a,u,o);let _=[C,E];a&&_.push(a),o&&_.push(o);let L=[{type:"int32",data:[h]},{type:"int32",data:[f]},{type:"int32",data:[d]}],U=s.runWebGPUProgram(R,_,e.dtype,L),j=We({inputs:{x:U},backend:s,attrs:{shape:x}});F.push(U);for(let K of F)s.disposeData(K.dataId);return j}function eie(e){let{inputs:t,backend:n,attrs:r}=e,{a:s,b:a,bias:o,preluActivationWeights:i}=t,{transposeA:u,transposeB:l,activation:c,leakyreluAlpha:d}=r;return xk({a:s,b:a,transposeA:u,transposeB:l,backend:n,bias:o,preluActivationWeights:i,leakyreluAlpha:d,activation:c})}var tie={kernelName:to,backendName:"webgpu",kernelFunc:eie},kE=class{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.workGroupSize=[128,1,1],this.size=!0,this.outputShape=N.assertAndGetBroadcastShape(t,n),this.dispatchLayout=ze(this.outputShape),this.dispatch=_e(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey=`binaryOpComplex_${e}`,this.op=e}getUserCode(){return`
      fn binaryOpComplex(
          areal : f32, aimag : f32, breal : f32, bimag : f32) -> f32 {
        ${pp(this.op,!1)}
      }

      ${Ue()}
        if(index < uniforms.size) {
          let areal = getARealAtOutCoordsByGlobalIndex(index);
          let aimag = getAImagAtOutCoordsByGlobalIndex(index);
          let breal = getBRealAtOutCoordsByGlobalIndex(index);
          let bimag = getBImagAtOutCoordsByGlobalIndex(index);
          setOutputFlat(index, binaryOpComplex(areal, aimag, breal, bimag));
        }
      }
    `}},nie=class{constructor(e,t,n,r){this.variableNames=["A","B"],this.size=!0;let s=256;this.workGroupSize=[s,1,1],this.outputShape=N.assertAndGetBroadcastShape(t,n),this.dispatchLayout=ze(this.outputShape),this.lastDimensionSize=r?n[0]:t[0],this.lastDimensionSize<256?this.workPerThread=1:this.lastDimensionSize<512?this.workPerThread=2:this.workPerThread=4,this.dispatch=_e(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]),this.useSharedMemoryWithB=r,this.op=e,this.shaderKey=`binaryShared_${e}_${this.lastDimensionSize}_${this.useSharedMemoryWithB}`}getUserCode(){let e=this.lastDimensionSize>1?`coords[${this.outputShape.length-1}]`:"0",t=this.useSharedMemoryWithB?`let a = getAAtOutCoordsByCoords(coords);
         let b = sharedBuf[${e}];`:`let a = sharedBuf[${e}];
         let b = getBAtOutCoordsByCoords(coords);`;return`
        fn binaryOperation(a : f32, b : f32) -> f32 {
          ${pp(this.op,!1)}
        }
        var<workgroup> sharedBuf : array<f32, ${this.lastDimensionSize}>;
        ${Ue()}

          // Fill in the shared memory buffer. Here we need a loop to make sure
          // that all data in A|B are uploaded when |sharedMemorySize| is larger
          // than work group size.
          for(var localIndex = i32(localId.x); localIndex < ${this.lastDimensionSize}; localIndex = localIndex + ${this.workGroupSize[0]}) {
            sharedBuf[localIndex] = f32(${this.useSharedMemoryWithB?"B":"A"}.numbers[localIndex]);
          }
          workgroupBarrier();

          for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
            let flatIndex = index * ${this.workPerThread} + i;
            if(flatIndex < uniforms.size) {
              let coords = getCoordsFromFlatIndex(flatIndex);

              ${t}
              setOutputFlat(flatIndex, binaryOperation(a, b));
            }
          }
        }
        `}},rie=class{constructor(e,t,n){this.variableNames=["A","B"],this.workPerThread=4,this.isVec4=!0,this.size=!0;let r=128;this.workGroupSize=[r,1,1],this.outputShape=N.assertAndGetBroadcastShape(t,n),this.dispatchLayout=ze(this.outputShape),this.dispatch=_e(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]),this.op=e,this.shaderKey=`binaryVec4_${e}`}getUserCode(){return`
      fn binaryOperation(a : vec4<f32>, b : vec4<f32>) -> vec4<f32> {
        ${pp(this.op,this.isVec4)}
      }
      ${Ue()}
        if (index < uniforms.size) {
          let a = getAAtOutCoordsByGlobalIndex(index);
          let b = getBAtOutCoordsByGlobalIndex(index);
          setOutputFlat(index, binaryOperation(a, b));
        }
      }
    `}},IE=class{constructor(e,t,n){this.variableNames=["A","B"],this.size=!0;let r=128;this.workGroupSize=[r,1,1],this.outputShape=N.assertAndGetBroadcastShape(t,n),this.dispatchLayout=ze(this.outputShape),this.dispatch=_e(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey=`binary_${e}`,this.op=e}getUserCode(){return`
      fn binaryOperation(a : f32, b : f32) -> f32 {
        ${pp(this.op,!1)}
      }
      ${Ue()}
        if (index < uniforms.size) {
          let a = getAAtOutCoordsByGlobalIndex(index);
          let b = getBAtOutCoordsByGlobalIndex(index);
          setOutputFlat(index, binaryOperation(a, b));
        }
      }
      `}};function SE(e,t,n){if(w.arraysEqual(t,n)&&w.sizeFromShape(t)%4==0)return new rie(e,t,n);let s=t.length===1&&n.length>1&&t[0]<1024,a=n.length===1&&t.length>1&&n[0]<1024;return s||a?new nie(e,t,n,a):new IE(e,t,n)}function Lr(e){let{inputs:t}=e,{x:n}=t;return e.backend.incRef(n.dataId),{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}var sie={kernelName:_a,backendName:"webgpu",kernelFunc:Lr};function nl(e){let{inputs:t,backend:n}=e,{real:r,imag:s}=t,a=n.makeTensorInfo(r.shape,"complex64"),o=n.tensorMap.get(a.dataId),i=Lr({inputs:{x:r},backend:n}),u=Lr({inputs:{x:s},backend:n});return o.complexTensorInfos={real:i,imag:u},a}var aie={kernelName:ql,backendName:"webgpu",kernelFunc:nl},Wm=class{constructor(e,t){this.variableNames=["A"],this.size=!0;let n=128;this.workGroupSize=[n,1,1],this.outputShape=e,this.dispatchLayout=ze(this.outputShape),this.dispatch=_e(this.dispatchLayout,this.outputShape,this.workGroupSize),this.op=t,this.shaderKey=`unary_${t}`}getUserCode(){return`
      fn unaryOperation(a : f32) -> f32 {
        ${tl(this.op,!1)}
      }
      ${Ue()}
        if (index < uniforms.size) {
          let a = getAAtOutCoordsByGlobalIndex(index);
          setOutputFlat(index, unaryOperation(a));
        }
      }
      `}};function fn({opType:e,cpuKernelImpl:t,dtype:n}){return({inputs:r,backend:s})=>{let{x:a}=r,o=s,i=n||a.dtype;if(o.shouldExecuteOnCPU([a])&&t!=null){let l=o.tensorMap.get(a.dataId),c=t(l.values,i);return o.makeTensorInfo(a.shape,i,c)}let u=new Wm(a.shape,e);return o.runWebGPUProgram(u,[a],i)}}function Rn({opSnippet:e,cpuKernelImpl:t,supportsComplex:n=!1,dtype:r}){return({inputs:s,backend:a})=>{let{a:o,b:i}=s,u=a;if(n&&o.dtype==="complex64"){let d=u.tensorMap.get(o.dataId),p=u.tensorMap.get(i.dataId),h,f;if(e!==Mt.MUL)[h,f]=[[d.complexTensorInfos.real,p.complexTensorInfos.real],[d.complexTensorInfos.imag,p.complexTensorInfos.imag]].map(g=>{let[b,y]=g,v={dataId:b.dataId,dtype:b.dtype,shape:o.shape},x={dataId:y.dataId,dtype:y.dtype,shape:i.shape},k=SE(e,o.shape,i.shape);return u.runWebGPUProgram(k,[v,x],In(b.dtype,y.dtype))});else{let g=new kE(Mt.COMPLEX_MULTIPLY_REAL,o.shape,i.shape),b=new kE(Mt.COMPLEX_MULTIPLY_IMAG,o.shape,i.shape),y=[{dataId:d.complexTensorInfos.real.dataId,dtype:d.complexTensorInfos.real.dtype,shape:o.shape},{dataId:d.complexTensorInfos.imag.dataId,dtype:d.complexTensorInfos.imag.dtype,shape:o.shape},{dataId:p.complexTensorInfos.real.dataId,dtype:p.complexTensorInfos.real.dtype,shape:i.shape},{dataId:p.complexTensorInfos.imag.dataId,dtype:p.complexTensorInfos.imag.dtype,shape:i.shape}];h=u.runWebGPUProgram(g,y,"float32"),f=u.runWebGPUProgram(b,y,"float32")}let m=nl({inputs:{real:h,imag:f},backend:u});return u.disposeData(h.dataId),u.disposeData(f.dataId),m}let l=r||In(o.dtype,i.dtype);if((o.dtype==="string"||i.dtype==="string"||u.shouldExecuteOnCPU([o,i]))&&t!=null){let d=u.tensorMap.get(o.dataId).values,p=u.tensorMap.get(i.dataId).values,h=o.dtype==="string"?N.fromUint8ToStringArray(d):d,f=o.dtype==="string"?N.fromUint8ToStringArray(p):p,[m,g]=t(o.shape,i.shape,h,f,l);return u.makeTensorInfo(g,l,m)}let c=SE(e,o.shape,i.shape);return u.runWebGPUProgram(c,[o,i],l)}}var{addImpl:oie,ceilImpl:iie,concatImpl:uie,equalImpl:cie,expImpl:lie,expm1Impl:die,floorImpl:pie,gatherNdImpl:hie,gatherV2Impl:fie,greaterEqualImpl:mie,greaterImpl:gie,lessEqualImpl:bie,lessImpl:yie,logImpl:vie,maxImpl:xie,maximumImpl:wie,minimumImpl:kie,multiplyImpl:Iie,negImpl:Sie,notEqualImpl:Cie,prodImpl:Tie,rangeImpl:Nie,rsqrtImpl:_ie,simpleAbsImpl:Eie,sliceImpl:Aie,stridedSliceImpl:$ie,stringNGramsImpl:Fie,subImpl:Die,tileImpl:Rie,topKImpl:Pie,transposeImpl:Oie,uniqueImpl:abe}=fm,Mie=fn({opType:bt.ABS,cpuKernelImpl:Eie}),Lie={kernelName:Vo,backendName:"webgpu",kernelFunc:Mie},Bie=Rn({opSnippet:Mt.ADD,cpuKernelImpl:oie,supportsComplex:!0}),zie={kernelName:_s,backendName:"webgpu",kernelFunc:Bie},Wie=class{constructor(e){this.workPerThread=4,this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=e[0],this.variableNames=e.map((t,n)=>`T${n}`),this.dispatchLayout=ze(this.outputShape),this.dispatch=_e(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]),this.shaderKey="addN"}getUserCode(){let e=[];this.variableNames.forEach(r=>{e.push(`let v${r} = get${r}AtOutCoordsByCoords(coords);`)});let t=this.variableNames.map(r=>`v${r}`).join(" + ");return`
      ${Ue()}
        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if (flatIndex < uniforms.size) {
            let coords = getCoordsFromFlatIndex(flatIndex);
            ${e.join(`
        `)}
            setOutputFlat(flatIndex, ${t});
          }
        }
      }
    `}};function Vie(e){let{inputs:t,backend:n}=e,r=t;if(r.length===1)return Lr({inputs:{x:r[0]},backend:n});let s=r.map(i=>i.dtype).reduce((i,u)=>In(i,u)),a=r.map(i=>i.shape),o=new Wie(a);return n.runWebGPUProgram(o,r,s)}var Uie={kernelName:la,backendName:"webgpu",kernelFunc:Vie},CE=class{constructor(e,t,n){this.workGroupSize=[64,1,1],this.variableNames=["x"],this.uniforms="axis : i32; infinityValue : f32;",this.size=!0;let r=[t];N.assertAxesAreInnerMostDims("arg"+n.charAt(0).toUpperCase()+n.slice(1),r,e.length),this.op=n==="min"?"<":">";let[s]=N.computeOutAndReduceShapes(e,r);this.outputShape=s.length===0?[1]:s,this.dispatchLayout=ze(this.outputShape),this.dispatch=_e(this.dispatchLayout,this.outputShape,[1,1,1]),this.inputShape=e,this.shaderKey=`argMinMax${this.op}`}getUserCode(){let e=`
      var<workgroup> xBestIndices : array<i32, ${this.workGroupSize[0]}>;
      var<workgroup> xBestValues : array<f32, ${this.workGroupSize[0]}>;
    `,t=(s,a)=>this.outputShape.length===1?s:`${s}[${a}]`,n=s=>this.inputShape.length===1?"uniforms.xShape":`uniforms.xShape[${s}]`;return`
      fn DIV_CEIL(a : u32, b : u32) -> u32 {
        return ((a - 1u) / b + 1u);
      }

      ${e}

      // In order to get a flattened index into the input tensor, we need to
      // add back the index along the reduced dimension to |outputCoords|.
      // This function outputs the offset to the first value along
      // |axis| and the stride to get the next value of the input along |axis|.
      fn getInputCoordInfo(outputIndex : i32) -> vec2<i32>{
        let outputCoords = getCoordsFromFlatIndex(outputIndex);
        var i = ${this.outputShape.length-1};

        var stride = 1;
        var inputStride = 1;
        var offset = 0;

        for (var r = 1; r <= ${this.inputShape.length}; r = r + 1) {
          let length = ${n(`${this.inputShape.length} - r`)};
          if (${this.inputShape.length} - r == uniforms.axis) {
            inputStride = stride;
          } else {
            offset = offset + ${t("outputCoords","i")} * stride;
            i = i - 1;
          }
          stride = stride * length;
        }

        return vec2<i32>(offset, inputStride);
      }

      fn getInputIndex(coordInfo : vec2<i32>, index : i32) -> i32{
        return coordInfo[0] + coordInfo[1] * index;
      }

      ${Ue()}
        let outputIndex = index / i32(workGroupSizeX);
        let coordInfo = getInputCoordInfo(outputIndex);
        let Length = ${n("uniforms.axis")};

        var bestIndex = i32(localId.x);
        var bestValue = uniforms.infinityValue;

        for (var k = i32(localId.x); k < Length && outputIndex < uniforms.size;
            k = k + i32(workGroupSizeX)) {
          let candidate = f32(x.numbers[getInputIndex(coordInfo, k)]);
          if (!isNanCustom(candidate) && candidate ${this.op} bestValue) {
            bestValue = candidate;
            bestIndex = k;
          }
        }
        xBestValues[localId.x] = bestValue;
        xBestIndices[localId.x] = bestIndex;
        workgroupBarrier();

        var reduceSize = min(u32(Length), workGroupSizeX);
        for (var currentSize = reduceSize / 2u; reduceSize > 1u;
            currentSize = reduceSize / 2u) {
          let interval = DIV_CEIL(reduceSize, 2u);
          if (localId.x < currentSize) {
            let candidate = xBestValues[localId.x + interval];
            if (candidate ${this.op} bestValue) {
              bestValue = candidate;
              xBestValues[localId.x] = bestValue;
              xBestIndices[localId.x] = xBestIndices[localId.x + interval];
            }
          }
          reduceSize = interval;
          workgroupBarrier();
        }

        if (localId.x == 0u && outputIndex < uniforms.size) {
          setOutputFlatI32(outputIndex, xBestIndices[localId.x]);
        }
      }
    `}},Gie=class{constructor(e,t){this.variableNames=["A"],this.workGroupSize=[16,16,1];let n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];this.outputShape=n,this.dispatchLayout={x:[0],y:[1]},this.dispatch=_e(this.dispatchLayout,this.outputShape,this.workGroupSize,[1,1,1]),this.shaderKey="transposeShared"}getUserCode(){return`
      let TILE_DIM = ${this.workGroupSize[0]};
      var<workgroup> tile : array<array<f32, ${this.workGroupSize[0]+1}>, ${this.workGroupSize[0]}>;
      ${zm()}
      fn main([[builtin(local_invocation_id)]] localId : vec3<u32>,
              [[builtin(workgroup_id)]] workgroupId : vec3<u32>) {
        var x = i32(workgroupId.x) * TILE_DIM + i32(localId.x);
        var y = i32(workgroupId.y) * TILE_DIM + i32(localId.y);
        let width = uniforms.outShape[0];
        let height = uniforms.outShape[1];
        if (x < width && y < height) {
          tile[localId.y][localId.x] =
              A.numbers[y * width + x];
        }
        workgroupBarrier();

        x = i32(workgroupId.y) * TILE_DIM + i32(localId.x);
        y = i32(workgroupId.x) * TILE_DIM + i32(localId.y);
        if (x < height && y < width) {
          setOutputFlat((y * height + x), tile[localId.x]
            [localId.y]);
        }
      }
    `}},Hie=class{constructor(e,t){this.variableNames=["A"],this.workPerThread=4,this.workGroupSize=[64,1,1],this.size=!0;let n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];this.outputShape=n,this.dispatchLayout=ze(this.outputShape),this.dispatch=_e(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]),this.newDim=t,this.shaderKey=`transpose_${t}`}getUserCode(){let e=on(this.outputShape.length),t=jie(this.newDim);return`
      ${Ue()}

        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let resRC = getCoordsFromFlatIndex(flatIndex);
            setOutputFlat(flatIndex, A.numbers[getFlatIndex${this.outputShape.length}D(
              ${e}(${t}), uniforms.aShape)]);
          }
        }
      }
    `}};function jie(e){let t=e.length;if(t>4)throw Error(`Transpose for rank ${t} is not yet supported`);let n=new Array(t);for(let r=0;r<e.length;r++)n[e[r]]=`resRC[${r}]`;return n.join()}function cu(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{perm:a}=r,o=n,i=s.shape.length,u=new Array(i);for(let c=0;c<u.length;c++)u[c]=s.shape[a[c]];if(n.shouldExecuteOnCPU([s])){let d=o.tensorMap.get(s.dataId).values,p=Oie(d,s.shape,s.dtype,a,u);return n.makeTensorInfo(u,s.dtype,p)}if(s.shape.length===2&&w.arraysEqual(a,[1,0])){let c=new Gie(s.shape,a);return o.runWebGPUProgram(c,[s],s.dtype)}let l=new Hie(s.shape,a);return o.runWebGPUProgram(l,[s],s.dtype)}var qie={kernelName:Ja,backendName:"webgpu",kernelFunc:cu};function Kie(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r,o=w.parseAxisParam(a,s.shape),i=N.getAxesPermutation(o,s.shape.length),u=s,l=[];i!=null&&(u=cu({inputs:{x:s},backend:n,attrs:{perm:i}}),l.push(u),o=N.getInnerMostAxes(o.length,u.shape.length)),N.assertAxesAreInnerMostDims("argMax",[o[0]],u.shape.length);let c=new CE(u.shape,o[0],"max"),d=[{type:"int32",data:[o[0]]},{type:"float32",data:[Number.NEGATIVE_INFINITY]}],p=n.runWebGPUProgram(c,[u],"int32",d);return l.forEach(h=>n.disposeData(h.dataId)),p}var Xie={kernelName:da,backendName:"webgpu",kernelFunc:Kie};function Yie(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r,o=w.parseAxisParam(a,s.shape),i=N.getAxesPermutation(o,s.shape.length),u=s,l=[];i!=null&&(u=cu({inputs:{x:s},backend:n,attrs:{perm:i}}),l.push(u),o=N.getInnerMostAxes(o.length,u.shape.length)),N.assertAxesAreInnerMostDims("argMin",[o[0]],u.shape.length);let c=new CE(u.shape,o[0],"min"),d=[{type:"int32",data:[o[0]]},{type:"float32",data:[Number.POSITIVE_INFINITY]}],p=n.runWebGPUProgram(c,[u],"int32",d);return l.forEach(h=>n.disposeData(h.dataId)),p}var Qie={kernelName:Hu,backendName:"webgpu",kernelFunc:Yie},TE=class{constructor(e,t){this.variableNames=["x"],this.uniforms="stride : vec2<i32>; pad : vec2<i32>; dilation : vec2<i32>; convDims : vec2<i32>; filterDims : vec2<i32>;",this.workGroupSize=[128,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=ze(this.outputShape),this.dispatch=_e(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey=`pool2D_${t}`,this.poolType=t}getUserCode(){let e="resultValue = max(value, resultValue);";this.poolType==="avg"&&(e="resultValue = resultValue + value; count = count + 1.0;");let t="resultValue";return this.poolType==="avg"&&(t="resultValue / count"),`
      ${Ue()}
      if (index < uniforms.size) {
        let coords = getCoordsFromFlatIndex(index);
          let batch = coords[0];
          let xRCCorner = vec2<i32>(coords.yz) * uniforms.stride - uniforms.pad;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          var resultValue = ${this.poolType==="avg"?"0.0":"-1.0 / pow(10.0, -20.0)"};
          var count = 0.0;

          for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + uniforms.dilation.x) {
            let xR = xRCorner + wR;

            if (xR < 0 || xR >= uniforms.convDims.x) {
              continue;
            }

            for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + uniforms.dilation.y) {
              let xC = xCCorner + wC;
              if (xC < 0 || xC >= uniforms.convDims.y) {
                continue;
              }

              let value = getX(batch, xR, xC, coords[3]);
              ${e}
            }
          }

          setOutputFlat(index, ${t});
        }
      }
    `}},NE=class{constructor(e){this.variableNames=["x"],this.uniforms="stride : vec2<i32>;",this.workGroupSize=[256,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=ze(this.outputShape),this.dispatch=_e(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="poolWithFilterSizeEqualsOne"}getUserCode(){return`
      ${Ue()}
        if (index < uniforms.size) {
          let coords = getCoordsFromFlatIndex(index);
          let batch = coords[0];
          let d = coords[3];

          let xRCCorner = coords.yz * uniforms.stride;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          let value = getX(batch, xRCorner, xCCorner, d);
          setOutputFlat(index, value);
        }
      }
    `}};function Zie(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:o,pad:i,dimRoundingMode:u}=r,l=1,c=N.computePool2DInfo(s.shape,a,o,l,i,u);if(c.filterWidth===1&&c.filterHeight===1&&w.arraysEqual(c.inShape,c.outShape))return Lr({inputs:{x:s},backend:n});let d,p=[{type:"int32",data:[c.strideHeight,c.strideWidth]}];return c.filterHeight===1&&c.filterWidth===1?d=new NE(c):(d=new TE(c,"avg"),p.push({type:"int32",data:[c.padInfo.top,c.padInfo.left]},{type:"int32",data:[c.dilationHeight,c.dilationWidth]},{type:"int32",data:[c.inHeight,c.inWidth]},{type:"int32",data:[c.effectiveFilterHeight,c.effectiveFilterWidth]})),n.runWebGPUProgram(d,[s],s.dtype,p)}var Jie={kernelName:pa,backendName:"webgpu",kernelFunc:Zie};function eue(e){let{inputs:t,backend:n,attrs:r}=e,{a:s,b:a}=t,{transposeA:o,transposeB:i}=r;return xk({a:s,b:a,transposeA:o,transposeB:i,backend:n})}var tue={kernelName:ha,backendName:"webgpu",kernelFunc:eue},nue=class{constructor(e,t){this.variableNames=["source"],this.workPerThread=1,this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.rank=t.length,this.dispatchLayout=ze(this.outputShape),this.dispatch=_e(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]),this.start=e,this.uniforms=`start : ${on(e.length)}; `,this.shaderKey="slice"}getUserCode(){let e=on(this.rank),t=rue(this.rank),n;return this.start.length===1?n=this.outputShape.map((s,a)=>"sourceLoc = uniforms.start + coords;"):n=this.outputShape.map((s,a)=>`sourceLoc.${wk[a]} = uniforms.start[${a}] + coords.${wk[a]};`),`
      ${Ue()}
        if (index < uniforms.size) {
          var sourceLoc : ${e};
          let coords = getCoordsFromFlatIndex(index);
          ${n.join(`
`)}
          setOutputFlat(index, getSource(${t}));
        }
      }
    `}},wk=["x","y","z","w","u","v"];function rue(e){if(e===1)return"sourceLoc";if(e<=6)return wk.slice(0,e).map(t=>`sourceLoc.${t}`).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}function rl(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,size:o}=r,[i,u]=$t.parseSliceParams(s,a,o);if($t.assertParamsValid(s,i,u),n.shouldExecuteOnCPU([s])||s.dtype==="string"){let d=n.tensorMap.get(s.dataId),p=Aie(d.values,i,u,s.shape,s.dtype);return n.makeTensorInfo(u,s.dtype,p)}if(w.sizeFromShape(u)===0)return n.makeTensorInfo(u,s.dtype,[]);let l=new nue(i,u),c=[{type:"int32",data:i}];return n.runWebGPUProgram(l,[s],s.dtype,c)}var sue={kernelName:yi,backendName:"webgpu",kernelFunc:rl},aue=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,crops:o}=r;w.assert(s.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGPU backend not implemented yet");let i=a.reduce((y,v)=>y*v),u=N.getReshaped(s.shape,a,i),l=N.getPermuted(u.length,a.length),c=N.getReshapedPermuted(s.shape,a,i),d=N.getSliceBeginCoords(o,a.length),p=N.getSliceSize(c,o,a.length),h=[],f=We({inputs:{x:s},backend:n,attrs:{shape:u}}),m=cu({inputs:{x:f},backend:n,attrs:{perm:l}}),g=We({inputs:{x:m},backend:n,attrs:{shape:c}}),b=rl({inputs:{x:g},backend:n,attrs:{begin:d,size:p}});return h.push(f),h.push(m),h.push(g),h.forEach(y=>n.disposeData(y.dataId)),b},oue={kernelName:Uo,backendName:"webgpu",kernelFunc:aue},_E=Rn({opSnippet:Mt.NOT_EQUAL,dtype:"bool",cpuKernelImpl:Cie}),iue={kernelName:oi,backendName:"webgpu",kernelFunc:_E};function hp(e){let{inputs:t,backend:n}=e,{input:r}=t,s=n.tensorMap.get(r.dataId);return Lr({inputs:{x:s.complexTensorInfos.real},backend:n})}var uue={kernelName:nd,backendName:"webgpu",kernelFunc:hp};function cue(e,t){let n=new Wm(e.shape,bt.TO_INT),r=t.runWebGPUProgram(n,[e],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}function kk(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dtype:a}=r;if(a==="complex64"){if(s.dtype==="complex64")return Lr({inputs:{x:s},backend:n});let o=kt(s.shape),i=kk({inputs:{x:s},backend:n,attrs:{dtype:"float32"}}),u=nl({inputs:{real:i,imag:o},backend:n});return o.dispose(),n.disposeData(i.dataId),u}if(s.dtype==="complex64"){let o=hp({inputs:{input:s},backend:n}),i=kk({inputs:{x:o},backend:n,attrs:{dtype:a}});return n.disposeData(o.dataId),i}if(!w.hasEncodingLoss(s.dtype,a)){let o=Lr({inputs:{x:s},backend:n});return{dataId:o.dataId,shape:o.shape,dtype:a}}if(a==="int32")return cue(s,n);if(a==="bool"){let o=n.makeTensorInfo([],"bool",w.getTypedArrayFromDType("bool",1)),u=_E({inputs:{a:s,b:o},backend:n});return n.disposeData(o.dataId),u}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${a}`)}var lue={kernelName:fa,backendName:"webgpu",kernelFunc:kk},due=fn({opType:bt.CEIL,cpuKernelImpl:iie}),pue={kernelName:ma,backendName:"webgpu",kernelFunc:due},hue=class{constructor(e){this.variableNames=["A"],this.uniforms="minVal : f32; maxVal : f32;",this.workPerThread=4,this.workGroupSize=[64,1,1],this.isVec4=!0,this.size=!0,this.outputShape=e,this.dispatchLayout=ze(this.outputShape),this.dispatch=_e(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]),this.shaderKey="clipVec4"}getUserCode(){return`
      ${Ue()}
        if(index < uniforms.size) {
          let value = getAAtOutCoordsByGlobalIndex(index);
          var clampedValue : vec4<f32>;
          for (var i = 0; i < 4; i = i + 1) {
            if (isNanCustom(value[i])) {
              clampedValue[i] = value[i];
            } else {
              clampedValue[i] = clamp(value[i], uniforms.minVal, uniforms.maxVal);
            }
          }

          setOutputFlat(index, clampedValue);
        }
      }
    `}},fue=class{constructor(e){this.variableNames=["A"],this.uniforms="minVal : f32; maxVal : f32;",this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=ze(this.outputShape),this.dispatch=_e(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="clip"}getUserCode(){return`
      ${Ue()}
        if(index < uniforms.size) {
          let value = getAAtOutCoordsByGlobalIndex(index);
          if (isNanCustom(value)) {
            setOutputFlat(index, value);
            return;
          }
          setOutputFlat(index, clamp(value, uniforms.minVal, uniforms.maxVal));
        }
      }
    `}};function mue(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{clipValueMin:a,clipValueMax:o}=r,i,u=[{type:"float32",data:[a]},{type:"float32",data:[o]}];return w.sizeFromShape(s.shape)%4==0?i=new hue(s.shape):i=new fue(s.shape),n.runWebGPUProgram(i,[s],s.dtype,u)}var gue={kernelName:Es,backendName:"webgpu",kernelFunc:mue},bue=class{constructor(e){this.uniforms="",this.workPerThread=4,this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=N.computeOutShape(e,1),this.variableNames=e.map((t,n)=>`T${n}`),this.dispatchLayout=ze(this.outputShape),this.dispatch=_e(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]),this.offsetLength=e.length-1;for(let t=0;t<this.offsetLength;t++)this.uniforms+=`offset${t} : i32;`;this.shaderKey="concat"}getUserCode(){let e=[];if(this.offsetLength>0){e.push("if (yC < uniforms.offset0){ setOutput(coords.x, coords.y, getT0(yR, yC)); }");for(let s=1;s<this.offsetLength;s++)e.push(`elseif (yC < uniforms.offset${[s]}){ setOutput(coords.x, coords.y, getT${s}(yR, yC - uniforms.offset${s-1})); }`);let n=this.offsetLength,r=this.offsetLength-1;e.push(`else { setOutput(coords.x, coords.y, getT${n}(yR, yC - uniforms.offset${r})); }`)}else e.push("setOutput(coords.x, coords.y, getT0(yR, yC));");return`
      ${Ue()}
        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let coords = getCoordsFromFlatIndex(flatIndex);
            let yR = coords.x;
            let yC = coords.y;

            ${e.join(`
        `)}
          }
        }
      }
    `}};function Vm(e){let{inputs:t,backend:n}=e,{input:r}=t,s=n.tensorMap.get(r.dataId);return Lr({inputs:{x:s.complexTensorInfos.imag},backend:n})}var yue={kernelName:Zl,backendName:"webgpu",kernelFunc:Vm};function Ik(e,t,n){let r=e[0].dtype;if(r==="complex64"){let h=e.map(y=>hp({inputs:{input:y},backend:n})),f=e.map(y=>Vm({inputs:{input:y},backend:n})),m=Ik(h,t,n),g=Ik(f,t,n),b=nl({inputs:{real:m,imag:g},backend:n});return h.forEach(y=>n.disposeData(y.dataId)),f.forEach(y=>n.disposeData(y.dataId)),n.disposeData(m.dataId),n.disposeData(g.dataId),b}let s=n.shouldExecuteOnCPU(e);if(r==="string"&&(s=!0),s){let h=e.map(x=>{let k=w.sizeFromShape(x.shape.slice(t));return We({inputs:{x},backend:n,attrs:{shape:[-1,k]}})}),f=h.map(x=>({vals:n.readSync(x.dataId),shape:x.shape})),m=N.computeOutShape(h.map(x=>x.shape),1),g=h[0].shape[0]===1,b=uie(f,m,r,g),y=N.computeOutShape(e.map(x=>x.shape),t),v=n.makeTensorInfo(y,r,b);return h.forEach(x=>n.disposeData(x.dataId)),v}let{tensors2D:a,outShape:o}=vue(e,t,n),i=a.map(h=>h.shape),u=new bue(i),l=[],c=new Array(i.length-1);if(c.length>0){c[0]=i[0][1],l.push({type:"int32",data:[c[0]]});for(let h=1;h<c.length;h++)c[h]=c[h-1]+i[h][1],l.push({type:"int32",data:[c[h]]})}let d=n.runWebGPUProgram(u,a,a[0].dtype,l);a.forEach(h=>n.disposeData(h.dataId));let p=We({inputs:{x:d},backend:n,attrs:{shape:o}});return n.disposeData(d.dataId),p}function vue(e,t,n){let r=N.computeOutShape(e.map(a=>a.shape),t);return{tensors2D:e.map(a=>We({inputs:{x:a},backend:n,attrs:{shape:[w.sizeFromShape(a.shape.slice(0,t)),w.sizeFromShape(a.shape.slice(t))]}})),outShape:r}}function EE(e){let{inputs:t,backend:n,attrs:r}=e,{axis:s}=r,a=w.parseAxisParam(s,t[0].shape)[0],o=N.computeOutShape(t.map(l=>l.shape),a);if(w.sizeFromShape(o)===0)return n.makeTensorInfo(o,t[0].dtype,[]);let i=t.filter(l=>w.sizeFromShape(l.shape)>0);if(i.length===1)return Lr({inputs:{x:i[0]},backend:n});let u=i.map(l=>l.shape);return N.assertParamsConsistent(u,a),Ik(i,a,n)}var xue={kernelName:Go,backendName:"webgpu",kernelFunc:EE},wue=class{constructor(e,t){this.variableNames=["A"],this.uniforms=`pad : vec2<i32>; stride : vec2<i32>; dilation : vec2<i32>; outWidth : i32; itemsPerBlockRow : i32;
      inChannels : i32;`,this.workPerThread=4,this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=ze(this.outputShape),this.dispatch=_e(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]),this.isChannelsLast=t,this.shaderKey=`im2col_${this.isChannelsLast}`}getUserCode(){let e=this.isChannelsLast?0:1,t=this.isChannelsLast?1:2;return`
    ${Ue()}

      for(var i = 0; i<${this.workPerThread}; i = i + 1) {
        let flatIndex = index * ${this.workPerThread} + i;

        let rc = getCoordsFromFlatIndex(flatIndex);

        if(flatIndex < uniforms.size) {
          let blockIndex = rc[0];
          let pos = rc[1];

          let offsetY = blockIndex / uniforms.outWidth * uniforms.stride[1] - uniforms.pad[1];
          let d0 = offsetY + uniforms.dilation[1] * pos / uniforms.itemsPerBlockRow;
          var value = 0.0;
          if(d0 < uniforms.aShape[${e}] && d0 >= 0) {
            let offsetX = (blockIndex % uniforms.outWidth) * uniforms.stride[0] -
              uniforms.pad[0];
            let d1 = offsetX + uniforms.dilation[0] * ((pos %
              uniforms.itemsPerBlockRow) / uniforms.inChannels);
            let ch = pos % uniforms.inChannels;
            if(d1 < uniforms.aShape[${t}] && d1 >= 0) {
              value = getA(d0, d1, ch);
            }
          }
          setOutputFlat(flatIndex, value);
        }
      }
    }
  `}};function AE({x:e,filter:t,convInfo:n,backend:r,bias:s=null,preluActivationWeights:a=null,leakyreluAlpha:o=0,activation:i=null}){let u=e.shape,l=n.dataFormat==="channelsLast",c=!1,d=!1,p=l?u[0]*u[1]*u[2]:u[0]*u[2]*u[3],h=We({inputs:{x:e},backend:r,attrs:{shape:[1,p,n.inChannels]}}),f=We({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}}),m=xk({a:h,b:f,transposeA:c,transposeB:d,backend:r,bias:s,activation:i,preluActivationWeights:a,leakyreluAlpha:o}),g=We({inputs:{x:m},backend:r,attrs:{shape:n.outShape}});return r.disposeData(h.dataId),r.disposeData(f.dataId),r.disposeData(m.dataId),g}function kue({x:e,filter:t,convInfo:n,backend:r,bias:s=null,preluActivationWeights:a=null,leakyreluAlpha:o=0,activation:i=null}){let{filterWidth:u,filterHeight:l,inChannels:c,strideWidth:d,strideHeight:p,padInfo:h,outWidth:f,outHeight:m,dilationWidth:g,dilationHeight:b,dataFormat:y}=n,v=y==="channelsLast",x=u*l*c,k=m*f,T=[k,x],C=!1,E=!1,F=[],O=We({inputs:{x:e},backend:r,attrs:{shape:e.shape.slice(1)}}),D=We({inputs:{x:t},backend:r,attrs:{shape:[1,x,-1]}});F.push(O),F.push(D);let R=new wue(T,v),_=[{type:"int32",data:[h.left,h.top]},{type:"int32",data:[d,p]},{type:"int32",data:[g,b]},{type:"int32",data:[f]},{type:"int32",data:[c*u]},{type:"int32",data:[c]}],L=r.runWebGPUProgram(R,[O],O.dtype,_),U=We({inputs:{x:L},backend:r,attrs:{shape:[1,T[0],T[1]]}});F.push(L),F.push(U);let j=[1,T[0],T[1]],K=new wE(j,[1,k,n.outChannels],X().get("WEBGPU_MATMUL_WORK_PER_THREAD"),C,E),q=j[1],Q=j[2],ee=n.outChannels,re=[{type:"int32",data:[q]},{type:"int32",data:[ee]},{type:"int32",data:[Q]}],se=r.runWebGPUProgram(K,[U,D],U.dtype,re),ne=v?[1,m,f,n.outChannels]:[1,n.outChannels,m,f],ie=We({inputs:{x:se},backend:r,attrs:{shape:ne}});F.push(se);for(let te of F)r.disposeData(te.dataId);return ie}var $E=class{constructor(e,t=!1,n=null,r=!1,s=!1){this.variableNames=["x","W"],this.uniforms=`filterDims : vec2<i32>; pad : vec2<i32>; stride : vec2<i32>; dilation : vec2<i32>;
      dimAOuter : i32; dimBOuter : i32; dimInner : i32;`,this.isVec4=!0,this.outputShape=e.outShape,w.assert(e.dataFormat==="channelsLast",()=>"TODO: NCHW is unimplemented"),this.dispatchLayout={x:[3],y:[1,2],z:[0]},this.workGroupSize=[8,8,1];let a=[4,4,1];this.dispatch=_e(this.dispatchLayout,this.outputShape,this.workGroupSize,a),this.convInfo=e,this.addBias=t,this.activation=n,this.hasPreluActivationWeights=r,this.hasLeakyreluAlpha=s,this.addBias&&this.variableNames.push("bias"),this.hasPreluActivationWeights&&this.variableNames.push("preluActivationWeights"),this.hasLeakyreluAlpha&&this.variableNames.push("leakyreluAlpha"),[this.fitA,this.fitB]=this.getShapeFit(a),this.shaderKey=`conv2DMMVec4_${this.activation}_${this.fitA}_${this.fitB}`}getShapeFit(e){let t=this.workGroupSize[1]*e[1],n=this.workGroupSize[0]*e[0],r=n,s=[t,r],a=[r,n],o=this.outputShape[1]*this.outputShape[2],i=this.outputShape[3],u=this.convInfo.filterHeight*this.convInfo.filterWidth*this.convInfo.inChannels;return[Us(s,[o,u]),Us(a,[u,i])]}getSampleAWithRemainder(e){return`let flatIndex${e} = getFlatIndex4D(coord, uniforms.xShape);
    let divBy4Remainder${e} = flatIndex${e} % 4;
    let divBy4Index${e} = flatIndex${e} / 4;
    let curData${e} = x.numbers[divBy4Index${e}];
    if (divBy4Remainder${e} == 0) {
      temp = curData${e};
    } else {
      // TODO: This could end up being a redundant load with another one in
      // the same shader invocation. Perhaps there's an opportunity for
      // optimization
      let nextData${e} = x.numbers[divBy4Index${e} + 1];
      if (divBy4Remainder${e} == 1) {
        temp = vec4<f32>(curData${e}.yzw, nextData${e}.x);
      } elseif (divBy4Remainder${e} == 2) {
        temp = vec4<f32>(curData${e}.zw, nextData${e}.xy);
      } elseif (divBy4Remainder${e} == 3) {
        temp = vec4<f32>(curData${e}.w, nextData${e}.xyz);
      }
    }
    `}getUserCode(){let t=xE([4,4,1],this.workGroupSize),s=`let outRow = r / uniforms.outShape[2];
        let outCol = r % uniforms.outShape[2];
        let WRow = c / (uniforms.filterDims[1] * uniforms.xShape[3]);
        let WCol = c / uniforms.xShape[3] % uniforms.filterDims[1];
        let inChCoord = c % uniforms.xShape[3];
        var coord = vec4<i32>(
            batch,
            outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0],
            outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1],
            inChCoord);
        var resData = vec4<f32>(0.0);
        ${this.convInfo.inChannels%4===0?`// The bounds checking is always needed since we use it to pad zero for
          // the 'same' padding type.
          if (coordsInBounds4D(coord, uniforms.xShape)) {
            resData = x.numbers[getFlatIndex4D(coord, uniforms.xShape) / 4];
          } else {
            resData = vec4<f32>(0.0); }`:`var temp = vec4<f32>(0.0);
          ${this.getSampleAWithRemainder(1)}
          resData = temp;
          if (WCol == (uniforms.filterDims[1] - 1)) {
            coord = vec4<i32>(
              coord.x, coord.y + 1, coord.z + 1 - uniforms.filterDims[1], 0);
              ${this.getSampleAWithRemainder(2)}
            if (inChCoord == 0) {
              resData = vec4<f32>(resData.xyz, temp.x);
            } elseif (inChCoord == 1) {
              resData = vec4<f32>(resData.xy, temp.xy);
            } else {
              resData = vec4<f32>(resData.x, temp.xyz);
            }
          }
          `}
        return resData;`,a=this.fitA?`${s}`:`if (r < uniforms.dimAOuter && c < uniforms.dimInner) {
          ${s}
         }
         return vec4<f32>(0.0);
        `,o=this.fitB?"return W.numbers[row * uniforms.dimBOuter / 4 + col];":`if(coordsInBounds2D(vec2<i32>(row, col * 4), vec2<i32>(uniforms.dimInner, uniforms.dimBOuter))) {
           return W.numbers[row * uniforms.dimBOuter / 4 + col];
         }
         return vec4<f32>(0.0);
        `,i="",u="";if(this.activation){let d=Gs(this.activation,this.isVec4);if(this.hasPreluActivationWeights)i=`fn activation(a : vec4<f32>, outCoord : vec4<i32>) -> vec4<f32> {
          let b = getPreluActivationWeightsAtOutCoordsByCoords(outCoord);
          ${d}
        }`;else{if(this.hasLeakyreluAlpha)throw i=`fn activation(a: vec4<f32>) -> vec4<f32> {
          let b = getLeakyreluAlphaAtOutCoords();
          ${d}
        }`,new Error("Leakyrelu is not supported.");i=`
        fn activation(a : vec4<f32>, outCoord : vec4<i32>) -> vec4<f32> {
          ${d}
        }`}u="value = activation(value, outCoord);"}let l=this.addBias?"value = value + getBiasAtOutCoordsByCoords(outCoord);":"";return`
        ${i}
        fn mm_readA(row : i32, col : i32, globalId : vec3<u32>) -> vec4<f32> {
          let r = row;
          let c = col * 4;
          var batch = i32(globalId.z);
          ${a}
        }

        fn mm_readB(row : i32, col : i32, globalId : vec3<u32>) -> vec4<f32> {
          ${o}
        }

        fn mm_write(row : i32, col : i32, valueInput : vec4<f32>, globalId : vec3<u32>) {
          var batch = i32(globalId.z);
          var value = valueInput;
          if (row < uniforms.dimAOuter && col * 4 < uniforms.dimBOuter)
          {
            let outCoord = vec4<i32>(
              batch,
              row / uniforms.outShape[2],
              row % uniforms.outShape[2],
              col * 4);
            ${l}
            ${u}
            setOutput(outCoord[0], outCoord[1], outCoord[2], outCoord[3],
              value);
          }
        }
        ${t}
      `}},FE=class{constructor(e,t=!1,n=null,r=!1){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>; pad : vec2<i32>; stride : vec2<i32>; dilation : vec2<i32>; dimAOuter : i32; dimBOuter : i32; dimInner : i32;",this.outputShape=e.outShape,w.assert(e.dataFormat==="channelsLast",()=>"TODO: NCHW is unimplemented"),this.dispatchLayout={x:[3],y:[1,2],z:[0]},this.workGroupSize=fk(this.dispatchLayout,this.outputShape),this.elementsPerThread=gk(this.dispatchLayout,this.outputShape),this.dispatch=_e(this.dispatchLayout,this.outputShape,this.workGroupSize,this.elementsPerThread),t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=t,this.activation=n,this.hasPreluActivationWeights=r,[this.fitA,this.fitB]=this.getShapeFit(),this.shaderKey=`conv2DMM_${this.elementsPerThread}_${this.activation}_${this.fitA}_${this.fitB}`}getShapeFit(){let e=this.workGroupSize[1]*this.elementsPerThread[1],t=this.workGroupSize[0]*this.elementsPerThread[0],n=e>t?e:t;w.assert(n%this.workGroupSize[0]==0&&n%this.workGroupSize[1]==0,()=>"tileInner must be multiple of workgroupsize.x and workgroupsize.y");let r=[e,n],s=[n,t],a=this.outputShape[1]*this.outputShape[2],o=this.outputShape[3],i=this.convInfo.filterHeight*this.convInfo.filterWidth*this.convInfo.inChannels;return[Us(r,[a,i]),Us(s,[i,o])]}getUserCode(){let e=vk(this.elementsPerThread,this.workGroupSize),t=`
    let outRow = row / uniforms.outShape[2];
    let outCol = row % uniforms.outShape[2];

    let WRow = col / (uniforms.filterDims[1] * uniforms.xShape[3]);
    let WCol = col / uniforms.xShape[3] % uniforms.filterDims[1];
    let coord = vec4<i32>(
        batch,
        outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0],
        outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1],
        col % uniforms.xShape[3]);
    // The bounds checking is always needed since we use it to pad zero for the
    // 'same' padding type.
    if(coordsInBounds4D(coord, uniforms.xShape)) {
      return x.numbers[getFlatIndex4D(coord, uniforms.xShape)];
    }
    return 0.0;`,n=this.fitA?`${t}`:`if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
      ${t}
    }
    return 0.0;
    `,r=this.fitB?"return W.numbers[row * uniforms.dimBOuter + col];":`if(coordsInBounds2D(vec2<i32>(row, col), vec2<i32>(uniforms.dimInner, uniforms.dimBOuter))) {
           return W.numbers[row * uniforms.dimBOuter + col];
	 }
	 return 0.0;
	 `,s="",a="";if(this.activation){let u=Gs(this.activation,!1);this.hasPreluActivationWeights?s=`fn activation(a: f32, outCoord : vec4<i32>) -> f32 {
                  let b = getPreluActivationWeightsAtOutCoordsByCoords(outCoord);
                  ${u}
                }`:s=`
                  fn activation(a : f32, outCoord : vec4<i32>) -> f32 {
                    ${u}
                  }
                `,a="value = activation(value, outCoord);"}let o=this.addBias?"value = value + getBiasAtOutCoordsByCoords(outCoord);":"";return`
    ${s}
    fn mm_readA(row : i32, col : i32, globalId : vec3<u32>) -> f32 {
      var batch = i32(globalId.z);
      ${n}
    }

    fn mm_readB(row : i32, col : i32, globalId : vec3<u32>) -> f32 {
      ${r}
    }

    fn mm_write(row : i32, col : i32, valueInput : f32, globalId : vec3<u32>) {
      var batch = i32(globalId.z);
      var value = valueInput;
      let outCoord = vec4<i32>(
          batch,
          row / uniforms.outShape[2],
          row % uniforms.outShape[2],
          col);
      ${o}
      ${a}
      result.numbers[getFlatIndex4D(outCoord, uniforms.outShape)] = value;
    }
    ${e}
  `}},DE=class{constructor(e,t=!1,n=null,r=!1){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>; pad : vec2<i32>; stride : vec2<i32>; dilation : vec2<i32>;",this.workGroupSize=[128,1,1],this.outputShape=e.outShape,this.dispatchLayout=ze(this.outputShape),this.dispatch=_e(this.dispatchLayout,this.outputShape,this.workGroupSize),w.assert(e.dataFormat==="channelsLast",()=>"TODO: NCHW is unimplemented"),t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=t,this.activation=n,this.hasPreluActivationWeights=r,this.shaderKey=`conv2DNaive_${this.activation}`}getUserCode(){let e="",t="";if(this.activation){let s=Gs(this.activation);this.hasPreluActivationWeights?e=`fn activation(a : f32, outCoord : vec4<i32>) -> f32{
               let b = getPreluActivationWeightsAtOutCoordsByCoords(outCoord);
               ${s}
             }`:e=`
                  fn activation(a : f32, outCoord : vec4<i32>) -> f32{
                    ${s}
                  }
                `,t="value = activation(value, outCoord);"}let n=this.addBias?"value = value + getBiasAtOutCoordsByCoords(outCoord);":"";return`
      ${e}
      fn readInp(batch : i32, row : i32, col : i32, chan : i32) -> f32 {
        let coord = vec4<i32>(batch, row, col, chan);
        if(coordsInBounds4D(coord, uniforms.xShape)) {
          return getX(batch, row, col, chan);
        }
        return 0.0;
      }

      fn readFilt(row : i32, col : i32, xChannel : i32, outChannel : i32) -> f32{
        let coord = vec4<i32>(row, col, xChannel, outChannel);
        if(coordsInBounds4D(coord, uniforms.wShape)) {
          return getW(row, col, xChannel, outChannel);
        }
        return 0.0;
      }

      fn writeResult(batch : i32, row : i32, col : i32, chan : i32, value : f32) {
        let coord = vec4<i32>(batch, row, col, chan);
        if (coordsInBounds4D(coord, uniforms.outShape)) {
          ${n}
          ${t}
          setOutput(batch, row, col, chan, value);
        }
      }

      ${hk()} {
        let coords = getOutputCoordsWithFlatDispatchLayout(globalId, localId, numWorkgroups);
        let batch = coords[0];
        let outChannel = coords[3];

        var acc = 0.0;

        for (var row = 0; row < uniforms.filterDims[0]; row = row + 1) {
          for (var col = 0; col < uniforms.filterDims[1]; col = col + 1) {
            for (var xChannel = 0; xChannel < uniforms.xShape[3]; xChannel = xChannel + 1) {
              let coordRow = coords[1] * uniforms.stride[0] + uniforms.dilation[0] * row - uniforms.pad[0];
              let coordCol = coords[2] * uniforms.stride[1] + uniforms.dilation[1] * col - uniforms.pad[1];
              let v = readInp(batch, coordRow, coordCol, xChannel);
              let f = readFilt(row, col, xChannel, outChannel);
              acc = acc + v * f;
            }
          }
        }

        writeResult(batch, coords[1], coords[2], outChannel, acc);
      }
    `}};function Iue(e){let{inputs:t,attrs:n,backend:r}=e,{x:s,filter:a}=t,{strides:o,pad:i,dataFormat:u,dilations:l,dimRoundingMode:c}=n,d=N.convertConv2DDataFormat(u),p=N.computeConv2DInfo(s.shape,a.shape,o,l,i,c,!1,d);if(p.filterHeight===1&&p.filterWidth===1&&p.dilationHeight===1&&p.dilationWidth===1&&p.strideHeight===1&&p.strideWidth===1&&(p.padInfo.type==="SAME"||p.padInfo.type==="VALID"))return AE({x:s,filter:a,convInfo:p,backend:r});if(X().getBool("WEBGPU_CONV_SEPARATE_IM2COL_SHADER")&&s.shape[0]===1)return kue({x:s,filter:a,convInfo:p,backend:r});let h,f=[p.padInfo.top,p.padInfo.left],m=[{type:"int32",data:[p.filterHeight,p.filterWidth]},{type:"int32",data:[...f]},{type:"int32",data:[p.strideHeight,p.strideWidth]},{type:"int32",data:[p.dilationHeight,p.dilationWidth]}],g=X().getBool("WEBGPU_USE_NAIVE_CONV2D");if(g?h=new DE(p):(p.inChannels%4==0||p.inChannels===3&&p.padInfo.type==="VALID")&&p.outChannels%4==0&&p.outChannels>=64?h=new $E(p):h=new FE(p),!g){let b=p.outShape[1]*p.outShape[2],y=p.outShape[3],v=p.filterHeight*p.filterWidth*p.inShape[3];m.push({type:"int32",data:[b]},{type:"int32",data:[y]},{type:"int32",data:[v]})}return r.runWebGPUProgram(h,[s,a],s.dtype,m)}var Sue={kernelName:ga,backendName:"webgpu",kernelFunc:Iue},Cue=class{constructor(e){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>; pads : vec2<i32>; stride : vec2<i32>; outBackprop : vec4<i32>; dimAOuter : i32; dimBOuter : i32; dimInner : i32;",this.outputShape=e.inShape,w.assert(e.dataFormat==="channelsLast",()=>"TODO: NCHW is unimplemented"),this.dispatchLayout={x:[3],y:[1,2],z:[0]},this.workGroupSize=fk(this.dispatchLayout,this.outputShape),this.elementsPerThread=gk(this.dispatchLayout,this.outputShape),this.dispatch=_e(this.dispatchLayout,this.outputShape,this.workGroupSize,this.elementsPerThread),this.shaderKey=`conv2DDerInputMM_${this.elementsPerThread}`}getUserCode(){return`
    fn mm_readA(row : i32, col : i32, globalId : vec3<u32>) -> f32 {
      var batch = i32(globalId.z);
      if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
      
    let outRow = row / uniforms.outShape[2];
    let outCol = row % uniforms.outShape[2];

    let WRow = col / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
    let WCol = col / uniforms.outBackprop[3] % uniforms.filterDims[1];
    let xR = f32(outRow - uniforms.pads[0] + WRow) / f32(uniforms.stride[0]);
    let xC = f32(outCol - uniforms.pads[1] + WCol) / f32(uniforms.stride[1]);
    if (xR < 0.0 || xR >= f32(uniforms.outBackprop[1]) || fract(xR) > 0.0) {
      return 0.0;
    }
    if (xC < 0.0 || xC >= f32(uniforms.outBackprop[2]) || fract(xC) > 0.0) {
      return 0.0;
    }
    let coord = vec4<i32>(
        batch,
        i32(xR),
        i32(xC),
        col % uniforms.outBackprop[3]);
    return x.numbers[getFlatIndex4D(coord, uniforms.xShape)];
    }
    return 0.0;
    }

    fn mm_readB(row : i32, col : i32, globalId : vec3<u32>) -> f32 {
      let coordX = uniforms.filterDims.x - 1 -
          row / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
      let coordY = uniforms.filterDims.y - 1 -
          (row / uniforms.outBackprop[3]) % uniforms.filterDims[1];
      if (row < uniforms.dimInner && col < uniforms.dimBOuter &&
          coordX >= 0 && coordY >= 0) {
        let coord = vec4<i32>(coordX, coordY, col,
            row % uniforms.outBackprop[3]);
        return W.numbers[getFlatIndex4D(coord, uniforms.wShape)];
      }
      return 0.0;
    }

    fn mm_write(row : i32, col : i32, valueInput : f32, globalId : vec3<u32>) {
      var batch = i32(globalId.z);
      var value = valueInput;
      let outCoord = vec4<i32>(
          batch,
          row / uniforms.outShape[2],
          row % uniforms.outShape[2],
          col);
      result.numbers[getFlatIndex4D(outCoord, uniforms.outShape)] = value;
    }

    ${vk(this.elementsPerThread,this.workGroupSize)}
  `}},Tue=class{constructor(e){this.variableNames=["dy","W"],this.uniforms="filterDims : vec2<i32>; pads : vec2<i32>; stride : vec2<i32>; outBackprop : vec4<i32>;",this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=ze(this.outputShape),this.dispatch=_e(this.dispatchLayout,this.outputShape,this.workGroupSize),this.isChannelsLast=e.dataFormat==="channelsLast",this.shaderKey=`conv2DDerInput_${this.isChannelsLast}`}getUserCode(){let e=this.isChannelsLast?1:2,t=this.isChannelsLast?2:3,n=this.isChannelsLast?3:1;return`
    ${Ue()} {
      if(index < uniforms.size) {
        let coords = getCoordsFromFlatIndex(index);
        let batch = coords[0];
        let d1 = coords[${n}];

        let dyCorner = vec2<i32>(coords[${e}]), coords[${t}]) - uniforms.pads;
        let dyRCorner = dyCorner.x;
        let dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {
          let dyR = (f32(dyRCorner) + f32(wR)) / f32(uniforms.stride.x);
          let wRPerm = uniforms.filterDims.x - 1 - wR;
          if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) || fract(dyR) > 0.0 ||
              wRPerm < 0) {
            continue;
          }
          let idyR = dyR;

          for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {
            let dyC = (f32(dyCCorner) + f32(wC)) / f32(uniforms.stride.y);
            let wCPerm = uniforms.filterDims.y - 1 - wC;
            if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||
                fract(dyC) > 0.0 || wCPerm < 0) {
              continue;
            }
            let idyC = dyC;

            for (var d2 = 0; d2 < uniforms.outBackprop[3]; d2 = d2 + 1) {
              if (${this.isChannelsLast}) {
                let xValue = getDy(batch, idyR, idyC, d2);
                let wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd = dotProd + xValue * wValue;
              } else {
                let xValue = getDy(batch, d2, idyR, idyC);
                let wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd = dotProd + xValue * wValue;
              }

            }
          }
        }
        setOutputFlat(index, dotProd);
      }
    }
  `}};function Nue(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{inputShape:o,strides:i,pad:u,dataFormat:l,dimRoundingMode:c}=r,d=N.convertConv2DDataFormat(l),p=N.computeConv2DInfo(o,a.shape,i,1,u,c,!1,d),h=[{type:"int32",data:[p.filterHeight,p.filterWidth]},{type:"int32",data:[p.filterHeight-1-p.padInfo.top,p.filterWidth-1-p.padInfo.left]},{type:"int32",data:[p.strideHeight,p.strideWidth]},{type:"int32",data:[p.batchSize,p.outHeight,p.outWidth,p.outChannels]}],f;if(X().getBool("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE"))f=new Tue(p);else{f=new Cue(p);let m=p.inShape[1]*p.inShape[2],g=p.inShape[3],b=p.filterHeight*p.filterWidth*p.outChannels;h.push({type:"uint32",data:[m]},{type:"uint32",data:[g]},{type:"uint32",data:[b]})}return n.runWebGPUProgram(f,[s,a],"float32",h)}var _ue={kernelName:ba,backendName:"webgpu",kernelFunc:Nue},Eue=fn({opType:bt.COS}),Aue={kernelName:ya,backendName:"webgpu",kernelFunc:Eue},$ue=fn({opType:bt.COSH}),Fue={kernelName:va,backendName:"webgpu",kernelFunc:$ue},Due=class{constructor(e,t,n,r){this.variableNames=["Image","Boxes","BoxInd"],this.uniforms="extrapolationValue : f32;",this.workGroupSize=[64,1,1],this.size=!0;let[s]=t;this.outputShape=[s,n[0],n[1],e],this.dispatchLayout=ze(this.outputShape),this.dispatch=_e(this.dispatchLayout,this.outputShape,this.workGroupSize),this.methodId=r==="bilinear"?1:0,this.cropHeightBiggerThan1=this.outputShape[1]>1,this.cropWidthBiggerThan1=this.outputShape[2]>1,this.shaderKey=`cropAndResize_${this.methodId}_${this.cropHeightBiggerThan1}_${this.cropWidthBiggerThan1}`}getUserCode(){let[e,t]=["f32(uniforms.imageShape[1] - 1)","f32(uniforms.imageShape[2] - 1)"],[n,r,s]=this.cropHeightBiggerThan1?[`(${e} / f32(uniforms.outShape[1] - 1))`,"(y2-y1) * height_ratio",`y1*${e} + f32(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${e}`],[a,o,i]=this.cropWidthBiggerThan1?[`(${t} / f32(uniforms.outShape[2] - 1))`,"(x2-x1) * width_ratio",`x1*${t} + f32(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${t}`];return`
      ${Ue()}
      if (index < uniforms.size) {
        let coords = getCoordsFromFlatIndex(index);
        let height_ratio = f32(${n});
        let width_ratio = f32(${a});
        let b = coords[0];
        let y = coords[1];
        let x = coords[2];
        let d = coords[3];
        // get box vals
        let y1 = getBoxes(b, 0);
        let x1 = getBoxes(b, 1);
        let y2 = getBoxes(b, 2);
        let x2 = getBoxes(b, 3);
        // get image in batch index
        let bInd = i32(round(getBoxInd(b)));
        if(bInd < 0 || bInd >= uniforms.outShape[0]) {
          return;
        }
        let height_scale = ${r};
        let width_scale = ${o};
        let in_y = ${s};
        if( in_y < 0.0 || in_y > ${e} ) {
          setOutputFlat(index, uniforms.extrapolationValue);
          return;
        }
        let in_x = ${i};
        if( in_x < 0.0 || in_x > ${t} ) {
          setOutputFlat(index, uniforms.extrapolationValue);
          return;
        }
        let sourceFracIndexCR = vec2<f32>(in_x,in_y);
        if(${this.methodId} == 1) {
          // Compute the four integer indices.
          let sourceFloorCR = vec2<i32>(sourceFracIndexCR);
          let sourceCeilCR = vec2<i32>(ceil(sourceFracIndexCR));
          let topLeft = getImage(bInd, sourceFloorCR.y, sourceFloorCR.x, d);
          let bottomLeft = getImage(bInd, sourceCeilCR.y, sourceFloorCR.x, d);
          let topRight = getImage(bInd, sourceFloorCR.y, sourceCeilCR.x, d);
          let bottomRight = getImage(bInd, sourceCeilCR.y, sourceCeilCR.x, d);
          let fracCR = sourceFracIndexCR - vec2<f32>(sourceFloorCR);
          let top = topLeft + (topRight - topLeft) * fracCR.x;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          let newValue = top + (bottom - top) * fracCR.y;
          setOutputFlat(index, newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          let sourceNearestCR = vec2<i32>(floor(
            sourceFracIndexCR + vec2<f32>(0.5,0.5)));
          let newValue = getImage(
            bInd, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutputFlat(index, newValue);
        }
      }
    }
    `}},Rue=e=>{let{inputs:t,backend:n,attrs:r}=e,{image:s,boxes:a,boxInd:o}=t,{cropSize:i,method:u,extrapolationValue:l}=r,c=new Due(s.shape[3],a.shape,i,u),d=[{type:"float32",data:[l]}];return n.runWebGPUProgram(c,[s,a,o],"float32",d)},Pue={kernelName:jo,backendName:"webgpu",kernelFunc:Rue},Oue=class{constructor(e,t){this.variableNames=["x"],this.workGroupSize=[64,1,1],this.size=!0,this.uniforms="blockSize : i32;",this.outputShape=e,this.dispatchLayout=ze(this.outputShape),this.dispatch=_e(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey=`depthToSpace_${t}`,this.dataFormat=t}getUserCode(){return`
      ${Ue()}
        if (index < uniforms.size) {
          let coords = getCoordsFromFlatIndex(index);
          let b = coords[0];
          let h = ${this.getHeightCoordString()};
          let w = ${this.getWidthCoordString()};
          let d = ${this.getDepthCoordString()};

          let in_h = h / uniforms.blockSize;
          let offset_h = h % uniforms.blockSize;
          let in_w = w / uniforms.blockSize;
          let offset_w = w % uniforms.blockSize;
          let offset_d = (offset_h * uniforms.blockSize + offset_w) *
            ${this.getOutputDepthSize()};
          let in_d = d + offset_d;

          let rlt = ${this.getInputSamplingString()};
          setOutputFlat(index, rlt);
        }
      }`}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?"uniforms.outShape[3]":"uniforms.outShape[1]"}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}};function Mue(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockSize:a,dataFormat:o}=r,i=s.shape[0],u=o==="NHWC"?s.shape[1]:s.shape[2],l=o==="NHWC"?s.shape[2]:s.shape[3],c=o==="NHWC"?s.shape[3]:s.shape[1],d=u*a,p=l*a,h=c/(a*a),f=o==="NHWC"?[i,d,p,h]:[i,h,d,p],m=[{type:"int32",data:[a]}],g=new Oue(f,o);return n.runWebGPUProgram(g,[s],s.dtype,m)}var Lue={kernelName:qo,backendName:"webgpu",kernelFunc:Mue},RE=class{constructor(e,t=!1,n=null,r=!1){this.variableNames=["x","W"],this.uniforms="pad : vec2<i32>; stride : vec2<i32>; dilation : vec2<i32>; inDims : vec2<i32>;",this.workGroupSize=[4,4,4],this.isVec4=!0,this.outputShape=e.outShape,this.dispatchLayout={x:[0,1],y:[2],z:[3]},this.dispatch=_e(this.dispatchLayout,this.outputShape,this.workGroupSize,[1,4,4]),w.assert(e.dataFormat==="channelsLast",()=>"TODO: NCHW is unimplemented"),t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=t,this.activation=n,this.hasPreluActivation=r,this.shaderKey=`depthwise3x3_${n}`}getUserCode(){let e="",t="";if(this.activation){let s=Gs(this.activation,this.isVec4);this.hasPreluActivation?e=`fn activation(a : vec4<f32>, outCoord : vec4<i32>) -> vec4<f32> {
          let b = getPreluActivationWeightsAtOutCoordsByCoords(outCoord);
          ${s}
        }`:e=`
        fn activation(a : vec4<f32>, outCoord : vec4<i32>) -> vec4<f32> {
            ${s}
          }
        `,t="dotProd[i] = activation(dotProd[i], coords);"}let n=this.addBias?"dotProd[i] = dotProd[i] + getBiasAtOutCoordsByCoords(coords);":"";return`
      ${e}

      ${zm()}
      fn main([[builtin(global_invocation_id)]] globalId: vec3<u32>) {
        let batch = 0;
        let r = i32(globalId.x);
        let c = i32(globalId.y) * 4;
        let d2 = i32(globalId.z) * 4;
        let xRCCorner = vec2<i32>(r, c) * uniforms.stride - uniforms.pad;
        let d1 = d2;
        let q = 0;

        let xRCorner = xRCCorner.x;
        let xCCorner = xRCCorner.y;

        var wVals : array<vec4<f32>, 9>;
        wVals[0] = getW(0, 0, d1, q);
        wVals[1] = getW(0, 1, d1, q);
        wVals[2] = getW(0, 2, d1, q);
        wVals[3] = getW(1, 0, d1, q);
        wVals[4] = getW(1, 1, d1, q);
        wVals[5] = getW(1, 2, d1, q);
        wVals[6] = getW(2, 0, d1, q);
        wVals[7] = getW(2, 1, d1, q);
        wVals[8] = getW(2, 2, d1, q);

        var xVals : array<array<vec4<f32>, 6>, 3>;
        for (var wR = 0; wR < 3; wR = wR + 1) {
          let xR = xRCorner + wR * uniforms.dilation[0];
          for (var wC = 0; wC < 6; wC = wC + 1) {
            let xC = xCCorner + wC * uniforms.dilation[1];
            if (xR < 0 || xR >= uniforms.inDims[0] || xC < 0 || xC >= uniforms.inDims[1]) {
              xVals[wR][wC] = vec4<f32>(0.0);
            } else {
              xVals[wR][wC] = getX(batch, xR, xC, d1);
            }
          }
        }

        var dotProd : array<vec4<f32>, 4>;
        dotProd[0] = vec4<f32>(0.0);
        dotProd[1] = vec4<f32>(0.0);
        dotProd[2] = vec4<f32>(0.0);
        dotProd[3] = vec4<f32>(0.0);

        for (var wR = 0; wR < 3; wR = wR + 1) {
          for (var wC = 0; wC < 3; wC = wC + 1) {
            let indexW = wR * 3 + wC;
            dotProd[0] = dotProd[0] + xVals[wR][0 + wC] * wVals[indexW];
            dotProd[1] = dotProd[1] + xVals[wR][1 + wC] * wVals[indexW];
            dotProd[2] = dotProd[2] + xVals[wR][2 + wC] * wVals[indexW];
            dotProd[3] = dotProd[3] + xVals[wR][3 + wC] * wVals[indexW];
          }
        }

        for (var i = 0; i < 4; i = i + 1) {
          let coords = vec4<i32>(batch, r, c + i, d2);
          if (coordsInBounds4D(coords, uniforms.outShape)) {
            ${n}
            ${t}
            setOutput(coords[0], coords[1], coords[2], coords[3], dotProd[i]);
          }
        }
      }
    `}},PE=class{constructor(e,t=!1,n=null,r=!1){this.variableNames=["x","W"],this.uniforms=`pad : vec2<i32>; stride : vec2<i32>; dilation : vec2<i32>;
      inDims : vec2<i32>; filterHeight : i32; filterWidth : i32;
      channelMul : i32;`,this.workGroupSize=[256,1,1],this.outputShape=e.outShape,this.dispatchLayout=ze(this.outputShape),this.dispatch=_e(this.dispatchLayout,this.outputShape,this.workGroupSize),w.assert(e.dataFormat==="channelsLast",()=>"TODO: NCHW is unimplemented"),t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=t,this.activation=n,this.hasPreluActivation=r,this.shaderKey=`depthwise_${this.activation}`}getUserCode(){let e="",t="";if(this.activation){let s=Gs(this.activation,!1);this.hasPreluActivation?e=`fn activation(a : f32, outCoord : vec4<i32>) -> f32 {
          let b = getPreluActivationWeightsAtOutCoordsByCoords(outCoord);
          ${s}
        }`:e=`
          fn activation(a : f32, outCoord : vec4<i32>) -> f32 {
            ${s}
          }
        `,t="dotProd = activation(dotProd, coords);"}let n=this.addBias?"dotProd = dotProd + getBiasAtOutCoordsByCoords(coords);":"";return`
      ${e}

      fn writeResult(batch : i32, row : i32, col : i32, chan : i32,
          value : f32) {
        let coord = vec4<i32>(batch, row, col, chan);
        if (coordsInBounds4D(coord, uniforms.outShape)) {
          setOutput(batch, row, col, chan, value);
        }
      }

      ${hk()} {
        let coords = getOutputCoordsWithFlatDispatchLayout(globalId,
            localId, numWorkgroups);
        let batch = coords[0];
        let xRCCorner = vec2<i32>(coords.yz) * uniforms.stride - uniforms.pad;
        let d2 = coords[3];
        let d1 = d2 / uniforms.channelMul;
        let q = d2 - d1 * uniforms.channelMul;

        let inputRowStart = xRCCorner.x;
        let inputColStart = xRCCorner.y;
        let inputRowEnd = inputRowStart + uniforms.filterHeight *
            uniforms.dilation[0];
        let inputColEnd = inputColStart + uniforms.filterWidth *
            uniforms.dilation[1];

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;

        // Extract if checking out of for loop for performance.
        if (inputRowStart >= 0 && inputColStart >= 0 &&
          inputRowEnd < uniforms.inDims[0] &&
              inputColEnd < uniforms.inDims[1]) {
            // Here using a constant value |this.convInfo.filterHeight| instead
            // of uniform value is in order to loop unrolling.
            for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {
              let xR = inputRowStart + wR * uniforms.dilation[0];

              for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {
                let xC = inputColStart + wC * uniforms.dilation[1];

                let xVal = getX(batch, xR, xC, d1);
                let wVal = getW(wR, wC, d1, q);
                dotProd = dotProd + xVal * wVal;
              }
            }
          } else {
            for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {
              let xR = inputRowStart + wR * uniforms.dilation[0];

              if (xR < 0 || xR >= uniforms.inDims[0]) {
                continue;
              }

              for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {
                let xC = inputColStart + wC * uniforms.dilation[1];

                if (xC < 0 || xC >= uniforms.inDims[1]) {
                  continue;
                }

                let xVal = getX(batch, xR, xC, d1);
                let wVal = getW(wR, wC, d1, q);
                dotProd = dotProd + xVal * wVal;
              }
            }
          }

        ${n}
        ${t}
        writeResult(batch, coords[1], coords[2], d2, dotProd);
      }
    `}};function Bue(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:o,pad:i,dilations:u,dimRoundingMode:l}=r,c=u;c==null&&(c=[1,1]);let d=N.computeConv2DInfo(s.shape,a.shape,o,c,i,l,!0),p=[{type:"int32",data:[d.padInfo.top,d.padInfo.left]},{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.dilationHeight,d.dilationWidth]},{type:"int32",data:[d.inHeight,d.inWidth]}],h;return d.batchSize===1&&d.inHeight===d.outHeight&&d.inWidth===d.outWidth&&d.strideHeight===1&&d.strideWidth===1&&d.filterHeight===d.filterWidth&&d.inChannels===d.outChannels&&d.filterHeight===3&&d.inChannels%4==0?h=new RE(d):(h=new PE(d),p.push({type:"int32",data:[d.filterHeight]},{type:"int32",data:[d.filterWidth]},{type:"int32",data:[d.outChannels/d.inChannels]})),n.runWebGPUProgram(h,[s,a],s.dtype,p)}var zue={kernelName:xa,backendName:"webgpu",kernelFunc:Bue},OE=Rn({opSnippet:Mt.MUL,cpuKernelImpl:Iie,supportsComplex:!0}),Wue={kernelName:Ma,backendName:"webgpu",kernelFunc:OE},Vue=class{constructor(e,t){this.workGroupSize=[64,1,1],this.variableNames=["x"],this.uniforms="reduceSize : i32;",this.size=!0,this.inputShape=[e.batchSize,e.inSize];let[n]=N.computeOutAndReduceShapes(this.inputShape,[1]);this.outputShape=n.length===0?[1]:n,this.dispatchLayout=ze(this.outputShape),this.dispatch=_e(this.dispatchLayout,this.outputShape,[1,1,1]),this.reduceType=t,this.shaderKey=`reduce_${t}`}getUserCode(){let e="",t="0.0";this.reduceType==="min"||this.reduceType==="max"?(e=`
         if (isNanCustom(candidate)) {
          bestValue = uniforms.NAN;
         } elseif (!isNanCustom(bestValue) && candidate ${this.reduceType==="min"?"<":">"} bestValue)
           {  bestValue = candidate; }`,t="f32(x.numbers[offset])"):this.reduceType==="sum"||this.reduceType==="mean"?e=" bestValue = bestValue + candidate; ":this.reduceType==="prod"&&(e=" bestValue = bestValue * candidate; ",t="1.0");let n=this.reduceType==="mean"?"setOutputFlat(outputIndex, bestValue / f32(uniforms.reduceSize));":"setOutputFlat(outputIndex, bestValue);";return`
       fn DIV_CEIL(a : u32, b : u32) -> u32 {
        return ((a - 1u) / b + 1u);
       }

       ${`
         var<workgroup> xBestValues : array<f32, ${this.workGroupSize[0]}>;
       `}
       fn getOffset(outputIndex : i32) -> i32 {
         let outputCoords = getCoordsFromFlatIndex(outputIndex);
         let offset = ${this.outputShape.length===1?"outputCoords":"outputCoords[0]"} * uniforms.reduceSize;
          return offset;
       }
       ${Ue()}
         let outputIndex = index / i32(workGroupSizeX);
         let offset = getOffset(outputIndex);
         var bestValue = ${t};
         let Length = uniforms.reduceSize;
         let WorkPerThread = DIV_CEIL(u32(Length), workGroupSizeX);
         for (var k = i32(localId.x); k < Length && outputIndex < uniforms.size;
             k = k + i32(workGroupSizeX)) {
           let candidate = f32(x.numbers[offset + k]);
           ${e}
         }
         xBestValues[localId.x] = bestValue;
         workgroupBarrier();

         var reduceSize = min(u32(Length), workGroupSizeX);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (localId.x < currentSize) {
            let candidate = xBestValues[localId.x + interval];
            ${e}
            xBestValues[localId.x] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (localId.x == 0u && outputIndex < uniforms.size) {
          ${n}
        }
       }
     `}};function fp(e,t,n,r,s){let a=e.shape.length,o=[],i=w.parseAxisParam(t,e.shape),u=i,l=N.getAxesPermutation(u,a),c=e;l!=null&&(c=cu({inputs:{x:e},attrs:{perm:l},backend:s}),u=N.getInnerMostAxes(u.length,a),o.push(c)),N.assertAxesAreInnerMostDims(r,u,a);let[d,p]=N.computeOutAndReduceShapes(c.shape,u),h=d;n&&(h=N.expandShapeToKeepDim(d,i));let f;if((r==="max"||r==="prod")&&s.shouldExecuteOnCPU([c])){let m=s.tensorMap.get(c.dataId).values;switch(r){case"max":let g=xie(m,w.sizeFromShape(p),h,e.dtype);f=s.makeTensorInfo(h,e.dtype,g);break;case"prod":let{outVals:b,outShape:y,outDtype:v}=Tie(c.shape,c.dtype,m,u);f=s.makeTensorInfo(y,v,b);break;default:throw new Error(`${r} CPU implementation is not yet supported.`)}}else{let m=w.sizeFromShape(p),b=w.sizeFromShape(c.shape)/m,y={windowSize:m,inSize:m,batchSize:b,outSize:1},v=r==="mean"?"float32":bd(e.dtype),x=[{type:"int32",data:[m]}],k=new Vue(y,r),T=s.runWebGPUProgram(k,[c],v,x);o.push(T),f=We({inputs:{x:T},attrs:{shape:h},backend:s})}return o.forEach(m=>s.disposeData(m.dataId)),f}function Sk(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:o}=r;return fp(s,a,o,"sum",n)}var Uue={kernelName:Ka,backendName:"webgpu",kernelFunc:Sk};function Gue(e){let{inputs:t,backend:n,attrs:r}=e,{equation:s}=r,a=t,{allDims:o,summedDims:i,idDims:u}=N.decodeEinsumEquation(s,a.length);N.checkEinsumDimSizes(o.length,u,a);let{path:l,steps:c}=N.getEinsumComputePath(i,u),d=c.length,p=null,h=o.length,f=[];for(let m=0;m<d;++m){for(let g of c[m]){let{permutationIndices:b,expandDims:y}=N.getEinsumPermutation(h,u[g]),v;N.isIdentityPermutation(b)?v=a[g]:(v=cu({inputs:{x:a[g]},backend:n,attrs:{perm:b}}),f.push(v));let x=v.shape.slice();for(let k=0;k<y.length;++k)x.splice(y[k],0,1);w.arraysEqual(v.shape,x)||(v=We({inputs:{x:v},backend:n,attrs:{shape:x}}),f.push(v)),p===null?p=v:(p=OE({inputs:{a:v,b:p},backend:n}),f.push(p))}m<d-1&&(l[m]>=0&&(p=Sk({inputs:{x:p},backend:n,attrs:{axis:l[m]-(o.length-h),keepDims:!1}}),f.push(p)),h--)}for(let m of f)m!==p&&n.disposeData(m.dataId);return p}var Hue={kernelName:Ql,backendName:"webgpu",kernelFunc:Gue},jue=fn({opType:bt.ELU}),que={kernelName:ka,backendName:"webgpu",kernelFunc:jue},Kue=Rn({opSnippet:Mt.EQUAL,dtype:"bool",cpuKernelImpl:cie}),Xue={kernelName:Ko,backendName:"webgpu",kernelFunc:Kue},ME=fn({opType:bt.EXP,cpuKernelImpl:lie,dtype:"float32"}),Yue={kernelName:Ia,backendName:"webgpu",kernelFunc:ME};function Ck(e){let{inputs:t,attrs:n,backend:r}=e,{dim:s}=n,{input:a}=t,o=a.shape.length,i=a.shape.slice(),u=s;return s<0&&(w.assert(-(o+1)<=s,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),u=o+s+1),i.splice(u,0,1),We({inputs:{x:a},backend:r,attrs:{shape:i}})}var Que={kernelName:Xo,backendName:"webgpu",kernelFunc:Ck},Zue=fn({opType:bt.EXPM1,cpuKernelImpl:die}),Jue={kernelName:Yo,backendName:"webgpu",kernelFunc:Zue},ece=class{constructor(e){this.variableNames=[],this.outputShape=[],this.uniforms="value : f32;",this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=ze(this.outputShape),this.dispatch=_e(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="fill"}getUserCode(){return`
    ${Ue()}
      if (index < uniforms.size) {
        setOutputFlat(index, uniforms.value);
      }
    }
  `}};function sl(e){let{backend:t,attrs:n}=e,{shape:r,value:s}=n,{dtype:a}=n;if(a=a||w.inferDtype(s),a==="string"){let o=w.getArrayFromDType(a,w.sizeFromShape(r));return o.fill(s),t.makeTensorInfo(r,a,o)}else{let o=new ece(r),i=[{type:"float32",data:[s]}];return t.runWebGPUProgram(o,[],a,i)}}var tce={kernelName:Zu,backendName:"webgpu",kernelFunc:sl},nce=class{constructor(e){this.outputShape=[],this.variableNames=["x"],this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=ze(this.outputShape),this.dispatch=_e(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="flipLeftRight"}getUserCode(){return`
      ${Ue()}
        if (index < uniforms.size) {
          let coords = getCoordsFromFlatIndex(index);
          let coordX = uniforms.xShape[2] - coords[2] - 1;
          let outputValue = getX(coords[0], coords[1], coordX, coords[3]);
          setOutputFlat(index, outputValue);
        }
      }
    `}},rce={kernelName:Qo,backendName:"webgpu",kernelFunc:({inputs:e,backend:t})=>{let{image:n}=e,r=t,s=new nce(n.shape);return r.runWebGPUProgram(s,[n],n.dtype)}},sce=fn({opType:bt.FLOOR,cpuKernelImpl:pie}),ace={kernelName:Sa,backendName:"webgpu",kernelFunc:sce},oce=Rn({opSnippet:Mt.INT_DIV,dtype:"int32"}),ice={kernelName:Ca,backendName:"webgpu",kernelFunc:oce},uce=(e,t,n,r,s)=>{let a=[r,...n];return s&&a.push(s),e.createBindGroup({layout:t,entries:a.map((o,i)=>({binding:i,resource:o}))})},LE=(e,t,n,r,s,a=!1)=>{let o={dtype:s.dtype,shape:s.shape},i=Bae(r,o,t,a),u=e.createShaderModule({code:i});return e.createComputePipeline({layout:n,compute:{module:u,entryPoint:"main"}})};function BE(e,t,n,r="",s=""){return e.shaderKey+"_"+(e.workGroupSize?e.workGroupSize.join(","):"")+t.map(o=>o.length).join(",")+n.join(",")+e.variableNames.join(",")+r+s}function zE(e){let{externalImage:t,backend:n,attrs:r,outShape:s,useImport:a}=e,{numChannels:o}=r,i=w.sizeFromShape(s),u=w.computeStrides(s),l=n.makeTensorInfo(s,"int32"),c=n.getFromPixelsProgram(a?"import":"copyExternal");c.updateOutputShape(s);let d=[l.shape],p=[l.dtype,a?"import":"copyExternal"],h=BE(c,d,p),f=c.getLayout(n.device),m=n.getAndSavePipeline(h,()=>LE(n.device,c,f.pipelineLayout,[],l,!0));c.setPipeline(m),a||n.queue.copyExternalImageToTexture({source:t,origin:{x:0,y:0}},{texture:c.makeInputTexture(n.device,s[1],s[0])},[s[1],s[0]]);let g=n.tensorMap.get(l.dataId);g.bufferInfo.buffer=n.acquireBuffer(g.bufferInfo.byteSize);let b=[i,o,...u,...c.dispatch];c.setUniform(n.device,b);let y;if(a){let v={source:t};y=n.device.importExternalTexture(v)}else y=c.inputTexture.createView();return n.runFromPixelsProgram(c,g.bufferInfo.buffer,f,y,l.dataId),l}var cce={kernelName:cd,backendName:"webgpu",kernelFunc:lce},al;function lce(e){let{inputs:t,backend:n,attrs:r}=e,{pixels:s}=t,{numChannels:a}=r;if(s==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let o=typeof HTMLVideoElement!="undefined"&&s instanceof HTMLVideoElement,i=typeof HTMLImageElement!="undefined"&&s instanceof HTMLImageElement,u=typeof HTMLCanvasElement!="undefined"&&s instanceof HTMLCanvasElement||typeof OffscreenCanvas!="undefined"&&s instanceof OffscreenCanvas,l=typeof ImageBitmap!="undefined"&&s instanceof ImageBitmap,[c,d]=o?[s.videoWidth,s.videoHeight]:[s.width,s.height],p=[d,c,a];if(X().getBool("WEBGPU_USE_IMPORT")&&o)return zE({externalImage:s,backend:n,attrs:r,outShape:p,useImport:!0});if((o||i)&&(al==null&&(al=document.createElement("canvas").getContext("2d")),al.canvas.width=c,al.canvas.height=d,al.drawImage(s,0,0,c,d),s=al.canvas),l||u||o||i)return zE({externalImage:s,backend:n,attrs:r,outShape:p,useImport:!1});let h=s.data,f=h;if(a!=null&&a!==4){f=new Uint8Array(s.width*s.height*a);let b=h.length,y=0;for(let v=0;v<b;v++)v%4<a&&(f[y++]=h[v])}let m=n.makeTensorInfo(p,"int32"),g=n.tensorMap.get(m.dataId);return g.values=new Int32Array(f),n.maybeReleaseBuffer(m.dataId),n.uploadToGPU(m.dataId),m}var dce=class{constructor(e,t,n,r,s){this.uniforms="varianceEpsilon : f32;",this.workGroupSize=[128,1,1],this.size=!0,this.variableNames=["x","mean","variance"],N.assertAndGetBroadcastShape(e,t),N.assertAndGetBroadcastShape(e,n),this.outputShape=e,this.dispatchLayout=ze(this.outputShape),this.dispatch=_e(this.dispatchLayout,this.outputShape,this.workGroupSize),r!=null&&(N.assertAndGetBroadcastShape(e,r),this.variableNames.push("offset")),s!=null&&(N.assertAndGetBroadcastShape(e,s),this.variableNames.push("scale")),this.offsetShape=r,this.scaleShape=s,this.shaderKey="batchNorm"}getUserCode(){let e="0.0";this.offsetShape!=null&&(e="getOffsetAtOutCoordsByGlobalIndex(index)");let t="1.0";return this.scaleShape!=null&&(t="getScaleAtOutCoordsByGlobalIndex(index)"),`
      ${Ue()}
        if (index < uniforms.size)
        {
          let xValue = getXAtOutCoordsByGlobalIndex(index);
          let meanValue = getMeanAtOutCoordsByGlobalIndex(index);
          let varianValue = getVarianceAtOutCoordsByGlobalIndex(index);
          let offsetValue = ${e};
          let scaleValue = ${t};
          let inv = scaleValue * inverseSqrt(varianValue + f32(uniforms.varianceEpsilon));
          setOutputFlat(index,dot(vec3<f32>(xValue, -meanValue, offsetValue), vec3<f32>(inv, inv, 1.0)));
        }
      }
  `}},pce={kernelName:Ta,backendName:"webgpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{x:r,scale:s,offset:a,mean:o,variance:i}=e,{varianceEpsilon:u}=t,l=n,c=[r,o,i],d=null;a!=null&&(d=a.shape,c.push(a));let p=null;s!=null&&(p=s.shape,c.push(s));let h=new dce(r.shape,o.shape,i.shape,d,p),f=[{type:"float32",data:[u]}];return l.runWebGPUProgram(h,c,r.dtype,f)}};function hce(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:o,preluActivationWeights:i}=t,{strides:u,pad:l,dataFormat:c,dilations:d,dimRoundingMode:p,activation:h,leakyreluAlpha:f}=r,m=N.convertConv2DDataFormat(c),g=N.computeConv2DInfo(s.shape,a.shape,u,d,l,p,!1,m),b=o!=null,y=i!=null,v;if(g.filterHeight===1&&g.filterWidth===1&&g.dilationHeight===1&&g.dilationWidth===1&&g.strideHeight===1&&g.strideWidth===1&&(g.padInfo.type==="SAME"||g.padInfo.type==="VALID"))return AE({x:s,filter:a,convInfo:g,backend:n,bias:o,activation:h,preluActivationWeights:i,leakyreluAlpha:f});let x=X().getBool("WEBGPU_USE_NAIVE_CONV2D"),k=g.inChannels%4==0&&g.outChannels%4==0,T=[g.padInfo.top,g.padInfo.left],C=[{type:"int32",data:[g.filterHeight,g.filterWidth]},{type:"int32",data:[...T]},{type:"int32",data:[g.strideHeight,g.strideWidth]},{type:"int32",data:[g.dilationHeight,g.dilationWidth]}];if(x)v=new DE(g,b,h,y);else{k?v=new $E(g,b,h,y):v=new FE(g,b,h,y);let F=g.outShape[1]*g.outShape[2],O=g.outShape[3],D=g.filterHeight*g.filterWidth*g.inShape[3];C.push({type:"int32",data:[F]},{type:"int32",data:[O]},{type:"int32",data:[D]})}let E=[s,a];return b&&E.push(o),y&&E.push(i),n.runWebGPUProgram(v,E,s.dtype,C)}var fce={kernelName:no,backendName:"webgpu",kernelFunc:hce};function mce(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:o,preluActivationWeights:i}=t,{strides:u,pad:l,dilations:c,dimRoundingMode:d,activation:p}=r,h=c;h==null&&(h=[1,1]),w.assert(N.eitherStridesOrDilationsAreOne(u,h),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${u} and dilations '${h}'`);let f=N.computeConv2DInfo(s.shape,a.shape,u,h,l,d,!0),m=[s,a],g=o!=null,b=i!=null;g&&m.push(o),b&&m.push(i);let y=[{type:"int32",data:[f.padInfo.top,f.padInfo.left]},{type:"int32",data:[f.strideHeight,f.strideWidth]},{type:"int32",data:[f.dilationHeight,f.dilationWidth]},{type:"int32",data:[f.inHeight,f.inWidth]}],v;return f.batchSize===1&&f.inHeight===f.outHeight&&f.inWidth===f.outWidth&&f.strideHeight===1&&f.strideWidth===1&&f.filterHeight===f.filterWidth&&f.inChannels===f.outChannels&&f.filterHeight===3&&f.inChannels%4==0?v=new RE(f,g,p,b):(v=new PE(f,g,p,b),y.push({type:"int32",data:[f.filterHeight]},{type:"int32",data:[f.filterWidth]},{type:"int32",data:[f.outChannels/f.inChannels]})),n.runWebGPUProgram(v,m,"float32",y)}var gce={kernelName:ro,backendName:"webgpu",kernelFunc:mce},bce=class{constructor(e,t){this.variableNames=["A","indices"],this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=ze(this.outputShape),this.dispatch=_e(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey=`gathernd_${e}`,this.sliceDim=e,this.uniforms=`sliceDim : i32; strides : ${on(e)};`}getUserCode(){let e;return this.sliceDim>1?e="uniforms.strides[j]":e="uniforms.strides",`
        ${Ue()}
        if (index < uniforms.size) {
          let coords = getCoordsFromFlatIndex(index);
          var flattenIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexTemp = i32(round(getIndices(coords[0], j)));
            let strideNum = ${e};
            flattenIndex = flattenIndex + indexTemp * strideNum;
          }

          setOutputFlat(index, getA(flattenIndex, coords[1]));
        }
      }
      `}};function yce(e){let{inputs:t,backend:n}=e,{params:r,indices:s}=t,a=s.shape,o=a[a.length-1],i=w.sizeFromShape(r.shape),[u,l,c,d]=N.prepareAndValidate(r,s),p=We({inputs:{x:s},backend:n,attrs:{shape:[l,o]}}),h=We({inputs:{x:r},backend:n,attrs:{shape:[w.sizeFromShape(r.shape)/c,c]}});if(n.shouldExecuteOnCPU([r,s])||r.dtype==="string"){let y=n.readSync(s.dataId),v=n.bufferSync(r),x=hie(y,v,r.dtype,l,o,c,d,r.shape,i);return n.makeTensorInfo(u,r.dtype,x.values)}let f=new bce(o,[l,c]),m=[{type:"int32",data:[o]},{type:"int32",data:d}],g=n.runWebGPUProgram(f,[h,p],h.dtype,m),b=We({inputs:{x:g},backend:n,attrs:{shape:u}});return n.disposeData(p.dataId),n.disposeData(h.dataId),n.disposeData(g.dataId),b}var vce={kernelName:Jo,backendName:"webgpu",kernelFunc:yce},xce=class{constructor(e,t){this.variableNames=["A","indices"],this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=e.slice(),this.aShape=e,this.outputShape=t,this.dispatchLayout=ze(this.outputShape),this.dispatch=_e(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="gather"}getUserCode(){let e=wce(this.aShape,"i32");return`
      ${Ue()}
        if (index < uniforms.size) {
          let resRC = getCoordsFromFlatIndex(index);
          setOutputFlat(index, getA(${e}));
        }
      }
    `}};function wce(e,t="int"){let n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let s=0;s<e.length;s++)s===2?r.push(`${t}(getIndices(resRC.x, resRC.z))`):r.push(`${n[s]}`);return r.join()}function WE(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,indices:a}=t,{axis:o,batchDims:i}=r,u=w.parseAxisParam(o,s.shape)[0],l=N.segment_util.collectGatherOpShapeInfo(s,a,u,i),c=w.sizeFromShape(a.shape),d=[],p=We({inputs:{x:s},backend:n,attrs:{shape:[l.batchSize,l.outerSize,l.dimSize,l.sliceSize]}}),h=We({inputs:{x:a},backend:n,attrs:{shape:[l.batchSize,c/l.batchSize]}});d.push(p),d.push(h);let f=[l.batchSize,l.outerSize,c/l.batchSize,l.sliceSize];if(n.shouldExecuteOnCPU([s,a])){let v=n.tensorMap.get(h.dataId).values,x=$e(h.shape,h.dtype,v),T=n.tensorMap.get(p.dataId).values,C=$e(p.shape,p.dtype,T),E=fie(C,x,f);return d.forEach(F=>n.disposeData(F.dataId)),n.makeTensorInfo(l.outputShape,E.dtype,E.values)}let m=new xce(p.shape,f),g=n.runWebGPUProgram(m,[p,h],p.dtype);d.push(g);let b=We({inputs:{x:g},backend:n,attrs:{shape:l.outputShape}});return d.forEach(y=>n.disposeData(y.dataId)),b}var kce={kernelName:Zo,backendName:"webgpu",kernelFunc:WE},Ice=Rn({opSnippet:Mt.GREATER,cpuKernelImpl:gie,dtype:"bool"}),Sce={kernelName:ei,backendName:"webgpu",kernelFunc:Ice},Cce=Rn({opSnippet:Mt.GREATER_EQUAL,dtype:"bool",cpuKernelImpl:mie}),Tce={kernelName:Na,backendName:"webgpu",kernelFunc:Cce},Nce=Rn({opSnippet:Mt.LESS,dtype:"bool",cpuKernelImpl:yie}),_ce={kernelName:ni,backendName:"webgpu",kernelFunc:Nce},Ece=Rn({opSnippet:Mt.LESS_EQUAL,dtype:"bool",cpuKernelImpl:bie}),Ace={kernelName:ri,backendName:"webgpu",kernelFunc:Ece},$ce=fn({opType:bt.LOG,cpuKernelImpl:vie}),Fce={kernelName:Ea,backendName:"webgpu",kernelFunc:$ce},Dce=Rn({opSnippet:Mt.LOGICAL_AND,dtype:"bool"}),Rce={kernelName:si,backendName:"webgpu",kernelFunc:Dce},Pce=fn({opType:bt.LOGICAL_NOT}),Oce={kernelName:rc,backendName:"webgpu",kernelFunc:Pce};function VE(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reductionIndices:a,keepDims:o}=r;return fp(s,a,o,"max",n)}var Mce={kernelName:Aa,backendName:"webgpu",kernelFunc:VE},Lce=Rn({opSnippet:Mt.MAX,cpuKernelImpl:wie}),Bce={kernelName:$a,backendName:"webgpu",kernelFunc:Lce};function zce(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:o,pad:i,dimRoundingMode:u}=r,l=1,c=N.computePool2DInfo(s.shape,a,o,l,i,u),d,p=[];if(c.filterHeight===1&&c.filterWidth===1){if(w.arraysEqual(c.inShape,c.outShape))return Lr({inputs:{x:s},backend:n});d=new NE(c),p.push({type:"int32",data:[c.strideHeight,c.strideWidth]})}else d=new TE(c,"max"),p.push({type:"int32",data:[c.strideHeight,c.strideWidth]},{type:"int32",data:[c.padInfo.top,c.padInfo.left]},{type:"int32",data:[c.dilationHeight,c.dilationWidth]},{type:"int32",data:[c.inHeight,c.inWidth]},{type:"int32",data:[c.effectiveFilterHeight,c.effectiveFilterWidth]});return n.runWebGPUProgram(d,[s],s.dtype,p)}var Wce={kernelName:Fa,backendName:"webgpu",kernelFunc:zce};function Vce(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{keepDims:a,axis:o}=r;return fp(s,o,a,"mean",n)}var Uce={kernelName:Da,backendName:"webgpu",kernelFunc:Vce};function Gce(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:o}=r;return fp(s,a,o,"min",n)}var Hce={kernelName:Ra,backendName:"webgpu",kernelFunc:Gce},jce=Rn({opSnippet:Mt.MIN,cpuKernelImpl:kie}),qce={kernelName:Pa,backendName:"webgpu",kernelFunc:jce},Kce=class{constructor(e,t,n){this.uniforms="",this.variableNames=["x"],this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=t.map((r,s)=>r[0]+e[s]+r[1]),this.dispatchLayout=ze(this.outputShape),this.dispatch=_e(this.dispatchLayout,this.outputShape,this.workGroupSize),this.xShape=e,t.map((r,s)=>{this.uniforms+=` pad${s} : vec2<i32>;`}),this.offset=n==="reflect"?0:1,this.shaderKey=`mirrorPad_${n}`}getUserCode(){let e=this.xShape.length,t=this.xShape.map((u,l)=>`uniforms.pad${l}[0]`).join(","),n=this.xShape.map((u,l)=>`uniforms.pad${l}[0] + uniforms.xShape${e>1?`[${l}]`:""}`).join(","),r=e===1?"start":"start[i]",s=e===1?"end":"end[i]",a=e===1?"outC":"outC[i]",o=on(e),i=e>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,e):"coords";return`
      ${Ue()}
        if (index < uniforms.size) {
          let start = ${o}(${t});
          let end = ${o}(${n});
          var outC = getCoordsFromFlatIndex(index);
          for (var i = 0; i < ${e}; i = i + 1) {
            if (${a} < ${r}) {
              ${a} = ${r} * 2 - ${a} - ${this.offset};
            } elseif(${a} >= ${s}) {
              ${a} = (${s} - 1) * 2 - ${a} + ${this.offset};
            }
          }
          let coords = outC - start;
          setOutputFlat(index, getX(${i}));
        }
      }
    `}},Xce={kernelName:Oa,backendName:"webgpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{x:r}=e,{paddings:s,mode:a}=t,o=n,i=s.map(c=>({type:"int32",data:[c[0],c[1]]})),u=new Kce(r.shape,s,a);return o.runWebGPUProgram(u,[r],r.dtype,i)}};function Yce(e){let{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])){let a=n.tensorMap.get(r.dataId),[o,i]=Sie(a.values,r.shape,r.dtype);return n.makeTensorInfo(i,r.dtype,o)}let s=new Wm(r.shape,bt.NEG);return n.runWebGPUProgram(s,[r],r.dtype)}var Qce={kernelName:ai,backendName:"webgpu",kernelFunc:Yce};function Zce(e){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:o,iouThreshold:i,scoreThreshold:u}=r,l=n.readSync(s.dataId),c=n.readSync(a.dataId),{selectedIndices:d}=Dr.nonMaxSuppressionV3Impl(l,c,o,i,u);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}var Jce={kernelName:ii,backendName:"webgpu",kernelFunc:Zce};function ele(e){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:o,iouThreshold:i,scoreThreshold:u,softNmsSigma:l}=r,c=n.readSync(s.dataId),d=n.readSync(a.dataId),p=o,h=i,f=u,m=l,{selectedIndices:g,selectedScores:b}=Dr.nonMaxSuppressionV5Impl(c,d,p,h,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([b.length],"float32",new Float32Array(b))]}var tle={kernelName:ui,backendName:"webgpu",kernelFunc:ele};function Um(e){let{inputs:t,backend:n}=e,{x:r}=t;if(r.dtype==="complex64"){let s=hp({inputs:{input:r},backend:n}),a=Um({inputs:{x:s},backend:n}),o=Vm({inputs:{input:r},backend:n}),i=Um({inputs:{x:o},backend:n}),u=nl({inputs:{real:a,imag:i},backend:n});return n.disposeData(s.dataId),n.disposeData(a.dataId),n.disposeData(o.dataId),n.disposeData(i.dataId),u}else return sl({attrs:{shape:r.shape,dtype:r.dtype,value:r.dtype==="string"?"":0},backend:n})}var nle={kernelName:Ni,backendName:"webgpu",kernelFunc:Um};function UE(e){let{inputs:t,backend:n}=e,{x:r}=t;if(r.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(r.dtype==="complex64"){let s=hp({inputs:{input:r},backend:n}),a=UE({inputs:{x:s},backend:n}),o=Vm({inputs:{input:r},backend:n}),i=Um({inputs:{x:o},backend:n}),u=nl({inputs:{real:a,imag:i},backend:n});return n.disposeData(s.dataId),n.disposeData(a.dataId),n.disposeData(o.dataId),n.disposeData(i.dataId),u}else return sl({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:n})}var rle={kernelName:ci,backendName:"webgpu",kernelFunc:UE};function sle(e){let{inputs:t,backend:n,attrs:r}=e,{axis:s}=r;if(t.length===1)return Ck({inputs:{input:t[0]},backend:n,attrs:{dim:s}});let a=t[0].shape,o=t[0].dtype;t.forEach(c=>{w.assertShapesMatch(a,c.shape,"All tensors passed to stack must have matching shapes"),w.assert(o===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});let i=[],u=t.map(c=>{let d=Ck({inputs:{input:c},backend:n,attrs:{dim:s}});return i.push(d),d}),l=EE({inputs:u,backend:n,attrs:{axis:s}});return i.forEach(c=>n.disposeData(c.dataId)),l}var ale={kernelName:di,backendName:"webgpu",kernelFunc:sle},ole=class{constructor(e,t){this.variableNames=["x"],this.uniforms="constantValue : f32;",this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=t.map((n,r)=>n[0]+e[r]+n[1]),this.dispatchLayout=ze(this.outputShape),this.dispatch=_e(this.dispatchLayout,this.outputShape,this.workGroupSize),t.map((n,r)=>{this.uniforms+=` pad${r} : vec2<i32>;`}),this.xShape=e,this.shaderKey="pad"}getUserCode(){let e=this.xShape.length,t=on(e),n=this.xShape.map((c,d)=>`uniforms.pad${d}[0]`).join(","),r=this.xShape.map((c,d)=>`uniforms.pad${d}[0] + uniforms.xShape${e>1?`[${d}]`:""}`).join(","),s=e>1?`${t}(${n})`:`${n}`,a=e>1?`${t}(${r})`:`${r}`,o=e>1?"any(outC < start)":"outC < start",i=e>1?"any(outC >= end)":"outC >= end",u=e>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,e):"coords";return`
      ${Ue()}
        if (index < uniforms.size) {
          let start = ${s};
          let end = ${a};
          let outC = getCoordsFromFlatIndex(index);

          if (${o} || ${i}) {
            setOutputFlat(index, uniforms.constantValue);
          } else {
            let coords = outC - start;
            setOutputFlat(index, getX(${u}));
          }
        }
      }
    `}},GE=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{paddings:a,constantValue:o}=r;if(a.every(l=>w.arraysEqual(l,[0,0])))return Lr({inputs:{x:s},backend:n});if(w.sizeFromShape(s.shape)===0){let l=a.map((c,d)=>c[0]+s.shape[d]+c[1]);return sl({backend:n,attrs:{shape:l,value:o,dtype:s.dtype}})}let i=[{type:"float32",data:[o]}];a.map(l=>i.push({type:"int32",data:[l[0],l[1]]}));let u=new ole(s.shape,a);return n.runWebGPUProgram(u,[s],s.dtype,i)},ile={kernelName:La,backendName:"webgpu",kernelFunc:GE},ule=Rn({opSnippet:Mt.POW}),cle={kernelName:Ba,backendName:"webgpu",kernelFunc:ule};function lle(e){let{inputs:t,backend:n}=e,{x:r,alpha:s}=t,a=new IE(Mt.PRELU,r.shape,s.shape);return n.runWebGPUProgram(a,[r,s],"float32")}var dle={kernelName:za,backendName:"webgpu",kernelFunc:lle};function ple(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:o}=r;return fp(s,a,o,"prod",n)}var hle={kernelName:pi,backendName:"webgpu",kernelFunc:ple},fle=e=>{let{backend:t,attrs:n}=e,{start:r,stop:s,step:a,dtype:o}=n,i=Nie(r,s,a,o);return t.makeTensorInfo([i.length],o,i)},mle={kernelName:oc,backendName:"webgpu",kernelFunc:fle},HE=Rn({opSnippet:Mt.DIV}),gle={kernelName:wa,backendName:"webgpu",kernelFunc:HE},ble=fn({opType:bt.RELU}),yle={kernelName:Wa,backendName:"webgpu",kernelFunc:ble},vle=fn({opType:bt.RELU6}),xle={kernelName:Ua,backendName:"webgpu",kernelFunc:vle},wle=class{constructor(e,t,n){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>; halfPixelCenters : f32;",this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=[e[0],t,n,e[3]],this.dispatchLayout=ze(this.outputShape),this.dispatch=_e(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="resizeBilinear"}getUserCode(){return`
      ${Ue()}
        if (index < uniforms.size) {
        let coords = getCoordsFromFlatIndex(index);
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveOutSize = vec2<f32>(
            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC =
            (vec2<f32>(rc) + vec2<f32>(uniforms.halfPixelCenters)) *
            effectiveInputOverOutputRatioRC - vec2<f32>(uniforms.halfPixelCenters);

          // Compute the four integer indices.
          let sourceFloorRC = vec2<i32>(sourceFracIndexRC);
          let sourceCeilRC = vec2<i32>(
            min(vec2<f32>(uniforms.xShape.yz) - vec2<f32>(1.0), ceil(sourceFracIndexRC)));

          let topLeft = getX(b, sourceFloorRC.x, sourceFloorRC.y, d);
          let bottomLeft = getX(b, sourceCeilRC.x, sourceFloorRC.y, d);
          let topRight = getX(b, sourceFloorRC.x, sourceCeilRC.y, d);
          let bottomRight = getX(b, sourceCeilRC.x, sourceCeilRC.y, d);

          let fracRC = sourceFracIndexRC - vec2<f32>(sourceFloorRC);

          let top = topLeft + (topRight - topLeft) * fracRC.y;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
          let newValue = top + (bottom - top) * fracRC.x;

          setOutputFlat(index, newValue);
        }
      }
    `}};function kle(e){let{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,size:o,halfPixelCenters:i}=r,[u,l]=o,c=a&&u>1?1:0,d=a&&l>1?1:0,h=[{type:"float32",data:[c,d]},{type:"float32",data:[i?.5:0]}],f=new wle(s.shape,u,l);return n.runWebGPUProgram(f,[s],"float32",h)}var Ile={kernelName:Va,backendName:"webgpu",kernelFunc:kle},Sle=class{constructor(e,t,n,r){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>; roundBase : f32;",this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=[e[0],t,n,e[3]],this.dispatchLayout=ze(this.outputShape),this.dispatch=_e(this.dispatchLayout,this.outputShape,this.workGroupSize),this.halfPixelCenters=r,this.shaderKey=`resizeNearest_${r}`}getUserCode(){let e;return this.halfPixelCenters?e="max((vec2<f32>(rc) + vec2<f32>(0.5)) * effectiveInputOverOutputRatioRC, vec2<f32>(0.0))":e="vec2<f32>(rc) * effectiveInputOverOutputRatioRC",`
      ${Ue()}
        if (index < uniforms.size) {
          let coords = getCoordsFromFlatIndex(index);
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveOutSize = vec2<f32>(
            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC = ${e};

          // Compute the coordinators of nearest neighbor point.
          let inputShapeRC = vec2<f32>(f32(uniforms.xShape.y), f32(uniforms.xShape.z));
          let sourceNearestRC = vec2<i32>(
            min(inputShapeRC - 1.0, floor(sourceFracIndexRC + uniforms.roundBase)));
          let newValue = getX(b, sourceNearestRC.x, sourceNearestRC.y, d);

          setOutputFlat(index, newValue);
        }
      }
    `}};function Cle(e){let{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:o,size:i}=r,[u,l]=i,c=a&&u>1?1:0,d=a&&l>1?1:0,h=[{type:"float32",data:[c,d]},{type:"float32",data:[a?.5:0]}],f=new Sle(s.shape,u,l,o);return n.runWebGPUProgram(f,[s],s.dtype,h)}var Tle={kernelName:uc,backendName:"webgpu",kernelFunc:Cle},Nle=class{constructor(e,t){this.outputShape=[],this.variableNames=["x"],this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=ze(this.outputShape),this.dispatch=_e(this.dispatchLayout,this.outputShape,this.workGroupSize),this.uniforms=`centerX : f32; centerY : f32; sinRadians : f32;
          cosRadians : f32;`,this.shaderKey="rotate",this.outputShape=e,typeof t=="number"?(this.uniforms+=" fillValue : f32;",this.fillSnippet="var outputValue = uniforms.fillValue;",this.shaderKey+="_float"):(this.uniforms+=" fillValue : vec3<f32>;",this.fillSnippet="var outputValue = uniforms.fillValue[coords[3]];",this.shaderKey+="_vec3")}getUserCode(){return`
        ${Ue()}

          if (index < uniforms.size) {
            let coords = getCoordsFromFlatIndex(index);
            let coordXFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.cosRadians - (f32(coords[1]) - uniforms.centerY) *
                uniforms.sinRadians;
            let coordYFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.sinRadians + (f32(coords[1]) - uniforms.centerY) *
                uniforms.cosRadians;
            let coordX = i32(round(coordXFloat + uniforms.centerX));
            let coordY = i32(round(coordYFloat + uniforms.centerY));
            ${this.fillSnippet}
            if(coordX >= 0 && coordX < uniforms.xShape[2] && coordY >= 0 &&
                coordY < uniforms.xShape[1]) {
              outputValue = getX(coords[0], coordY, coordX, coords[3]);
            }
            setOutputFlat(index, outputValue);
          }
        }
      `}},_le={kernelName:_i,backendName:"webgpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{image:r}=e,{radians:s,fillValue:a,center:o}=t,i=n,u=new Nle(r.shape,a),[l,c]=N.getImageCenter(o,r.shape[1],r.shape[2]),d=[{type:"float32",data:[l]},{type:"float32",data:[c]},{type:"float32",data:[Math.sin(s)]},{type:"float32",data:[Math.cos(s)]}];return typeof a=="number"?d.push({type:"float32",data:[Number.parseFloat(a.toFixed(2))]}):d.push({type:"float32",data:a}),i.runWebGPUProgram(u,[r],r.dtype,d)}},Ele=fn({opType:bt.RSQRT,cpuKernelImpl:_ie}),Ale={kernelName:Ga,backendName:"webgpu",kernelFunc:Ele},$le=class{constructor(e,t,n,r,s,a,o){this.variableNames=["updates","indices"],this.workGroupSize=[64,1,1],this.atomic=!0,this.outputShape=a,this.type=o,this.dispatchLayout=ze(e),this.dispatch=_e(this.dispatchLayout,e,this.workGroupSize),this.sliceDimGreaterThanOne=t>1,this.shaderKey=`scatter_${n}_${r}_${this.sliceDimGreaterThanOne}_${o}`;let i=on(s.length);this.uniforms=`sliceDim : i32; strides: ${i}; size: i32;`,this.updatesRank=r,this.indicesRank=n}getUserCode(){let e="";this.indicesRank===1?e="coords[0]":this.indicesRank===2&&(e="coords[0], j");let t=`getIndices(${e})`,n=this.sliceDimGreaterThanOne?"uniforms.strides[j]":"uniforms.strides",r="",s="",a="";this.updatesRank===1?(r="coords[0]",s="flattenedIndex",a=`
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> i32 {
        return index;
      }
      `):this.updatesRank===2&&(r="coords[0], coords[1]",s="vec2<i32>(flattenedIndex, coords[1])",a=`
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> vec2<i32> {
        let d0 = index / uniforms.updatesShape[1];
        let d1 = index - d0 * uniforms.updatesShape[1];
        return vec2<i32>(d0, d1);
      }
      `);let o=`getUpdates(${r})`,i=this.type==="int32"?"atomicAdd(&(result.numbers[flatIndex]), i32(updateValue));":`
     var assumed = atomicLoad(&(result.numbers[flatIndex]));
     var success = 0;
     for (; success == 0;) {
       let new = bitcast<f32>(assumed) + updateValue;
       let newI32 = bitcast<i32>(new);
       let resValue = atomicCompareExchangeWeak(&(result.numbers[flatIndex]), assumed, newI32);
       assumed = resValue[0];
       success = resValue[1];
     }
     `;return`
    ${a}

      ${Ue()}

        if (index < uniforms.size) {
          let coords = getUpdatesCoordsFromFlatIndex(index);
          var flattenedIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexInside = i32(round(${t}));
            flattenedIndex = flattenedIndex + indexInside * ${n};
          }
          let updateValue = ${o};
          let flatIndex = getOutputFlatIndex(${s});

         ${i}
        }
      }`}};function Fle(e){let{inputs:t,backend:n,attrs:r}=e,{indices:s,updates:a}=t,{shape:o}=r,{sliceRank:i,numUpdates:u,sliceSize:l,strides:c,outputSize:d}=N.calculateShapes(a,s,o),p=[d/l,l];if(d===0)return n.makeTensorInfo(o,s.dtype);let h=We({inputs:{x:s},backend:n,attrs:{shape:[u,i]}}),f=We({inputs:{x:a},backend:n,attrs:{shape:[u,l]}}),m=f.dtype,g=sl({backend:n,attrs:{shape:p,value:0,dtype:m}}),b=w.sizeFromShape(f.shape),y=[{type:"int32",data:[i]},{type:"int32",data:c},{type:"int32",data:[b]}],v=new $le(f.shape,i,h.shape.length,f.shape.length,c,p,m),x=n.runWebGPUProgram(v,[f,h],m,y,g),k=We({inputs:{x},backend:n,attrs:{shape:o}});return n.disposeData(h.dataId),n.disposeData(f.dataId),n.disposeData(x.dataId),k}var Dle={kernelName:gi,backendName:"webgpu",kernelFunc:Fle},Rle=class{constructor(e,t,n){this.variableNames=["c","a","b"],this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=ze(this.outputShape),this.dispatch=_e(this.dispatchLayout,this.outputShape,this.workGroupSize),this.cRank=e,this.rank=n,this.shaderKey="select"}getUserCode(){let e,t;if(this.rank>4)throw Error(`Where for rank ${this.rank} is not yet supported`);if(this.rank===1)t="resRC",e="resRC";else{let r=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[],a=[];for(let o=0;o<this.outputShape.length;o++)a.push(`${r[o]}`),o<this.cRank&&s.push(`${r[o]}`);e=s.join(),t=a.join()}return`
      ${Ue()}
        if (index < uniforms.size) {
          let resRC = getCoordsFromFlatIndex(index);
          let cVal = getC(${e});
          if (cVal >= 1.0) {
            setOutputFlat(index, getA(${t}));
          } else {
            setOutputFlat(index, getB(${t}));
          }
        }
      }
    `}};function Ple(e){let{inputs:t,backend:n}=e,{condition:r,t:s,e:a}=t,o=new Rle(r.shape.length,s.shape,s.shape.length);return n.runWebGPUProgram(o,[r,s,a],In(s.dtype,a.dtype))}var Ole={kernelName:bi,backendName:"webgpu",kernelFunc:Ple},Mle=fn({opType:bt.SIGMOID}),Lle={kernelName:ja,backendName:"webgpu",kernelFunc:Mle},Ble=fn({opType:bt.SIN}),zle={kernelName:Ha,backendName:"webgpu",kernelFunc:Ble},Wle=fn({opType:bt.SINH}),Vle={kernelName:vi,backendName:"webgpu",kernelFunc:Wle},jE=Rn({opSnippet:Mt.SUB,cpuKernelImpl:Die,supportsComplex:!0}),Ule={kernelName:Qa,backendName:"webgpu",kernelFunc:jE};function Gle(e){let{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{dim:a}=r,o=w.parseAxisParam([a],s.shape),i=VE({inputs:{x:s},backend:n,attrs:{reductionIndices:o,keepDims:!1}}),u=N.expandShapeToKeepDim(i.shape,o),l=We({inputs:{x:i},backend:n,attrs:{shape:u}}),c=jE({inputs:{a:s,b:l},backend:n}),d=ME({inputs:{x:c},backend:n}),p=Sk({inputs:{x:d},backend:n,attrs:{axis:o,keepDims:!1}}),h=We({inputs:{x:p},backend:n,attrs:{shape:u}}),f=HE({inputs:{a:d,b:h},backend:n});return n.disposeData(i.dataId),n.disposeData(l.dataId),n.disposeData(c.dataId),n.disposeData(d.dataId),n.disposeData(p.dataId),n.disposeData(h.dataId),f}var Hle={kernelName:Xa,backendName:"webgpu",kernelFunc:Gle},jle=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,paddings:o}=r;w.assert(s.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGPU backend not implemented yet");let i=a.reduce((b,y)=>b*y),u=[[0,0]];u.push(...o);for(let b=1+a.length;b<s.shape.length;++b)u.push([0,0]);let l=[],c=GE({inputs:{x:s},backend:n,attrs:{paddings:u,constantValue:0}}),d=N.getReshaped(c.shape,a,i,!1),p=N.getPermuted(d.length,a.length,!1),h=N.getReshapedPermuted(c.shape,a,i,!1),f=We({inputs:{x:c},backend:n,attrs:{shape:d}}),m=cu({inputs:{x:f},backend:n,attrs:{perm:p}}),g=We({inputs:{x:m},backend:n,attrs:{shape:h}});return l.push(c),l.push(f),l.push(m),l.forEach(b=>n.disposeData(b.dataId)),g},qle={kernelName:xi,backendName:"webgpu",kernelFunc:jle},Kle=class{constructor(e,t,n,r,s,a,o=!0){this.variableNames=["updates","indices","defaultValue"],this.workGroupSize=[64,1,1],this.workPerThread=4,this.size=!0,this.outputShape=a,this.dispatchLayout=ze(this.outputShape),this.dispatch=_e(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]);let i=t>1;this.shaderKey=`scatter_${n}_${r}_${i}`;let u=on(s.length);this.uniforms=`updateSize : i32; sliceDim : i32; strides: ${u};`;let l="";n===1?l="i":n===2&&(l="i, j"),this.indicesSnippet=`getIndices(${l})`;let c="";r===1?c="i":r===2&&(c="i, coords[1]"),this.updatesSnippet=`getUpdates(${c})`,this.strideString=i?"uniforms.strides[j]":"uniforms.strides"}getUserCode(){return`
      ${Ue()}

        let globalIndex = index * ${this.workPerThread};
        if (globalIndex < uniforms.size) {
          var sum = vec4<f32>(0.0);
          var found = vec4<bool>(false);
          for (var i = 0; i < uniforms.updateSize; i = i + 1) {
            var flattenedIndex = 0;
            for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
              let indexInside = i32(round(${this.indicesSnippet}));
              flattenedIndex = flattenedIndex + indexInside * ${this.strideString};
            }
            for (var innerIndex = 0; innerIndex < ${this.workPerThread}; innerIndex = innerIndex + 1) {
              let curIndex = globalIndex + innerIndex;
              let coords = getCoordsFromFlatIndex(curIndex);
              if (flattenedIndex == coords[0]) {
                sum[innerIndex] = sum[innerIndex] + ${this.updatesSnippet};
                found[innerIndex] = true;
              }
            }
          }
          for (var innerIndex = 0; innerIndex < ${this.workPerThread}; innerIndex = innerIndex + 1) {
            let curIndex = globalIndex + innerIndex;
            if (curIndex < uniforms.size)
            {
              setOutputFlat(curIndex, mix(getDefaultValue(), sum[innerIndex], f32(found[innerIndex])));
            }
          }
        }
      }`}};function Xle(e){let{inputs:t,backend:n,attrs:r}=e,{sparseIndices:s,sparseValues:a,defaultValue:o}=t,{outputShape:i}=r,{sliceRank:u,numUpdates:l,strides:c,outputSize:d}=N.calculateShapes(a,s,i),p=!1,h=[{type:"int32",data:[l]},{type:"int32",data:[u]},{type:"int32",data:c}],f=new Kle(l,u,s.shape.length,a.shape.length,c,[d,1],p),m=n.runWebGPUProgram(f,[a,s,o],a.dtype,h),g=We({inputs:{x:m},backend:n,attrs:{shape:i}});return n.disposeData(m.dataId),g}var Yle={kernelName:od,backendName:"webgpu",kernelFunc:Xle};function Qle(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{numOrSizeSplits:a,axis:o}=r,i=w.parseAxisParam(o,s.shape)[0],u=N.prepareSplitSize(s,a,i),l=s.shape.length,c=new Array(l).fill(0),d=s.shape.slice();return u.map(p=>{let h=[...d];h[i]=p;let f=rl({inputs:{x:s},backend:n,attrs:{begin:c,size:h}});return c[i]+=p,f})}var Zle={kernelName:wi,backendName:"webgpu",kernelFunc:Qle},Jle=fn({opType:bt.SQRT}),ede={kernelName:qa,backendName:"webgpu",kernelFunc:Jle},tde={kernelName:hc,backendName:"webgpu",kernelFunc:({inputs:e,backend:t})=>{let{x:n}=e,r=t,s=new Wm(n.shape,bt.SQUARE);return r.runWebGPUProgram(s,[n],n.dtype)}},nde=Rn({opSnippet:Mt.SQUARED_DIFFERENCE}),rde={kernelName:Ya,backendName:"webgpu",kernelFunc:nde},sde=class{constructor(e){this.variableNames=["x"],this.workPerThread=1,this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=ze(this.outputShape),this.dispatch=_e(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]);let t=on(this.outputShape.length);this.uniforms=`begin : ${t};  strides : ${t}; `,this.shaderKey="stridedSlice"}getUserCode(){let e=this.outputShape.length,t="";if(e===1)t="coords * uniforms.strides + uniforms.begin";else{let r=0;t=this.outputShape.map((s,a)=>(r++,this.outputShape.length===1?`coords * uniforms.strides[${a}] + uniforms.begin[${a}]`:`coords[${r-1}] * uniforms.strides[${a}] + uniforms.begin[${a}]`)).join(",")}return`
       ${Ue()}
         if (index < uniforms.size) {
           let coords = getCoordsFromFlatIndex(index);
           setOutputFlat(index, getX(${t}));
         }
       }
     `}};function ade(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,end:o,strides:i,beginMask:u,endMask:l,ellipsisMask:c,newAxisMask:d,shrinkAxisMask:p}=r,{finalShapeSparse:h,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:b,begin:y,end:v,strides:x}=$t.sliceInfo(s.shape,a,o,i,u,l,c,d,p),k;if(m)k=We({inputs:{x:s},backend:n,attrs:{shape:f}});else if(g||b){w.assert(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);let T=$t.computeOutShape(y,v,x),C=rl({inputs:{x:s},backend:n,attrs:{begin:y,size:T}});k=We({inputs:{x:C},backend:n,attrs:{shape:f}}),n.disposeData(C.dataId)}else if(n.shouldExecuteOnCPU([s])){let C=n.readSync(s.dataId),E=$e(s.shape,s.dtype,C),F=$ie(h,E,x,y);k=n.makeTensorInfo(f,s.dtype,F.values)}else{let C=new sde(h),E=[{type:"int32",data:y},{type:"int32",data:x}],F=n.runWebGPUProgram(C,[s],s.dtype,E);k=We({inputs:{x:F},backend:n,attrs:{shape:f}}),n.disposeData(F.dataId)}return k}var ode={kernelName:ki,backendName:"webgpu",kernelFunc:ade};function ide(e){let{inputs:t,backend:n,attrs:r}=e,{separator:s,nGramWidths:a,leftPad:o,rightPad:i,padWidth:u,preserveShortSequences:l}=r,{data:c,dataSplits:d}=t,p=n.readSync(c.dataId),h=n.readSync(d.dataId),[f,m]=Fie(p,h,s,a,o,i,u,l);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(d.shape,"int32",m)]}var ude={kernelName:id,backendName:"webgpu",kernelFunc:ide},cde=fn({opType:bt.TANH}),lde={kernelName:Za,backendName:"webgpu",kernelFunc:cde},dde=class{constructor(e,t){this.variableNames=["A"],this.workGroupSize=[64,1,1],this.size=!0;let n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[r]*t[r];this.outputShape=n,this.dispatchLayout=ze(this.outputShape),this.dispatch=_e(this.dispatchLayout,this.outputShape,this.workGroupSize),this.rank=this.outputShape.length,this.shaderKey="tile"}getUserCode(){let e=pde(this.rank,"uniforms.");return`
      ${Ue()}
        if (index < uniforms.size) {
          let resRC = getCoordsFromFlatIndex(index);
          setOutputFlat(index, getA(${e}));
        }
      }
    `}};function pde(e,t=""){if(e>=5)throw Error(`Tile for rank ${e} is not yet supported`);if(e===1)return`(resRC % ${t}aShape)`;let n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let s=0;s<e;s++)r.push(`(${n[s]} % ${t}aShape[${s}])`);return r.join()}function hde(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reps:a}=r;if(n.shouldExecuteOnCPU([s])||s.dtype==="string"||s.shape.length>=5){let u=n.readSync(s.dataId),l=s.dtype==="string"?u.map(p=>w.decodeString(p)):u,c=$e(s.shape,s.dtype,l),d=Rie(c,a);return n.makeTensorInfo(d.shape,d.dtype,d.values)}let o=new dde(s.shape,a);return n.runWebGPUProgram(o,[s],s.dtype)}var fde={kernelName:As,backendName:"webgpu",kernelFunc:hde},mde=class{constructor(e){this.variableNames=["x","indices"],this.workGroupSize=[256,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=ze(this.outputShape),this.dispatch=_e(this.dispatchLayout,this.outputShape,this.workGroupSize),this.uniforms=`inputSize : i32; firstPass : i32; negativeInf : f32;
        dir : i32; inc : i32;`,this.shaderKey="swap"}getUserCode(){return`
        ${Ue()}
          if (index < uniforms.size) {
            let outC = getCoordsFromFlatIndex(index);
            let batch = outC[0];
            let elemIdx = outC[1];
            // We compare elements pair-wise within a group of size 2 * inc.
            // The comparing rule for each group alternates between ascending
            // and descending. Within each group, we compare each pair at
            // positions i and i+inc. To decide whether an element at position i
            // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
            // inc, it is in the first half of the group, we denote it as x0,
            // otherwise we denote it as x1.
            // For example, as shown in the Bitonic top K paper referenced
            // above, Figure5(a) shows that element[1] is in the second half of
            // the group when group size is 2, but it is in the first half of
            // the group when group size is 4.
            let isFirstInPair = elemIdx % (2 * uniforms.inc) < uniforms.inc;
            var i = 0;
            if (isFirstInPair) {
              i = elemIdx;
            } else {
              i = elemIdx - uniforms.inc;
            }

            var i0 = 0;
            if (uniforms.firstPass == 1) {
              i0 = i;
            } else {
              i0 = i32(getIndices(batch, i));
            }

            var i1 = 0;
            if (uniforms.firstPass == 1) {
              i1 = i + uniforms.inc;
            } else {
              i1 = i32(getIndices(batch, i + uniforms.inc));
            }

            var x0 = f32(0.0);
            var x1 = f32(0.0);
            if (i0 < uniforms.inputSize) {
              x0 = getX(batch, i0);
            } else {
              x0 = uniforms.negativeInf;
            }
            if (i1 < uniforms.inputSize) {
              x1 = getX(batch, i1);
            } else {
              x1 = uniforms.negativeInf;
            }

            let reverse = elemIdx % (2 * uniforms.dir) >= uniforms.dir;
            let isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
            if (reverse == isGreater) {
              // Elements in opposite order of direction
              let iTemp = i0;
              i0 = i1;
              i1 = iTemp;
            }
            if (isFirstInPair) {
              setOutputFlat(index, f32(i0));
            } else {
              setOutputFlat(index, f32(i1));
            }
          }
        }
      `}},gde=class{constructor(e){this.variableNames=["x","indices"],this.workGroupSize=[256,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=ze(this.outputShape),this.dispatch=_e(this.dispatchLayout,this.outputShape,this.workGroupSize),this.uniforms="inputSize : i32; firstPass : i32; k : i32;",this.shaderKey="merge"}getUserCode(){return`
        ${Ue()}
          if (index < uniforms.size) {
            let outC = getCoordsFromFlatIndex(index);
            let batch = outC[0];
            let elemIdx = outC[1];
            // The output size is half of the previous size.
            // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _
            // (k=4), we only need to output the indices at positions |, the
            // indices at positions _ can be thrown away, see Figure5(b) After
            // Phase 2 (Merge phase) in the Bitonic Top K paper referenced
            // above.
            // For example, the paper shows we only need to output the orange
            // bars. The output sequence should look like this | | | | | | | |.
            // Because the sequence is halved, to map the output index back to
            // the previous sequence to find the corresponding value, we need
            // to double the index. When we double the index, we basically
            // interpolate a position, so 2i looks like
            // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k
            // position of each 2k positions by - elemIdx % k. E.g. for output
            // at index 4,5,6,7, we want to get the corresponding element at
            // original index 8,9,10,11, for output at index 8,9,10,11,
            // we want to get the corresponding element at original index
            // 16,17,18,19, so on and so forth.

            var i = 0;
            if (elemIdx < uniforms.k) {
              i = elemIdx;
            } else {
              i = elemIdx * 2 - elemIdx % uniforms.k;
            }
            var i0 = 0;
            if (uniforms.firstPass == 1) {
              i0 = i;
            } else {
              i0 = i32(getIndices(batch, i));
            }
            var i1 = 0;
            if (uniforms.firstPass == 1) {
              i1 = i + uniforms.k;
            } else {
              i1 = i32(getIndices(batch, i + uniforms.k));
            }

            let x0 = getX(batch, i0);
            var x1 = f32(0.0);
            if (i1 < uniforms.inputSize) {
              x1 = getX(batch, i1);
            } else {
              x1 = x0;
            }

            if (x0 >= x1) {
              setOutputFlat(index, f32(i0));
            } else {
              setOutputFlat(index, f32(i1));
            }
          }
        }
      `}};function ol(e,t){t!==null&&e.disposeData(t.dataId)}function qE(e){let t=1;for(;t<e;)t*=2;return t}function bde(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{k:a,sorted:o}=r,i=s.shape,u=i[i.length-1];if(n.shouldExecuteOnCPU([s])){let k=n.readSync(s.dataId),[T,C]=Pie(k,i,s.dtype,a,o);return[n.makeTensorInfo(T.shape,T.dtype,T.values),n.makeTensorInfo(C.shape,C.dtype,C.values)]}if(a===0)return i[i.length-1]=0,[n.makeTensorInfo(i,s.dtype,[]),n.makeTensorInfo(i,"int32",[])];if(u===1)return[s,sl({attrs:{shape:i,dtype:"int32",value:0},backend:n})];let c=w.sizeFromShape(i)/u,d=We({inputs:{x:s},attrs:{shape:[c,u]},backend:n}),p=qE(a),h=qE(u),f=null,m=()=>f===null?[d,d]:[d,f],g=(k,T,C)=>{let E=m(),F=new mde(C),D=[{type:"int32",data:[u]},{type:"int32",data:[f===null?1:0]},{type:"float32",data:[Number.NEGATIVE_INFINITY]},{type:"int32",data:[k]},{type:"int32",data:[T]}],R=f;f=n.runWebGPUProgram(F,E,"int32",D),ol(n,R)};for(let k=1;k<p;k*=2){let T=k*2;for(let C=k;C>=1;C/=2)g(T,C,[c,h])}for(let k=h;k>p;k/=2){let T=m(),C=new gde([c,k/2]),F=[{type:"int32",data:[u]},{type:"int32",data:[f===null?1:0]},{type:"int32",data:[p]}],O=f;f=n.runWebGPUProgram(C,T,"int32",F),ol(n,O);let D=p/2,R=D*2;for(let _=D;_>=1;_/=2)g(R,_,f.shape)}let b=f;f=rl({inputs:{x:f},backend:n,attrs:{begin:0,size:[c,a]}}),ol(n,b);let y=WE({inputs:{x:d,indices:f},backend:n,attrs:{axis:1,batchDims:1}});ol(n,d);let v=i.slice(0,-1);v.push(a),b=f,f=We({inputs:{x:f},attrs:{shape:v},backend:n}),ol(n,b);let x=y;return y=We({inputs:{x:y},attrs:{shape:v},backend:n}),ol(n,x),[y,f]}var yde={kernelName:Si,backendName:"webgpu",kernelFunc:bde},vde=class{constructor(e){this.variableNames=["Image","Transforms"],this.uniforms="interpolationModeId : i32; fillModeId : i32; fillValue : f32;",this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=ze(this.outputShape),this.dispatch=_e(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="transform"}getUserCode(){return`
          fn mapCoord(outCoord : f32, len : f32) -> f32{
            var inCoord = outCoord;
            if(uniforms.fillModeId == 2) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  if (inCoord < sz2) {
                    inCoord = sz2 * f32(i32(f32(-inCoord / sz2))) +
                    inCoord;
                  }
                  if (inCoord < -len) {
                    inCoord = inCoord + sz2;
                  } else {
                    inCoord = -inCoord - 1.0;
                  }
                }
              } elseif (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  inCoord = inCoord - sz2 * f32(i32(f32(inCoord / sz2)));
                  if (inCoord >= len) {
                    inCoord = sz2 - inCoord - 1.0;
                  }
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } elseif (uniforms.fillModeId == 3) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord + len * (f32(i32(f32(-inCoord / sz))) + 1.0);
                }
              } elseif (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord - len * f32(i32(f32(inCoord / sz)));
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } elseif (uniforms.fillModeId == 4) {
              return clamp(outCoord, 0.0, len - 1.0);
            }
            return outCoord;
          }
          fn readWithFillValue(batch : i32, coordY : i32, coordX : i32,
            channel : i32) -> f32 {
            var outputValue : f32;
            if (0 <= coordY && coordY < uniforms.imageShape[1] && 0 <= coordX && coordX < uniforms.imageShape[2]) {
                outputValue = getImage(batch, coordY, coordX, channel);
            } else {
              outputValue = uniforms.fillValue;
            }
            return outputValue;
          }

          ${Ue()}
            if (index < uniforms.size) {
              let coords = getCoordsFromFlatIndex(index);
              var outputValue : f32;
              let batch = coords[0];
              let x = coords[2];
              let y = coords[1];
              let channel = coords[3];
              let xf = f32(x);
              let yf = f32(y);
              let a1 = getTransforms(batch, 0);
              let a2 = getTransforms(batch, 1);
              let a3 = getTransforms(batch, 2);
              let b1 = getTransforms(batch, 3);
              let b2 = getTransforms(batch, 4);
              let b3 = getTransforms(batch, 5);
              let c1 = getTransforms(batch, 6);
              let c2 = getTransforms(batch, 7);
              let projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = uniforms.fillValue;
              } else {
                let inX = (a1 * xf + a2 * yf + a3) / projection;
                let inY = (b1 * xf + b2 * yf + b3) / projection;
                let mapX = mapCoord(inX, f32(uniforms.imageShape[2]));
                let mapY = mapCoord(inY, f32(uniforms.imageShape[1]));

                if (uniforms.interpolationModeId == 1) {
                  let coordY = i32(round(mapY));
                  let coordX = i32(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  let yFloor = floor(mapY);
                  let xFloor = floor(mapX);
                  let yCeil = yFloor + 1.0;
                  let xCeil = xFloor + 1.0;
                  let valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yFloor), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yFloor), i32(xCeil), channel);
                  let valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yCeil), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yCeil), i32(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutputFlat(index, outputValue);
            }
          }
        `}};function xde(e){let{inputs:t,backend:n,attrs:r}=e,{image:s,transforms:a}=t,{interpolation:o,fillMode:i,fillValue:u,outputShape:l}=r,[c,d,p,h]=s.shape,[f,m]=l!=null?l:[d,p],g=[c,f,m,h],b=new vde(g),y=o==="nearest"?1:2,v;switch(i){case"constant":v=1;break;case"reflect":v=2;break;case"wrap":v=3;break;case"nearest":v=4;break;default:v=1;break}let x=[{type:"int32",data:[y]},{type:"int32",data:[v]},{type:"float32",data:[u]}];return n.runWebGPUProgram(b,[s,a],"float32",x)}var wde={kernelName:Ci,backendName:"webgpu",kernelFunc:xde};function kde(e){let{inputs:t,backend:n,attrs:r}=e,{value:s}=t,{axis:a}=r;a<0&&(a+=s.shape.length);let o=s,i=o.shape.length,u=s.shape[a],l=new Array(i-1),c=0;for(let m=0;m<i;m++)m!==a&&(l[c++]=o.shape[m]);let d=[],p=new Array(i).fill(0),h=o.shape.slice();h[a]=1;let f=new Array(u);for(let m=0;m<f.length;m++){p[a]=m;let g=rl({inputs:{x:o},backend:n,attrs:{begin:p,size:h}}),b=We({inputs:{x:g},backend:n,attrs:{shape:l}});f[m]=b,d.push(g)}return d.forEach(m=>n.disposeData(m.dataId)),f}var Ide={kernelName:Ti,backendName:"webgpu",kernelFunc:kde},Sde=[tie,Lie,zie,Uie,Xie,Qie,Jie,tue,oue,lue,pue,gue,aie,xue,Sue,_ue,Aue,Fue,Pue,Lue,zue,Hue,que,Xue,Que,Yue,Jue,tce,rce,cce,ace,ice,pce,fce,gce,vce,kce,Sce,Tce,sie,yue,_ce,Ace,Fce,Rce,Oce,Mce,Bce,Wce,Uce,Hce,qce,Xce,Wue,Qce,Jce,tle,iue,rle,ale,ile,dle,hle,cle,mle,uue,gle,yle,xle,Joe,Ile,Tle,_le,Ale,Dle,Ole,Lle,zle,Vle,sue,ode,ude,Hle,qle,Zle,Yle,ede,tde,rde,Ule,Uue,lde,fde,yde,wde,qie,Ide,nle];for(let e of Sde)mc(e);var Cde=class{constructor(e){this.device=e,this.numUsedBuffers=0,this.numFreeBuffers=0,this.freeBuffers=new Map,this.usedBuffers=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireBuffer(e,t){let n=KE(e,t);if(this.freeBuffers.has(n)||this.freeBuffers.set(n,[]),this.usedBuffers.has(n)||this.usedBuffers.set(n,[]),this.numBytesUsed+=e,this.numUsedBuffers++,this.freeBuffers.get(n).length>0){this.numFreeBuffers--;let s=this.freeBuffers.get(n).shift();return this.usedBuffers.get(n).push(s),s}this.numBytesAllocated+=e;let r=this.device.createBuffer({size:e,usage:t});return this.usedBuffers.get(n).push(r),r}releaseBuffer(e,t,n){if(this.freeBuffers==null)return;let r=KE(t,n);this.freeBuffers.has(r)||this.freeBuffers.set(r,[]),this.freeBuffers.get(r).push(e),this.numFreeBuffers++,this.numUsedBuffers--;let s=this.usedBuffers.get(r),a=s.indexOf(e);if(a<0)throw new Error("Cannot release a buffer that was never provided by this buffer manager");s.splice(a,1),this.numBytesUsed-=t}getNumUsedBuffers(){return this.numUsedBuffers}getNumFreeBuffers(){return this.numFreeBuffers}reset(){this.freeBuffers=new Map,this.usedBuffers=new Map,this.numUsedBuffers=0,this.numFreeBuffers=0,this.numBytesUsed=0,this.numBytesAllocated=0}dispose(){this.freeBuffers==null&&this.usedBuffers==null||(this.freeBuffers.forEach((e,t)=>{e.forEach(n=>{n.destroy()})}),this.usedBuffers.forEach((e,t)=>{e.forEach(n=>{n.destroy()})}),this.freeBuffers=null,this.usedBuffers=null,this.numUsedBuffers=0,this.numFreeBuffers=0,this.numBytesUsed=0,this.numBytesAllocated=0)}};function KE(e,t){return`${e}_${t}`}var XE=class{constructor(){this.outputShape=[0],this.variableNames=[],this.workGroupSize=[256,1,1],this.lastUniformData=[],this.inputTexture=null,this.layout=null,this.lastPixelSize={width:0,height:0},this.disposed=!1,this.shaderKey="fromPixels",this.useImport=!1}updateOutputShape(e){w.arraysEqual(this.outputShape,e)||(this.outputShape=e,this.workPerThread=e[2],this.dispatchLayout=ze(this.outputShape),this.dispatch=_e(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]))}makeFromPixelsSource(){let e=this.useImport?"textureLoad(src, vec2<i32>(coords.yx));":"textureLoad(src, vec2<i32>(coords.yx), 0)";return`
      [[binding(1), group(0)]] var src: ${this.useImport?"texture_external":"texture_2d<f32>"};

      ${Ue()}
        let flatIndexBase = index * uniforms.numChannels;
        for (var i = 0; i < uniforms.numChannels; i = i + 1) {
          let flatIndex = flatIndexBase + i;
          if (flatIndex < uniforms.size) {
            let coords = getCoordsFromFlatIndex(flatIndexBase);
            let values = ${e};
            result.numbers[flatIndex] = i32(floor(255.0 * values[i]));
          }
        }
      }
  `}getUserCode(){return this.makeFromPixelsSource()}setPipeline(e){this.pipeline=e}setUniform(e,t){if(!this.uniform){let n=e.createBuffer({size:t.length*4,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});this.uniform=n}!t||t.length===this.lastUniformData.length&&t.every((n,r)=>n===this.lastUniformData[r])||(e.queue.writeBuffer(this.uniform,0,new Uint32Array(t)),this.lastUniformData=t)}makeInputTexture(e,t,n){return(!this.inputTexture||this.lastPixelSize.width!==t||this.lastPixelSize.height!==n)&&(this.inputTexture&&this.inputTexture.destroy(),this.inputTexture=e.createTexture({size:[t,n],format:"rgba8unorm",usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING}),this.lastPixelSize.width=t,this.lastPixelSize.height=n),this.inputTexture}dispose(){this.disposed||(this.uniform&&this.uniform.destroy(),this.inputTexture&&this.inputTexture.destroy(),this.disposed=!0)}getLayout(e){return this.layout===null&&(this.layout=this.createTextureLayout(e)),this.layout}createTextureLayout(e){let t=[];t.push({binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}),t.push({binding:1,visibility:GPUShaderStage.COMPUTE,texture:{}}),t.push({binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{}});let n=e.createBindGroupLayout({entries:t}),r=e.createPipelineLayout({bindGroupLayouts:[n]});return{bindGroupLayout:n,pipelineLayout:r}}},Tde=class extends XE{constructor(){super(...arguments);this.layout=null,this.useImport=!0}getUserCode(){return this.makeFromPixelsSource()}getLayout(e){return this.layout===null&&(this.layout=this.createTextureImportLayout(e)),this.layout}createTextureImportLayout(e){let t=[];t.push({binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}),t.push({binding:1,visibility:GPUShaderStage.COMPUTE,externalTexture:{}}),t.push({binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{}});let n=e.createBindGroupLayout({entries:t}),r=e.createPipelineLayout({bindGroupLayouts:[n]});return{bindGroupLayout:n,pipelineLayout:r}}},Nde=X().getNumber("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD"),YE=class extends Mu{constructor(e,t=!1){super();if(this.commandQueueOwnedIds=new WeakSet,this.tensorDisposalQueue=[],this.uniformDisposalQueue=[],this.disposed=!1,this.uploadWaitMs=0,this.downloadWaitMs=0,this.dispatchNumberInEncoder=0,!yk())throw new Error("WebGPU is not supported on this device");this.layoutCache={},this.pipelineCache={},this.device=e,this.queue=e.queue,this.currentCommandEncoder=null,this.currentComputePass=null,this.supportTimeQuery=t,this.bufferManager=new Cde(this.device),this.tensorMap=new Ul(this,is()),this.supportTimeQuery&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:2})),X().getBool("WEBGPU_USE_PROFILE_TOOL")&&(this.dummyCanvas=document.createElement("canvas"),this.dummyCanvas.width=1,this.dummyCanvas.height=1,this.dummyContext=this.dummyCanvas.getContext("webgpu"),this.dummyContext.configure({device:e,format:"bgra8unorm"}),document.body.appendChild(this.dummyCanvas))}nextDataId(){return YE.nextDataId++}floatPrecision(){return 32}defaultGpuBufferUsage(){return GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST}flushDisposalQueue(){this.tensorDisposalQueue.forEach(e=>{this.maybeReleaseBuffer(e),this.tensorMap.delete(e)}),this.uniformDisposalQueue.forEach(e=>this.bufferManager.releaseBuffer(e.buffer,e.byteSize,e.usage)),this.tensorDisposalQueue=[],this.uniformDisposalQueue=[]}disposeData(e,t=!1){if(this.tensorMap.has(e)){let n=this.tensorMap.get(e);if(n.refCount--,!t&&n.refCount>0)return!1;if(this.commandQueueOwnedIds.has(e))return this.tensorDisposalQueue.push(e),!1;this.maybeReleaseBuffer(e);let{complexTensorInfos:r}=this.tensorMap.get(e);r!=null&&(this.disposeData(r.real.dataId,!0),this.disposeData(r.imag.dataId,!0)),this.tensorMap.delete(e)}return!0}memory(){return{numBytesInGPU:this.bufferManager.numBytesUsed,numBytesAllocatedInGPU:this.bufferManager.numBytesAllocated,unreliable:!1}}getBufferManager(){return this.bufferManager}acquireBuffer(e,t=this.defaultGpuBufferUsage()){return this.bufferManager.acquireBuffer(e,t)}maybeReleaseBuffer(e){let t=this.tensorMap.get(e);t!=null&&t.bufferInfo.buffer!=null&&(this.bufferManager.releaseBuffer(t.bufferInfo.buffer,t.bufferInfo.byteSize,t.bufferInfo.usage),t.bufferInfo.buffer=null)}refCount(e){return this.tensorMap.has(e)?this.tensorMap.get(e).refCount:0}incRef(e){let t=this.tensorMap.get(e);t.refCount++}decRef(e){if(this.tensorMap.has(e)){let t=this.tensorMap.get(e);t.refCount--}}write(e,t,n){if(n==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");let r={id:this.nextDataId()},s=w.sizeFromShape(t)*bk(n);return n==="bool"&&e instanceof Uint8Array&&(e=Int32Array.from(e)),this.tensorMap.set(r,{dtype:n,values:e,bufferInfo:{byteSize:s,usage:this.defaultGpuBufferUsage()},refCount:1}),r}move(e,t,n,r,s){if(r==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");let a=w.sizeFromShape(n)*bk(r);this.tensorMap.set(e,{dtype:r,values:t,bufferInfo:{byteSize:a,usage:this.defaultGpuBufferUsage()},refCount:s})}submitQueue(){this.ensureComputePassEnded(),this.queue.submit([this.currentCommandEncoder.finish()]),this.currentCommandEncoder=null,this.dispatchNumberInEncoder=0,this.commandQueueOwnedIds=new WeakSet,this.flushDisposalQueue()}getBuffer(e){return this.uploadToGPU(e),this.tensorMap.get(e).bufferInfo.buffer}getFromPixelsProgram(e){switch(e){case"copyExternal":return this.fromPixelProgram||(this.fromPixelProgram=new XE),this.fromPixelProgram;case"import":return this.fromPixelImportProgram||(this.fromPixelImportProgram=new Tde),this.fromPixelImportProgram;default:w.assert(!1,()=>"Unsupported fromPixels shape");return}}ensureCommandEncoderReady(){this.currentCommandEncoder||(this.currentCommandEncoder=this.device.createCommandEncoder())}ensureComputePassEnded(){this.currentComputePass&&(this.currentComputePass.endPass(),this.currentComputePass=null)}getComputePass(){return this.currentComputePass||(this.currentComputePass=this.currentCommandEncoder.beginComputePass()),this.currentComputePass}async getBufferData(e){if(e.values!=null)return e.values;let t=this.acquireBuffer(e.bufferInfo.byteSize,GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ);this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.copyBufferToBuffer(e.bufferInfo.buffer,0,t,0,e.bufferInfo.byteSize),this.submitQueue(),await t.mapAsync(GPUMapMode.READ);let n=t.getMappedRange().slice(0);return t.unmap(),t!=null&&this.bufferManager.releaseBuffer(t,e.bufferInfo.byteSize,GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ),X().getBool("WEBGPU_USE_PROFILE_TOOL")&&(w.assert(this.dummyContext!==void 0,()=>"Fail to get context for profiling tool"),this.dummyContext.getCurrentTexture()),n}convertAndCacheOnCPU(e,t){let n=this.tensorMap.get(e);return this.maybeReleaseBuffer(e),n.values=t,n.values}readSync(e){let t=this.tensorMap.get(e),{values:n}=t;if(n==null)throw new Error("WebGPU readSync is only available for CPU-resident tensors.");return n}async read(e){if(!this.tensorMap.has(e))throw new Error(`Tensor ${e} was not registered!`);let t=this.tensorMap.get(e),{values:n}=t;if(n!=null)return this.convertAndCacheOnCPU(e,n);let r;if(t.dtype==="complex64"){let s=await Promise.all([this.read(t.complexTensorInfos.real.dataId),this.read(t.complexTensorInfos.imag.dataId)]),a=s[0],o=s[1];r=N.mergeRealAndImagArrays(a,o)}else{let s=await this.getBufferData(t);r=bE(s,t.dtype)}return this.convertAndCacheOnCPU(e,r),r}bufferSync(e){let t=this.readSync(e.dataId),n=t;if(e.dtype==="string")try{n=t.map(r=>w.decodeString(r))}catch(r){throw new Error("Failed to decode encoded string bytes into utf-8")}return $e(e.shape,e.dtype,n)}async time(e){let t=this.activeTimers,n=[],r=!1;this.programTimersStack==null?(this.programTimersStack=n,r=!0):this.activeTimers.push(n),this.activeTimers=n,e();let s=w.flatten(this.activeTimers.map(u=>u.query)).filter(u=>u!=null),a=w.flatten(this.activeTimers.map(u=>u.name)).filter(u=>u!=null);this.activeTimers=t,r&&(this.programTimersStack=null);let o={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null},i=await Promise.all(s);return o.kernelMs=w.sum(i),o.getExtraProfileInfo=()=>i.map((u,l)=>({name:a[l],ms:u})).map(u=>`${u.name}: ${u.ms}`).join(", "),this.uploadWaitMs=0,this.downloadWaitMs=0,o}getAndSavePipeline(e,t){return e in this.pipelineCache||(this.pipelineCache[e]=t()),this.pipelineCache[e]}makeTensorInfo(e,t,n){let r;if(t==="string"&&n!=null&&n.length>0&&w.isString(n[0])){let s=n.map(a=>w.encodeString(a));r=this.write(s,e,t)}else r=this.write(n,e,t);return{dataId:r,shape:e,dtype:t}}tensorToBinding(e){if(!e)return null;let t=this.tensorMap.get(e.dataId);return{offset:0,size:t.bufferInfo.byteSize,buffer:t.bufferInfo.buffer}}async getQueryTime(e){return this.supportTimeQuery?this.getTimeFromQuerySet(e):0}uploadToGPU(e){let t=this.tensorMap.get(e);t.bufferInfo.buffer==null&&(t.bufferInfo.buffer=this.acquireBuffer(t.bufferInfo.byteSize),t.values&&this.queue.writeBuffer(t.bufferInfo.buffer,0,t.values))}makeUniformsDataView(e){let t=this.acquireBuffer(e.byteLength,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);return this.queue.writeBuffer(t,0,e),{offset:0,size:e.byteLength,buffer:t}}arrayToDataView(e,t){let n=4,r=new DataView(new ArrayBuffer(t*n)),s=0;return e.forEach(a=>{let o=a.data;if(a.type!=="int32"&&a.type!=="float32"&&a.type!=="uint32")throw new Error(`${a.type} not supported!`);a.type==="int32"?o.forEach(i=>{r.setInt32(s*n,i,!0),s++}):a.type==="uint32"?o.forEach(i=>{r.setUint32(s*n,i,!0),s++}):o.forEach(i=>{r.setFloat32(s*n,i,!0),s++})}),r}computePadding(e){let t=0,n=0,r=0,s=[];return e.forEach((a,o)=>{a.data.length===0&&(a.data=[1]);let i;switch(a.data.length){case 0:i=1;break;case 1:i=1;break;case 2:i=2;break;case 3:i=4;break;case 4:i=4;break;default:w.assert(!1,()=>`Unsupported ${a.data.length}D shape`)}n=Math.ceil(t/i)*i-t;for(let u=0;u<n;++u)s.push({type:a.type,data:[0]}),r++;s.push({type:a.type,data:a.data}),r=r+a.data.length,t+=a.data.length+n}),this.arrayToDataView(s,r)}createLayout(e){let t=[];t.push({binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}});for(let s=0;s<e;s++)t.push({binding:s+1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}});t.push({binding:e+1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}});let n=this.device.createBindGroupLayout({entries:t}),r=this.device.createPipelineLayout({bindGroupLayouts:[n]});return{bindGroupLayout:n,pipelineLayout:r}}getCachedOrCreateLayout(e){return e in this.layoutCache||(this.layoutCache[e]=this.createLayout(e)),this.layoutCache[e]}runWebGPUProgram(e,t,n,r,s){if(!s){if(s=this.makeTensorInfo(e.outputShape,n),w.sizeFromShape(s.shape)===0){let E=this.tensorMap.get(s.dataId);return E.values=w.getTypedArrayFromDType(s.dtype,0),s}this.uploadToGPU(s.dataId)}let a=[{type:"float32",data:[NaN]}],o=t.concat(s).map(E=>E.shape),i="int32";o.map(E=>{a.push({type:i,data:E})});let u=w.computeStrides(s.shape);if(a.push({type:i,data:u}),e.size){let E=w.sizeFromShape(e.outputShape);a.push({type:i,data:[e.isVec4?E/4:E]})}r&&(a=[...a,...r]);let l=null,c=this.computePadding(a),d=c.byteLength;l=this.makeUniformsDataView(c);let p=t.map((E,F)=>{if(E.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");return this.uploadToGPU(E.dataId),{dtype:this.tensorMap.get(E.dataId).dtype,shape:E.shape,name:e.variableNames[F]}}),h=p.map(E=>E.dtype).concat(s.dtype),f=p.map(E=>N.getBroadcastDims(E.shape,s.shape)),m=p.map(E=>w.arraysEqual(E.shape,s.shape)).join("_"),g=f.map(E=>E.join("_")).join(";"),b=BE(e,o,h,g,m),{bindGroupLayout:y,pipelineLayout:v}=this.getCachedOrCreateLayout(e.variableNames.length),x=this.getAndSavePipeline(b,()=>LE(this.device,e,v,p,s)),k=this.activeTimers!=null,T=uce(this.device,y,t.map(E=>this.tensorToBinding(E)),this.tensorToBinding(s),l);this.ensureCommandEncoderReady();let C=this.getComputePass();if(k&&this.supportTimeQuery&&C.writeTimestamp(this.querySet,0),C.setPipeline(x),C.setBindGroup(0,T),C.dispatch(e.dispatch[0],e.dispatch[1],e.dispatch[2]),k&&this.supportTimeQuery&&C.writeTimestamp(this.querySet,1),this.dispatchNumberInEncoder++,t.forEach(E=>{this.commandQueueOwnedIds.add(E.dataId)}),this.commandQueueOwnedIds.add(s.dataId),l){let E={byteSize:d,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM,buffer:l.buffer};this.uniformDisposalQueue.push(E)}return X().get("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE")<=this.dispatchNumberInEncoder&&this.submitQueue(),k&&this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(this.querySet)}),s}runFromPixelsProgram(e,t,n,r,s){let a=this.device.createBindGroup({layout:n.bindGroupLayout,entries:[{binding:0,resource:{buffer:t}},{binding:1,resource:r},{binding:2,resource:{buffer:e.uniform}}]});this.ensureCommandEncoderReady();let o=this.getComputePass(),i=this.activeTimers!=null;i&&this.supportTimeQuery&&o.writeTimestamp(this.querySet,0),o.setPipeline(e.pipeline),o.setBindGroup(0,a),o.dispatch(e.dispatch[0],e.dispatch[1],e.dispatch[2]),i&&this.supportTimeQuery&&o.writeTimestamp(this.querySet,1),this.commandQueueOwnedIds.add(s),this.submitQueue(),i&&this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(this.querySet)})}async getTimeFromQuerySet(e){let t=this.acquireBuffer(16,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE),n=this.acquireBuffer(16,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.resolveQuerySet(e,0,2,t,0),this.currentCommandEncoder.copyBufferToBuffer(t,0,n,0,16),this.submitQueue(),await n.mapAsync(GPUMapMode.READ);let r=new BigUint64Array(n.getMappedRange()),s=Number(r[1]-r[0]);return n.unmap(),this.bufferManager.releaseBuffer(n,16,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST),this.bufferManager.releaseBuffer(t,16,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE),s/1e6}shouldExecuteOnCPU(e,t=Nde){return X().getBool("WEBGPU_CPU_FORWARD")&&e.every(n=>this.tensorMap.get(n.dataId).bufferInfo.buffer==null&&w.sizeFromShape(n.shape)<t)}numDataIds(){return this.tensorMap.numDataIds()-this.tensorDisposalQueue.length}dispose(){this.disposed||(this.bufferManager.dispose(),this.fromPixelProgram&&this.fromPixelProgram.dispose(),this.fromPixelImportProgram&&this.fromPixelImportProgram.dispose(),this.disposed=!0)}},Tk=YE;Tk.nextDataId=0;var QE={};Ee(QE,{WebGPUBackend:()=>Tk,webgpu_util:()=>gE});bc.isBrowser()&&yk()&&wd("webgpu",async()=>{X().set("CHECK_COMPUTATION_FOR_ERRORS",!1);let e={powerPreference:X().get("WEBGPU_USE_LOW_POWER_GPU")?"low-power":"high-performance"},t=await navigator.gpu.requestAdapter(e),n={},r=t.features.has("timestamp-query");r?n={requiredFeatures:["timestamp-query"]}:console.warn("This device doesn't support timestamp-query extension. Start Chrome browser with flag --disable-dawn-features=disallow_unsafe_apis then try again. Or zero will shown for the kernel time when profiling mode isenabled. Using performance.now is not workable for webgpu sinceit doesn't support synchronously to read data from GPU.");let s=await t.requestDevice(n);return new Tk(s,r)},3);var Lt;(function(e){e[e.float32=0]="float32",e[e.int32=1]="int32",e[e.bool=2]="bool",e[e.string=3]="string",e[e.complex64=4]="complex64"})(Lt||(Lt={}));var mp;(function(e){e[e.linear=0]="linear",e[e.relu=1]="relu",e[e.relu6=2]="relu6",e[e.prelu=3]="prelu",e[e.leakyrelu=4]="leakyrelu",e[e.sigmoid=5]="sigmoid",e[e.elu=6]="elu"})(mp||(mp={}));var ZE;function _de(e){ZE=e.wasm.cwrap(to,null,["number","array","number","number","array","number","number","number","number","number","number","number","number"])}function Ede(e){let{inputs:t,backend:n,attrs:r}=e,{a:s,b:a,bias:o,preluActivationWeights:i}=t;if(s.dtype!=="float32"||a.dtype!=="float32")throw new Error("_FusedMatMul for non non-float32 tensors not yet supported.");let{transposeA:u,transposeB:l,activation:c,leakyreluAlpha:d}=r,p=n.dataIdMap.get(s.dataId).id,h=n.dataIdMap.get(a.dataId).id,f=0;if(o!=null){let E=n.dataIdMap.get(o.dataId);if(E.shape.length!==1)throw new Error(`_FusedMatMul only supports rank-1 bias but got rank ${E.shape.length}.`);f=E.id}let m=i==null?0:n.dataIdMap.get(i.dataId).id,g=mp[c];if(g==null)throw new Error(`${c} activation not yet supported for FusedConv2D in the wasm backend.`);let b=u?s.shape[2]:s.shape[1],y=l?a.shape[1]:a.shape[2],v=Ri.assertAndGetBroadcastShape(s.shape.slice(0,-2),a.shape.slice(0,-2)),x=n.makeOutput([...v,b,y],s.dtype),k=n.dataIdMap.get(x.dataId).id,T=new Uint8Array(new Int32Array(s.shape).buffer),C=new Uint8Array(new Int32Array(a.shape).buffer);return ZE(p,T,s.shape.length,h,C,a.shape.length,u,l,g,f,m,d||0,k),x}var Ade={kernelName:to,backendName:"wasm",setupFunc:_de,kernelFunc:Ede};function mn(e,t){let n;function r(a){n=a.wasm.cwrap(e,null,["number","number","number"])}function s(a){let{backend:o,inputs:{x:i}}=a,u=o.dataIdMap.get(i.dataId).id,l=o.makeOutput(i.shape,t||i.dtype),c=o.dataIdMap.get(l.dataId).id;return w.sizeFromShape(l.shape)===0||n(u,Lt[i.dtype],c),l}return{kernelName:e,backendName:"wasm",setupFunc:r,kernelFunc:s}}var $de=mn(Vo);function Pn(e,t,n){let r;function s(o){r=o.wasm.cwrap(e,null,["number","array","number","number","array","number","number","number"])}function a(o){let{backend:i,inputs:u}=o,{a:l,b:c}=u,d=i.dataIdMap.get(l.dataId).id,p=i.dataIdMap.get(c.dataId).id,h=n!=null?n:l.dtype,f=N.assertAndGetBroadcastShape(l.shape,c.shape),m=i.makeOutput(f,h);if(w.sizeFromShape(f)===0)return m;let g=new Uint8Array(new Int32Array(l.shape).buffer),b=new Uint8Array(new Int32Array(c.shape).buffer),y=i.dataIdMap.get(m.dataId).id;return(()=>r(d,g,l.shape.length,p,b,c.shape.length,Lt[l.dtype],y))(),m}return{kernelName:e,backendName:"wasm",setupFunc:s,kernelFunc:a}}var Fde=!0,Dde=Pn(_s,Fde),JE;function Rde(e){JE=e.wasm.cwrap(la,null,["array","number","number","number"])}function Pde(e){let{inputs:t,backend:n}=e,r=n.makeOutput(t[0].shape,t[0].dtype);if(w.sizeFromShape(r.shape)===0)return r;let s=t.map(i=>n.dataIdMap.get(i.dataId).id),a=new Uint8Array(new Int32Array(s).buffer),o=n.dataIdMap.get(r.dataId).id;return JE(a,s.length,Lt[r.dtype],o),r}var Ode={kernelName:la,backendName:"wasm",setupFunc:Rde,kernelFunc:Pde};function Gm(e){let{inputs:{x:t},backend:n}=e,r=n.makeOutput(t.shape,t.dtype),s=n.typedArrayFromHeap(t);return n.typedArrayFromHeap(r).set(s),r}var Mde={kernelName:_a,backendName:"wasm",kernelFunc:Gm},eA;function Lde(e){eA=e.wasm.cwrap(Ja,null,["number","array","number","number","number","array","number"])}function il(e){let{inputs:t,backend:n,attrs:r}=e,[s,a]=zde(t.x.shape,r.perm),o=!0;for(let f=0;f<a.length;f++)a[f]!==f&&(o=!1);let i=Bde(t.x.shape,r.perm),u={dataId:t.x.dataId,shape:s,dtype:t.x.dtype};if(o){let f=Gm({inputs:t,backend:n});return f.shape=i,f}let l=n.makeOutput(i,u.dtype),c=n.dataIdMap.get(u.dataId).id,d=n.dataIdMap.get(l.dataId).id,p=new Uint8Array(new Int32Array(a).buffer),h=new Uint8Array(new Int32Array(u.shape).buffer);return eA(c,h,u.shape.length,Lt[u.dtype],d,p,a.length),l}function Bde(e,t){let n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];return n}function zde(e,t){let n=[],r=[];for(let s=0;s<e.length;++s)e[s]!==1&&n.push(e[s]),e[t[s]]!==1&&r.push(t[s]);for(let s=0;s<r.length;++s){let a=-1;for(let o=0;o<r.length;++o)r[o]>=s&&(a===-1||r[a]>r[o])&&(a=o);r[a]=s}return[n,r]}var Wde={kernelName:Ja,backendName:"wasm",kernelFunc:il,setupFunc:Lde};function _o(e,t,n){let r=e.shape,s=e.shape.length,a=w.parseAxisParam(t,r),o=a,i=N.getAxesPermutation(o,s),u=null,l=!1;if(i!=null){let c=new Array(s);for(let h=0;h<c.length;h++)c[h]=r[i[h]];o=N.getInnerMostAxes(o.length,s),u=il({inputs:{x:e},attrs:{perm:i},backend:n});let d=n.dataIdMap.get(e.dataId).id;n.dataIdMap.get(u.dataId).id!==d&&(l=!0)}return{transposed:u,originalAxes:a,axes:o,inputWasTransposed:l}}var tA;function Vde(e){tA=e.wasm.cwrap(Uu,null,["number, number, number"])}function Ude(e){let{backend:t,inputs:n,attrs:r}=e,{axis:s,keepDims:a}=r,{x:o}=n,u=t.dataIdMap.get(o.dataId).id,l=o,{transposed:c,axes:d,originalAxes:p,inputWasTransposed:h}=_o(o,s,t);if(h){let v=t.dataIdMap.get(c.dataId).id;l=c,u=v}let f=l.shape.length;N.assertAxesAreInnerMostDims("all",d,f);let[m,g]=N.computeOutAndReduceShapes(l.shape,d),b=w.sizeFromShape(g),y=t.makeOutput(m,o.dtype);if(w.sizeFromShape(l.shape)!==0){let v=t.dataIdMap.get(y.dataId).id;tA(u,b,v)}if(h&&t.disposeData(c.dataId),a){let v=N.expandShapeToKeepDim(y.shape,p);y.shape=v}return y}var Gde={kernelName:Uu,backendName:"wasm",setupFunc:Vde,kernelFunc:Ude},nA;function Hde(e){nA=e.wasm.cwrap(Gu,null,["number, number, number"])}function jde(e){let{backend:t,inputs:n,attrs:r}=e,{axis:s,keepDims:a}=r,{x:o}=n,u=t.dataIdMap.get(o.dataId).id,l=o,{transposed:c,axes:d,originalAxes:p,inputWasTransposed:h}=_o(o,s,t);if(h){let v=t.dataIdMap.get(c.dataId).id;l=c,u=v}let f=l.shape.length;N.assertAxesAreInnerMostDims("any",d,f);let[m,g]=N.computeOutAndReduceShapes(l.shape,d),b=w.sizeFromShape(g),y=t.makeOutput(m,o.dtype);if(w.sizeFromShape(l.shape)!==0){let v=t.dataIdMap.get(y.dataId).id;nA(u,b,v)}if(h&&t.disposeData(c.dataId),a){let v=N.expandShapeToKeepDim(y.shape,p);y.shape=v}return y}var qde={kernelName:Gu,backendName:"wasm",setupFunc:Hde,kernelFunc:jde},rA;function Kde(e){rA=e.wasm.cwrap(da,null,["number","number","number","number","number"])}function Xde(e){let{backend:t,inputs:n,attrs:r}=e,{axis:s}=r,{x:a}=n,o=t.dataIdMap.get(a.dataId).id,i=o,u=a,{transposed:l,axes:c,inputWasTransposed:d}=_o(a,s,t);if(d){let b=t.dataIdMap.get(l.dataId).id;b!==o&&(u=l,i=b)}let p=u.shape.slice(0,-1),h=t.makeOutput(p,"int32"),f=t.dataIdMap.get(h.dataId).id,m=w.sizeFromShape(h.shape),g=u.shape[c[0]];return rA(i,Lt[u.dtype],m,g,f),d&&t.disposeData(l.dataId),h}var Yde={kernelName:da,backendName:"wasm",kernelFunc:Xde,setupFunc:Kde},sA;function Qde(e){sA=e.wasm.cwrap(pa,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Zde(e){let{inputs:t,attrs:n,backend:r}=e,s=t.x,a=r.dataIdMap.get(s.dataId).id,{filterSize:o,strides:i,pad:u,dimRoundingMode:l}=n,c=N.computePool2DInfo(s.shape,o,i,1,u,l),d=c.filterHeight,p=c.filterWidth,h=c.padInfo.top,f=c.padInfo.right,m=c.padInfo.bottom,g=c.padInfo.left,b=c.strideHeight,y=c.strideWidth,v=c.inChannels;if(c.dataFormat!=="channelsLast")throw new Error(`wasm backend does not support dataFormat:'${c.dataFormat}'. Please use 'channelsLast'.`);if(c.dilationWidth!==1||c.dilationHeight!==1)throw new Error(`was backend only supports average pooling with dilation = [1, 1], got [${c.dilationHeight}, ${c.dilationWidth}].`);let x=r.makeOutput(c.outShape,"float32"),k=r.dataIdMap.get(x.dataId).id;return sA(a,s.shape[0],s.shape[1],s.shape[2],d,p,h,f,m,g,b,y,v,k),x}var Jde={kernelName:pa,backendName:"wasm",setupFunc:Qde,kernelFunc:Zde};function Kn(e){let{inputs:t,attrs:n}=e,{x:r}=t,{shape:s}=n,a=w.sizeFromShape(r.shape),o=w.inferFromImplicitShape(s,a);return w.assert(a===w.sizeFromShape(o),()=>`new shape: ${o}, old shape: ${r.shape}. New shape and old shape must have the same number of elements.`),e.backend.incRef(r.dataId),{dataId:r.dataId,shape:o,dtype:r.dtype}}var epe={kernelName:hi,backendName:"wasm",kernelFunc:Kn},aA;function tpe(e){aA=e.wasm.cwrap(ha,null,["number","array","number","number","array","number","number","number","number"])}function npe(e){let{inputs:t,backend:n,attrs:r}=e,{a:s,b:a}=t,{transposeA:o,transposeB:i}=r;if(s.dtype!=="float32"||a.dtype!=="float32")throw new Error("BatchMatMul for non non-float32 tensors not yet supported.");let u=s.shape.length,l=a.shape.length,c=o?s.shape[u-2]:s.shape[u-1],d=i?a.shape[l-1]:a.shape[l-2],p=o?s.shape[u-1]:s.shape[u-2],h=i?a.shape[l-2]:a.shape[l-1],f=s.shape.slice(0,-2),m=a.shape.slice(0,-2),g=w.sizeFromShape(f),b=w.sizeFromShape(m),v=Ri.assertAndGetBroadcastShape(s.shape.slice(0,-2),a.shape.slice(0,-2)).concat([p,h]);w.assert(c===d,()=>`Error in matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${s.shape} and ${a.shape} and transposeA=${o} and transposeB=${i} must match.`);let x=o?[g,c,p]:[g,p,c],k=i?[b,h,d]:[b,d,h],T=Kn({inputs:{x:s},backend:n,attrs:{shape:x}}),C=Kn({inputs:{x:a},backend:n,attrs:{shape:k}}),E=n.dataIdMap.get(T.dataId).id,F=n.dataIdMap.get(C.dataId).id,O=o?T.shape[2]:T.shape[1],D=i?C.shape[1]:C.shape[2],R=Math.max(g,b),_=n.makeOutput([R,O,D],T.dtype),L=n.dataIdMap.get(_.dataId).id,U=new Uint8Array(new Int32Array(T.shape).buffer),j=new Uint8Array(new Int32Array(C.shape).buffer);return aA(E,U,T.shape.length,F,j,C.shape.length,o,i,L),n.disposeData(T.dataId),n.disposeData(C.dataId),_.shape=v,_}var rpe={kernelName:ha,backendName:"wasm",setupFunc:tpe,kernelFunc:npe};function lu(e){let{inputs:{x:t},attrs:{begin:n,size:r},backend:s}=e,[a,o]=$t.parseSliceParams(t,n,r),i=$t.isSliceContinous(t.shape,a,o),u=s.readSync(t.dataId),l=s.makeOutput(o,t.dtype),c=w.computeStrides(t.shape),d=s.dataIdMap.get(l.dataId);if(i){let f=$t.computeFlatOffset(a,c);return t.dtype==="string"?d.stringBytes=u.slice(f,f+w.sizeFromShape(o)):s.typedArrayFromHeap(l).set(u.subarray(f,f+w.sizeFromShape(o))),l}if(t.dtype==="string"){let f=bm(u,a,o,t.shape,t.dtype);return d.stringBytes=f,l}let p=s.typedArrayFromHeap(l),h=t.shape.length;if(h===2)spe(u,c[0],p,a,o);else if(h===3)ape(u,c[0],c[1],p,a,o);else if(h===4)ope(u,c[0],c[1],c[2],p,a,o);else{let f=bm(u,a,o,t.shape,t.dtype);p.set(f)}return l}function spe(e,t,n,r,s){let a=0,o=r[0],i=r[1],u=o+s[0];for(let l=o;l<u;l++){let c=l*t+i;n.set(e.subarray(c,c+s[1]),a),a+=s[1]}}function ape(e,t,n,r,s,a){let o=0,i=s[0],u=s[1],l=s[2],c=i+a[0],d=u+a[1];for(let p=i;p<c;p++)for(let h=u;h<d;h++){let f=p*t+h*n+l;r.set(e.subarray(f,f+a[2]),o),o+=a[2]}}function ope(e,t,n,r,s,a,o){let i=0,u=a[0],l=a[1],c=a[2],d=u+o[0],p=l+o[1],h=c+o[2],f=a[3];for(let m=u;m<d;m++)for(let g=l;g<p;g++)for(let b=c;b<h;b++){let y=m*t+g*n+b*r+f;s.set(e.subarray(y,y+o[3]),i),i+=o[3]}}var ipe={kernelName:yi,backendName:"wasm",kernelFunc:lu};function upe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,crops:o}=r,i=a.reduce((b,y)=>b*y),u=N.getReshaped(s.shape,a,i),l=N.getPermuted(u.length,a.length),c=N.getReshapedPermuted(s.shape,a,i),d=N.getSliceBeginCoords(o,a.length),p=N.getSliceSize(c,o,a.length),h=Kn({inputs:{x:s},backend:n,attrs:{shape:u}}),f=il({inputs:{x:h},backend:n,attrs:{perm:l}}),m=Kn({inputs:{x:f},backend:n,attrs:{shape:c}}),g=lu({inputs:{x:m},backend:n,attrs:{begin:d,size:p}});return n.disposeData(h.dataId),n.disposeData(f.dataId),n.disposeData(h.dataId),g}var cpe={kernelName:Uo,backendName:"wasm",kernelFunc:upe};function gp(e){let{inputs:{x:t},attrs:{dtype:n},backend:r}=e,s=r.makeOutput(t.shape,n),a=r.typedArrayFromHeap(t);return r.typedArrayFromHeap(s).set(a),s}var lpe={kernelName:fa,backendName:"wasm",kernelFunc:gp},dpe=mn(ma),oA;function ppe(e){oA=e.wasm.cwrap(Es,null,["number","number","number","number"])}function hpe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{clipValueMin:a,clipValueMax:o}=r,i=n.dataIdMap.get(s.dataId).id,u=n.makeOutput(s.shape,s.dtype),l=n.dataIdMap.get(u.dataId).id;return oA(i,a,o,l),u}var fpe={kernelName:Es,backendName:"wasm",setupFunc:ppe,kernelFunc:hpe};function iA(e){let{inputs:t,backend:n}=e,r=w.parseAxisParam(e.attrs.axis,t[0].shape)[0],s=N.computeOutShape(t.map(h=>h.shape),r),a=t.filter(h=>w.sizeFromShape(h.shape)>0);if(a.length===1)return Gm({inputs:{x:a[0]},backend:n});let o=n.makeOutput(s,t[0].dtype);if(w.sizeFromShape(s)===0)return o;let i=a.map(h=>h.shape);if(N.assertParamsConsistent(i,r),a[0].dtype==="string"){let h=a.map(v=>{let x=w.sizeFromShape(v.shape.slice(r));return Kn({inputs:{x:v},backend:n,attrs:{shape:[-1,x]}})}),f=h.map(v=>({vals:n.readSync(v.dataId),shape:v.shape}));s=N.computeOutShape(h.map(v=>v.shape),1);let m=h[0].shape[0]===1,g=Rw(f,s,t[0].dtype,m),b=N.computeOutShape(a.map(v=>v.shape),r);o.shape=b;let y=n.dataIdMap.get(o.dataId);return y.stringBytes=N.fromStringArrayToUint8(g),h.forEach(v=>n.disposeData(v.dataId)),o}let u=w.sizeFromShape(a[0].shape.slice(0,r)),l=0,c=a.map(h=>{let f=w.sizeFromShape(h.shape.slice(r));return l+=f,f}),d=a.map(h=>n.typedArrayFromHeap(h)),p=n.typedArrayFromHeap(o);for(let h=0;h<u;h++){let f=h*l;for(let m=0;m<d.length;m++){let g=c[m],b=h*g,y=d[m].subarray(b,b+g);p.set(y,f),f+=g}}return o}var mpe={kernelName:Go,backendName:"wasm",kernelFunc:iA},uA;function gpe(e){uA=e.wasm.cwrap(ga,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function bpe(e){let{inputs:t,attrs:n,backend:r}=e,{x:s,filter:a}=t,o=r.dataIdMap.get(s.dataId).id,i=r.dataIdMap.get(a.dataId).id,{strides:u,dilations:l,pad:c,dimRoundingMode:d,dataFormat:p}=n,h=N.convertConv2DDataFormat(p),f=N.computeConv2DInfo(s.shape,a.shape,u,l,c,d,!1,h),m=f.filterHeight,g=f.filterWidth,b=f.padInfo.top,y=f.padInfo.right,v=f.padInfo.bottom,x=f.padInfo.left,k=f.dilationHeight,T=f.dilationWidth,C=f.strideHeight,E=f.strideWidth,F=f.inChannels,O=f.outChannels,D=f.padInfo.type==="SAME"?1:0;if(f.dataFormat!=="channelsLast")throw new Error(`wasm backend Conv2D does not support dataFormat:'${f.dataFormat}'. Please use 'channelsLast'.`);let R=r.makeOutput(f.outShape,"float32"),_=r.dataIdMap.get(R.dataId).id;return uA(o,s.shape[0],s.shape[1],s.shape[2],i,m,g,b,y,v,x,D,k,T,C,E,F,O,_),R}var ype={kernelName:ga,backendName:"wasm",setupFunc:gpe,kernelFunc:bpe},cA;function vpe(e){cA=e.wasm.cwrap(ba,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function xpe(e){let{backend:t,inputs:n,attrs:r}=e,{dy:s,filter:a}=n,{strides:o,pad:i,dataFormat:u,dimRoundingMode:l,inputShape:c}=r,d=1,p=N.convertConv2DDataFormat(u),h=N.computeConv2DInfo(c,a.shape,o,d,i,l,!1,p),{batchSize:f,filterHeight:m,filterWidth:g,inChannels:b,inHeight:y,inWidth:v,outChannels:x,outHeight:k,outWidth:T,strideHeight:C,strideWidth:E}=h,F=m-1-h.padInfo.top,O=g-1-h.padInfo.left,D=h.dataFormat==="channelsLast",R=w.computeStrides(h.inShape),_=w.computeStrides(s.shape),[L,U,j]=w.computeStrides(a.shape),K=R[0],q=D?R[1]:R[2],Q=D?R[2]:1,ee=D?1:R[1],re=_[0],se=D?_[1]:_[2],ne=D?_[2]:1,ie=D?1:_[1],te=t.makeOutput(h.inShape,"float32"),pe=t.dataIdMap.get(te.dataId).id,be=t.dataIdMap.get(s.dataId).id,Ce=t.dataIdMap.get(a.dataId).id;return cA(be,Ce,f,m,g,y,v,b,k,T,x,C,E,F,O,L,U,j,K,q,Q,ee,re,se,ne,ie,pe),te}var wpe={kernelName:ba,backendName:"wasm",setupFunc:vpe,kernelFunc:xpe},kpe=mn(ya),Ipe=mn(va),Nk;(function(e){e[e.bilinear=0]="bilinear",e[e.nearest=1]="nearest"})(Nk||(Nk={}));var lA;function Spe(e){lA=e.wasm.cwrap(jo,null,["number","number","number","number","array","number","number","number","number","number"])}function Cpe(e){let{backend:t,inputs:n,attrs:r}=e,{method:s,extrapolationValue:a,cropSize:o}=r,{image:i,boxes:u,boxInd:l}=n,c=u.shape[0],[d,p]=o,h=[c,d,p,i.shape[3]],f=t.dataIdMap.get(i.dataId),m;i.dtype!=="float32"&&(m=gp({backend:t,inputs:{x:i},attrs:{dtype:"float32"}}),f=t.dataIdMap.get(m.dataId));let g=f.id,b=t.dataIdMap.get(u.dataId).id,y=t.dataIdMap.get(l.dataId).id,v=t.makeOutput(h,"float32"),x=t.dataIdMap.get(v.dataId).id,k=new Uint8Array(new Int32Array(i.shape).buffer);return lA(g,b,y,c,k,d,p,Nk[s],a,x),m!=null&&t.disposeData(m.dataId),v}var Tpe={kernelName:jo,backendName:"wasm",setupFunc:Spe,kernelFunc:Cpe},dA;function Npe(e){dA=e.wasm.cwrap(Ho,null,["number","number","number","number","number","number"])}function _pe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:o,reverse:i}=r,u=s.shape.length;w.assert(s.dtype==="float32"||s.dtype==="int32",()=>`cumsum does not support ${s.dtype} tensors in the WASM backend`);let l=N.getAxesPermutation([a],u),c=s;l!==null&&(c=il({inputs:{x:s},attrs:{perm:l},backend:n}));let d=N.getInnerMostAxes(1,u)[0];N.assertAxesAreInnerMostDims("cumsum",[d],u);let p=n.makeOutput(c.shape,c.dtype),h=c.shape[d],f=n.dataIdMap.get(c.dataId).id,m=n.dataIdMap.get(p.dataId).id;dA(f,o?1:0,i?1:0,h,m,Lt[s.dtype]);let g=p;if(l!==null){let b=N.getUndoAxesPermutation(l);g=il({inputs:{x:p},attrs:{perm:b},backend:n}),n.disposeData(c.dataId),n.disposeData(p.dataId)}return g}var Epe={kernelName:Ho,backendName:"wasm",setupFunc:Npe,kernelFunc:_pe},pA;function Ape(e){pA=e.wasm.cwrap(qo,null,["number","number","number","array","number","array","array","number","number"])}function $pe(e){let{backend:t,inputs:n,attrs:r}=e,{x:s}=n,{blockSize:a,dataFormat:o}=r,i=s.shape[0],u=o==="NHWC"?s.shape[1]:s.shape[2],l=o==="NHWC"?s.shape[2]:s.shape[3],c=o==="NHWC"?s.shape[3]:s.shape[1],d=u*a,p=l*a,h=c/(a*a),f=o==="NHWC"?[i,d,p,h]:[i,h,d,p],m=t.makeOutput(f,"float32"),b=t.dataIdMap.get(s.dataId).id,y=new Uint8Array(new Int32Array(w.computeStrides(s.shape)).buffer),v=new Uint8Array(new Int32Array(f).buffer),x=new Uint8Array(new Int32Array(w.computeStrides(f)).buffer),k=t.dataIdMap.get(m.dataId).id;return pA(b,a,o==="NHWC"?1:0,y,s.shape.length-1,v,x,f.length,k),m}var Fpe={kernelName:qo,backendName:"wasm",setupFunc:Ape,kernelFunc:$pe},hA;function Dpe(e){hA=e.wasm.cwrap(xa,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Rpe(e){let{inputs:t,attrs:n,backend:r}=e,{x:s,filter:a}=t,o=r.dataIdMap.get(s.dataId).id,i=r.dataIdMap.get(a.dataId).id,{strides:u,dilations:l,pad:c,dimRoundingMode:d}=n,p=l==null?[1,1]:l,h=N.computeConv2DInfo(s.shape,a.shape,u,p,c,d,!0),f=h.filterHeight,m=h.filterWidth,g=h.padInfo.top,b=h.padInfo.right,y=h.padInfo.bottom,v=h.padInfo.left,x=h.dilationHeight,k=h.dilationWidth,T=h.strideHeight,C=h.strideWidth,E=h.inChannels,F=h.outChannels,O=h.padInfo.type==="SAME"?1:0;if(h.dataFormat!=="channelsLast")throw new Error(`wasm backend DepthwiseConv2dNative does not support dataFormat:'${h.dataFormat}'. Please use 'channelsLast'.`);let D=r.makeOutput(h.outShape,"float32"),R=r.dataIdMap.get(D.dataId).id;return hA(o,s.shape[0],s.shape[1],s.shape[2],i,f,m,g,b,y,v,O,x,k,T,C,E,F,R),D}var Ppe={kernelName:xa,backendName:"wasm",setupFunc:Dpe,kernelFunc:Rpe},Ope=mn(ka),Mpe=!1,Lpe=Pn(Ko,Mpe,"bool"),Bpe=mn(Ia,"float32");function _k(e){let{inputs:t,attrs:n,backend:r}=e,{input:s}=t,{dim:a}=n,o=s.shape.length,i=s.shape.slice(),u=a;return a<0&&(w.assert(-(o+1)<=a,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),u=o+a+1),i.splice(u,0,1),Kn({inputs:{x:s},backend:r,attrs:{shape:i}})}var zpe={kernelName:Xo,backendName:"wasm",kernelFunc:_k};function fA(e){let{attrs:{shape:t,value:n,dtype:r},backend:s}=e,a=s.makeOutput(t,r);return s.typedArrayFromHeap(a).fill(n),a}var Wpe={kernelName:Zu,backendName:"wasm",kernelFunc:fA},mA;function Vpe(e){mA=e.wasm.cwrap(Qo,null,["number","number","number","number","number","number"])}function Upe(e){let{inputs:t,backend:n}=e,{image:r}=t,s=n.makeOutput(r.shape,r.dtype),a=n.dataIdMap.get(r.dataId).id,o=n.dataIdMap.get(s.dataId).id,[i,u,l,c]=r.shape;return mA(a,i,u,l,c,o),s}var Gpe={kernelName:Qo,backendName:"wasm",kernelFunc:Upe,setupFunc:Vpe},Hpe=mn(Sa),jpe=!1,qpe=Pn(Ca,jpe),gA;function Kpe(e){gA=e.wasm.cwrap(Ta,null,["number","number","number","number","number","number","number"])}function Xpe(e){let{backend:t,inputs:n,attrs:r}=e,{varianceEpsilon:s}=r,{x:a,mean:o,variance:i,offset:u,scale:l}=n,c=t.dataIdMap.get(a.dataId).id,d=t.dataIdMap.get(o.dataId).id,p=t.dataIdMap.get(i.dataId).id,h=u!=null?t.dataIdMap.get(u.dataId).id:0,f=l!=null?t.dataIdMap.get(l.dataId).id:0,m=t.makeOutput(a.shape,a.dtype);if(w.sizeFromShape(a.shape)===0)return m;let g=t.dataIdMap.get(m.dataId).id;return gA(c,d,p,h,f,s,g),m}var Ype={kernelName:Ta,backendName:"wasm",setupFunc:Kpe,kernelFunc:Xpe},bA;function Qpe(e){bA=e.wasm.cwrap(no,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Zpe(e){let{inputs:t,attrs:n,backend:r}=e,{x:s,filter:a,bias:o,preluActivationWeights:i}=t,{strides:u,pad:l,dilations:c,dataFormat:d,dimRoundingMode:p,activation:h,leakyreluAlpha:f}=n,m=N.computeConv2DInfo(s.shape,a.shape,u,c,l,p),g=mp[h];if(g==null)throw new Error(`${h} activation not yet supported for FusedConv2D in the wasm backend.`);let b=r.dataIdMap.get(s.dataId).id,y=r.dataIdMap.get(a.dataId).id,v=m.outChannels,x=0;if(o!=null){let ne=r.dataIdMap.get(o.dataId);if(ne.shape.length!==1)throw new Error(`FusedConv2D only supports rank-1 bias but got rank ${ne.shape.length}.`);if(ne.shape[0]!==v)throw new Error(`FusedConv2D bias shape (${ne.shape}) does not match the number of output channels (${v})`);x=ne.id}let k=m.filterHeight,T=m.filterWidth,C=m.padInfo.top,E=m.padInfo.right,F=m.padInfo.bottom,O=m.padInfo.left,D=m.dilationHeight,R=m.dilationWidth,_=m.strideHeight,L=m.strideWidth,U=m.inChannels,j=m.padInfo.type==="SAME"?1:0,K=m.batchSize,q=m.inHeight,Q=m.inWidth;if(d!=="NHWC")throw new Error(`wasm backend FusedConv2D does not support dataFormat:'${d}'. Please use 'NHWC'.`);let ee=r.makeOutput(m.outShape,"float32"),re=r.dataIdMap.get(ee.dataId).id,se=i==null?0:r.dataIdMap.get(i.dataId).id;return bA(b,K,q,Q,y,k,T,x,C,E,F,O,j,D,R,_,L,U,v,g,se,f||0,re),ee}var Jpe={kernelName:no,backendName:"wasm",setupFunc:Qpe,kernelFunc:Zpe},yA;function ehe(e){yA=e.wasm.cwrap(ro,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function the(e){let{inputs:t,attrs:n,backend:r}=e,{x:s,filter:a,bias:o,preluActivationWeights:i}=t,{strides:u,pad:l,dilations:c,dataFormat:d,dimRoundingMode:p,activation:h,leakyreluAlpha:f}=n,m=N.computeConv2DInfo(s.shape,a.shape,u,c,l,p,!0),g=mp[h];if(g==null)throw new Error(`${h} activation not yet supported for FusedDepthwiseConv2D in the wasm backend.`);let b=r.dataIdMap.get(s.dataId).id,y=r.dataIdMap.get(a.dataId).id,v=m.outChannels,x=0;if(o!=null){let ne=r.dataIdMap.get(o.dataId);if(ne.shape.length!==1)throw new Error(`FusedDepthwiseConv2D only supports rank-1 bias but got rank ${ne.shape.length}.`);if(ne.shape[0]!==v)throw new Error(`FusedDepthwiseConv2D bias shape (${ne.shape}) does not match the number of output channels (${v})`);x=ne.id}let k=m.filterHeight,T=m.filterWidth,C=m.padInfo.top,E=m.padInfo.right,F=m.padInfo.bottom,O=m.padInfo.left,D=m.dilationHeight,R=m.dilationWidth,_=m.strideHeight,L=m.strideWidth,U=m.inChannels,j=m.padInfo.type==="SAME"?1:0,K=m.batchSize,q=m.inHeight,Q=m.inWidth;if(d!=="NHWC")throw new Error(`wasm backend FusedDepthwiseConv2D does not support dataFormat:'${d}'. Please use 'NHWC'.`);let ee=r.makeOutput(m.outShape,"float32"),re=r.dataIdMap.get(ee.dataId).id,se=i==null?0:r.dataIdMap.get(i.dataId).id;return yA(b,K,q,Q,y,k,T,x,C,E,F,O,j,D,R,_,L,U,v,g,se,f||0,re),ee}var nhe={kernelName:ro,backendName:"wasm",setupFunc:ehe,kernelFunc:the},vA;function rhe(e){vA=e.wasm.cwrap(Jo,null,["number","number","number","number","number","number","array","number"])}function she(e){let{backend:t,inputs:n}=e,{params:r,indices:s}=n,[a,o,i,u]=Ey.prepareAndValidate(r,s),l=t.makeOutput(a,r.dtype);if(o===0)return l;let c=s.shape,d=c[c.length-1],h=t.dataIdMap.get(r.dataId).id,m=t.dataIdMap.get(s.dataId).id,g=new Uint8Array(new Int32Array(u).buffer),b=t.dataIdMap.get(l.dataId).id;return vA(h,Lt[r.dtype],m,o,d,i,g,b),l}var ahe={kernelName:Jo,backendName:"wasm",setupFunc:rhe,kernelFunc:she},xA;function ohe(e){xA=e.wasm.cwrap("Gather",null,["number","number","array","number","number","number","array","number"])}function ihe(e){let{backend:t,inputs:n,attrs:r}=e,{x:s,indices:a}=n,{axis:o,batchDims:i}=r,u=w.parseAxisParam(o,s.shape)[0],l=t.readSync(a.dataId),c=s.shape[u];for(let F=0;F<l.length;++F){let O=l[F];w.assert(O<=c-1&&O>=0,()=>`GatherV2: the index value ${O} is not in [0, ${c-1}]`)}let d=N.segment_util.collectGatherOpShapeInfo(s,a,u,i),p=Kn({inputs:{x:s},attrs:{shape:[d.batchSize,d.outerSize,d.dimSize,d.sliceSize]},backend:t}),h=w.sizeFromShape(a.shape),f=Kn({inputs:{x:a},attrs:{shape:[d.batchSize,h/d.batchSize]},backend:t}),m=[d.batchSize,d.outerSize,h/d.batchSize,d.sliceSize],g=t.makeOutput(m,s.dtype);if(w.sizeFromShape(s.shape)===0)return g;let b=p.shape.length-1,v=t.dataIdMap.get(p.dataId).id,k=t.dataIdMap.get(f.dataId).id,T=t.dataIdMap.get(g.dataId).id,C=new Uint8Array(new Int32Array(w.computeStrides(p.shape)).buffer),E=new Uint8Array(new Int32Array(w.computeStrides(m)).buffer);return xA(v,Lt[s.dtype],C,b,k,d.batchSize,E,T),t.disposeData(p.dataId),t.disposeData(f.dataId),g.shape=d.outputShape,g}var uhe={kernelName:Zo,backendName:"wasm",setupFunc:ohe,kernelFunc:ihe},che=!1,lhe=Pn(ei,che,"bool"),dhe=!1,phe=Pn(Na,dhe,"bool"),wA;function hhe(e){wA=e.wasm.cwrap(ti,null,["number","number","number","number"])}function fhe(e){let{inputs:{x:t},attrs:{alpha:n},backend:r}=e,s=r.dataIdMap.get(t.dataId).id,a=r.makeOutput(t.shape,"float32");if(w.sizeFromShape(t.shape)!==0){let o=r.dataIdMap.get(a.dataId).id;wA(s,Lt[t.dtype],n,o)}return a}var mhe={kernelName:ti,backendName:"wasm",setupFunc:hhe,kernelFunc:fhe},ghe=!1,bhe=Pn(ni,ghe,"bool"),yhe=!1,vhe=Pn(ri,yhe,"bool"),xhe=mn(Ea),whe=!1,khe=Pn(si,whe,"bool"),kA;function Ihe(e){kA=e.wasm.cwrap(Aa,null,["number","number","number","number"])}function She(e){let{backend:t,inputs:n,attrs:r}=e,{reductionIndices:s,keepDims:a}=r,{x:o}=n,u=t.dataIdMap.get(o.dataId).id,l=o,{transposed:c,axes:d,originalAxes:p,inputWasTransposed:h}=_o(o,s,t);if(h){let v=t.dataIdMap.get(c.dataId).id;l=c,u=v}let f=l.shape.length;N.assertAxesAreInnerMostDims("max",d,f);let[m,g]=N.computeOutAndReduceShapes(l.shape,d),b=w.sizeFromShape(g),y=t.makeOutput(m,o.dtype);if(w.sizeFromShape(l.shape)!==0){let v=t.dataIdMap.get(y.dataId).id;kA(u,Lt[o.dtype],b,v)}if(h&&t.disposeData(c.dataId),a){let v=N.expandShapeToKeepDim(y.shape,p);y.shape=v}return y}var Che={kernelName:Aa,backendName:"wasm",setupFunc:Ihe,kernelFunc:She},The=!1,Nhe=Pn($a,The),IA;function _he(e){IA=e.wasm.cwrap(Fa,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Ehe(e){let{inputs:t,attrs:n,backend:r}=e,s=t.x,a=r.dataIdMap.get(s.dataId).id;w.assert(s.dtype==="float32",()=>`Error in MaxPool: only float32 input is supported. Got ${s.dtype}.`);let{filterSize:o,strides:i,pad:u,dimRoundingMode:l}=n,c=N.computePool2DInfo(s.shape,o,i,1,u,l),d=c.filterHeight,p=c.filterWidth,h=c.padInfo.top,f=c.padInfo.right,m=c.padInfo.bottom,g=c.padInfo.left,b=c.dilationHeight,y=c.dilationWidth,v=c.strideHeight,x=c.strideWidth,k=c.inChannels,T=c.outChannels;if(c.dataFormat!=="channelsLast")throw new Error(`wasm backend does not support dataFormat:'${c.dataFormat}'. Please use 'channelsLast'.`);let C=r.makeOutput(c.outShape,"float32"),E=r.dataIdMap.get(C.dataId).id;return IA(a,s.shape[0],s.shape[1],s.shape[2],d,p,h,f,m,g,b,y,v,x,k,T,E),C}var Ahe={kernelName:Fa,backendName:"wasm",setupFunc:_he,kernelFunc:Ehe},SA;function $he(e){SA=e.wasm.cwrap(Da,null,["number, number, number"])}function Fhe(e){let{backend:t,inputs:n,attrs:r}=e,{axis:s,keepDims:a}=r,{x:o}=n,i=t.dataIdMap.get(o.dataId).id,u=i,l=o,{transposed:c,axes:d,originalAxes:p,inputWasTransposed:h}=_o(o,s,t),f=d;if(h){let x=t.dataIdMap.get(c.dataId).id;x!==i&&(l=c,u=x,f=N.getInnerMostAxes(f.length,l.shape.length))}N.assertAxesAreInnerMostDims("mean",f,l.shape.length);let[m,g]=N.computeOutAndReduceShapes(l.shape,f),b=w.sizeFromShape(g),y=l;l.dtype!=="float32"&&(y=gp({backend:t,inputs:{x:l},attrs:{dtype:"float32"}}),u=t.dataIdMap.get(y.dataId).id);let v=t.makeOutput(m,"float32");if(w.sizeFromShape(l.shape)!==0){let x=t.dataIdMap.get(v.dataId).id;SA(u,b,x)}if(h&&t.disposeData(c.dataId),a){let x=N.expandShapeToKeepDim(v.shape,p);v.shape=x}return l.dtype!=="float32"&&t.disposeData(y.dataId),v}var Dhe={kernelName:Da,backendName:"wasm",setupFunc:$he,kernelFunc:Fhe},CA;function Rhe(e){CA=e.wasm.cwrap(Ra,null,["number","number","number","number"])}function Phe(e){let{backend:t,inputs:n,attrs:r}=e,{axis:s,keepDims:a}=r,{x:o}=n,i=t.dataIdMap.get(o.dataId).id,u=i,l=o,{transposed:c,axes:d,originalAxes:p,inputWasTransposed:h}=_o(o,s,t);if(h){let v=t.dataIdMap.get(c.dataId).id;v!==i&&(l=c,u=v)}let f=l.shape.length;N.assertAxesAreInnerMostDims("min",d,f);let[m,g]=N.computeOutAndReduceShapes(l.shape,d),b=w.sizeFromShape(g),y=t.makeOutput(m,l.dtype);if(w.sizeFromShape(l.shape)!==0){let v=t.dataIdMap.get(y.dataId).id;CA(u,Lt[o.dtype],b,v)}if(h&&t.disposeData(c.dataId),a){let v=N.expandShapeToKeepDim(y.shape,p);y.shape=v}return y}var Ohe={kernelName:Ra,backendName:"wasm",setupFunc:Rhe,kernelFunc:Phe},Mhe=!1,Lhe=Pn(Pa,Mhe),Ek;(function(e){e[e.reflect=0]="reflect",e[e.symmetric=1]="symmetric"})(Ek||(Ek={}));var TA;function Bhe(e){TA=e.wasm.cwrap(Oa,null,["number","array","number","number","array","array","number","number"])}function zhe(e){let{inputs:{x:t},backend:n,attrs:{paddings:r,mode:s}}=e,a=r.map((f,m)=>f[0]+t.shape[m]+f[1]),o=n.dataIdMap.get(t.dataId).id,i=n.makeOutput(a,t.dtype),u=n.dataIdMap.get(i.dataId).id,l=new Uint8Array(new Int32Array(t.shape).buffer),c=r.map(f=>f[0]),d=r.map(f=>f[1]),p=new Uint8Array(new Int32Array(c).buffer),h=new Uint8Array(new Int32Array(d).buffer);return TA(o,l,t.shape.length,Lt[t.dtype],p,h,Ek[s],u),i}var Whe={kernelName:Oa,backendName:"wasm",kernelFunc:zhe,setupFunc:Bhe},Vhe=!0,Uhe=Pn(Ma,Vhe),Ghe=mn(ai);function Ak(e,t){let n=new Int32Array(e.wasm.HEAPU8.buffer,t,4),r=n[0],s=n[1],a=n[2],o=n[3];return e.wasm._free(t),{pSelectedIndices:r,selectedSize:s,pSelectedScores:a,pValidOutputs:o}}var NA;function Hhe(e){NA=e.wasm.cwrap(ii,"number",["number","number","number","number","number"])}function jhe(e){let{backend:t,inputs:n,attrs:r}=e,{iouThreshold:s,maxOutputSize:a,scoreThreshold:o}=r,{boxes:i,scores:u}=n,l=t.dataIdMap.get(i.dataId).id,c=t.dataIdMap.get(u.dataId).id,d=NA(l,c,a,s,o),{pSelectedIndices:p,selectedSize:h,pSelectedScores:f,pValidOutputs:m}=Ak(t,d);return t.wasm._free(f),t.wasm._free(m),t.makeOutput([h],"int32",p)}var qhe={kernelName:ii,backendName:"wasm",setupFunc:Hhe,kernelFunc:jhe},_A;function Khe(e){_A=e.wasm.cwrap(ac,"number",["number","number","number","number","number","bool"])}function Xhe(e){let{backend:t,inputs:n,attrs:r}=e,{iouThreshold:s,maxOutputSize:a,scoreThreshold:o,padToMaxOutputSize:i}=r,{boxes:u,scores:l}=n,c=t.dataIdMap.get(u.dataId).id,d=t.dataIdMap.get(l.dataId).id,p=_A(c,d,a,s,o,i),{pSelectedIndices:h,selectedSize:f,pSelectedScores:m,pValidOutputs:g}=Ak(t,p);t.wasm._free(m);let b=t.makeOutput([f],"int32",h),y=t.makeOutput([],"int32",g);return[b,y]}var Yhe={kernelName:ac,backendName:"wasm",setupFunc:Khe,kernelFunc:Xhe},EA;function Qhe(e){EA=e.wasm.cwrap(ui,"number",["number","number","number","number","number","number"])}function Zhe(e){let{backend:t,inputs:n,attrs:r}=e,{iouThreshold:s,maxOutputSize:a,scoreThreshold:o,softNmsSigma:i}=r,{boxes:u,scores:l}=n,c=t.dataIdMap.get(u.dataId).id,d=t.dataIdMap.get(l.dataId).id,p=EA(c,d,a,s,o,i),{pSelectedIndices:h,selectedSize:f,pSelectedScores:m,pValidOutputs:g}=Ak(t,p);t.wasm._free(g);let b=t.makeOutput([f],"int32",h),y=t.makeOutput([f],"float32",m);return[b,y]}var Jhe={kernelName:ui,backendName:"wasm",setupFunc:Qhe,kernelFunc:Zhe},efe=!1,tfe=Pn(oi,efe,"bool"),AA;function nfe(e){AA=e.wasm.cwrap(li,null,["number","number","number","number","number"])}function rfe(e){let{inputs:t,backend:n,attrs:r}=e,{indices:s}=t,{depth:a,onValue:o,offValue:i}=r,u=n.makeOutput([...s.shape,a],"int32"),l=n.dataIdMap.get(u.dataId).id,d=n.dataIdMap.get(s.dataId).id;return AA(d,a,o,i,l),u}var sfe={kernelName:li,backendName:"wasm",setupFunc:nfe,kernelFunc:rfe};function afe(e){let{inputs:{x:t},backend:n}=e,r=n.makeOutput(t.shape,t.dtype);return n.typedArrayFromHeap(r).fill(1),r}var ofe={kernelName:ci,backendName:"wasm",kernelFunc:afe};function ife(e){let{inputs:t,backend:n,attrs:r}=e,{axis:s}=r;if(t.length===1)return _k({inputs:{input:t[0]},backend:n,attrs:{dim:s}});let a=t[0].shape,o=t[0].dtype;t.forEach(c=>{w.assertShapesMatch(a,c.shape,"All tensors passed to stack must have matching shapes"),w.assert(o===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});let i=[],u=t.map(c=>{let d=_k({inputs:{input:c},backend:n,attrs:{dim:s}});return i.push(d),d}),l=iA({inputs:u,backend:n,attrs:{axis:s}});return i.forEach(c=>n.disposeData(c.dataId)),l}var ufe={kernelName:di,backendName:"wasm",kernelFunc:ife},$A;function cfe(e){$A=e.wasm.cwrap(La,null,["number","array","number","number","array","array","number","number"])}function lfe(e){let{inputs:{x:t},backend:n,attrs:{paddings:r,constantValue:s}}=e,a=r.map((m,g)=>m[0]+t.shape[g]+m[1]);if(w.sizeFromShape(t.shape)===0)return fA({backend:n,attrs:{shape:a,value:s,dtype:t.dtype}});let o=n.dataIdMap.get(t.dataId).id,i=n.makeOutput(a,t.dtype),l=n.dataIdMap.get(i.dataId).id,c=new Uint8Array(new Int32Array(t.shape).buffer),d=r.map(m=>m[0]),p=r.map(m=>m[1]),h=new Uint8Array(new Int32Array(d).buffer),f=new Uint8Array(new Int32Array(p).buffer);return $A(o,c,t.shape.length,Lt[t.dtype],h,f,s,l),i}var FA={kernelName:La,backendName:"wasm",kernelFunc:lfe,setupFunc:cfe},dfe=!1,pfe=Pn(Ba,dfe),DA;function hfe(e){DA=e.wasm.cwrap(za,null,["number","number","number"])}function ffe(e){let{inputs:t,backend:n}=e,{x:r,alpha:s}=t,a=n.dataIdMap.get(r.dataId).id,o=n.dataIdMap.get(s.dataId).id,i=a,u=r,l=u;u.dtype!=="float32"&&(l=gp({backend:n,inputs:{x:r},attrs:{dtype:"float32"}}),i=n.dataIdMap.get(l.dataId).id);let c=n.makeOutput(r.shape,"float32"),d=n.dataIdMap.get(c.dataId).id;return DA(i,o,d),u.dtype!=="float32"&&n.disposeData(l.dataId),c}var mfe={kernelName:za,backendName:"wasm",setupFunc:hfe,kernelFunc:ffe},RA;function gfe(e){RA=e.wasm.cwrap(pi,null,["number","number","number","number"])}function bfe(e){let{backend:t,inputs:n,attrs:r}=e,{axis:s,keepDims:a}=r,{x:o}=n,i=t.dataIdMap.get(o.dataId).id,u=i,l=o,{transposed:c,axes:d,originalAxes:p,inputWasTransposed:h}=_o(o,s,t),f=d;if(h){let v=t.dataIdMap.get(c.dataId).id;v!==i&&(l=c,u=v,f=N.getInnerMostAxes(f.length,l.shape.length))}N.assertAxesAreInnerMostDims("prod",f,l.shape.length);let[m,g]=N.computeOutAndReduceShapes(l.shape,f),b=w.sizeFromShape(g),y=t.makeOutput(m,l.dtype);if(w.sizeFromShape(l.shape)!==0){let v=t.dataIdMap.get(y.dataId).id;RA(u,b,Lt[y.dtype],v)}if(h&&t.disposeData(c.dataId),a){let v=N.expandShapeToKeepDim(y.shape,p);y.shape=v}return y}var yfe={kernelName:pi,backendName:"wasm",setupFunc:gfe,kernelFunc:bfe},vfe=e=>{let{backend:t,attrs:n}=e,{start:r,stop:s,step:a,dtype:o}=n,i=Mw(r,s,a,o),u=t.makeOutput([i.length],o);return t.typedArrayFromHeap(u).set(i),u},xfe={kernelName:oc,backendName:"wasm",kernelFunc:vfe},wfe=!0,kfe=Pn(wa,wfe),Ife=mn(Wa),Sfe=mn(Ua),PA;function Cfe(e){PA=e.wasm.cwrap(Va,null,["number","number","number","number","number","number","number","number","number","number"])}function Tfe(e){let{backend:t,inputs:n,attrs:r}=e,{images:s}=n,{alignCorners:a,halfPixelCenters:o,size:i}=r,[u,l]=i,[c,d,p,h]=s.shape,f=[c,u,l,h],m=t.dataIdMap.get(s.dataId),g;m.dtype!=="float32"&&(g=gp({backend:t,inputs:{x:s},attrs:{dtype:"float32"}}),m=t.dataIdMap.get(g.dataId));let b=m.id,y=t.makeOutput(f,"float32");if(w.sizeFromShape(s.shape)===0)return y;let v=t.dataIdMap.get(y.dataId).id;return PA(b,c,d,p,h,u,l,a?1:0,o?1:0,v),g!=null&&t.disposeData(g.dataId),y}var Nfe={kernelName:Va,backendName:"wasm",setupFunc:Cfe,kernelFunc:Tfe},OA;function _fe(e){OA=e.wasm.cwrap(fi,null,["number","array","number","array","number","number"])}function Efe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dims:a}=r,o=w.parseAxisParam(a,s.shape);if(s.shape.length===0)return Gm({inputs:{x:s},backend:n});let i=n.makeOutput(s.shape,s.dtype),u=n.dataIdMap.get(s.dataId).id,l=n.dataIdMap.get(i.dataId).id,c=new Uint8Array(new Int32Array(o).buffer),d=new Uint8Array(new Int32Array(s.shape).buffer);OA(u,c,o.length,d,s.shape.length,l);let p=Kn({inputs:{x:i},attrs:{shape:s.shape},backend:n});return n.disposeData(i.dataId),p}var Afe={kernelName:fi,backendName:"wasm",kernelFunc:Efe,setupFunc:_fe},MA;function $fe(e){MA=e.wasm.cwrap(_i,null,["number","number","number","number","number","number","number","number","array","number","number"])}function Ffe(e){let{inputs:t,backend:n,attrs:r}=e,{image:s}=t,{radians:a,fillValue:o,center:i}=r,u=n.makeOutput(s.shape,s.dtype),l=n.dataIdMap.get(s.dataId).id,c=n.dataIdMap.get(u.dataId).id,[d,p,h,f]=s.shape,[m,g]=N.getImageCenter(i,p,h),b=o===0,y=255,v=typeof o=="number"?[o,o,o,b?0:y]:[...o,y],x=new Uint8Array(new Int32Array(v).buffer);return MA(l,d,p,h,f,a,m,g,x,v.length,c),u}var Dfe={kernelName:_i,backendName:"wasm",kernelFunc:Ffe,setupFunc:$fe},Rfe=mn(mi),Pfe=mn(Ga),LA;function Ofe(e){LA=e.wasm.cwrap(gi,null,["number","number","number","number","number","number","array","number","number"])}function Mfe(e){let{backend:t,inputs:n,attrs:r}=e,{indices:s,updates:a}=n,{shape:o}=r,i=t.makeOutput(o,a.dtype);if(w.sizeFromShape(o)===0)return i;let{sliceRank:u,numUpdates:l,sliceSize:c,strides:d,outputSize:p}=Ay.calculateShapes(a,s,o),f=t.dataIdMap.get(s.dataId).id,g=t.dataIdMap.get(a.dataId).id,b=new Uint8Array(new Int32Array(d).buffer),y=t.dataIdMap.get(i.dataId).id;return LA(f,g,Lt[a.dtype],u,l,c,b,p,y),i}var Lfe={kernelName:gi,backendName:"wasm",setupFunc:Ofe,kernelFunc:Mfe},BA;function Bfe(e){BA=e.wasm.cwrap("SelectV2",null,["number","number","number","number","number"])}function zfe(e){let{inputs:t,backend:n}=e,{condition:r,t:s,e:a}=t,o=n.dataIdMap.get(r.dataId).id,i=n.dataIdMap.get(s.dataId).id,u=n.dataIdMap.get(a.dataId).id,l=n.makeOutput(s.shape,s.dtype),c=n.dataIdMap.get(l.dataId).id,d=r.shape.length,p=s.shape.length,h=d===0||d>1||p===1?1:w.sizeFromShape(s.shape.slice(1));return BA(o,i,u,h,c),l}var Wfe={kernelName:bi,backendName:"wasm",kernelFunc:zfe,setupFunc:Bfe},zA;function Vfe(e){zA=e.wasm.cwrap(ja,null,["number","number"])}function Ufe(e){let{backend:t,inputs:{x:n}}=e,r=t.dataIdMap.get(n.dataId).id,s=t.makeOutput(n.shape,n.dtype),a=t.dataIdMap.get(s.dataId).id;return w.sizeFromShape(s.shape)===0||zA(r,a),s}var Gfe={kernelName:"Sigmoid",backendName:"wasm",setupFunc:Vfe,kernelFunc:Ufe},Hfe=mn(Ha),WA;function jfe(e){WA=e.wasm.cwrap(Xa,null,["number","number","number","number"])}function qfe(e){let{backend:t,inputs:{logits:n},attrs:{dim:r}}=e,s=t.dataIdMap.get(n.dataId).id,a=t.makeOutput(n.shape,n.dtype),o=t.dataIdMap.get(a.dataId).id,i=n.shape[r],u=w.sizeFromShape(n.shape)/i;return w.sizeFromShape(a.shape)===0||WA(s,o,i,u),a}var Kfe={kernelName:Xa,backendName:"wasm",setupFunc:jfe,kernelFunc:qfe};function Xfe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,paddings:o}=r,i=w.sizeFromShape(a),u=[[0,0]];u.push(...o);for(let T=1+a.length;T<s.shape.length;++T)u.push([0,0]);let l=FA.kernelFunc({inputs:{x:s},backend:n,attrs:{paddings:u,constantValue:0}}),c=N.getReshaped(l.shape,a,i,!1),d=N.getPermuted(c.length,a.length,!1),p=N.getReshapedPermuted(l.shape,a,i,!1),m=Kn({inputs:{x:l},backend:n,attrs:{shape:c}}),y=il({inputs:{x:m},backend:n,attrs:{perm:d}}),k=Kn({inputs:{x:y},backend:n,attrs:{shape:p}});return n.disposeData(l.dataId),n.disposeData(m.dataId),n.disposeData(y.dataId),k}var Yfe={kernelName:xi,backendName:"wasm",kernelFunc:Xfe},VA;function Qfe(e){VA=e.wasm.cwrap("SparseFillEmptyRows","number",["number","number","number","number","number","number","number","number","number","number","number","number"])}function Zfe(e){let{backend:t,inputs:n}=e,{indices:r,values:s,denseShape:a,defaultValue:o}=n,i=r.shape[0],u=r.shape[1],l=t.readSync(a.dataId)[0],c=[i+l,u],d=t.dataIdMap.get(r.dataId).id,p=t.dataIdMap.get(s.dataId).id,h=t.dataIdMap.get(o.dataId).id,f=t.makeOutput(c,r.dtype),m=t.dataIdMap.get(f.dataId).id,g=t.makeOutput(c.slice(0,1),s.dtype),b=t.dataIdMap.get(g.dataId).id,y=t.makeOutput([l],"bool"),v=t.dataIdMap.get(y.dataId).id,x=t.makeOutput([i],r.dtype),k=t.dataIdMap.get(x.dataId).id,T=t.makeOutput([4],"int32"),C=t.dataIdMap.get(T.dataId).id,E=VA(d,p,Lt[s.dtype],i,l,u,h,m,b,v,k,C),F=t.readSync(T.dataId),O;switch(F[0]){case 1:{O=N.getSparseFillEmptyRowsIndicesDenseShapeMismatch(F[1]);break}case 2:{O=N.getSparseFillEmptyRowsNegativeIndexErrorMessage(F[1],F[2]);break}case 3:O=N.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(F[1],F[2],F[3]);break;default:O=""}if(t.disposeData(T.dataId),O)throw t.disposeData(f.dataId),t.disposeData(g.dataId),t.disposeData(y.dataId),t.disposeData(x.dataId),new Error(O);let D=f,R=g;return E!==c[0]&&(D=lu({inputs:{x:f},attrs:{begin:0,size:[E,u]},backend:t}),R=lu({inputs:{x:g},attrs:{begin:0,size:E},backend:t}),t.disposeData(f.dataId),t.disposeData(g.dataId)),[D,R,y,x]}var Jfe={kernelName:rd,backendName:"wasm",setupFunc:Qfe,kernelFunc:Zfe},UA;function eme(e){UA=e.wasm.cwrap(pc,null,["number","number","number","number","number","number","number"])}function tme(e){let{backend:t,inputs:n}=e,{inputIndices:r,inputShape:s,newShape:a}=n;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${r.shape}`);if(s.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${s.shape}`);if(a.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${a.shape}`);let o=t.dataIdMap.get(r.dataId).id,i=t.dataIdMap.get(s.dataId).id,u=t.dataIdMap.get(a.dataId).id,l=r.shape[0],c=w.sizeFromShape(a.shape),d=t.makeOutput([l,c],r.dtype),p=t.dataIdMap.get(d.dataId).id,h=t.makeOutput([c],a.dtype),f=t.dataIdMap.get(h.dataId).id,m=t.makeOutput([3],"int32"),g=t.dataIdMap.get(m.dataId).id;UA(o,i,u,l,p,f,g);let b=t.readSync(m.dataId),y;switch(b[0]){case 0:{y=N.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(b[1],b[2]);break}case 1:{y=N.getSparseReshapeNegativeOutputDimErrorMessage(b[1],b[2]);break}case 2:y=N.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage();break;case 3:{let v=Array.from(t.readSync(s.dataId)),x=Array.from(t.readSync(h.dataId));y=N.getSparseReshapeInputOutputMultipleErrorMessage(v,x);break}case 4:{let v=Array.from(t.readSync(s.dataId)),x=Array.from(t.readSync(h.dataId));y=N.getSparseReshapeInputOutputMismatchErrorMessage(v,x);break}default:y=""}if(t.disposeData(m.dataId),y)throw t.disposeData(d.dataId),t.disposeData(h.dataId),new Error(y);return[d,h]}var nme={kernelName:pc,backendName:"wasm",setupFunc:eme,kernelFunc:tme},GA;function HA(e){GA=e.wasm.cwrap("SparseSegmentReduction",null,["number","number","number","number","number","number","number","number","number"])}function jA(e,t){let{backend:n,inputs:r}=e,{data:s,indices:a,segmentIds:o}=r,i=a.shape[0],u=n.readSync(o.dataId,i-1,i)[0],c=i>0?u+1:0;if(c<0)throw new Error(N.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let d=s.shape.slice();d[0]=c;let p=n.dataIdMap.get(s.dataId).id,h=n.dataIdMap.get(a.dataId).id,f=n.dataIdMap.get(o.dataId).id,m=n.makeOutput(d,s.dtype),g=n.dataIdMap.get(m.dataId).id,b=n.makeOutput([4],"int32"),y=n.dataIdMap.get(b.dataId).id;GA(p,Lt[s.dtype],s.shape[0],h,f,g,y,t,0);let v=n.readSync(b.dataId),x;switch(v[0]){case 0:{x=N.getSparseSegmentReductionNegativeSegmentIdsErrorMessage();break}case 1:{x=N.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage();break}case 2:x=N.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(v[1],v[2]);break;case 3:x=N.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(v[1],v[2],v[3]);break;default:x=""}if(n.disposeData(b.dataId),x)throw n.disposeData(m.dataId),new Error(x);return m}function rme(e){return jA(e,!0)}var sme={kernelName:sd,backendName:"wasm",setupFunc:HA,kernelFunc:rme};function ame(e){return jA(e,!1)}var ome={kernelName:ad,backendName:"wasm",setupFunc:HA,kernelFunc:ame};function ime(e){let{inputs:t,attrs:n,backend:r}=e,{x:s}=t,{numOrSizeSplits:a,axis:o}=n,i=w.parseAxisParam(o,s.shape)[0],u=N.prepareSplitSize(s,a,i),l=new Array(s.shape.length).fill(0),c=s.shape.slice();return u.map(d=>{let p=[...c];p[i]=d;let h=lu({inputs:{x:s},attrs:{begin:l,size:p},backend:r});return l[i]+=d,h})}var ume={kernelName:wi,backendName:"wasm",kernelFunc:ime},cme=mn(qa),lme=mn(hc),dme=!0,pme=Pn(Ya,dme),qA;function hme(e){qA=e.wasm.cwrap(eo,null,["number","number","number","number"])}function fme(e){let{backend:t,inputs:n,attrs:r}=e,{alpha:s}=r,{x:a}=n,o=t.dataIdMap.get(a.dataId).id,i=t.makeOutput(a.shape,a.dtype),u=t.dataIdMap.get(i.dataId).id;return qA(o,s,Lt[a.dtype],u),i}var mme={kernelName:eo,backendName:"wasm",setupFunc:hme,kernelFunc:fme},KA;function gme(e){KA=e.wasm.cwrap(ki,null,["number","array","number","array","array","array","array","array","number","number"])}function bme(e){let{backend:t,inputs:n,attrs:r}=e,{x:s}=n,{begin:a,end:o,strides:i,beginMask:u,endMask:l,ellipsisMask:c,newAxisMask:d,shrinkAxisMask:p}=r,{finalShapeSparse:h,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:b,begin:y,end:v,strides:x}=$t.sliceInfo(s.shape,a,o,i,u,l,c,d,p),k;if(m)k=Kn({inputs:{x:s},backend:t,attrs:{shape:f}});else if(g||b){w.assert(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);let T=$t.computeOutShape(y,v,x),C=lu({inputs:{x:s},backend:t,attrs:{begin:y,size:T}});k=Kn({inputs:{x:C},backend:t,attrs:{shape:f}}),t.disposeData(C.dataId)}else{let T=t.makeOutput(h,"float32"),C=t.dataIdMap.get(s.dataId).id,E=new Uint8Array(new Int32Array(w.computeStrides(s.shape)).buffer),F=new Uint8Array(new Int32Array(y).buffer),O=new Uint8Array(new Int32Array(v).buffer),D=new Uint8Array(new Int32Array(x).buffer),R=new Uint8Array(new Int32Array(h).buffer),_=new Uint8Array(new Int32Array(w.computeStrides(h)).buffer),L=t.dataIdMap.get(T.dataId).id;KA(C,E,s.shape.length,F,O,D,R,_,h.length,L),k=Kn({inputs:{x:T},backend:t,attrs:{shape:f}}),t.disposeData(T.dataId)}return k}var yme={kernelName:ki,backendName:"wasm",setupFunc:gme,kernelFunc:bme},vme=!0,xme=Pn(Qa,vme),XA;function wme(e){XA=e.wasm.cwrap(Ka,null,["number","number","number","number"])}function kme(e){let{backend:t,inputs:n,attrs:r}=e,{axis:s,keepDims:a}=r,{x:o}=n,i=t.dataIdMap.get(o.dataId).id,u=i,l=o,{transposed:c,axes:d,originalAxes:p,inputWasTransposed:h}=_o(o,s,t),f=d;if(h){let v=t.dataIdMap.get(c.dataId).id;v!==i&&(l=c,u=v,f=N.getInnerMostAxes(f.length,l.shape.length))}N.assertAxesAreInnerMostDims("sum",f,l.shape.length);let[m,g]=N.computeOutAndReduceShapes(l.shape,f),b=w.sizeFromShape(g),y=t.makeOutput(m,l.dtype);if(w.sizeFromShape(l.shape)!==0){let v=t.dataIdMap.get(y.dataId).id;XA(u,b,Lt[y.dtype],v)}if(h&&t.disposeData(c.dataId),a){let v=N.expandShapeToKeepDim(y.shape,p);y.shape=v}return y}var Ime={kernelName:Ka,backendName:"wasm",setupFunc:wme,kernelFunc:kme},Sme=mn(Ii),Cme=mn(Za),YA;function Tme(e){YA=e.wasm.cwrap(As,null,["number","array","number","array","number","number"])}function Nme(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,a=n.dataIdMap.get(s.dataId).id,{reps:o}=r,i=new Array(s.shape.length);for(let p=0;p<i.length;p++)i[p]=s.shape[p]*o[p];let u=new Uint8Array(new Int32Array(s.shape).buffer),l=new Uint8Array(new Int32Array(i).buffer),c=n.makeOutput(i,s.dtype),d=n.dataIdMap.get(c.dataId).id;return YA(a,u,s.shape.length,l,i.length,Lt[c.dtype],d),c}var _me={kernelName:As,backendName:"wasm",setupFunc:Tme,kernelFunc:Nme},QA;function Eme(e){QA=e.wasm.cwrap(Si,null,["number","array","number","number","number","bool","number","number"])}var Ame=({inputs:e,backend:t,attrs:n})=>{let{x:r}=e,{k:s,sorted:a}=n,o=t.dataIdMap.get(r.dataId).id,i=new Uint8Array(new Int32Array(r.shape).buffer),u=r.shape.slice();u[u.length-1]=s;let l=t.makeOutput(u,r.dtype),c=t.dataIdMap.get(l.dataId).id,d=t.makeOutput(u,"int32"),p=t.dataIdMap.get(d.dataId).id;return QA(o,i,r.shape.length,Lt[r.dtype],s,a,c,p),[l,d]},$me={kernelName:Si,backendName:"wasm",setupFunc:Eme,kernelFunc:Ame},ZA;function Fme(e){ZA=e.wasm.cwrap(Ci,null,["number","number","bool","number","number","number","number","number","number","array","number","number","number","number","number"])}function Dme(e){let{backend:t,inputs:n,attrs:r}=e,{image:s,transforms:a}=n,{interpolation:o,fillMode:i,fillValue:u,outputShape:l}=r,[c,d,p,h]=s.shape,[f,m]=l!=null?l:[d,p],g=[c,f,m,h],b=new Uint8Array(new Int32Array(w.computeStrides(s.shape)).buffer),y=t.makeOutput(g,s.dtype),v=t.dataIdMap.get(y.dataId).id,k=t.dataIdMap.get(s.dataId).id,C=t.dataIdMap.get(a.dataId).id,E=o==="nearest"?1:2,F;switch(i){case"constant":F=1;break;case"reflect":F=2;break;case"wrap":F=3;break;case"nearest":F=4;break;default:F=1;break}return ZA(k,C,a.shape[0]>1,c,f,m,h,p,d,b,s.shape.length-1,E,F,u,v),y}var Rme={kernelName:Ci,backendName:"wasm",setupFunc:Fme,kernelFunc:Dme};function Pme(e){let{inputs:t,backend:n,attrs:r}=e,{value:s}=t,{axis:a}=r;a<0&&(a+=s.shape.length);let o=s.shape[a],i=s.shape.length,u=new Array(i-1),l=0;for(let h=0;h<i;h++)h!==a&&(u[l++]=s.shape[h]);let c=new Array(o),d=new Array(i).fill(0),p=s.shape.slice();p[a]=1;for(let h=0;h<c.length;h++)d[a]=h,c[h]=lu({inputs:{x:s},attrs:{begin:d,size:p},backend:n});return c.map(({dataId:h,dtype:f})=>({dataId:h,dtype:f,shape:u}))}var Ome={kernelName:Ti,backendName:"wasm",kernelFunc:Pme};function Mme(e){let{inputs:{x:t},backend:n}=e,r=n.makeOutput(t.shape,t.dtype);return n.typedArrayFromHeap(r).fill(0),r}var Lme={kernelName:Ni,backendName:"wasm",kernelFunc:Mme},Bme=[$de,Dde,Ode,Gde,qde,Yde,Jde,rpe,cpe,lpe,dpe,fpe,mpe,ype,wpe,kpe,Ipe,Tpe,Epe,Fpe,Ppe,Ope,Lpe,Bpe,zpe,Wpe,Gpe,Hpe,qpe,Ade,Ype,Jpe,nhe,ahe,uhe,lhe,phe,Mde,mhe,bhe,vhe,xhe,khe,Che,Nhe,Ahe,Dhe,Ohe,Lhe,Whe,Uhe,Ghe,qhe,Yhe,Jhe,tfe,sfe,ofe,ufe,FA,pfe,mfe,yfe,xfe,kfe,Ife,Sfe,epe,Nfe,Afe,Dfe,Pfe,Rfe,Lfe,Wfe,Gfe,Hfe,ipe,Kfe,Yfe,Jfe,nme,sme,ome,ume,cme,lme,pme,mme,yme,xme,Ime,Sme,Cme,_me,$me,Rme,Wde,Ome,Lme];for(let e of Bme)mc(e);var $k=X();$k.registerFlag("WASM_HAS_SIMD_SUPPORT",async()=>WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11])));$k.registerFlag("WASM_HAS_MULTITHREAD_SUPPORT",async()=>{if($k.get("IS_NODE"))return!1;try{return new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch(e){return!1}});var JA=Bo(lD()),zme='var Module={};function threadPrintErr(){var text=Array.prototype.slice.call(arguments).join(" ");console.error(text)}function threadAlert(){var text=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:text,threadId:Module["_pthread_self"]()})}var err=threadPrintErr;this.alert=threadAlert;Module["instantiateWasm"]=function(info,receiveInstance){var instance=new WebAssembly.Instance(Module["wasmModule"],info);Module["wasmModule"]=null;receiveInstance(instance);return instance.exports};function moduleLoaded(){}this.onmessage=function(e){try{if(e.data.cmd==="load"){Module["wasmModule"]=e.data.wasmModule;Module["wasmMemory"]=e.data.wasmMemory;Module["buffer"]=Module["wasmMemory"].buffer;Module["ENVIRONMENT_IS_PTHREAD"]=true;if(typeof e.data.urlOrBlob==="string"){importScripts(e.data.urlOrBlob)}else{var objectUrl=URL.createObjectURL(e.data.urlOrBlob);importScripts(objectUrl);URL.revokeObjectURL(objectUrl)}WasmBackendModuleThreadedSimd(Module).then(function(instance){Module=instance;moduleLoaded()})}else if(e.data.cmd==="objectTransfer"){Module["PThread"].receiveObjectTransfer(e.data)}else if(e.data.cmd==="run"){Module["__performance_now_clock_drift"]=performance.now()-e.data.time;Module["__emscripten_thread_init"](e.data.threadInfoStruct,0,0);var max=e.data.stackBase;var top=e.data.stackBase+e.data.stackSize;Module["establishStackSpace"](top,max);Module["_emscripten_tls_init"]();Module["PThread"].receiveObjectTransfer(e.data);Module["PThread"].setThreadStatus(Module["_pthread_self"](),1);try{var result=Module["invokeEntryPoint"](e.data.start_routine,e.data.arg);if(!Module["getNoExitRuntime"]())Module["PThread"].threadExit(result)}catch(ex){if(ex==="Canceled!"){Module["PThread"].threadCancel()}else if(ex!="unwind"){if(ex instanceof Module["ExitStatus"]){if(Module["getNoExitRuntime"]()){}else{Module["PThread"].threadExit(ex.status)}}else{Module["PThread"].threadExit(-2);throw ex}}}}else if(e.data.cmd==="cancel"){if(Module["_pthread_self"]()){Module["PThread"].threadCancel()}}else if(e.data.target==="setimmediate"){}else if(e.data.cmd==="processThreadQueue"){if(Module["_pthread_self"]()){Module["_emscripten_current_thread_process_queued_calls"]()}}else{err("worker.js received unknown command "+e.data.cmd);err(e.data)}}catch(ex){err("worker.js onmessage() captured an uncaught exception: "+ex);if(ex&&ex.stack)err(ex.stack);throw ex}};if(typeof process==="object"&&typeof process.versions==="object"&&typeof process.versions.node==="string"){self={location:{href:__filename}};var onmessage=this.onmessage;var nodeWorkerThreads=require("worker_threads");global.Worker=nodeWorkerThreads.Worker;var parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",function(data){onmessage({data:data})});var nodeFS=require("fs");var nodeRead=function(filename){return nodeFS.readFileSync(filename,"utf8")};function globalEval(x){global.require=require;global.Module=Module;eval.call(null,x)}importScripts=function(f){globalEval(nodeRead(f))};postMessage=function(msg){parentPort.postMessage(msg)};if(typeof performance==="undefined"){performance={now:function(){return Date.now()}}}}',Wme=Bo(dD()),e$=class extends Mu{constructor(e){super();this.wasm=e,this.dataIdNextNumber=1,this.wasm.tfjs.initWithThreadsCount(n$),Dk=this.wasm.tfjs.getThreadsCount(),this.dataIdMap=new Ul(this,is())}write(e,t,n){let r={id:this.dataIdNextNumber++};return this.move(r,e,t,n,1),r}numDataIds(){return this.dataIdMap.numDataIds()}async time(e){let t=w.now();return e(),{kernelMs:w.now()-t}}move(e,t,n,r,s){let a=this.dataIdNextNumber++;if(r==="string"){let l=t;this.dataIdMap.set(e,{id:a,stringBytes:l,shape:n,dtype:r,memoryOffset:null,refCount:s});return}let o=w.sizeFromShape(n),i=o*w.bytesPerElement(r),u=this.wasm._malloc(i);this.dataIdMap.set(e,{id:a,memoryOffset:u,shape:n,dtype:r,refCount:s}),this.wasm.tfjs.registerTensor(a,o,u),t!=null&&this.wasm.HEAPU8.set(new Uint8Array(t.buffer,t.byteOffset,i),u)}async read(e){return this.readSync(e)}readSync(e,t,n){let{memoryOffset:r,dtype:s,shape:a,stringBytes:o}=this.dataIdMap.get(e);if(s==="string")return(t==null||t===0)&&(n==null||n>=o.length)?o:o.slice(t,n);t=t||0,n=n||w.sizeFromShape(a);let i=w.bytesPerElement(s),u=this.wasm.HEAPU8.slice(r+t*i,r+n*i);return Gme(u.buffer,s)}disposeData(e,t=!1){if(this.dataIdMap.has(e)){let n=this.dataIdMap.get(e);if(n.refCount--,!t&&n.refCount>0)return!1;this.wasm._free(n.memoryOffset),this.wasm.tfjs.disposeData(n.id),this.dataIdMap.delete(e)}return!0}refCount(e){return this.dataIdMap.has(e)?this.dataIdMap.get(e).refCount:0}incRef(e){let t=this.dataIdMap.get(e);t!=null&&t.refCount++}floatPrecision(){return 32}getMemoryOffset(e){return this.dataIdMap.get(e).memoryOffset}dispose(){this.wasm.tfjs.dispose(),"PThread"in this.wasm&&this.wasm.PThread.terminateAllThreads(),this.wasm=null}memory(){return{unreliable:!1}}makeOutput(e,t,n){let r;if(n==null)r=this.write(null,e,t);else{let s=this.dataIdNextNumber++;r={id:s},this.dataIdMap.set(r,{id:s,memoryOffset:n,shape:e,dtype:t,refCount:1});let a=w.sizeFromShape(e);this.wasm.tfjs.registerTensor(s,a,n)}return{dataId:r,shape:e,dtype:t}}typedArrayFromHeap({shape:e,dtype:t,dataId:n}){let r=this.wasm.HEAPU8.buffer,{memoryOffset:s}=this.dataIdMap.get(n),a=w.sizeFromShape(e);switch(t){case"float32":return new Float32Array(r,s,a);case"int32":return new Int32Array(r,s,a);case"bool":return new Uint8Array(r,s,a);default:throw new Error(`Unknown dtype ${t}`)}}};function Vme(e){return(t,n)=>(w.fetch(e,{credentials:"same-origin"}).then(r=>{r.ok||t.env.a(`failed to load wasm binary file at '${e}'`),r.arrayBuffer().then(s=>{WebAssembly.instantiate(s,t).then(a=>{n(a.instance,a.module)})})}),{})}function t$(e,t,n){if(Hm!=null)return Hm;let r="tfjs-backend-wasm.wasm";return e&&t?r="tfjs-backend-wasm-threaded-simd.wasm":e&&(r="tfjs-backend-wasm-simd.wasm"),yp!=null&&yp[r]!=null?yp[r]:n+r}async function Ume(){let[e,t]=await Promise.all([X().getAsync("WASM_HAS_SIMD_SUPPORT"),X().getAsync("WASM_HAS_MULTITHREAD_SUPPORT")]);return new Promise((n,r)=>{let s={};s.locateFile=(i,u)=>{if(i.endsWith(".worker.js")){let l=zme,c=new Blob([l],{type:"application/javascript"});return URL.createObjectURL(c)}return i.endsWith(".wasm")?t$(e,t,bp!=null?bp:u):u+i},Fk&&(s.instantiateWasm=Vme(t$(e,t,bp!=null?bp:"")));let a=!1;s.onAbort=()=>{if(a||vp)return;vp=!0,r({message:"Make sure the server can serve the `.wasm` file relative to the bundled js file. For more details see https://github.com/tensorflow/tfjs/blob/master/tfjs-backend-wasm/README.md#using-bundlers"})};let o;t&&e&&Hm==null?(s.mainScriptUrlOrBlob=new Blob(["var WasmBackendModuleThreadedSimd = "+JA.default.toString()],{type:"text/javascript"}),o=(0,JA.default)(s)):o=(0,Wme.default)(s),o.then(i=>{a=!0,vp=!1;let u=null;i.tfjs={init:i.cwrap("init",null,[]),initWithThreadsCount:i.cwrap("init_with_threads_count",null,["number"]),getThreadsCount:i.cwrap("get_threads_count","number",[]),registerTensor:i.cwrap("register_tensor",null,["number","number","number"]),disposeData:i.cwrap("dispose_data",u,["number"]),dispose:i.cwrap("dispose",u,[])},n({wasm:i})})})}function Gme(e,t){switch(t){case"float32":return new Float32Array(e);case"int32":return new Int32Array(e);case"bool":return new Uint8Array(e);default:throw new Error(`Unknown dtype ${t}`)}}var Hme=["tfjs-backend-wasm.wasm","tfjs-backend-wasm-simd.wasm","tfjs-backend-wasm-threaded-simd.wasm"],Hm=null,bp=null,yp={},vp=!1,Fk=!1;function jme(e,t=!1){if(My("setWasmPath has been deprecated in favor of setWasmPaths and will be removed in a future release."),vp)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPath()` before you call `tf.setBackend()` or `tf.ready()`");Hm=e,Fk=t}function qme(e,t=!1){if(vp)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPaths()` before you call `tf.setBackend()` or `tf.ready()`");if(typeof e=="string")bp=e;else{yp=e;let n=Hme.filter(r=>yp[r]==null);if(n.length>0)throw new Error(`There were no entries found for the following binaries: ${n.join(",")}. Please either call setWasmPaths with a map providing a path for each binary, or with a string indicating the directory where all the binaries can be found.`)}Fk=t}var n$=-1,Dk=-1;function Kme(e){n$=e}function Xme(){if(Dk===-1)throw new Error("WASM backend not initialized.");return Dk}var Yme="0.0.0",Qme=2;wd("wasm",async()=>{let{wasm:e}=await Ume();return new e$(e)},Qme);var Eo="3.11.0-20211201",Zme={tfjs:Eo,"tfjs-core":Eo,"tfjs-data":Eo,"tfjs-layers":Eo,"tfjs-converter":Eo,"tfjs-backend-cpu":Eo,"tfjs-backend-webgl":Eo,"tfjs-backend-wasm":Eo};var aI={};ih(aI,{AnchorPosition:()=>ks,DrawBox:()=>Xm,DrawBoxOptions:()=>Kk,DrawFaceLandmarks:()=>sI,DrawFaceLandmarksOptions:()=>rI,DrawTextField:()=>$o,DrawTextFieldOptions:()=>Sp,drawContour:()=>Hs,drawDetections:()=>ige,drawFaceExpressions:()=>pge,drawFaceLandmarks:()=>fge});function Hs(e,t,n=!1){if(e.beginPath(),t.slice(1).forEach(({x:r,y:s},a)=>{let o=t[a];e.moveTo(o.x,o.y),e.lineTo(r,s)}),n){let r=t[t.length-1],s=t[0];if(!r||!s)return;e.moveTo(r.x,r.y),e.lineTo(s.x,s.y)}e.stroke()}var Lk={};ih(Lk,{computeReshapedDimensions:()=>Mk,getCenterPoint:()=>hu,isDimensions:()=>qm,isEven:()=>jm,isFloat:()=>Ok,isTensor:()=>du,isTensor1D:()=>Jme,isTensor2D:()=>Pk,isTensor3D:()=>js,isTensor4D:()=>Ir,isValidNumber:()=>ns,isValidProbablitiy:()=>ul,range:()=>xs,round:()=>pu});var On=class{constructor(t,n){if(!ns(t)||!ns(n))throw new Error(`Dimensions.constructor - expected width and height to be valid numbers, instead have ${JSON.stringify({width:t,height:n})}`);this._width=t,this._height=n}get width(){return this._width}get height(){return this._height}reverse(){return new On(1/this.width,1/this.height)}};function du(e,t){return e instanceof Ae&&e.shape.length===t}function Jme(e){return du(e,1)}function Pk(e){return du(e,2)}function js(e){return du(e,3)}function Ir(e){return du(e,4)}function Ok(e){return e%1!=0}function jm(e){return e%2==0}function pu(e,t=2){let n=10**t;return Math.floor(e*n)/n}function qm(e){return e&&e.width&&e.height}function Mk({width:e,height:t},n){let r=n/Math.max(t,e);return new On(Math.round(e*r),Math.round(t*r))}function hu(e){return e.reduce((t,n)=>t.add(n),new Pe(0,0)).div(new Pe(e.length,e.length))}function xs(e,t,n){return Array(e).fill(0).map((r,s)=>t+s*n)}function ns(e){return!!e&&e!==1/0&&e!==-1/0&&!Number.isNaN(e)||e===0}function ul(e){return ns(e)&&e>=0&&e<=1}var Pe=class{constructor(t,n){this._x=t,this._y=n}get x(){return this._x}get y(){return this._y}add(t){return new Pe(this.x+t.x,this.y+t.y)}sub(t){return new Pe(this.x-t.x,this.y-t.y)}mul(t){return new Pe(this.x*t.x,this.y*t.y)}div(t){return new Pe(this.x/t.x,this.y/t.y)}abs(){return new Pe(Math.abs(this.x),Math.abs(this.y))}magnitude(){return Math.sqrt(this.x**2+this.y**2)}floor(){return new Pe(Math.floor(this.x),Math.floor(this.y))}};var dt=class{static isRect(t){return!!t&&[t.x,t.y,t.width,t.height].every(ns)}static assertIsValidBox(t,n,r=!1){if(!dt.isRect(t))throw new Error(`${n} - invalid box: ${JSON.stringify(t)}, expected object with properties x, y, width, height`);if(!r&&(t.width<0||t.height<0))throw new Error(`${n} - width (${t.width}) and height (${t.height}) must be positive numbers`)}constructor(t,n=!0){let r=t||{},s=[r.left,r.top,r.right,r.bottom].every(ns),a=[r.x,r.y,r.width,r.height].every(ns);if(!a&&!s)throw new Error(`Box.constructor - expected box to be IBoundingBox | IRect, instead have ${JSON.stringify(r)}`);let[o,i,u,l]=a?[r.x,r.y,r.width,r.height]:[r.left,r.top,r.right-r.left,r.bottom-r.top];dt.assertIsValidBox({x:o,y:i,width:u,height:l},"Box.constructor",n),this._x=o,this._y=i,this._width=u,this._height=l}get x(){return this._x}get y(){return this._y}get width(){return this._width}get height(){return this._height}get left(){return this.x}get top(){return this.y}get right(){return this.x+this.width}get bottom(){return this.y+this.height}get area(){return this.width*this.height}get topLeft(){return new Pe(this.left,this.top)}get topRight(){return new Pe(this.right,this.top)}get bottomLeft(){return new Pe(this.left,this.bottom)}get bottomRight(){return new Pe(this.right,this.bottom)}round(){let[t,n,r,s]=[this.x,this.y,this.width,this.height].map(a=>Math.round(a));return new dt({x:t,y:n,width:r,height:s})}floor(){let[t,n,r,s]=[this.x,this.y,this.width,this.height].map(a=>Math.floor(a));return new dt({x:t,y:n,width:r,height:s})}toSquare(){let{x:t,y:n,width:r,height:s}=this,a=Math.abs(r-s);return r<s&&(t-=a/2,r+=a),s<r&&(n-=a/2,s+=a),new dt({x:t,y:n,width:r,height:s})}rescale(t){let n=qm(t)?t.width:t,r=qm(t)?t.height:t;return new dt({x:this.x*n,y:this.y*r,width:this.width*n,height:this.height*r})}pad(t,n){let[r,s,a,o]=[this.x-t/2,this.y-n/2,this.width+t,this.height+n];return new dt({x:r,y:s,width:a,height:o})}clipAtImageBorders(t,n){let{x:r,y:s,right:a,bottom:o}=this,i=Math.max(r,0),u=Math.max(s,0),l=a-i,c=o-u,d=Math.min(l,t-i),p=Math.min(c,n-u);return new dt({x:i,y:u,width:d,height:p}).floor()}shift(t,n){let{width:r,height:s}=this,a=this.x+t,o=this.y+n;return new dt({x:a,y:o,width:r,height:s})}padAtBorders(t,n){let r=this.width+1,s=this.height+1,a=1,o=1,i=r,u=s,l=this.left,c=this.top,d=this.right,p=this.bottom;return d>n&&(i=-d+n+r,d=n),p>t&&(u=-p+t+s,p=t),l<1&&(u=2-l,l=1),c<1&&(u=2-c,c=1),{dy:o,edy:u,dx:a,edx:i,y:c,ey:p,x:l,ex:d,w:r,h:s}}calibrate(t){return new dt({left:this.left+t.left*this.width,top:this.top+t.top*this.height,right:this.right+t.right*this.width,bottom:this.bottom+t.bottom*this.height}).toSquare().round()}};var cl=class extends dt{constructor(t,n,r,s,a=!1){super({left:t,top:n,right:r,bottom:s},a)}};var Ao=class{constructor(t,n,r,s,a){this._imageDims=new On(a.width,a.height),this._score=t,this._classScore=n,this._className=r,this._box=new dt(s).rescale(this._imageDims)}get score(){return this._score}get classScore(){return this._classScore}get className(){return this._className}get box(){return this._box}get imageDims(){return this._imageDims}get imageWidth(){return this.imageDims.width}get imageHeight(){return this.imageDims.height}get relativeBox(){return new dt(this._box).rescale(this.imageDims.reverse())}forSize(t,n){return new Ao(this.score,this.classScore,this.className,this.relativeBox,{width:t,height:n})}};var St=class extends Ao{constructor(t,n,r){super(t,t,"",n,r)}forSize(t,n){let{score:r,relativeBox:s,imageDims:a}=super.forSize(t,n);return new St(r,s,a)}};function Bk(e,t,n=!0){let r=Math.max(0,Math.min(e.right,t.right)-Math.max(e.left,t.left)),s=Math.max(0,Math.min(e.bottom,t.bottom)-Math.max(e.top,t.top)),a=r*s;return n?a/(e.area+t.area-a):a/Math.min(e.area,t.area)}function zk(e){let t=e.map(i=>i.x),n=e.map(i=>i.y),r=t.reduce((i,u)=>u<i?u:i,1/0),s=n.reduce((i,u)=>u<i?u:i,1/0),a=t.reduce((i,u)=>i<u?u:i,0),o=n.reduce((i,u)=>i<u?u:i,0);return new cl(r,s,a,o)}function Wk(e,t,n,r=!0){let s=t.map((o,i)=>({score:o,boxIndex:i})).sort((o,i)=>o.score-i.score).map(o=>o.boxIndex),a=[];for(;s.length>0;){let o=s.pop();a.push(o);let i=s,u=[];for(let l=0;l<i.length;l++){let c=i[l],d=e[o],p=e[c];u.push(Bk(d,p,r))}s=s.filter((l,c)=>u[c]<=n)}return a}function rs(e,t){return M(()=>{let[n,r,s]=t,a=_n([...e.shape.slice(0,3),1],n,"float32"),o=_n([...e.shape.slice(0,3),1],r,"float32"),i=_n([...e.shape.slice(0,3),1],s,"float32"),u=ot([a,o,i],3);return he(e,u)})}function Vk(e,t=!1){return M(()=>{let[n,r]=e.shape.slice(1);if(n===r)return e;let s=Math.abs(n-r),a=Math.round(s*(t?.5:1)),o=n>r?2:1,i=p=>{let h=e.shape.slice();return h[o]=p,_n(h,0,"float32")},u=i(a),l=s-u.shape[o],d=[t&&l?i(l):null,e,u].filter(p=>!!p).map(p=>ue(p,"float32"));return ot(d,o)})}function ege(e){let t=e.slice();for(let n=t.length-1;n>0;n--){let r=Math.floor(Math.random()*(n+1)),s=t[n];t[n]=t[r],t[r]=s}return t}function xp(e){return 1/(1+Math.exp(-e))}function tge(e){return Math.log(e/(1-e))}var ll=class extends dt{constructor(t,n,r,s,a=!1){super({x:t,y:n,width:r,height:s},a)}};var nge=.5,rge=.43,sge=.45,Sr=class{constructor(t,n,r=new Pe(0,0)){let{width:s,height:a}=n;this._imgDims=new On(s,a),this._shift=r,this._positions=t.map(o=>o.mul(new Pe(s,a)).add(r))}get shift(){return new Pe(this._shift.x,this._shift.y)}get imageWidth(){return this._imgDims.width}get imageHeight(){return this._imgDims.height}get positions(){return this._positions}get relativePositions(){return this._positions.map(t=>t.sub(this._shift).div(new Pe(this.imageWidth,this.imageHeight)))}forSize(t,n){return new this.constructor(this.relativePositions,{width:t,height:n})}shiftBy(t,n){return new this.constructor(this.relativePositions,this._imgDims,new Pe(t,n))}shiftByPoint(t){return this.shiftBy(t.x,t.y)}align(t,n={}){if(t){let a=t instanceof St?t.box.floor():new dt(t);return this.shiftBy(a.x,a.y).align(null,n)}let{useDlibAlignment:r,minBoxPadding:s}={useDlibAlignment:!1,minBoxPadding:.2,...n};return r?this.alignDlib():this.alignMinBbox(s)}alignDlib(){let t=this.getRefPointsForAlignment(),[n,r,s]=t,a=d=>s.sub(d).magnitude(),o=(a(n)+a(r))/2,i=Math.floor(o/sge),u=hu(t),l=Math.floor(Math.max(0,u.x-nge*i)),c=Math.floor(Math.max(0,u.y-rge*i));return new ll(l,c,Math.min(i,this.imageWidth+l),Math.min(i,this.imageHeight+c))}alignMinBbox(t){let n=zk(this.positions);return n.pad(n.width*t,n.height*t)}getRefPointsForAlignment(){throw new Error("getRefPointsForAlignment not implemented by base class")}};var r$=class extends Sr{getRefPointsForAlignment(){let t=this.positions;return[t[0],t[1],hu([t[3],t[4]])]}};var dl=class extends Sr{getJawOutline(){return this.positions.slice(0,17)}getLeftEyeBrow(){return this.positions.slice(17,22)}getRightEyeBrow(){return this.positions.slice(22,27)}getNose(){return this.positions.slice(27,36)}getLeftEye(){return this.positions.slice(36,42)}getRightEye(){return this.positions.slice(42,48)}getMouth(){return this.positions.slice(48,68)}getRefPointsForAlignment(){return[this.getLeftEye(),this.getRightEye(),this.getMouth()].map(hu)}};var wp=class{constructor(t,n){this._label=t,this._distance=n}get label(){return this._label}get distance(){return this._distance}toString(t=!0){return`${this.label}${t?` (${pu(this.distance)})`:""}`}};var kp=class extends dt{static assertIsValidLabeledBox(t,n){if(dt.assertIsValidBox(t,n),!ns(t.label))throw new Error(`${n} - expected property label (${t.label}) to be a number`)}constructor(t,n){super(t);this._label=n}get label(){return this._label}};var qs=class{constructor(t,n){if(typeof t!="string")throw new Error("LabeledFaceDescriptors - constructor expected label to be a string");if(!Array.isArray(n)||n.some(r=>!(r instanceof Float32Array)))throw new Error("LabeledFaceDescriptors - constructor expected descriptors to be an array of Float32Array");this._label=t,this._descriptors=n}get label(){return this._label}get descriptors(){return this._descriptors}toJSON(){return{label:this.label,descriptors:this.descriptors.map(t=>Array.from(t))}}static fromJSON(t){let n=t.descriptors.map(r=>new Float32Array(r));return new qs(t.label,n)}};var s$=class extends kp{static assertIsValidPredictedBox(t,n){if(kp.assertIsValidLabeledBox(t,n),!ul(t.score)||!ul(t.classScore))throw new Error(`${n} - expected properties score (${t.score}) and (${t.classScore}) to be a number between [0, 1]`)}constructor(t,n,r,s){super(t,n);this._score=r,this._classScore=s}get score(){return this._score}get classScore(){return this._classScore}};function ws(e){return e.detection instanceof St}function fu(e,t){return{...e,...{detection:t}}}function Uk(){let e=window.fetch;if(!e)throw new Error("fetch - missing fetch implementation for browser environment");return{Canvas:HTMLCanvasElement,CanvasRenderingContext2D,Image:HTMLImageElement,ImageData,Video:HTMLVideoElement,createCanvasElement:()=>document.createElement("canvas"),createImageElement:()=>document.createElement("img"),createVideoElement:()=>document.createElement("video"),fetch:e,readFile:()=>{throw new Error("readFile - filesystem not available for browser environment")}}}function Ip(){return typeof global=="object"&&typeof process!="undefined"&&process.versions!=null&&process.versions.node!=null}function Km(e){let t="";if(!e&&Ip())try{e=UF("fs")}catch(r){t=r.toString()}return{readFile:e?r=>new Promise((s,a)=>{e.readFile(r,(o,i)=>o?a(o):s(i))}):()=>{throw new Error(`readFile - failed to require fs in nodejs environment with error: ${t}`)}}}function Gk(){let e=global.Canvas||global.HTMLCanvasElement,t=global.Image||global.HTMLImageElement,n=global.Video||global.HTMLVideoElement,r=()=>{if(e)return new e;throw new Error("createCanvasElement - missing Canvas implementation for nodejs environment")},s=()=>{if(t)return new t;throw new Error("createImageElement - missing Image implementation for nodejs environment")},a=()=>{if(n)return new n;throw new Error("createVideoElement - missing Video implementation for nodejs environment")},o=global.fetch,i=Km();return{Canvas:e||class{},CanvasRenderingContext2D:global.CanvasRenderingContext2D||class{},Image:t||class{},ImageData:global.ImageData||class{},Video:global.HTMLVideoElement||class{},createCanvasElement:r,createImageElement:s,createVideoElement:a,fetch:o,...i}}function Hk(){return typeof window=="object"&&typeof document!="undefined"&&typeof HTMLImageElement!="undefined"&&typeof HTMLCanvasElement!="undefined"&&typeof HTMLVideoElement!="undefined"&&typeof ImageData!="undefined"&&typeof CanvasRenderingContext2D!="undefined"}var un;function age(){if(!un)throw new Error("getEnv - environment is not defined, check isNodejs() and isBrowser()");return un}function jk(e){un=e}function qk(){return Hk()?jk(Uk()):Ip()?jk(Gk()):null}function oge(e){if(un||qk(),!un)throw new Error("monkeyPatch - environment is not defined, check isNodejs() and isBrowser()");let{Canvas:t=un.Canvas,Image:n=un.Image}=e;un.Canvas=t,un.Image=n,un.createCanvasElement=e.createCanvasElement||(()=>new t),un.createImageElement=e.createImageElement||(()=>new n),un.ImageData=e.ImageData||un.ImageData,un.Video=e.Video||un.Video,un.fetch=e.fetch||un.fetch,un.readFile=e.readFile||un.readFile}var rt={getEnv:age,setEnv:jk,initialize:qk,createBrowserEnv:Uk,createFileSystem:Km,createNodejsEnv:Gk,monkeyPatch:oge,isBrowser:Hk,isNodejs:Ip};qk();function mu(e){return!rt.isNodejs()&&typeof e=="string"?document.getElementById(e):e}function Xn(e){let{Canvas:t,CanvasRenderingContext2D:n}=rt.getEnv();if(e instanceof n)return e;let r=mu(e);if(!(r instanceof t))throw new Error("resolveContext2d - expected canvas to be of instance of Canvas");let s=r.getContext("2d");if(!s)throw new Error("resolveContext2d - canvas 2d context is null");return s}var ks;(function(s){s.TOP_LEFT="TOP_LEFT",s.TOP_RIGHT="TOP_RIGHT",s.BOTTOM_LEFT="BOTTOM_LEFT",s.BOTTOM_RIGHT="BOTTOM_RIGHT"})(ks||(ks={}));var Sp=class{constructor(t={}){let{anchorPosition:n,backgroundColor:r,fontColor:s,fontSize:a,fontStyle:o,padding:i}=t;this.anchorPosition=n||ks.TOP_LEFT,this.backgroundColor=r||"rgba(0, 0, 0, 0.5)",this.fontColor=s||"rgba(255, 255, 255, 1)",this.fontSize=a||14,this.fontStyle=o||"Georgia",this.padding=i||4}},$o=class{constructor(t,n,r={}){this.text=typeof t=="string"?[t]:t instanceof $o?t.text:t,this.anchor=n,this.options=new Sp(r)}measureWidth(t){let{padding:n}=this.options;return this.text.map(r=>t.measureText(r).width).reduce((r,s)=>r<s?s:r,0)+2*n}measureHeight(){let{fontSize:t,padding:n}=this.options;return this.text.length*t+2*n}getUpperLeft(t,n){let{anchorPosition:r}=this.options,s=r===ks.BOTTOM_RIGHT||r===ks.TOP_RIGHT,a=r===ks.BOTTOM_LEFT||r===ks.BOTTOM_RIGHT,o=this.measureWidth(t),i=this.measureHeight(),u=s?this.anchor.x-o:this.anchor.x,l=a?this.anchor.y-i:this.anchor.y;if(n){let{width:c,height:d}=n,p=Math.max(Math.min(u,c-o),0),h=Math.max(Math.min(l,d-i),0);return{x:p,y:h}}return{x:u,y:l}}draw(t){let n=mu(t),r=Xn(n),{backgroundColor:s,fontColor:a,fontSize:o,fontStyle:i,padding:u}=this.options;r.font=`${o}px ${i}`;let l=this.measureWidth(r),c=this.measureHeight();r.fillStyle=s;let d=this.getUpperLeft(r,n);r.fillRect(d.x,d.y,l,c),r.fillStyle=a,this.text.forEach((p,h)=>{let f=u+d.x,m=u+d.y+(h+1)*o;r.fillText(p,f,m)})}};var Kk=class{constructor(t={}){let{boxColor:n,lineWidth:r,label:s,drawLabelOptions:a}=t;this.boxColor=n||"rgba(0, 0, 255, 1)",this.lineWidth=r||2,this.label=s;let o={anchorPosition:ks.BOTTOM_LEFT,backgroundColor:this.boxColor};this.drawLabelOptions=new Sp({...o,...a})}},Xm=class{constructor(t,n={}){this.box=new dt(t),this.options=new Kk(n)}draw(t){let n=Xn(t),{boxColor:r,lineWidth:s}=this.options,{x:a,y:o,width:i,height:u}=this.box;n.strokeStyle=r,n.lineWidth=s,n.strokeRect(a,o,i,u);let{label:l}=this.options;l&&new $o([l],{x:a-s/2,y:o},this.options.drawLabelOptions).draw(t)}};function ige(e,t){(Array.isArray(t)?t:[t]).forEach(r=>{let s=r instanceof St?r.score:ws(r)?r.detection.score:void 0,a=r instanceof St?r.box:ws(r)?r.detection.box:new dt(r),o=s?`${pu(s)}`:void 0;new Xm(a,{label:o}).draw(e)})}function Cp(e){let{Image:t,Video:n}=rt.getEnv();return e instanceof t&&e.complete||e instanceof n&&e.readyState>=3}function Xk(e){return new Promise((t,n)=>{(e instanceof rt.getEnv().Canvas||Cp(e))&&t(null);function r(a){!a.currentTarget||(a.currentTarget.removeEventListener("load",s),a.currentTarget.removeEventListener("error",r),n(a))}function s(a){!a.currentTarget||(a.currentTarget.removeEventListener("load",s),a.currentTarget.removeEventListener("error",r),t(a))}e.addEventListener("load",s),e.addEventListener("error",r)})}function Yk(e){return new Promise((t,n)=>{e instanceof Blob||n(new Error("bufferToImage - expected buf to be of type: Blob"));let r=new FileReader;r.onload=()=>{typeof r.result!="string"&&n(new Error("bufferToImage - expected reader.result to be a string, in onload"));let s=rt.getEnv().createImageElement();s.onload=()=>t(s),s.onerror=n,s.src=r.result},r.onerror=n,r.readAsDataURL(e)})}function gu(e){let{Image:t,Video:n}=rt.getEnv();return e instanceof t?new On(e.naturalWidth,e.naturalHeight):e instanceof n?new On(e.videoWidth,e.videoHeight):new On(e.width,e.height)}function bu({width:e,height:t}){let{createCanvasElement:n}=rt.getEnv(),r=n();return r.width=e,r.height=t,r}function Tp(e,t){let{ImageData:n}=rt.getEnv();if(!(e instanceof n)&&!Cp(e))throw new Error("createCanvasFromMedia - media has not finished loading yet");let{width:r,height:s}=t||gu(e),a=bu({width:r,height:s});return e instanceof n?Xn(a).putImageData(e,0,0):Xn(a).drawImage(e,0,0,r,s),a}async function Qk(e,t){let n=t||rt.getEnv().createCanvasElement(),[r,s,a]=e.shape.slice(Ir(e)?1:0),o=M(()=>e.as3D(r,s,a).toInt());return await Pi.toPixels(o,n),o.dispose(),n}function Ym(e){let{Image:t,Canvas:n,Video:r}=rt.getEnv();return e instanceof t||e instanceof n||e instanceof r}function Zk(e,t,n=!1){let{Image:r,Canvas:s}=rt.getEnv();if(!(e instanceof r||e instanceof s))throw new Error("imageToSquare - expected arg0 to be HTMLImageElement | HTMLCanvasElement");if(t<=0)return bu({width:1,height:1});let a=gu(e),o=t/Math.max(a.height,a.width),i=o*a.width,u=o*a.height,l=bu({width:t,height:t}),c=e instanceof s?e:Tp(e),d=Math.abs(i-u)/2,p=n&&i<u?d:0,h=n&&u<i?d:0;return c.width>0&&c.height>0&&Xn(l).drawImage(c,p,h,i,u),l}var Ks=class{constructor(t,n=!1){this._imageTensors=[];this._canvases=[];this._treatAsBatchInput=!1;this._inputDimensions=[];this._inputSize=0;if(!Array.isArray(t))throw new Error(`NetInput.constructor - expected inputs to be an Array of TResolvedNetInput or to be instanceof tf.Tensor4D, instead have ${t}`);this._treatAsBatchInput=n,this._batchSize=t.length,t.forEach((r,s)=>{if(js(r)){this._imageTensors[s]=r,this._inputDimensions[s]=r.shape;return}if(Ir(r)){let o=r.shape[0];if(o!==1)throw new Error(`NetInput - tf.Tensor4D with batchSize ${o} passed, but not supported in input array`);this._imageTensors[s]=r,this._inputDimensions[s]=r.shape.slice(1);return}let a=r instanceof rt.getEnv().Canvas?r:Tp(r);this._canvases[s]=a,this._inputDimensions[s]=[a.height,a.width,3]})}get imageTensors(){return this._imageTensors}get canvases(){return this._canvases}get isBatchInput(){return this.batchSize>1||this._treatAsBatchInput}get batchSize(){return this._batchSize}get inputDimensions(){return this._inputDimensions}get inputSize(){return this._inputSize}get reshapedInputDimensions(){return xs(this.batchSize,0,1).map((t,n)=>this.getReshapedInputDimensions(n))}getInput(t){return this.canvases[t]||this.imageTensors[t]}getInputDimensions(t){return this._inputDimensions[t]}getInputHeight(t){return this._inputDimensions[t][0]}getInputWidth(t){return this._inputDimensions[t][1]}getReshapedInputDimensions(t){if(typeof this.inputSize!="number")throw new Error("getReshapedInputDimensions - inputSize not set, toBatchTensor has not been called yet");let n=this.getInputWidth(t),r=this.getInputHeight(t);return Mk({width:n,height:r},this.inputSize)}toBatchTensor(t,n=!0){return this._inputSize=t,M(()=>{let r=xs(this.batchSize,0,1).map(a=>{let o=this.getInput(a);if(o instanceof Ae){let i=Ir(o)?o:Nn(o);return i=Vk(i,n),(i.shape[1]!==t||i.shape[2]!==t)&&(i=ar.resizeBilinear(i,[t,t],!1,!1)),i.as3D(t,t,3)}if(o instanceof rt.getEnv().Canvas)return Pi.fromPixels(Zk(o,t,n));throw new Error(`toBatchTensor - at batchIdx ${a}, expected input to be instanceof tf.Tensor or instanceof HTMLCanvasElement, instead have ${o}`)});return Ut(r.map(a=>ue(a,"float32"))).as4D(this.batchSize,t,t,3)})}};async function xt(e){if(e instanceof Ks)return e;let t=Array.isArray(e)?e:[e];if(!t.length)throw new Error("toNetInput - empty array passed as input");let n=s=>Array.isArray(e)?` at input index ${s}:`:"",r=t.map(mu);return r.forEach((s,a)=>{if(!Ym(s)&&!js(s)&&!Ir(s))throw typeof t[a]=="string"?new Error(`toNetInput -${n(a)} string passed, but could not resolve HTMLElement for element id ${t[a]}`):new Error(`toNetInput -${n(a)} expected media to be of type HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | tf.Tensor3D, or to be an element id`);if(Ir(s)){let o=s.shape[0];if(o!==1)throw new Error(`toNetInput -${n(a)} tf.Tensor4D with batchSize ${o} passed, but not supported in input array`)}}),await Promise.all(r.map(s=>Ym(s)&&Xk(s))),new Ks(r,Array.isArray(e))}async function pl(e,t){let{Canvas:n}=rt.getEnv(),r=e;if(!(e instanceof n)){let o=await xt(e);if(o.batchSize>1)throw new Error("extractFaces - batchSize > 1 not supported");let i=o.getInput(0);r=i instanceof n?i:await Qk(i)}let s=Xn(r);return t.map(o=>o instanceof St?o.forSize(r.width,r.height).box.floor():o).map(o=>o.clipAtImageBorders(r.width,r.height)).map(({x:o,y:i,width:u,height:l})=>{let c=bu({width:u,height:l});return u>0&&l>0&&Xn(c).putImageData(s.getImageData(o,i,u,l),0,0),c})}async function hl(e,t){if(!js(e)&&!Ir(e))throw new Error("extractFaceTensors - expected image tensor to be 3D or 4D");if(Ir(e)&&e.shape[0]>1)throw new Error("extractFaceTensors - batchSize > 1 not supported");return M(()=>{let[n,r,s]=e.shape.slice(Ir(e)?1:0);return t.map(i=>i instanceof St?i.forSize(r,n).box:i).map(i=>i.clipAtImageBorders(r,n)).map(({x:i,y:u,width:l,height:c})=>Ec(e.as3D(n,r,s),[u,i,0],[c,l,s]))})}async function Xs(e,t){let{fetch:n}=rt.getEnv(),r=await n(e,t);if(!(r.status<400))throw new Error(`failed to fetch: (${r.status}) ${r.statusText}, from url: ${r.url}`);return r}async function uge(e){let t=await Xs(e),n=await t.blob();if(!n.type.startsWith("image/"))throw new Error(`fetchImage - expected blob type to be of type image/*, instead have: ${n.type}, for url: ${t.url}`);return Yk(n)}async function Jk(e){return(await Xs(e)).json()}async function cge(e){return new Float32Array(await(await Xs(e)).arrayBuffer())}function a$(e){return new Promise((t,n)=>{e instanceof Blob||n(new Error("bufferToVideo - expected buf to be of type: Blob"));let r=rt.getEnv().createVideoElement();r.oncanplay=()=>t(r),r.onerror=n,r.playsInline=!0,r.muted=!0,r.src=URL.createObjectURL(e),r.play()})}async function lge(e){let t=await Xs(e),n=await t.blob();if(!n.type.startsWith("video/"))throw new Error(`fetchVideo - expected blob type to be of type video/*, instead have: ${n.type}, for url: ${t.url}`);return a$(n)}function Qm(e,t){let n=`${t}-weights_manifest.json`;if(!e)return{modelBaseUri:"",manifestUri:n};if(e==="/")return{modelBaseUri:"/",manifestUri:`/${n}`};let r=e.startsWith("http://")?"http://":e.startsWith("https://")?"https://":"";e=e.replace(r,"");let s=e.split("/").filter(i=>i),a=e.endsWith(".json")?s[s.length-1]:n,o=r+(e.endsWith(".json")?s.slice(0,s.length-1):s).join("/");return o=e.startsWith("/")?`/${o}`:o,{modelBaseUri:o,manifestUri:o==="/"?`/${a}`:`${o}/${a}`}}async function eI(e,t){let{manifestUri:n,modelBaseUri:r}=Qm(e,t),s=await Jk(n);return tn.loadWeights(s,r)}function dge(e,t,n=!1){let{width:r,height:s}=n?gu(t):t;return e.width=r,e.height=s,{width:r,height:s}}var gn=class{constructor(t){this._params=void 0;this._paramMappings=[];this._name=t}get params(){return this._params}get paramMappings(){return this._paramMappings}get isLoaded(){return!!this.params}getParamFromPath(t){let{obj:n,objProp:r}=this.traversePropertyPath(t);return n[r]}reassignParamFromPath(t,n){let{obj:r,objProp:s}=this.traversePropertyPath(t);r[s].dispose(),r[s]=n}getParamList(){return this._paramMappings.map(({paramPath:t})=>({path:t,tensor:this.getParamFromPath(t)}))}getTrainableParams(){return this.getParamList().filter(t=>t.tensor instanceof oo)}getFrozenParams(){return this.getParamList().filter(t=>!(t.tensor instanceof oo))}variable(){this.getFrozenParams().forEach(({path:t,tensor:n})=>{this.reassignParamFromPath(t,n.variable())})}freeze(){this.getTrainableParams().forEach(({path:t,tensor:n})=>{let r=er(n.dataSync());n.dispose(),this.reassignParamFromPath(t,r)})}dispose(t=!0){this.getParamList().forEach(n=>{if(t&&n.tensor.isDisposed)throw new Error(`param tensor has already been disposed for path ${n.path}`);n.tensor.dispose()}),this._params=void 0}serializeParams(){return new Float32Array(this.getParamList().map(({tensor:t})=>Array.from(t.dataSync())).reduce((t,n)=>t.concat(n)))}async load(t){if(t instanceof Float32Array){this.extractWeights(t);return}await this.loadFromUri(t)}async loadFromUri(t){if(t&&typeof t!="string")throw new Error(`${this._name}.loadFromUri - expected model uri`);let n=await eI(t,this.getDefaultModelName());this.loadFromWeightMap(n)}async loadFromDisk(t){if(t&&typeof t!="string")throw new Error(`${this._name}.loadFromDisk - expected model file path`);let{readFile:n}=rt.getEnv(),{manifestUri:r,modelBaseUri:s}=Qm(t,this.getDefaultModelName()),a=l=>Promise.all(l.map(c=>n(c).then(d=>d.buffer))),o=tn.weightsLoaderFactory(a),i=JSON.parse((await n(r)).toString()),u=await o(i,s);this.loadFromWeightMap(u)}loadFromWeightMap(t){let{paramMappings:n,params:r}=this.extractParamsFromWeightMap(t);this._paramMappings=n,this._params=r}extractWeights(t){let{paramMappings:n,params:r}=this.extractParams(t);this._paramMappings=n,this._params=r}traversePropertyPath(t){if(!this.params)throw new Error("traversePropertyPath - model has no loaded params");let n=t.split("/").reduce((a,o)=>{if(!a.nextObj.hasOwnProperty(o))throw new Error(`traversePropertyPath - object does not have property ${o}, for path ${t}`);return{obj:a.nextObj,objProp:o,nextObj:a.nextObj[o]}},{nextObj:this.params}),{obj:r,objProp:s}=n;if(!r||!s||!(r[s]instanceof Ae))throw new Error(`traversePropertyPath - parameter is not a tensor, for path ${t}`);return{obj:r,objProp:s}}};function Yn(e,t,n){return M(()=>{let r=_c(e,t.depthwise_filter,t.pointwise_filter,n,"same");return r=Z(r,t.bias),r})}function Zm(e,t,n=!1){return M(()=>{let r=Qe(n?Z(Wt(e,t.conv0.filters,[2,2],"same"),t.conv0.bias):Yn(e,t.conv0,[2,2])),s=Yn(r,t.conv1,[1,1]),a=Qe(Z(r,s)),o=Yn(a,t.conv2,[1,1]);return Qe(Z(r,Z(s,o)))})}function Np(e,t,n=!1,r=!0){return M(()=>{let s=Qe(n?Z(Wt(e,t.conv0.filters,r?[2,2]:[1,1],"same"),t.conv0.bias):Yn(e,t.conv0,r?[2,2]:[1,1])),a=Yn(s,t.conv1,[1,1]),o=Qe(Z(s,a)),i=Yn(o,t.conv2,[1,1]),u=Qe(Z(s,Z(a,i))),l=Yn(u,t.conv3,[1,1]);return Qe(Z(s,Z(a,Z(i,l))))})}function yu(e,t,n="same",r=!1){return M(()=>{let s=Z(Wt(e,t.filters,[1,1],n),t.bias);return r?Qe(s):s})}function Mn(e,t){Object.keys(e).forEach(n=>{t.some(r=>r.originalPath===n)||e[n].dispose()})}function fl(e,t){return(n,r,s,a)=>{let o=qr(e(n*r*s*s),[s,s,n,r]),i=je(e(r));return t.push({paramPath:`${a}/filters`},{paramPath:`${a}/bias`}),{filters:o,bias:i}}}function Jm(e,t){return(n,r,s)=>{let a=jr(e(n*r),[n,r]),o=je(e(r));return t.push({paramPath:`${s}/weights`},{paramPath:`${s}/bias`}),{weights:a,bias:o}}}var eg=class{constructor(t,n,r){this.depthwise_filter=t;this.pointwise_filter=n;this.bias=r}};function ml(e,t){return(n,r,s)=>{let a=qr(e(3*3*n),[3,3,n,1]),o=qr(e(n*r),[1,1,n,r]),i=je(e(r));return t.push({paramPath:`${s}/depthwise_filter`},{paramPath:`${s}/pointwise_filter`},{paramPath:`${s}/bias`}),new eg(a,o,i)}}function gl(e){return t=>{let n=e(`${t}/depthwise_filter`,4),r=e(`${t}/pointwise_filter`,4),s=e(`${t}/bias`,1);return new eg(n,r,s)}}function lr(e,t){return(n,r,s)=>{let a=e[n];if(!du(a,r))throw new Error(`expected weightMap[${n}] to be a Tensor${r}D, instead have ${a}`);return t.push({originalPath:n,paramPath:s||n}),a}}function Ln(e){let t=e;function n(s){let a=t.slice(0,s);return t=t.slice(s),a}function r(){return t}return{extractWeights:n,getRemainingWeights:r}}function tg(e,t){let n=fl(e,t),r=ml(e,t);function s(o,i,u,l=!1){let c=l?n(o,i,3,`${u}/conv0`):r(o,i,`${u}/conv0`),d=r(i,i,`${u}/conv1`),p=r(i,i,`${u}/conv2`);return{conv0:c,conv1:d,conv2:p}}function a(o,i,u,l=!1){let{conv0:c,conv1:d,conv2:p}=s(o,i,u,l),h=r(i,i,`${u}/conv3`);return{conv0:c,conv1:d,conv2:p,conv3:h}}return{extractDenseBlock3Params:s,extractDenseBlock4Params:a}}function o$(e){let t=[],{extractWeights:n,getRemainingWeights:r}=Ln(e),{extractDenseBlock4Params:s}=tg(n,t),a=s(3,32,"dense0",!0),o=s(32,64,"dense1"),i=s(64,128,"dense2"),u=s(128,256,"dense3");if(r().length!==0)throw new Error(`weights remaing after extract: ${r().length}`);return{paramMappings:t,params:{dense0:a,dense1:o,dense2:i,dense3:u}}}function ng(e){return t=>{let n=e(`${t}/filters`,4),r=e(`${t}/bias`,1);return{filters:n,bias:r}}}function rg(e,t){let n=lr(e,t),r=ng(n),s=gl(n);function a(i,u=!1){let l=u?r(`${i}/conv0`):s(`${i}/conv0`),c=s(`${i}/conv1`),d=s(`${i}/conv2`);return{conv0:l,conv1:c,conv2:d}}function o(i,u=!1){let l=u?r(`${i}/conv0`):s(`${i}/conv0`),c=s(`${i}/conv1`),d=s(`${i}/conv2`),p=s(`${i}/conv3`);return{conv0:l,conv1:c,conv2:d,conv3:p}}return{extractDenseBlock3Params:a,extractDenseBlock4Params:o}}function i$(e){let t=[],{extractDenseBlock4Params:n}=rg(e,t),r={dense0:n("dense0",!0),dense1:n("dense1"),dense2:n("dense2"),dense3:n("dense3")};return Mn(e,t),{params:r,paramMappings:t}}var _p=class extends gn{constructor(){super("FaceFeatureExtractor")}forwardInput(t){let{params:n}=this;if(!n)throw new Error("FaceFeatureExtractor - load model before inference");return M(()=>{let r=ue(t.toBatchTensor(112,!0),"float32"),a=rs(r,[122.782,117.001,104.298]).div(255),o=Np(a,n.dense0,!0);return o=Np(o,n.dense1),o=Np(o,n.dense2),o=Np(o,n.dense3),o=Ar(o,[7,7],[2,2],"valid"),o})}async forward(t){return this.forwardInput(await xt(t))}getDefaultModelName(){return"face_feature_extractor_model"}extractParamsFromWeightMap(t){return i$(t)}extractParams(t){return o$(t)}};function Ep(e,t){return M(()=>Z(Re(e,t.weights),t.bias))}function u$(e,t,n){let r=[],{extractWeights:s,getRemainingWeights:a}=Ln(e),i=Jm(s,r)(t,n,"fc");if(a().length!==0)throw new Error(`weights remaing after extract: ${a().length}`);return{paramMappings:r,params:{fc:i}}}function c$(e){let t=[],n=lr(e,t);function r(a){let o=n(`${a}/weights`,2),i=n(`${a}/bias`,1);return{weights:o,bias:i}}let s={fc:r("fc")};return Mn(e,t),{params:s,paramMappings:t}}function sg(e){let t={},n={};return Object.keys(e).forEach(r=>{let s=r.startsWith("fc")?n:t;s[r]=e[r]}),{featureExtractorMap:t,classifierMap:n}}var Ap=class extends gn{constructor(t,n){super(t);this._faceFeatureExtractor=n}get faceFeatureExtractor(){return this._faceFeatureExtractor}runNet(t){let{params:n}=this;if(!n)throw new Error(`${this._name} - load model before inference`);return M(()=>{let r=t instanceof Ks?this.faceFeatureExtractor.forwardInput(t):t;return Ep(r.as2D(r.shape[0],-1),n.fc)})}dispose(t=!0){this.faceFeatureExtractor.dispose(t),super.dispose(t)}loadClassifierParams(t){let{params:n,paramMappings:r}=this.extractClassifierParams(t);this._params=n,this._paramMappings=r}extractClassifierParams(t){return u$(t,this.getClassifierChannelsIn(),this.getClassifierChannelsOut())}extractParamsFromWeightMap(t){let{featureExtractorMap:n,classifierMap:r}=sg(t);return this.faceFeatureExtractor.loadFromWeightMap(n),c$(r)}extractParams(t){let n=this.getClassifierChannelsIn(),r=this.getClassifierChannelsOut(),s=r*n+r,a=t.slice(0,t.length-s),o=t.slice(t.length-s);return this.faceFeatureExtractor.extractWeights(a),this.extractClassifierParams(o)}};var tI=["neutral","happy","sad","angry","fearful","disgusted","surprised"],Fo=class{constructor(t){this.neutral=0;this.happy=0;this.sad=0;this.angry=0;this.fearful=0;this.disgusted=0;this.surprised=0;if(t.length!==7)throw new Error(`FaceExpressions.constructor - expected probabilities.length to be 7, have: ${t.length}`);tI.forEach((n,r)=>{this[n]=t[r]})}asSortedArray(){return tI.map(t=>({expression:t,probability:this[t]})).sort((t,n)=>n.probability-t.probability)}};var ag=class extends Ap{constructor(t=new _p){super("FaceExpressionNet",t)}forwardInput(t){return M(()=>ls(this.runNet(t)))}async forward(t){return this.forwardInput(await xt(t))}async predictExpressions(t){let n=await xt(t),r=await this.forwardInput(n),s=await Promise.all(vt(r).map(async o=>{let i=o.dataSync();return o.dispose(),i}));r.dispose();let a=s.map(o=>new Fo(o));return n.isBatchInput?a:a[0]}getDefaultModelName(){return"face_expression_model"}getClassifierChannelsIn(){return 256}getClassifierChannelsOut(){return 7}};function nI(e){return e.expressions instanceof Fo}function og(e,t){return{...e,...{expressions:t}}}function pge(e,t,n=.1,r){(Array.isArray(t)?t:[t]).forEach(a=>{let o=a instanceof Fo?a:nI(a)?a.expressions:void 0;if(!o)throw new Error("drawFaceExpressions - expected faceExpressions to be FaceExpressions | WithFaceExpressions<{}> or array thereof");let u=o.asSortedArray().filter(d=>d.probability>n),l=ws(a)?a.detection.box.bottomLeft:r||new Pe(0,0);new $o(u.map(d=>`${d.expression} (${pu(d.probability)})`),l).draw(e)})}function vu(e){return ws(e)&&e.landmarks instanceof Sr&&e.unshiftedLandmarks instanceof Sr&&e.alignedRect instanceof St}function hge(e){let t=(i,u,l,c)=>Math.atan2(c-u,l-i)%Math.PI,n=i=>i*180/Math.PI,r={roll:void 0,pitch:void 0,yaw:void 0};if(!e||!e._positions||e._positions.length!==68)return r;let s=e._positions;r.roll=-t(s[36]._x,s[36]._y,s[45]._x,s[45]._y),r.pitch=t(0,Math.abs(s[0]._x-s[30]._x)/s[30]._x,Math.PI,Math.abs(s[16]._x-s[30]._x)/s[30]._x);let a=s.reduce((i,u)=>i<u._y?i:u._y,1/0),o=s.reduce((i,u)=>i>u._y?i:u._y,-1/0);return r.yaw=Math.PI*(e._imgDims._height/(o-a)/1.4-1),r}function bl(e,t){let{box:n}=e.detection,r=t.shiftBy(n.x,n.y),s=r.align(),{imageDims:a}=e.detection,o=new St(e.detection.score,s.rescale(a.reverse()),a),i=hge(t);return{...e,...{landmarks:r,unshiftedLandmarks:t,alignedRect:o,angle:i}}}var rI=class{constructor(t={}){let{drawLines:n=!0,drawPoints:r=!0,lineWidth:s,lineColor:a,pointSize:o,pointColor:i}=t;this.drawLines=n,this.drawPoints=r,this.lineWidth=s||1,this.pointSize=o||2,this.lineColor=a||"rgba(0, 255, 255, 1)",this.pointColor=i||"rgba(255, 0, 255, 1)"}},sI=class{constructor(t,n={}){this.faceLandmarks=t,this.options=new rI(n)}draw(t){let n=Xn(t),{drawLines:r,drawPoints:s,lineWidth:a,lineColor:o,pointSize:i,pointColor:u}=this.options;if(r&&this.faceLandmarks instanceof dl&&(n.strokeStyle=o,n.lineWidth=a,Hs(n,this.faceLandmarks.getJawOutline()),Hs(n,this.faceLandmarks.getLeftEyeBrow()),Hs(n,this.faceLandmarks.getRightEyeBrow()),Hs(n,this.faceLandmarks.getNose()),Hs(n,this.faceLandmarks.getLeftEye(),!0),Hs(n,this.faceLandmarks.getRightEye(),!0),Hs(n,this.faceLandmarks.getMouth(),!0)),s){n.strokeStyle=u,n.fillStyle=u;let l=c=>{n.beginPath(),n.arc(c.x,c.y,i,0,2*Math.PI),n.fill()};this.faceLandmarks.positions.forEach(l)}}};function fge(e,t){(Array.isArray(t)?t:[t]).forEach(r=>{let s=r instanceof Sr?r:vu(r)?r.landmarks:void 0;if(!s)throw new Error("drawFaceLandmarks - expected faceExpressions to be FaceLandmarks | WithFaceLandmarks<WithFaceDetection<{}>> or array thereof");new sI(s).draw(e)})}var l$="1.6.0";function gge(e,t){let n=fl(e,t),r=ml(e,t);function s(o,i,u){let l=r(o,i,`${u}/separable_conv0`),c=r(i,i,`${u}/separable_conv1`),d=n(o,i,1,`${u}/expansion_conv`);return{separable_conv0:l,separable_conv1:c,expansion_conv:d}}function a(o,i){let u=r(o,o,`${i}/separable_conv0`),l=r(o,o,`${i}/separable_conv1`),c=r(o,o,`${i}/separable_conv2`);return{separable_conv0:u,separable_conv1:l,separable_conv2:c}}return{extractConvParams:n,extractSeparableConvParams:r,extractReductionBlockParams:s,extractMainBlockParams:a}}function d$(e,t){let n=[],{extractWeights:r,getRemainingWeights:s}=Ln(e),{extractConvParams:a,extractSeparableConvParams:o,extractReductionBlockParams:i,extractMainBlockParams:u}=gge(r,n),l=a(3,32,3,"entry_flow/conv_in"),c=i(32,64,"entry_flow/reduction_block_0"),d=i(64,128,"entry_flow/reduction_block_1"),p={conv_in:l,reduction_block_0:c,reduction_block_1:d},h={};xs(t,0,1).forEach(b=>{h[`main_block_${b}`]=u(128,`middle_flow/main_block_${b}`)});let f=i(128,256,"exit_flow/reduction_block"),m=o(256,512,"exit_flow/separable_conv"),g={reduction_block:f,separable_conv:m};if(s().length!==0)throw new Error(`weights remaing after extract: ${s().length}`);return{paramMappings:n,params:{entry_flow:p,middle_flow:h,exit_flow:g}}}function bge(e,t){let n=lr(e,t),r=ng(n),s=gl(n);function a(i){let u=s(`${i}/separable_conv0`),l=s(`${i}/separable_conv1`),c=r(`${i}/expansion_conv`);return{separable_conv0:u,separable_conv1:l,expansion_conv:c}}function o(i){let u=s(`${i}/separable_conv0`),l=s(`${i}/separable_conv1`),c=s(`${i}/separable_conv2`);return{separable_conv0:u,separable_conv1:l,separable_conv2:c}}return{extractConvParams:r,extractSeparableConvParams:s,extractReductionBlockParams:a,extractMainBlockParams:o}}function p$(e,t){let n=[],{extractConvParams:r,extractSeparableConvParams:s,extractReductionBlockParams:a,extractMainBlockParams:o}=bge(e,n),i=r("entry_flow/conv_in"),u=a("entry_flow/reduction_block_0"),l=a("entry_flow/reduction_block_1"),c={conv_in:i,reduction_block_0:u,reduction_block_1:l},d={};xs(t,0,1).forEach(m=>{d[`main_block_${m}`]=o(`middle_flow/main_block_${m}`)});let p=a("exit_flow/reduction_block"),h=s("exit_flow/separable_conv"),f={reduction_block:p,separable_conv:h};return Mn(e,n),{params:{entry_flow:c,middle_flow:d,exit_flow:f},paramMappings:n}}function h$(e,t,n){return Z(Wt(e,t.filters,n,"same"),t.bias)}function oI(e,t,n=!0){let r=n?Qe(e):e;return r=Yn(r,t.separable_conv0,[1,1]),r=Yn(Qe(r),t.separable_conv1,[1,1]),r=Vt(r,[3,3],[2,2],"same"),r=Z(r,h$(e,t.expansion_conv,[2,2])),r}function yge(e,t){let n=Yn(Qe(e),t.separable_conv0,[1,1]);return n=Yn(Qe(n),t.separable_conv1,[1,1]),n=Yn(Qe(n),t.separable_conv2,[1,1]),n=Z(n,e),n}var iI=class extends gn{constructor(t){super("TinyXception");this._numMainBlocks=t}forwardInput(t){let{params:n}=this;if(!n)throw new Error("TinyXception - load model before inference");return M(()=>{let r=ue(t.toBatchTensor(112,!0),"float32"),a=rs(r,[122.782,117.001,104.298]).div(255),o=Qe(h$(a,n.entry_flow.conv_in,[2,2]));return o=oI(o,n.entry_flow.reduction_block_0,!1),o=oI(o,n.entry_flow.reduction_block_1),xs(this._numMainBlocks,0,1).forEach(i=>{o=yge(o,n.middle_flow[`main_block_${i}`])}),o=oI(o,n.exit_flow.reduction_block),o=Qe(Yn(o,n.exit_flow.separable_conv,[1,1])),o})}async forward(t){return this.forwardInput(await xt(t))}getDefaultModelName(){return"tiny_xception_model"}extractParamsFromWeightMap(t){return p$(t,this._numMainBlocks)}extractParams(t){return d$(t,this._numMainBlocks)}};function f$(e){let t=[],{extractWeights:n,getRemainingWeights:r}=Ln(e),s=Jm(n,t),a=s(512,1,"fc/age"),o=s(512,2,"fc/gender");if(r().length!==0)throw new Error(`weights remaing after extract: ${r().length}`);return{paramMappings:t,params:{fc:{age:a,gender:o}}}}function m$(e){let t=[],n=lr(e,t);function r(a){let o=n(`${a}/weights`,2),i=n(`${a}/bias`,1);return{weights:o,bias:i}}let s={fc:{age:r("fc/age"),gender:r("fc/gender")}};return Mn(e,t),{params:s,paramMappings:t}}var Ys;(function(n){n.FEMALE="female",n.MALE="male"})(Ys||(Ys={}));var ig=class extends gn{constructor(t=new iI(2)){super("AgeGenderNet");this._faceFeatureExtractor=t}get faceFeatureExtractor(){return this._faceFeatureExtractor}runNet(t){let{params:n}=this;if(!n)throw new Error(`${this._name} - load model before inference`);return M(()=>{let r=t instanceof Ks?this.faceFeatureExtractor.forwardInput(t):t,s=Ar(r,[7,7],[2,2],"valid").as2D(r.shape[0],-1),a=Ep(s,n.fc.age).as1D(),o=Ep(s,n.fc.gender);return{age:a,gender:o}})}forwardInput(t){return M(()=>{let{age:n,gender:r}=this.runNet(t);return{age:n,gender:ls(r)}})}async forward(t){return this.forwardInput(await xt(t))}async predictAgeAndGender(t){let n=await xt(t),r=await this.forwardInput(n),s=vt(r.age),a=vt(r.gender),o=s.map((u,l)=>({ageTensor:u,genderTensor:a[l]})),i=await Promise.all(o.map(async({ageTensor:u,genderTensor:l})=>{let c=u.dataSync()[0],d=l.dataSync()[0],p=d>.5,h=p?Ys.MALE:Ys.FEMALE,f=p?d:1-d;return u.dispose(),l.dispose(),{age:c,gender:h,genderProbability:f}}));return r.age.dispose(),r.gender.dispose(),n.isBatchInput?i:i[0]}getDefaultModelName(){return"age_gender_model"}dispose(t=!0){this.faceFeatureExtractor.dispose(t),super.dispose(t)}loadClassifierParams(t){let{params:n,paramMappings:r}=this.extractClassifierParams(t);this._params=n,this._paramMappings=r}extractClassifierParams(t){return f$(t)}extractParamsFromWeightMap(t){let{featureExtractorMap:n,classifierMap:r}=sg(t);return this.faceFeatureExtractor.loadFromWeightMap(n),m$(r)}extractParams(t){let n=512*1+1+(512*2+2),r=t.slice(0,t.length-n),s=t.slice(t.length-n);return this.faceFeatureExtractor.extractWeights(r),this.extractClassifierParams(s)}};var $p=class extends Ap{postProcess(t,n,r){let s=r.map(({width:o,height:i})=>{let u=n/Math.max(i,o);return{width:o*u,height:i*u}}),a=s.length;return M(()=>{let o=(d,p)=>Ut([_n([68],d,"float32"),_n([68],p,"float32")],1).as2D(1,136).as1D(),i=(d,p)=>{let{width:h,height:f}=s[d];return p(h,f)?Math.abs(h-f)/2:0},u=d=>i(d,(p,h)=>p<h),l=d=>i(d,(p,h)=>h<p);return t.mul(_n([a,136],n,"float32")).sub(Ut(Array.from(Array(a),(d,p)=>o(u(p),l(p))))).div(Ut(Array.from(Array(a),(d,p)=>o(s[p].width,s[p].height))))})}forwardInput(t){return M(()=>{let n=this.runNet(t);return this.postProcess(n,t.inputSize,t.inputDimensions.map(([r,s])=>({height:r,width:s})))})}async forward(t){return this.forwardInput(await xt(t))}async detectLandmarks(t){let n=await xt(t),r=M(()=>vt(this.forwardInput(n))),s=await Promise.all(r.map(async(a,o)=>{let i=Array.from(a.dataSync()),u=i.filter((c,d)=>jm(d)),l=i.filter((c,d)=>!jm(d));return new dl(Array(68).fill(0).map((c,d)=>new Pe(u[d],l[d])),{height:n.getInputHeight(o),width:n.getInputWidth(o)})}));return r.forEach(a=>a.dispose()),n.isBatchInput?s:s[0]}getClassifierChannelsOut(){return 136}};var yl=class extends $p{constructor(t=new _p){super("FaceLandmark68Net",t)}getDefaultModelName(){return"face_landmark_68_model"}getClassifierChannelsIn(){return 256}};function g$(e){let t=[],{extractDenseBlock3Params:n}=rg(e,t),r={dense0:n("dense0",!0),dense1:n("dense1"),dense2:n("dense2")};return Mn(e,t),{params:r,paramMappings:t}}function b$(e){let t=[],{extractWeights:n,getRemainingWeights:r}=Ln(e),{extractDenseBlock3Params:s}=tg(n,t),a=s(3,32,"dense0",!0),o=s(32,64,"dense1"),i=s(64,128,"dense2");if(r().length!==0)throw new Error(`weights remaing after extract: ${r().length}`);return{paramMappings:t,params:{dense0:a,dense1:o,dense2:i}}}var uI=class extends gn{constructor(){super("TinyFaceFeatureExtractor")}forwardInput(t){let{params:n}=this;if(!n)throw new Error("TinyFaceFeatureExtractor - load model before inference");return M(()=>{let r=ue(t.toBatchTensor(112,!0),"float32"),a=rs(r,[122.782,117.001,104.298]).div(255),o=Zm(a,n.dense0,!0);return o=Zm(o,n.dense1),o=Zm(o,n.dense2),o=Ar(o,[14,14],[2,2],"valid"),o})}async forward(t){return this.forwardInput(await xt(t))}getDefaultModelName(){return"face_feature_extractor_tiny_model"}extractParamsFromWeightMap(t){return g$(t)}extractParams(t){return b$(t)}};var ug=class extends $p{constructor(t=new uI){super("FaceLandmark68TinyNet",t)}getDefaultModelName(){return"face_landmark_68_tiny_model"}getClassifierChannelsIn(){return 128}};var y$=class extends yl{};function v$(e,t){return Z(V(e,t.weights),t.biases)}function cI(e,t,n,r,s="same"){let{filters:a,bias:o}=t.conv,i=Wt(e,a,n,s);return i=Z(i,o),i=v$(i,t.scale),r?Qe(i):i}function x$(e,t){return cI(e,t,[1,1],!0)}function lI(e,t){return cI(e,t,[1,1],!1)}function cg(e,t){return cI(e,t,[2,2],!0,"valid")}function vge(e,t){function n(i,u,l){let c=e(i),d=c.length/(u*l*l);if(Ok(d))throw new Error(`depth has to be an integer: ${d}, weights.length: ${c.length}, numFilters: ${u}, filterSize: ${l}`);return M(()=>Oe(qr(c,[u,d,l,l]),[2,3,1,0]))}function r(i,u,l,c){let d=n(i,u,l),p=je(e(u));return t.push({paramPath:`${c}/filters`},{paramPath:`${c}/bias`}),{filters:d,bias:p}}function s(i,u){let l=je(e(i)),c=je(e(i));return t.push({paramPath:`${u}/weights`},{paramPath:`${u}/biases`}),{weights:l,biases:c}}function a(i,u,l,c){let d=r(i,u,l,`${c}/conv`),p=s(u,`${c}/scale`);return{conv:d,scale:p}}function o(i,u,l,c,d=!1){let p=a((d?.5:1)*i,u,l,`${c}/conv1`),h=a(i,u,l,`${c}/conv2`);return{conv1:p,conv2:h}}return{extractConvLayerParams:a,extractResidualLayerParams:o}}function w$(e){let{extractWeights:t,getRemainingWeights:n}=Ln(e),r=[],{extractConvLayerParams:s,extractResidualLayerParams:a}=vge(t,r),o=s(4704,32,7,"conv32_down"),i=a(9216,32,3,"conv32_1"),u=a(9216,32,3,"conv32_2"),l=a(9216,32,3,"conv32_3"),c=a(36864,64,3,"conv64_down",!0),d=a(36864,64,3,"conv64_1"),p=a(36864,64,3,"conv64_2"),h=a(36864,64,3,"conv64_3"),f=a(147456,128,3,"conv128_down",!0),m=a(147456,128,3,"conv128_1"),g=a(147456,128,3,"conv128_2"),b=a(589824,256,3,"conv256_down",!0),y=a(589824,256,3,"conv256_1"),v=a(589824,256,3,"conv256_2"),x=a(589824,256,3,"conv256_down_out"),k=M(()=>Oe(jr(t(256*128),[128,256]),[1,0]));if(r.push({paramPath:"fc"}),n().length!==0)throw new Error(`weights remaing after extract: ${n().length}`);return{params:{conv32_down:o,conv32_1:i,conv32_2:u,conv32_3:l,conv64_down:c,conv64_1:d,conv64_2:p,conv64_3:h,conv128_down:f,conv128_1:m,conv128_2:g,conv256_down:b,conv256_1:y,conv256_2:v,conv256_down_out:x,fc:k},paramMappings:r}}function xge(e,t){let n=lr(e,t);function r(o){let i=n(`${o}/scale/weights`,1),u=n(`${o}/scale/biases`,1);return{weights:i,biases:u}}function s(o){let i=n(`${o}/conv/filters`,4),u=n(`${o}/conv/bias`,1),l=r(o);return{conv:{filters:i,bias:u},scale:l}}function a(o){return{conv1:s(`${o}/conv1`),conv2:s(`${o}/conv2`)}}return{extractConvLayerParams:s,extractResidualLayerParams:a}}function k$(e){let t=[],{extractConvLayerParams:n,extractResidualLayerParams:r}=xge(e,t),s=n("conv32_down"),a=r("conv32_1"),o=r("conv32_2"),i=r("conv32_3"),u=r("conv64_down"),l=r("conv64_1"),c=r("conv64_2"),d=r("conv64_3"),p=r("conv128_down"),h=r("conv128_1"),f=r("conv128_2"),m=r("conv256_down"),g=r("conv256_1"),b=r("conv256_2"),y=r("conv256_down_out"),{fc:v}=e;if(t.push({originalPath:"fc",paramPath:"fc"}),!Pk(v))throw new Error(`expected weightMap[fc] to be a Tensor2D, instead have ${v}`);let x={conv32_down:s,conv32_1:a,conv32_2:o,conv32_3:i,conv64_down:u,conv64_1:l,conv64_2:c,conv64_3:d,conv128_down:p,conv128_1:h,conv128_2:f,conv256_down:m,conv256_1:g,conv256_2:b,conv256_down_out:y,fc:v};return Mn(e,t),{params:x,paramMappings:t}}function ss(e,t){let n=x$(e,t.conv1);return n=lI(n,t.conv2),n=Z(n,e),n=Qe(n),n}function Fp(e,t){let n=cg(e,t.conv1);n=lI(n,t.conv2);let r=Ar(e,2,2,"valid"),s=kt(r.shape),a=r.shape[3]!==n.shape[3];if(r.shape[1]!==n.shape[1]||r.shape[2]!==n.shape[2]){let i=[...n.shape];i[1]=1;let u=kt(i);n=ot([n,u],1);let l=[...n.shape];l[2]=1;let c=kt(l);n=ot([n,c],2)}return r=a?ot([r,s],3):r,n=Z(r,n),n=Qe(n),n}var vl=class extends gn{constructor(){super("FaceRecognitionNet")}forwardInput(t){let{params:n}=this;if(!n)throw new Error("FaceRecognitionNet - load model before inference");return M(()=>{let r=ue(t.toBatchTensor(150,!0),"float32"),a=rs(r,[122.782,117.001,104.298]).div(255),o=cg(a,n.conv32_down);o=Vt(o,3,2,"valid"),o=ss(o,n.conv32_1),o=ss(o,n.conv32_2),o=ss(o,n.conv32_3),o=Fp(o,n.conv64_down),o=ss(o,n.conv64_1),o=ss(o,n.conv64_2),o=ss(o,n.conv64_3),o=Fp(o,n.conv128_down),o=ss(o,n.conv128_1),o=ss(o,n.conv128_2),o=Fp(o,n.conv256_down),o=ss(o,n.conv256_1),o=ss(o,n.conv256_2),o=Fp(o,n.conv256_down_out);let i=o.mean([1,2]);return Re(i,n.fc)})}async forward(t){return this.forwardInput(await xt(t))}async computeFaceDescriptor(t){var a;if((a=t==null?void 0:t.shape)==null?void 0:a.some(o=>o<=0))return new Float32Array(128);let n=await xt(t),r=M(()=>vt(this.forwardInput(n))),s=await Promise.all(r.map(o=>o.data()));return r.forEach(o=>o.dispose()),n.isBatchInput?s:s[0]}getDefaultModelName(){return"face_recognition_model"}extractParamsFromWeightMap(t){return k$(t)}extractParams(t){return w$(t)}};function wge(e){let t=new vl;return t.extractWeights(e),t}function lg(e,t){return{...e,...{descriptor:t}}}function kge(e){return typeof e.age=="number"}function dg(e,t){return{...e,...{age:t}}}function Ige(e){return(e.gender===Ys.MALE||e.gender===Ys.FEMALE)&&ul(e.genderProbability)}function pg(e,t,n){return{...e,...{gender:t,genderProbability:n}}}function Sge(e,t){function n(u,l){let c=qr(e(3*3*u),[3,3,u,1]),d=je(e(u)),p=je(e(u)),h=je(e(u)),f=je(e(u));return t.push({paramPath:`${l}/filters`},{paramPath:`${l}/batch_norm_scale`},{paramPath:`${l}/batch_norm_offset`},{paramPath:`${l}/batch_norm_mean`},{paramPath:`${l}/batch_norm_variance`}),{filters:c,batch_norm_scale:d,batch_norm_offset:p,batch_norm_mean:h,batch_norm_variance:f}}function r(u,l,c,d,p){let h=qr(e(u*l*c*c),[c,c,u,l]),f=je(e(l));return t.push({paramPath:`${d}/filters`},{paramPath:`${d}/${p?"batch_norm_offset":"bias"}`}),{filters:h,bias:f}}function s(u,l,c,d){let{filters:p,bias:h}=r(u,l,c,d,!0);return{filters:p,batch_norm_offset:h}}function a(u,l,c){let d=n(u,`${c}/depthwise_conv`),p=s(u,l,1,`${c}/pointwise_conv`);return{depthwise_conv:d,pointwise_conv:p}}function o(){let u=s(3,32,3,"mobilenetv1/conv_0"),l=a(32,64,"mobilenetv1/conv_1"),c=a(64,128,"mobilenetv1/conv_2"),d=a(128,128,"mobilenetv1/conv_3"),p=a(128,256,"mobilenetv1/conv_4"),h=a(256,256,"mobilenetv1/conv_5"),f=a(256,512,"mobilenetv1/conv_6"),m=a(512,512,"mobilenetv1/conv_7"),g=a(512,512,"mobilenetv1/conv_8"),b=a(512,512,"mobilenetv1/conv_9"),y=a(512,512,"mobilenetv1/conv_10"),v=a(512,512,"mobilenetv1/conv_11"),x=a(512,1024,"mobilenetv1/conv_12"),k=a(1024,1024,"mobilenetv1/conv_13");return{conv_0:u,conv_1:l,conv_2:c,conv_3:d,conv_4:p,conv_5:h,conv_6:f,conv_7:m,conv_8:g,conv_9:b,conv_10:y,conv_11:v,conv_12:x,conv_13:k}}function i(){let u=s(1024,256,1,"prediction_layer/conv_0"),l=s(256,512,3,"prediction_layer/conv_1"),c=s(512,128,1,"prediction_layer/conv_2"),d=s(128,256,3,"prediction_layer/conv_3"),p=s(256,128,1,"prediction_layer/conv_4"),h=s(128,256,3,"prediction_layer/conv_5"),f=s(256,64,1,"prediction_layer/conv_6"),m=s(64,128,3,"prediction_layer/conv_7"),g=r(512,12,1,"prediction_layer/box_predictor_0/box_encoding_predictor"),b=r(512,9,1,"prediction_layer/box_predictor_0/class_predictor"),y=r(1024,24,1,"prediction_layer/box_predictor_1/box_encoding_predictor"),v=r(1024,18,1,"prediction_layer/box_predictor_1/class_predictor"),x=r(512,24,1,"prediction_layer/box_predictor_2/box_encoding_predictor"),k=r(512,18,1,"prediction_layer/box_predictor_2/class_predictor"),T=r(256,24,1,"prediction_layer/box_predictor_3/box_encoding_predictor"),C=r(256,18,1,"prediction_layer/box_predictor_3/class_predictor"),E=r(256,24,1,"prediction_layer/box_predictor_4/box_encoding_predictor"),F=r(256,18,1,"prediction_layer/box_predictor_4/class_predictor"),O=r(128,24,1,"prediction_layer/box_predictor_5/box_encoding_predictor"),D=r(128,18,1,"prediction_layer/box_predictor_5/class_predictor");return{conv_0:u,conv_1:l,conv_2:c,conv_3:d,conv_4:p,conv_5:h,conv_6:f,conv_7:m,box_predictor_0:{box_encoding_predictor:g,class_predictor:b},box_predictor_1:{box_encoding_predictor:y,class_predictor:v},box_predictor_2:{box_encoding_predictor:x,class_predictor:k},box_predictor_3:{box_encoding_predictor:T,class_predictor:C},box_predictor_4:{box_encoding_predictor:E,class_predictor:F},box_predictor_5:{box_encoding_predictor:O,class_predictor:D}}}return{extractMobilenetV1Params:o,extractPredictionLayerParams:i}}function I$(e){let t=[],{extractWeights:n,getRemainingWeights:r}=Ln(e),{extractMobilenetV1Params:s,extractPredictionLayerParams:a}=Sge(n,t),o=s(),i=a(),l={extra_dim:Qh(n(5118*4),[1,5118,4])};if(t.push({paramPath:"output_layer/extra_dim"}),r().length!==0)throw new Error(`weights remaing after extract: ${r().length}`);return{params:{mobilenetv1:o,prediction_layer:i,output_layer:l},paramMappings:t}}function Cge(e,t){let n=lr(e,t);function r(l,c,d){let p=n(`${l}/Conv2d_${c}_pointwise/weights`,4,`${d}/filters`),h=n(`${l}/Conv2d_${c}_pointwise/convolution_bn_offset`,1,`${d}/batch_norm_offset`);return{filters:p,batch_norm_offset:h}}function s(l){let c=`mobilenetv1/conv_${l}`,d=`MobilenetV1/Conv2d_${l}_depthwise`,p=`${c}/depthwise_conv`,h=`${c}/pointwise_conv`,f=n(`${d}/depthwise_weights`,4,`${p}/filters`),m=n(`${d}/BatchNorm/gamma`,1,`${p}/batch_norm_scale`),g=n(`${d}/BatchNorm/beta`,1,`${p}/batch_norm_offset`),b=n(`${d}/BatchNorm/moving_mean`,1,`${p}/batch_norm_mean`),y=n(`${d}/BatchNorm/moving_variance`,1,`${p}/batch_norm_variance`);return{depthwise_conv:{filters:f,batch_norm_scale:m,batch_norm_offset:g,batch_norm_mean:b,batch_norm_variance:y},pointwise_conv:r("MobilenetV1",l,h)}}function a(){return{conv_0:r("MobilenetV1",0,"mobilenetv1/conv_0"),conv_1:s(1),conv_2:s(2),conv_3:s(3),conv_4:s(4),conv_5:s(5),conv_6:s(6),conv_7:s(7),conv_8:s(8),conv_9:s(9),conv_10:s(10),conv_11:s(11),conv_12:s(12),conv_13:s(13)}}function o(l,c){let d=n(`${l}/weights`,4,`${c}/filters`),p=n(`${l}/biases`,1,`${c}/bias`);return{filters:d,bias:p}}function i(l){let c=o(`Prediction/BoxPredictor_${l}/BoxEncodingPredictor`,`prediction_layer/box_predictor_${l}/box_encoding_predictor`),d=o(`Prediction/BoxPredictor_${l}/ClassPredictor`,`prediction_layer/box_predictor_${l}/class_predictor`);return{box_encoding_predictor:c,class_predictor:d}}function u(){return{conv_0:r("Prediction",0,"prediction_layer/conv_0"),conv_1:r("Prediction",1,"prediction_layer/conv_1"),conv_2:r("Prediction",2,"prediction_layer/conv_2"),conv_3:r("Prediction",3,"prediction_layer/conv_3"),conv_4:r("Prediction",4,"prediction_layer/conv_4"),conv_5:r("Prediction",5,"prediction_layer/conv_5"),conv_6:r("Prediction",6,"prediction_layer/conv_6"),conv_7:r("Prediction",7,"prediction_layer/conv_7"),box_predictor_0:i(0),box_predictor_1:i(1),box_predictor_2:i(2),box_predictor_3:i(3),box_predictor_4:i(4),box_predictor_5:i(5)}}return{extractMobilenetV1Params:a,extractPredictionLayerParams:u}}function S$(e){let t=[],{extractMobilenetV1Params:n,extractPredictionLayerParams:r}=Cge(e,t),s=e["Output/extra_dim"];if(t.push({originalPath:"Output/extra_dim",paramPath:"output_layer/extra_dim"}),!js(s))throw new Error(`expected weightMap['Output/extra_dim'] to be a Tensor3D, instead have ${s}`);let a={mobilenetv1:n(),prediction_layer:r(),output_layer:{extra_dim:s}};return Mn(e,t),{params:a,paramMappings:t}}function Br(e,t,n){return M(()=>{let r=Wt(e,t.filters,n,"same");return r=Z(r,t.batch_norm_offset),dn(r,0,6)})}var Tge=.0010000000474974513;function Nge(e,t,n){return M(()=>{let r=Bi(e,t.filters,n,"same");return r=ho(r,t.batch_norm_mean,t.batch_norm_variance,t.batch_norm_offset,t.batch_norm_scale,Tge),dn(r,0,6)})}function _ge(e){return[2,4,6,12].some(t=>t===e)?[2,2]:[1,1]}function C$(e,t){return M(()=>{let n,r=Br(e,t.conv_0,[2,2]);if([t.conv_1,t.conv_2,t.conv_3,t.conv_4,t.conv_5,t.conv_6,t.conv_7,t.conv_8,t.conv_9,t.conv_10,t.conv_11,t.conv_12,t.conv_13].forEach((a,o)=>{let i=o+1,u=_ge(i);r=Nge(r,a.depthwise_conv,u),r=Br(r,a.pointwise_conv,[1,1]),i===11&&(n=r)}),n===null)throw new Error("mobileNetV1 - output of conv layer 11 is null");return{out:r,conv11:n}})}function Ege(e,t,n){let r=e.arraySync(),s=Math.min(r[t][0],r[t][2]),a=Math.min(r[t][1],r[t][3]),o=Math.max(r[t][0],r[t][2]),i=Math.max(r[t][1],r[t][3]),u=Math.min(r[n][0],r[n][2]),l=Math.min(r[n][1],r[n][3]),c=Math.max(r[n][0],r[n][2]),d=Math.max(r[n][1],r[n][3]),p=(o-s)*(i-a),h=(c-u)*(d-l);if(p<=0||h<=0)return 0;let f=Math.max(s,u),m=Math.max(a,l),g=Math.min(o,c),b=Math.min(i,d),y=Math.max(g-f,0)*Math.max(b-m,0);return y/(p+h-y)}function T$(e,t,n,r,s){let a=e.shape[0],o=Math.min(n,a),i=t.map((c,d)=>({score:c,boxIndex:d})).filter(c=>c.score>s).sort((c,d)=>d.score-c.score),u=c=>c<=r?1:0,l=[];return i.forEach(c=>{if(l.length>=o)return;let d=c.score;for(let p=l.length-1;p>=0;--p){let h=Ege(e,c.boxIndex,l[p]);if(h!==0&&(c.score*=u(h),c.score<=s))break}d===c.score&&l.push(c.boxIndex)}),l}function Age(e){let t=vt(Oe(e,[1,0])),n=[he(t[2],t[0]),he(t[3],t[1])],r=[Z(t[0],me(n[0],2)),Z(t[1],me(n[1],2))];return{sizes:n,centers:r}}function $ge(e,t){let{sizes:n,centers:r}=Age(e),s=vt(Oe(t,[1,0])),a=me(V(Tn(me(s[2],5)),n[0]),2),o=Z(V(me(s[0],10),n[0]),r[0]),i=me(V(Tn(me(s[3],5)),n[1]),2),u=Z(V(me(s[1],10),n[1]),r[1]);return Oe(Ut([he(o,a),he(u,i),Z(o,a),Z(u,i)]),[1,0])}function N$(e,t,n){return M(()=>{let r=e.shape[0],s=$ge(G(tr(n.extra_dim,[r,1,1]),[-1,4]),G(e,[-1,4]));s=G(s,[r,s.shape[0]/r,4]);let a=$r(Ve(t,[0,0,1],[-1,-1,-1])),o=Ve(a,[0,0,0],[-1,-1,1]);o=G(o,[r,o.shape[1]]);let i=vt(s),u=vt(o);return{boxes:i,scores:u}})}function xu(e,t){return M(()=>{let n=e.shape[0],r=G(yu(e,t.box_encoding_predictor),[n,-1,1,4]),s=G(yu(e,t.class_predictor),[n,-1,3]);return{boxPredictionEncoding:r,classPrediction:s}})}function _$(e,t,n){return M(()=>{let r=Br(e,n.conv_0,[1,1]),s=Br(r,n.conv_1,[2,2]),a=Br(s,n.conv_2,[1,1]),o=Br(a,n.conv_3,[2,2]),i=Br(o,n.conv_4,[1,1]),u=Br(i,n.conv_5,[2,2]),l=Br(u,n.conv_6,[1,1]),c=Br(l,n.conv_7,[2,2]),d=xu(t,n.box_predictor_0),p=xu(e,n.box_predictor_1),h=xu(s,n.box_predictor_2),f=xu(o,n.box_predictor_3),m=xu(u,n.box_predictor_4),g=xu(c,n.box_predictor_5),b=ot([d.boxPredictionEncoding,p.boxPredictionEncoding,h.boxPredictionEncoding,f.boxPredictionEncoding,m.boxPredictionEncoding,g.boxPredictionEncoding],1),y=ot([d.classPrediction,p.classPrediction,h.classPrediction,f.classPrediction,m.classPrediction,g.classPrediction],1);return{boxPredictions:b,classPredictions:y}})}var zr=class{constructor({minConfidence:t,maxResults:n}={}){this._name="SsdMobilenetv1Options";if(this._minConfidence=t||.5,this._maxResults=n||100,typeof this._minConfidence!="number"||this._minConfidence<=0||this._minConfidence>=1)throw new Error(`${this._name} - expected minConfidence to be a number between 0 and 1`);if(typeof this._maxResults!="number")throw new Error(`${this._name} - expected maxResults to be a number`)}get minConfidence(){return this._minConfidence}get maxResults(){return this._maxResults}};var wu=class extends gn{constructor(){super("SsdMobilenetv1")}forwardInput(t){let{params:n}=this;if(!n)throw new Error("SsdMobilenetv1 - load model before inference");return M(()=>{let r=ue(t.toBatchTensor(512,!1),"float32"),s=he(me(r,127.5),1),a=C$(s,n.mobilenetv1),{boxPredictions:o,classPredictions:i}=_$(a.out,a.conv11,n.prediction_layer);return N$(o,i,n.output_layer)})}async forward(t){return this.forwardInput(await xt(t))}async locateFaces(t,n={}){let{maxResults:r,minConfidence:s}=new zr(n),a=await xt(t),{boxes:o,scores:i}=this.forwardInput(a),u=o[0],l=i[0];for(let v=1;v<o.length;v++)o[v].dispose(),i[v].dispose();let c=Array.from(l.dataSync()),p=T$(u,c,r,.5,s),h=a.getReshapedInputDimensions(0),f=a.inputSize,m=f/h.width,g=f/h.height,b=u.arraySync(),y=p.map(v=>{let[x,k]=[Math.max(0,b[v][0]),Math.min(1,b[v][2])].map(E=>E*g),[T,C]=[Math.max(0,b[v][1]),Math.min(1,b[v][3])].map(E=>E*m);return new St(c[v],new ll(T,x,C-T,k-x),{height:a.getInputHeight(0),width:a.getInputWidth(0)})});return u.dispose(),l.dispose(),y}getDefaultModelName(){return"ssd_mobilenetv1_model"}extractParamsFromWeightMap(t){return S$(t)}extractParams(t){return I$(t)}};function E$(e){let t=new wu;return t.extractWeights(e),t}function Fge(e){return E$(e)}var A$=class extends wu{};var $$=.4,F$=[new Pe(.738768,.874946),new Pe(2.42204,2.65704),new Pe(4.30971,7.04493),new Pe(10.246,4.59428),new Pe(12.6868,11.8741)],D$=[new Pe(1.603231,2.094468),new Pe(6.041143,7.080126),new Pe(2.882459,3.518061),new Pe(4.266906,5.178857),new Pe(9.041765,10.66308)],R$=[117.001,114.697,97.404],P$="tiny_yolov2_model",O$="tiny_yolov2_separable_conv_model";var hg=e=>typeof e=="number";function dI(e){if(!e)throw new Error(`invalid config: ${e}`);if(typeof e.withSeparableConvs!="boolean")throw new Error(`config.withSeparableConvs has to be a boolean, have: ${e.withSeparableConvs}`);if(!hg(e.iouThreshold)||e.iouThreshold<0||e.iouThreshold>1)throw new Error(`config.iouThreshold has to be a number between [0, 1], have: ${e.iouThreshold}`);if(!Array.isArray(e.classes)||!e.classes.length||!e.classes.every(t=>typeof t=="string"))throw new Error(`config.classes has to be an array class names: string[], have: ${JSON.stringify(e.classes)}`);if(!Array.isArray(e.anchors)||!e.anchors.length||!e.anchors.map(t=>t||{}).every(t=>hg(t.x)&&hg(t.y)))throw new Error(`config.anchors has to be an array of { x: number, y: number }, have: ${JSON.stringify(e.anchors)}`);if(e.meanRgb&&(!Array.isArray(e.meanRgb)||e.meanRgb.length!==3||!e.meanRgb.every(hg)))throw new Error(`config.meanRgb has to be an array of shape [number, number, number], have: ${JSON.stringify(e.meanRgb)}`)}function xl(e){return M(()=>{let t=V(e,ke(.10000000149011612));return Z(Qe(he(e,t)),t)})}function Qs(e,t){return M(()=>{let n=Fr(e,[[0,0],[1,1],[1,1],[0,0]]);return n=Wt(n,t.conv.filters,[1,1],"valid"),n=he(n,t.bn.sub),n=V(n,t.bn.truediv),n=Z(n,t.conv.bias),xl(n)})}function Zs(e,t){return M(()=>{let n=Fr(e,[[0,0],[1,1],[1,1],[0,0]]);return n=_c(n,t.depthwise_filter,t.pointwise_filter,[1,1],"valid"),n=Z(n,t.bias),xl(n)})}function Dge(e,t){let n=fl(e,t);function r(o,i){let u=je(e(o)),l=je(e(o));return t.push({paramPath:`${i}/sub`},{paramPath:`${i}/truediv`}),{sub:u,truediv:l}}function s(o,i,u){let l=n(o,i,3,`${u}/conv`),c=r(i,`${u}/bn`);return{conv:l,bn:c}}let a=ml(e,t);return{extractConvParams:n,extractConvWithBatchNormParams:s,extractSeparableConvParams:a}}function M$(e,t,n,r){let{extractWeights:s,getRemainingWeights:a}=Ln(e),o=[],{extractConvParams:i,extractConvWithBatchNormParams:u,extractSeparableConvParams:l}=Dge(s,o),c;if(t.withSeparableConvs){let[d,p,h,f,m,g,b,y,v]=r,x=t.isFirstLayerConv2d?i(d,p,3,"conv0"):l(d,p,"conv0"),k=l(p,h,"conv1"),T=l(h,f,"conv2"),C=l(f,m,"conv3"),E=l(m,g,"conv4"),F=l(g,b,"conv5"),O=y?l(b,y,"conv6"):void 0,D=v?l(y,v,"conv7"):void 0,R=i(v||y||b,5*n,1,"conv8");c={conv0:x,conv1:k,conv2:T,conv3:C,conv4:E,conv5:F,conv6:O,conv7:D,conv8:R}}else{let[d,p,h,f,m,g,b,y,v]=r,x=u(d,p,"conv0"),k=u(p,h,"conv1"),T=u(h,f,"conv2"),C=u(f,m,"conv3"),E=u(m,g,"conv4"),F=u(g,b,"conv5"),O=u(b,y,"conv6"),D=u(y,v,"conv7"),R=i(v,5*n,1,"conv8");c={conv0:x,conv1:k,conv2:T,conv3:C,conv4:E,conv5:F,conv6:O,conv7:D,conv8:R}}if(a().length!==0)throw new Error(`weights remaing after extract: ${a().length}`);return{params:c,paramMappings:o}}function Rge(e,t){let n=lr(e,t);function r(i){let u=n(`${i}/sub`,1),l=n(`${i}/truediv`,1);return{sub:u,truediv:l}}function s(i){let u=n(`${i}/filters`,4),l=n(`${i}/bias`,1);return{filters:u,bias:l}}function a(i){let u=s(`${i}/conv`),l=r(`${i}/bn`);return{conv:u,bn:l}}let o=gl(n);return{extractConvParams:s,extractConvWithBatchNormParams:a,extractSeparableConvParams:o}}function L$(e,t){let n=[],{extractConvParams:r,extractConvWithBatchNormParams:s,extractSeparableConvParams:a}=Rge(e,n),o;if(t.withSeparableConvs){let i=t.filterSizes&&t.filterSizes.length||9;o={conv0:t.isFirstLayerConv2d?r("conv0"):a("conv0"),conv1:a("conv1"),conv2:a("conv2"),conv3:a("conv3"),conv4:a("conv4"),conv5:a("conv5"),conv6:i>7?a("conv6"):void 0,conv7:i>8?a("conv7"):void 0,conv8:r("conv8")}}else o={conv0:s("conv0"),conv1:s("conv1"),conv2:s("conv2"),conv3:s("conv3"),conv4:s("conv4"),conv5:s("conv5"),conv6:s("conv6"),conv7:s("conv7"),conv8:r("conv8")};return Mn(e,n),{params:o,paramMappings:n}}var Is=class{constructor({inputSize:t,scoreThreshold:n}={}){this._name="TinyYolov2Options";if(this._inputSize=t||416,this._scoreThreshold=n||.5,typeof this._inputSize!="number"||this._inputSize%32!=0)throw new Error(`${this._name} - expected inputSize to be a number divisible by 32`);if(typeof this._scoreThreshold!="number"||this._scoreThreshold<=0||this._scoreThreshold>=1)throw new Error(`${this._name} - expected scoreThreshold to be a number between 0 and 1`)}get inputSize(){return this._inputSize}get scoreThreshold(){return this._scoreThreshold}};var pI=class extends gn{constructor(t){super("TinyYolov2");dI(t),this._config=t}get config(){return this._config}get withClassScores(){return this.config.withClassScores||this.config.classes.length>1}get boxEncodingSize(){return 5+(this.withClassScores?this.config.classes.length:0)}runTinyYolov2(t,n){let r=Qs(t,n.conv0);return r=Vt(r,[2,2],[2,2],"same"),r=Qs(r,n.conv1),r=Vt(r,[2,2],[2,2],"same"),r=Qs(r,n.conv2),r=Vt(r,[2,2],[2,2],"same"),r=Qs(r,n.conv3),r=Vt(r,[2,2],[2,2],"same"),r=Qs(r,n.conv4),r=Vt(r,[2,2],[2,2],"same"),r=Qs(r,n.conv5),r=Vt(r,[2,2],[1,1],"same"),r=Qs(r,n.conv6),r=Qs(r,n.conv7),yu(r,n.conv8,"valid",!1)}runMobilenet(t,n){let r=this.config.isFirstLayerConv2d?xl(yu(t,n.conv0,"valid",!1)):Zs(t,n.conv0);return r=Vt(r,[2,2],[2,2],"same"),r=Zs(r,n.conv1),r=Vt(r,[2,2],[2,2],"same"),r=Zs(r,n.conv2),r=Vt(r,[2,2],[2,2],"same"),r=Zs(r,n.conv3),r=Vt(r,[2,2],[2,2],"same"),r=Zs(r,n.conv4),r=Vt(r,[2,2],[2,2],"same"),r=Zs(r,n.conv5),r=Vt(r,[2,2],[1,1],"same"),r=n.conv6?Zs(r,n.conv6):r,r=n.conv7?Zs(r,n.conv7):r,yu(r,n.conv8,"valid",!1)}forwardInput(t,n){let{params:r}=this;if(!r)throw new Error("TinyYolov2 - load model before inference");return M(()=>{let s=ue(t.toBatchTensor(n,!1),"float32");return s=this.config.meanRgb?rs(s,this.config.meanRgb):s,s=s.div(255),this.config.withSeparableConvs?this.runMobilenet(s,r):this.runTinyYolov2(s,r)})}async forward(t,n){return this.forwardInput(await xt(t),n)}async detect(t,n={}){let{inputSize:r,scoreThreshold:s}=new Is(n),a=await xt(t),o=await this.forwardInput(a,r),i=M(()=>vt(o)[0].expandDims()),u={width:a.getInputWidth(0),height:a.getInputHeight(0)},l=await this.extractBoxes(i,a.getReshapedInputDimensions(0),s);o.dispose(),i.dispose();let c=l.map(g=>g.box),d=l.map(g=>g.score),p=l.map(g=>g.classScore),h=l.map(g=>this.config.classes[g.label]);return Wk(c.map(g=>g.rescale(r)),d,this.config.iouThreshold,!0).map(g=>new Ao(d[g],p[g],h[g],c[g],u))}getDefaultModelName(){return""}extractParamsFromWeightMap(t){return L$(t,this.config)}extractParams(t){let n=this.config.filterSizes||pI.DEFAULT_FILTER_SIZES,r=n?n.length:void 0;if(r!==7&&r!==8&&r!==9)throw new Error(`TinyYolov2 - expected 7 | 8 | 9 convolutional filters, but found ${r} filterSizes in config`);return M$(t,this.config,this.boxEncodingSize,n)}async extractBoxes(t,n,r){let{width:s,height:a}=n,o=Math.max(s,a),i=o/s,u=o/a,l=t.shape[1],c=this.config.anchors.length,[d,p,h]=M(()=>{let b=t.reshape([l,l,c,this.boxEncodingSize]),y=b.slice([0,0,0,0],[l,l,c,4]),v=b.slice([0,0,0,4],[l,l,c,1]),x=this.withClassScores?ls(b.slice([0,0,0,5],[l,l,c,this.config.classes.length]),3):ke(0);return[y,v,x]}),f=[],m=await p.array(),g=await d.array();for(let b=0;b<l;b++)for(let y=0;y<l;y++)for(let v=0;v<c;v++){let x=xp(m[b][y][v][0]);if(!r||x>r){let k=(y+xp(g[b][y][v][0]))/l*i,T=(b+xp(g[b][y][v][1]))/l*u,C=Math.exp(g[b][y][v][2])*this.config.anchors[v].x/l*i,E=Math.exp(g[b][y][v][3])*this.config.anchors[v].y/l*u,F=k-C/2,O=T-E/2,D={row:b,col:y,anchor:v},{classScore:R,label:_}=this.withClassScores?await this.extractPredictedClass(h,D):{classScore:1,label:0};f.push({box:new cl(F,O,F+C,O+E),score:x,classScore:x*R,label:_,...D})}}return d.dispose(),p.dispose(),h.dispose(),f}async extractPredictedClass(t,n){let{row:r,col:s,anchor:a}=n,o=await t.array();return Array(this.config.classes.length).fill(0).map((i,u)=>o[r][s][a][u]).map((i,u)=>({classScore:i,label:u})).reduce((i,u)=>i.classScore>u.classScore?i:u)}},wl=pI;wl.DEFAULT_FILTER_SIZES=[3,16,32,64,128,256,512,1024,1024];var kl=class extends wl{constructor(t=!0){let n={withSeparableConvs:t,iouThreshold:$$,classes:["face"],...t?{anchors:D$,meanRgb:R$}:{anchors:F$,withClassScores:!0}};super(n)}get withSeparableConvs(){return this.config.withSeparableConvs}get anchors(){return this.config.anchors}async locateFaces(t,n){return(await this.detect(t,n)).map(s=>new St(s.score,s.relativeBox,{width:s.imageWidth,height:s.imageHeight}))}getDefaultModelName(){return this.withSeparableConvs?O$:P$}extractParamsFromWeightMap(t){return super.extractParamsFromWeightMap(t)}};function Pge(e,t=!0){let n=new kl(t);return n.extractWeights(e),n}var fg=class extends Is{constructor(){super(...arguments);this._name="TinyFaceDetectorOptions"}};var Wr=class{async then(t){return t(await this.run())}async run(){throw new Error("ComposableTask - run is not implemented")}};async function ku(e,t,n,r,s=({alignedRect:a})=>a){let a=e.map(u=>vu(u)?s(u):u.detection),o=r||(t instanceof Ae?await hl(t,a):await pl(t,a)),i=await n(o);return o.forEach(u=>u instanceof Ae&&u.dispose()),i}async function Il(e,t,n,r,s){return ku([e],t,async a=>n(a[0]),r,s)}var B$=.4,z$=[new Pe(1.603231,2.094468),new Pe(6.041143,7.080126),new Pe(2.882459,3.518061),new Pe(4.266906,5.178857),new Pe(9.041765,10.66308)],W$=[117.001,114.697,97.404];var Sl=class extends wl{constructor(){let t={withSeparableConvs:!0,iouThreshold:B$,classes:["face"],anchors:z$,meanRgb:W$,isFirstLayerConv2d:!0,filterSizes:[3,16,32,64,128,256,512]};super(t)}get anchors(){return this.config.anchors}async locateFaces(t,n){return(await this.detect(t,n)).map(s=>new St(s.score,s.relativeBox,{width:s.imageWidth,height:s.imageHeight}))}getDefaultModelName(){return"tiny_face_detector_model"}extractParamsFromWeightMap(t){return super.extractParamsFromWeightMap(t)}};var st={ssdMobilenetv1:new wu,tinyFaceDetector:new Sl,tinyYolov2:new kl,faceLandmark68Net:new yl,faceLandmark68TinyNet:new ug,faceRecognitionNet:new vl,faceExpressionNet:new ag,ageGenderNet:new ig},V$=(e,t)=>st.ssdMobilenetv1.locateFaces(e,t),Oge=(e,t)=>st.tinyFaceDetector.locateFaces(e,t),Mge=(e,t)=>st.tinyYolov2.locateFaces(e,t),U$=e=>st.faceLandmark68Net.detectLandmarks(e),Lge=e=>st.faceLandmark68TinyNet.detectLandmarks(e),Bge=e=>st.faceRecognitionNet.computeFaceDescriptor(e),zge=e=>st.faceExpressionNet.predictExpressions(e),Wge=e=>st.ageGenderNet.predictAgeAndGender(e),G$=e=>st.ssdMobilenetv1.load(e),Vge=e=>st.tinyFaceDetector.load(e),Uge=e=>st.tinyYolov2.load(e),Gge=e=>st.faceLandmark68Net.load(e),Hge=e=>st.faceLandmark68TinyNet.load(e),jge=e=>st.faceRecognitionNet.load(e),qge=e=>st.faceExpressionNet.load(e),Kge=e=>st.ageGenderNet.load(e),Xge=G$,Yge=V$,Qge=U$;var hI=class extends Wr{constructor(t,n,r){super();this.parentTask=t;this.input=n;this.extractedFaces=r}},Cl=class extends hI{async run(){let t=await this.parentTask,n=await ku(t,this.input,async r=>Promise.all(r.map(s=>st.faceExpressionNet.predictExpressions(s))),this.extractedFaces);return t.map((r,s)=>og(r,n[s]))}withAgeAndGender(){return new Nl(this,this.input)}},Tl=class extends hI{async run(){let t=await this.parentTask;if(!t)return;let n=await Il(t,this.input,r=>st.faceExpressionNet.predictExpressions(r),this.extractedFaces);return og(t,n)}withAgeAndGender(){return new _l(this,this.input)}},Iu=class extends Cl{withAgeAndGender(){return new Cu(this,this.input)}withFaceDescriptors(){return new Do(this,this.input)}},Su=class extends Tl{withAgeAndGender(){return new Tu(this,this.input)}withFaceDescriptor(){return new Ro(this,this.input)}};var fI=class extends Wr{constructor(t,n,r){super();this.parentTask=t;this.input=n;this.extractedFaces=r}},Nl=class extends fI{async run(){let t=await this.parentTask,n=await ku(t,this.input,async r=>Promise.all(r.map(s=>st.ageGenderNet.predictAgeAndGender(s))),this.extractedFaces);return t.map((r,s)=>{let{age:a,gender:o,genderProbability:i}=n[s];return dg(pg(r,o,i),a)})}withFaceExpressions(){return new Cl(this,this.input)}},_l=class extends fI{async run(){let t=await this.parentTask;if(!t)return;let{age:n,gender:r,genderProbability:s}=await Il(t,this.input,a=>st.ageGenderNet.predictAgeAndGender(a),this.extractedFaces);return dg(pg(t,r,s),n)}withFaceExpressions(){return new Tl(this,this.input)}},Cu=class extends Nl{withFaceExpressions(){return new Iu(this,this.input)}withFaceDescriptors(){return new Do(this,this.input)}},Tu=class extends _l{withFaceExpressions(){return new Su(this,this.input)}withFaceDescriptor(){return new Ro(this,this.input)}};var mg=class extends Wr{constructor(t,n){super();this.parentTask=t;this.input=n}},Do=class extends mg{async run(){let t=await this.parentTask;return(await ku(t,this.input,r=>Promise.all(r.map(s=>st.faceRecognitionNet.computeFaceDescriptor(s))),null,r=>r.landmarks.align(null,{useDlibAlignment:!0}))).map((r,s)=>lg(t[s],r))}withFaceExpressions(){return new Iu(this,this.input)}withAgeAndGender(){return new Cu(this,this.input)}},Ro=class extends mg{async run(){let t=await this.parentTask;if(!t)return;let n=await Il(t,this.input,r=>st.faceRecognitionNet.computeFaceDescriptor(r),null,r=>r.landmarks.align(null,{useDlibAlignment:!0}));return lg(t,n)}withFaceExpressions(){return new Su(this,this.input)}withAgeAndGender(){return new Tu(this,this.input)}};var gg=class extends Wr{constructor(t,n,r){super();this.parentTask=t;this.input=n;this.useTinyLandmarkNet=r}get landmarkNet(){return this.useTinyLandmarkNet?st.faceLandmark68TinyNet:st.faceLandmark68Net}},bg=class extends gg{async run(){let t=await this.parentTask,n=t.map(a=>a.detection),r=this.input instanceof Ae?await hl(this.input,n):await pl(this.input,n),s=await Promise.all(r.map(a=>this.landmarkNet.detectLandmarks(a)));return r.forEach(a=>a instanceof Ae&&a.dispose()),t.map((a,o)=>bl(a,s[o]))}withFaceExpressions(){return new Iu(this,this.input)}withAgeAndGender(){return new Cu(this,this.input)}withFaceDescriptors(){return new Do(this,this.input)}},yg=class extends gg{async run(){let t=await this.parentTask;if(!t)return;let{detection:n}=t,r=this.input instanceof Ae?await hl(this.input,[n]):await pl(this.input,[n]),s=await this.landmarkNet.detectLandmarks(r[0]);return r.forEach(a=>a instanceof Ae&&a.dispose()),bl(t,s)}withFaceExpressions(){return new Su(this,this.input)}withAgeAndGender(){return new Tu(this,this.input)}withFaceDescriptor(){return new Ro(this,this.input)}};var vg=class extends Wr{constructor(t,n=new zr){super();this.input=t;this.options=n}},Dp=class extends vg{async run(){let{input:t,options:n}=this,r;if(n instanceof fg)r=st.tinyFaceDetector.locateFaces(t,n);else if(n instanceof zr)r=st.ssdMobilenetv1.locateFaces(t,n);else if(n instanceof Is)r=st.tinyYolov2.locateFaces(t,n);else throw new Error("detectFaces - expected options to be instance of TinyFaceDetectorOptions | SsdMobilenetv1Options | TinyYolov2Options");return r}runAndExtendWithFaceDetections(){return new Promise((t,n)=>{this.run().then(r=>t(r.map(s=>fu({},s)))).catch(r=>n(r))})}withFaceLandmarks(t=!1){return new bg(this.runAndExtendWithFaceDetections(),this.input,t)}withFaceExpressions(){return new Cl(this.runAndExtendWithFaceDetections(),this.input)}withAgeAndGender(){return new Nl(this.runAndExtendWithFaceDetections(),this.input)}},xg=class extends vg{async run(){let t=await new Dp(this.input,this.options),n=t[0];return t.forEach(r=>{r.score>n.score&&(n=r)}),n}runAndExtendWithFaceDetection(){return new Promise(async t=>{let n=await this.run();t(n?fu({},n):void 0)})}withFaceLandmarks(t=!1){return new yg(this.runAndExtendWithFaceDetection(),this.input,t)}withFaceExpressions(){return new Tl(this.runAndExtendWithFaceDetection(),this.input)}withAgeAndGender(){return new _l(this.runAndExtendWithFaceDetection(),this.input)}};function Zge(e,t=new zr){return new xg(e,t)}function wg(e,t=new zr){return new Dp(e,t)}async function H$(e,t){return wg(e,new zr(t?{minConfidence:t}:{})).withFaceLandmarks().withFaceDescriptors()}async function Jge(e,t={}){return wg(e,new Is(t)).withFaceLandmarks().withFaceDescriptors()}var ebe=H$;function mI(e,t){if(e.length!==t.length)throw new Error("euclideanDistance: arr1.length !== arr2.length");let n=Array.from(e),r=Array.from(t);return Math.sqrt(n.map((s,a)=>s-r[a]).reduce((s,a)=>s+a**2,0))}var kg=class{constructor(t,n=.6){this._distanceThreshold=n;let r=Array.isArray(t)?t:[t];if(!r.length)throw new Error("FaceRecognizer.constructor - expected atleast one input");let s=1,a=()=>`person ${s++}`;this._labeledDescriptors=r.map(o=>{if(o instanceof qs)return o;if(o instanceof Float32Array)return new qs(a(),[o]);if(o.descriptor&&o.descriptor instanceof Float32Array)return new qs(a(),[o.descriptor]);throw new Error("FaceRecognizer.constructor - expected inputs to be of type LabeledFaceDescriptors | WithFaceDescriptor<any> | Float32Array | Array<LabeledFaceDescriptors | WithFaceDescriptor<any> | Float32Array>")})}get labeledDescriptors(){return this._labeledDescriptors}get distanceThreshold(){return this._distanceThreshold}computeMeanDistance(t,n){return n.map(r=>mI(r,t)).reduce((r,s)=>r+s,0)/(n.length||1)}matchDescriptor(t){return this.labeledDescriptors.map(({descriptors:n,label:r})=>new wp(r,this.computeMeanDistance(t,n))).reduce((n,r)=>n.distance<r.distance?n:r)}findBestMatch(t){let n=this.matchDescriptor(t);return n.distance<this._distanceThreshold?n:new wp("unknown",n.distance)}toJSON(){return{distanceThreshold:this._distanceThreshold,labeledDescriptors:this._labeledDescriptors.map(t=>t.toJSON())}}static fromJSON(t){let n=t.labeledDescriptors.map(r=>qs.fromJSON(r));return new kg(n,t.distanceThreshold)}};function tbe(e){let t=new Sl;return t.extractWeights(e),t}function j$(e,t){let{width:n,height:r}=new On(t.width,t.height);if(n<=0||r<=0)throw new Error(`resizeResults - invalid dimensions: ${JSON.stringify({width:n,height:r})}`);if(Array.isArray(e))return e.map(s=>j$(s,{width:n,height:r}));if(vu(e)){let s=e.detection.forSize(n,r),a=e.unshiftedLandmarks.forSize(s.box.width,s.box.height);return bl(fu(e,s),a)}return ws(e)?fu(e,e.detection.forSize(n,r)):e instanceof Sr||e instanceof St?e.forSize(n,r):e}var nbe=l$;return rbe;})();
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use backend file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/
/** @license See the LICENSE file. */
